****
事务
****
在本章节中，我们将会覆盖如下主题：

- 执行事务；
- 使用保存点；
- 隔离级别；
- 锁；

简介
====
在下面的主题中，我们将讨论 MySQL 中的事务和各种隔离级别。事务是指一组应该成功或失败的 SQL 语句。事务还应满足原子性，一致性，隔离性和持久性（ACID）属性。举一个从账户 A 到账户 B 的汇款的一个非常基本的例子。假设 A 有 600 美元， B 有 400 美元， B 希望从 A 转移 100 美元到自己。银行将从 A 中扣除 100 美元，并使用以下 SQL 代码添加到 B（用于说明）：

.. code-block:: shell

    mysql> SELECT balance INTO @a.bal FROM account WHERE account_number='A';

编程检查是否 ``@a.bal`` 的值大于或等于 100 ：

.. code-block:: shell

    mysql> UPDATE account SET balance=@a.bal-100 WHERE account_number='A';
    mysql> SELECT balance INTO @b.bal FROM account WHERE account_number='B';

编程检查是否 ``@b.bal`` 是 ``NOT NULL`` ：

.. code-block:: shell

    mysql> UPDATE account SET balance=@b.bal+100 WHERE account_number='B';

这四行 ``SQL`` 应该是单个事务的一部分，并满足以下 ``ACID`` 属性：

- 原子性：要么所有的 ``SQL`` 都应该成功，要么全部都应该失败。不应该有任何部分更新。 如果不遵守此属性，并且在运行两个 ``SQL`` 后数据库崩溃，则 A 将丢失 100 。
- 一致性：事务必须仅以允许的方式更改受影响的数据。在此示例中，如果不存在带有 B 的 account_number ，则应回滚整个事务。
- 隔离性：同时发生的多个事务(并发事务)不应导致数据库处于不一致状态。应该执行每个事务，就好像它是系统中的唯一事务一样。任何交易都不应影响任何其他交易的存在。假设 A 在转移到 B 的同时准确地同时转移所有这 600 个；两笔交易都应独立行事，确保在转移金额前保持平衡。
- 持久性：数据应该在磁盘上持久存在，尽管存在任何数据库或系统故障，但不应丢失。

``InnoDB`` 是 MySQL 中的默认存储引擎，支持事务，而 ``MyISAM`` 不支持它们。

执行事务
========
创建虚拟表和样本数据以了解此配方：

.. code-block:: shell

    mysql> CREATE DATABASE bank;
    mysql> USE bank;
    mysql> CREATE TABLE account(account_number
    varchar(10) PRIMARY KEY, balance int);
    mysql> INSERT INTO account VALUES('A',600),('B',400);

为了启动一个事务，执行 ``START TRANSACTION`` 或者 ``BEGIN`` 语句：

.. code-block:: shell

    mysql> START TRANSACTION;
    or
    mysql> BEGIN;

然后执行您希望在事务中执行的所有语句，例如将 100 从 A 转到 B ：

.. code-block:: shell

    mysql> SELECT balance INTO @a.bal FROM account WHERE account_number='A';
    # Programmatically check if @a.bal is greater than or equal to 100
    mysql> UPDATE account SET balance=@a.bal-100 WHERE account_number='A';
    mysql> SELECT balance INTO @b.bal FROM account WHERE account_number='B';
    # Programmatically check if @b.bal IS NOT NULL
    mysql> UPDATE account SET balance=@b.bal+100 WHERE account_number='B';

确保成功执行所有 ``SQL`` 后，执行 ``COMMIT`` 语句，该语句将完成事务并提交数据：

.. code-block:: shell

    mysql> COMMIT;

如果您遇到任何错误并希望中止事务，则可以执行 ``ROLLBACK`` 语句而不是 ``COMMIT`` 。 例如，如果 A 想要转移到不存在的帐户，而不是发送给 B ，您应该中止交易并将金额退还给 A ：

.. code-block:: shell

    mysql> BEGIN;
    mysql> SELECT balance INTO @a.bal FROM account WHERE account_number='A';
    mysql> UPDATE account SET balance=@a.bal-100 WHERE account_number='A';
    mysql> SELECT balance INTO @b.bal FROM account WHERE account_number='C';
    Query OK, 0 rows affected, 1 warning (0.07 sec)
    mysql> SHOW WARNINGS;
    mysql> SELECT @b.bal;
    +--------+
    | @b.bal |
    +--------+
    | NULL   |
    +--------+
    1 row in set (0.00 sec)
    mysql> ROLLBACK;
    Query OK, 0 rows affected (0.01 sec)

自动提交
--------
默认情况下， ``autocommit`` 为 ``ON`` ，这意味着所有单个语句在执行后都会立即提交，除非它们位于 ``BEGIN ... COMMIT`` 块中。如果 ``autocommit`` 为 ``OFF`` ，则需要显式发出 ``COMMIT`` 语句以提交事务。 要禁用它，请执行：

.. code-block:: shell

    mysql> SET autocommit=0;

无法回滚 ``DDL`` 语句，例如数据库的 ``CREATE`` 或 ``DROP`` 以及表或存储例程的 ``CREATE`` ， ``DROP`` 或 ``ALTER`` 。

某些语句（如 ``DDL`` ， ``LOAD DATA INFILE`` ， ``ANALYZE TABLE`` ， ``replication`` 相关的语句等）会导致隐式 ``COMMIT`` 。 有关这些陈述的更多详细信息 https://dev.mysql.com/doc/refman/8.0/en/implicit-commit.html

使用保存点
==========
使用保存点，您可以回滚到事务中的某些点，而不会终止事务。您可以使用 ``SAVEPOINT identifier`` 为事务设置名称，并使用 ``ROLLBACK TO identifier`` 语句将事务回滚到指定的保存点，而不终止事务。

假设 A 想要转移到多个账户; 即使转移到一个帐户失败，其他帐户也不应回滚：

.. code-block:: shell

    mysql> BEGIN;
    Query OK, 0 rows affected (0.00 sec)
    mysql> SELECT balance INTO @a.bal FROM account WHERE
    account_number='A';
    Query OK, 1 row affected (0.01 sec)
    mysql> UPDATE account SET balance=@a.bal-100 WHERE
    account_number='A';
    Query OK, 1 row affected (0.01 sec)
    Rows matched: 1 Changed: 1 Warnings: 0
    mysql> UPDATE account SET balance=balance+100 WHERE
    account_number='B';
    Query OK, 1 row affected (0.00 sec)
    Rows matched: 1 Changed: 1 Warnings: 0
    mysql> SAVEPOINT transfer_to_b;
    Query OK, 0 rows affected (0.00 sec)
    mysql> SELECT balance INTO @a.bal FROM account WHERE
    account_number='A';
    Query OK, 1 row affected (0.00 sec)
    mysql> UPDATE account SET balance=balance+100 WHERE
    account_number='C';
    Query OK, 0 rows affected (0.00 sec)
    Rows matched: 0 Changed: 0 Warnings: 0
    ### 由于没有更新行，这意味着没有“C”帐户，您可以将事务回滚到 SAVEPOINT ，其中转移到 B 成功。 然后 'A' 将返回 100 被扣除以转移到 C 。如果您不想使用保存点，您应该在两个交易中执行这些操作。
    mysql> ROLLBACK TO transfer_to_b;
    Query OK, 0 rows affected (0.00 sec)
    mysql> COMMIT;
    Query OK, 0 rows affected (0.00 sec)
    mysql> SELECT balance FROM account WHERE
    account_number='A';
    +---------+
    | balance |
    +---------+
    | 400     |
    +---------+
    1 row in set (0.00 sec)
    mysql> SELECT balance FROM account WHERE
    account_number='B';
    +---------+
    | balance |
    +---------+
    | 600     |
    +---------+
    1 row in set (0.00 sec)

隔离级别
========
当两个或多个事务同时发生时，隔离级别定义事务与其他事务所做的资源数据修改的隔离程度。 隔离级别有四种类型；要更改隔离级别，您需要设置动态且具有会话级别范围的 ``tx_isolation`` 变量。

为了改变隔离级别，执行 ``SET @@transaction_isolation = 'READ-COMMITTED';``

多个事务并发时可能遇到的问题
----------------------------
1. Lost Update 更新丢失
   a. 第一类更新丢失，回滚覆盖：撤消一个事务时，在该事务内的写操作要回滚，把其它已提交的事务写入的数据覆盖了。
   b. 第二类更新丢失，提交覆盖：提交一个事务时，写操作依赖于事务内读到的数据，读发生在其他事务提交前，写发生在其他事务提交后，把其他已提交的事务写入的数据覆盖了。这是不可重复读的特例。
2. Dirty Read 脏读：一个事务读到了另一个未提交的事务写的数据。
3. Non-Repeatable Read 不可重复读：一个事务中两次读同一行数据，可是这两次读到的数据不一样。
4. Phantom Read 幻读：一个事务中两次查询，但第二次查询比第一次查询多了或少了几行或几列数据。

事务隔离级别
------------
- Read Uncommitted 读未提交：不允许第一类更新丢失。允许脏读，不隔离事务。
- Read Committed 读已提交：不允许脏读，允许不可重复读。
- Repeatable Read 可重复读：不允许不可重复读。但可能出现幻读。
- Serializable 串行化：所有的增删改查串行执行。

读未提交
------
当前事务可以读取由另一个未提交的事务写入的数据，该事务也称为脏读。可防止第一类丢失更新。

例如， A 想要向他的账户添加一些金额并将其转移到 B 。假设两个交易同时发生；流程将是这样的。

最初有 400 美元，并希望在他的帐户中加入 500 美元后将 500 美元转移到 B 。

+------------------------------------------------------------------+------------------------------------------------------------------------------+
| 事务1(添加金额)                                                  | 事务2(转账)                                                                  |
+==================================================================+==============================================================================+
| BEGIN;                                                           | BEGIN;                                                                       |
+------------------------------------------------------------------+------------------------------------------------------------------------------+
| UPDATE account SET balance=balance+500 WHERE account_number='A'; | --                                                                           |
+------------------------------------------------------------------+------------------------------------------------------------------------------+
| --                                                               | SELECT balance INTO @a.bal FROM account WHERE account_number='A';#为900      |
+------------------------------------------------------------------+------------------------------------------------------------------------------+
| 回滚，由于某些原因事务回滚了                                     | --                                                                           |
+------------------------------------------------------------------+------------------------------------------------------------------------------+
| --                                                               | A转账900给B UPDATE account SET balance=balance-900 WHERE account_number='A'; |
+------------------------------------------------------------------+------------------------------------------------------------------------------+
| --                                                               | B接受金额 UPDATE account SET balance=balance+900 WHERE account_number='B';   |
+------------------------------------------------------------------+------------------------------------------------------------------------------+
| --                                                               | 事务2完成 COMMIT;                                                            |
+------------------------------------------------------------------+------------------------------------------------------------------------------+

您可以注意到，事务2 已读取事务1未提交的数据，导致帐户 A 在此事务之后进入负余额，这显然是不希望的。

读提交
------
当前事务只能读取另一个事务提交的数据，但因为存在同一行数据重复读取值不一样的问题，因此也被称为不可重复读。

再举一个例子，其中 A 有 400 美元而 B 有 600 美元。

+------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------+
| 事务1(添加金额)                                                  | 事务2(转账)                                                                                                                    |
+==================================================================+================================================================================================================================+
| BEGIN;                                                           | BEGIN;                                                                                                                         |
+------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------+
| UPDATE account SET balance=balance+500 WHERE account_number='A'; | --                                                                                                                             |
+------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------+
| --                                                               | SELECT balance INTO @a.bal FROM account WHERE account_number='A';#因为事务1没有提交，所以值为400，注意此处已经不存在读未提交了 |
+------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------+
| COMMIT;                                                          | --                                                                                                                             |
+------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------+
| --                                                               | SELECT balance INTO @a.bal FROM account WHERE account_number='A';#因为事务1已经提交，所以值为400                               |
+------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------+

您可以注意到，在同一事务中，为同一 ``SELECT`` 语句提取了不同的结果。

可重复读
--------
即使另一个事务已提交数据，事务也将看到上面第一个语句读取的相同数据。同一事务中的所有一致读会读取第一次读取建立的快照。但是存在一个问题，就是可以读取同一事务中更改的数据。即可能存在幻读。

当事务开始并执行其第一次读取时，将创建读取视图并保持打开直到事务结束。为了在事务结束之前提供相同的结果集， ``InnoDB`` 使用行版本控制和 ``UNDO`` 信息。假设事务 1 已选择了几行，而另一个事务已删除这些行并提交了数据。如果事务 1 打开，它应该能够看到它在开头选择的行。删除的行保留在 ``UNDO`` 日志空间中以完成事务 1 。一旦事务 1 完成，行将被标记为从 ``UNDO`` 日志中删除。这称为 ``MultiVersion`` 并发控制（MVCC）。

再次使用相同的示例，其中 ``A`` 有 400 ， ``B`` 有 600 。

+-----------------------------------------------------------------+-----------------------------------------------------------------------------------------------------+
| 事务1(添加金额)                                                 | 事务2(转账)                                                                                         |
+=================================================================+=====================================================================================================+
| BEGIN;                                                          | BEGIN;                                                                                              |
+-----------------------------------------------------------------+-----------------------------------------------------------------------------------------------------+
| --                                                              | SELECT balance INTO @a.bal FROM account WHERE account_number='A';                                   |
+-----------------------------------------------------------------+-----------------------------------------------------------------------------------------------------+
| UPDATE account SET balance=balance+500 WHERE account_number='A' | --                                                                                                  |
+-----------------------------------------------------------------+-----------------------------------------------------------------------------------------------------+
| --                                                              | SELECT balance INTO @a.bal FROM account WHERE account_number='A';#即使事务1已经提交，还是返回400    |
+-----------------------------------------------------------------+-----------------------------------------------------------------------------------------------------+
| COMMIT;                                                         | --                                                                                                  |
+-----------------------------------------------------------------+-----------------------------------------------------------------------------------------------------+
| --                                                              | COMMIT;                                                                                             |
+-----------------------------------------------------------------+-----------------------------------------------------------------------------------------------------+
| --                                                              | SELECT balance INTO @a.bal FROM account WHERE account_number='A';#这是一个新的事务，可以看到返回900 |
+-----------------------------------------------------------------+-----------------------------------------------------------------------------------------------------+

这仅适用于 ``SELECT`` 语句，不一定适用于 ``DML`` 语句。 如果插入或修改某些行然后提交该事务，则从另一个并发 ``REPEATABLE READ`` 事务发出的 ``DELETE`` 或 ``UPDATE`` 语句可能会影响那些刚刚提交的行，即使当前事务会话中无法查询它们。如果事务确实更新或删除了由其他事务提交的行，则这些更改将对当前事务可见。

删除导致幻读的例子：

+---------------------------------------------------------------------+-------------------------------------------------------+
| 事务1                                                               | 事务2                                                 |
+=====================================================================+=======================================================+
| BEGIN;                                                              | BEGIN;                                                |
+---------------------------------------------------------------------+-------------------------------------------------------+
| SELECT * FROM account;#返回2行                                      | --                                                    |
+---------------------------------------------------------------------+-------------------------------------------------------+
| --                                                                  | INSERT INTO account VALUES('c',1000);#插入新账号      |
+---------------------------------------------------------------------+-------------------------------------------------------+
| --                                                                  | COMMIT;                                               |
+---------------------------------------------------------------------+-------------------------------------------------------+
| SELECT * FROM account_number='c';#因为MVCC没有行返回                | --                                                    |
+---------------------------------------------------------------------+-------------------------------------------------------+
| DELETE FROM account WHERE account_number='c';#奇怪的是，账号c被删除 | --                                                    |
+---------------------------------------------------------------------+-------------------------------------------------------+
| --                                                                  | SELECT * FROM account;#因为事务1没有提交，所以返回3行 |
+---------------------------------------------------------------------+-------------------------------------------------------+
| COMMIT;                                                             | --                                                    |
+---------------------------------------------------------------------+-------------------------------------------------------+
| --                                                                  | SELECT * FROM account;#因为事务1已经提交，所以返回2行 |
+---------------------------------------------------------------------+-------------------------------------------------------+

另一个更新导致幻读例子：

+-------------------------------------------------------------------------------+---------------------------------------+
| 事务1                                                                         | 事务2                                 |
+===============================================================================+=======================================+
| BEGIN;                                                                        | BEGIN;                                |
+-------------------------------------------------------------------------------+---------------------------------------+
| SELECT * FROM account;#返回2行                                                | --                                    |
+-------------------------------------------------------------------------------+---------------------------------------+
| --                                                                            | INSERT INTO account VALUES('D',1000); |
+-------------------------------------------------------------------------------+---------------------------------------+
| --                                                                            | COMMIT;                               |
+-------------------------------------------------------------------------------+---------------------------------------+
| SELECT * FROM account;#因为MVCC，所以返回2行                                  | --                                    |
+-------------------------------------------------------------------------------+---------------------------------------+
| UPDATE account SET balance=1000 WHERE account_number='D';#奇怪是账号D被更新了 | --                                    |
+-------------------------------------------------------------------------------+---------------------------------------+
| SELECT * FROM account;#返回3行                                                | --                                    |
+-------------------------------------------------------------------------------+---------------------------------------+

串行
----
这通过锁定所选的所有行来提供最高级别的隔离。这个级别就像 REPEATABLE READ ，但是如果禁用自动提交， ``InnoDB`` 会隐式地将所有普通的 ``SELECT`` 语句转换为 ``SELECT ... LOCK IN SHARE MODE`` 。如果启用了自动提交，则 SELECT 是其自己的事务。

例如：

+-------------------------------------------------+-------------------------------------------------------------------------------------+
| 事务1                                           | 事务2                                                                               |
+=================================================+=====================================================================================+
| BEGIN;                                          | BEGIN;                                                                              |
+-------------------------------------------------+-------------------------------------------------------------------------------------+
| SELECT * FROM account WHERE account_number='A'; | --                                                                                  |
+-------------------------------------------------+-------------------------------------------------------------------------------------+
| --                                              | UPDATE account SET balance=1000 WHERE account_number='A';#这将会等待知道事务1释放锁 |
+-------------------------------------------------+-------------------------------------------------------------------------------------+
| COMMIT                                          | --                                                                                  |
+-------------------------------------------------+-------------------------------------------------------------------------------------+
| --                                              | #将会更新成功                                                                       |
+-------------------------------------------------+-------------------------------------------------------------------------------------+

另一个例子：

+------------------------------------------------------------------+---------------------------------------------+
| 事务1                                                            | 事务2                                       |
+==================================================================+=============================================+
| BEGIN;                                                           | BEGIN;                                      |
+------------------------------------------------------------------+---------------------------------------------+
| SELECT * FROM account WHERE account_number='A'#选择A的值         | --                                          |
+------------------------------------------------------------------+---------------------------------------------+
| --                                                               | INSERT INTO account VALUES('D',2000);#插入D |
+------------------------------------------------------------------+---------------------------------------------+
| SELECT * FROM account WHERE account_number='D'#等待直到事务2完成 | --                                          |
+------------------------------------------------------------------+---------------------------------------------+
| --                                                               | COMMIT;                                     |
+------------------------------------------------------------------+---------------------------------------------+
| # 现在前面的选择语句返回D的值                                    | --                                          |
+------------------------------------------------------------------+---------------------------------------------+

因此， ``serializable`` 等待锁并始终读取最新提交的数据。

锁
==
存在两种类型的锁：

- 内部锁： ``MySQL`` 在服务器本身内执行内部锁定，以管理多个会话对表内容的争用；
- 外部锁： ``MySQL`` 为客户端会话提供选项，以显式获取表锁，以防止其他会话访问该表；

**内部锁：存在两种类型的锁**

- 行级别的锁：锁定的粒度到行的级别。仅锁定访问的行。这允许多个会话同时进行写访问，使其适用于多用户，高度并发和 ``OLTP`` 应用程序。 只有 ``InnoDB`` 支持行级锁。
- 表级别的锁： ``MySQL`` 对 ``MyISAM`` ， ``MEMORY`` 和 ``MERGE`` 表使用表级锁定，一次只允许一个会话更新这些表。此锁定级别使这些存储引擎更适合于只读，大多数读取或单用户应用程序。

参考 https://dev.mysql.com/doc/refman/8.0/en/internal-locking.html 和 https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html 来了解更多关于 InnoDB 锁。

**外部锁：你可以使用LOCK TABLE 和 UNLOCK TABLES 语句控制锁**

``READ`` 和 ``WRITE`` 的表锁定解释如下：

- READ ：当表被锁定为 ``READ`` 时，多个会话可以从表中读取数据而不获取锁。此外，多个会话可以获取同一个表上的锁，这就是 ``READ`` 锁也称为共享锁的原因。当持有 ``READ`` 锁定时，没有会话可以将数据写入表中（包括持有锁的会话）。如果有任何写入尝试，它将处于等待状态，直到释放 ``READ`` 锁定。
- WRITE ：当表被锁定为 ``WRITE`` 时，除了持有锁的会话之外，没有其他会话可以从表读取和写入数据。在释放现有锁之前，没有其他会话可以获取任何锁。这就是为什么这被称为独占锁。 如果进行了任何读/写尝试，它将处于等待状态，直到释放 ``WRITE`` 锁。

执行 ``UNLOCK TABLES`` 语句或会话终止时，将释放所有锁。

语法如下：

.. code-block:: shell

    mysql> LOCK TABLES table_name [READ | WRITE]

为了释放锁，使用：

.. code-block:: shell

    mysql> UNLOCK TABLES;

要锁定所有数据库中的所有表，请执行以下语句。 当想获取数据库的一致快照时使用它。 它会冻结对数据库的所有写入：

.. code-block:: shell

    mysql> FLUSH TABLES WITH READ LOCK;

锁队列
------
除共享锁（一个表可以有多个共享锁）之外，一个表不能持有多个锁。如果表已经具有共享锁并且出现了申请独占锁，则它将保留在队列中，直到释放共享锁。当排它锁在队列中时，所有后续共享锁也会被阻塞并保留在队列中。

``InnoDB`` 在从表中读/写时获取元数据锁。如果第二个事务请求 ``WRITE LOCK`` ，它将保留在队列中，直到第一个事务完成。如果第三个事务要读取数据，则必须等到第二个事务完成。

事务1：

.. code-block:: shell

    mysql> BEGIN;
    mysql> SELECT * FROM employees LIMIT 10;

注意没有提交，事务还是打开的。

事务2：

.. code-block:: shell

    mysql> LOCK TABLE employees WRITE;

此语句必须等到事务 1 完成。

事务3：

.. code-block:: shell

    mysql> SELECT * FROM employees LIMIT 10;

即使事务 3 也不会给出任何结果，因为队列中存在独占锁（它正在等待事务 1 完成）。 而且，它阻止了表上的所有操作。您可以通过从另一个会话中检查 ``SHOW PROCESSLIST`` 来检查：

.. code-block:: shell

    mysql> SHOW PROCESSLIST;

您可以注意到事务 2 和事务 3 都在等待事务 1 。

为了获取更多关于元数据的锁，请参考 https://dev.mysql.com/doc/refman/8.0/en/metadata-locking.html 。

使用带有 ``READ LOCK`` 的 ``FLUSH TABLES`` 时，可以观察到相同的行为。

事务1：

.. code-block:: shell

    mysql> BEGIN;
    mysql> SELECT * FROM employees LIMIT 10;

请注意， ``COMMIT`` 没有执行。事务保持打开。

事务2：

.. code-block:: shell

    mysql> FLUSH TABLES WITH READ LOCK;

事务3：

.. code-block:: shell

    mysql> SELECT * FROM employees LIMIT 10;

甚至事务 3 也不会给出任何结果，因为 ``FLUSH TABLES`` 在获取锁之前等待表上的所有操作完成。而且，它阻止了表上的所有操作。 您可以通过从另一个会话中 ``SHOW PROCESSLIST`` 来检查这一点。

.. code-block:: shell

    mysql> SHOW PROCESSLIST;

为了获取一致的备份，所有备份方法都使用 ``FLUSH TABLES WITH READ LOCK`` ，如果表上存在长时间运行的事务，这可能非常危险。

详情请参考 https://www.cnblogs.com/zengkefu/p/5678353.html


关于各个隔离级别使用锁情况需要进一步研究。。