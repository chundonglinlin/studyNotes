

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>1. 请求到web响应的生命周期 &mdash; laravel 1.0 文档</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="索引"
              href="genindex.html"/>
        <link rel="search" title="搜索" href="search.html"/>
    <link rel="top" title="laravel 1.0 文档" href="index.html"/>
        <link rel="next" title="2. 请求到console响应的生命周期" href="请求到响应的生命周期-console.html"/>
        <link rel="prev" title="Welcome to laravel&#39;s documentation!" href="index.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> laravel
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">目录:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">1. 请求到web响应的生命周期</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id2">1.1. 程序启动准备</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id3">1.1.1. 服务容器实例化</a></li>
<li class="toctree-l3"><a class="reference internal" href="#kernel">1.1.2. 核心类(Kernel类)实例化</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id8">1.2. 请求实例化</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id9">1.3. 处理请求</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id10">1.3.1. 请求处理准备工作</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id20">1.3.2. 中间件</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id21">1.3.3. 路由处理生成响应</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id25">1.4. 响应的发送和程序终止</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id26">1.4.1. 响应的发送</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id27">1.4.2. 程序终止</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="请求到响应的生命周期-console.html">2. 请求到console响应的生命周期</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的容器.html">3. 容器</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的Facades.html">4. Facades</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的Facades原理分析.html">5. Facade的原理</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的服务提供器.html">6. 服务提供器</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的路由.html">7. 路由</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的路由—路由的正则编译.html">8. 路由的正则编译</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的路由—路由的匹配与参数绑定.html">9. 路由的匹配与参数绑定</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的路由—路由中间件.html">10. 路由的中间件</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的中间件.html">11. 中间件</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的中间件-SubstituteBindings.html">12. 中间件SubstituteBindings</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的中间件-CSRF.html">13. 中间件CSRF</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的请求.html">14. 请求</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的控制器.html">15. 控制器</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的控制器—控制器方法的参数构建与运行.html">16. 控制器方法的参数构建与运行</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的响应.html">17. 响应</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的视图.html">18. 视图</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的生成URL.html">19. URL</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的Session.html">20. Session</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的Session原理分析.html">21. Session原理分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的表单验证机制详解.html">22. 表单验证机制详解</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的日志.html">23. 日志</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的异常和错误处理.html">24. 异常和错误处理</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的异常和错误处理原理分析.html">25. 异常和错误处理原理分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的Blade.html">26. Blade</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的blade原理分析.html">27. Blade原理分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的前端.html">28. 前端</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的Mix.html">29. Mix</a></li>
<li class="toctree-l1"><a class="reference internal" href="laravel-mix.html">30. mix使用手册</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的用户认证系统.html">31. Laravel 的用户认证系统</a></li>
<li class="toctree-l1"><a class="reference internal" href="用户认证JWT.html">32. 用户认证JWT</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的API认证系统Passport.html">33. Laravel 的 API 认证系统 Passport</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的用户授权系统.html">34. Laravel用户授权系统</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的命令行.html">35. 命令行</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的广播系统.html">36. 广播</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的广播系统原理分析.html">37. 广播系统原理分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的缓存系统.html">38. 缓存</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的集合Collection.html">39. 集合</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的事件系统.html">40. 事件</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的事件系统原理分析.html">41. 事件系统原理分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的文件存储.html">42. 文件存储</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的辅助函数-字符串操作.html">43. 辅助函数-字符串函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的辅助函数-数组和对象操作.html">44. 辅助函数-数组和对象函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的辅助函数-路径操作.html">45. 辅助函数-路径函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的辅助函数-tap分析.html">46. 辅助函数-Tap函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的辅助函数-其它.html">47. 辅助函数-其它杂项</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的邮件发送功能.html">48. 邮件</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的消息通知.html">49. 通知</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel Queue——消息队列任务与分发源码剖析.html">50. 消息队列任务与分发源码剖析</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的任务调度.html">51. 任务调度</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的数据库—原始方式.html">52. 数据库-原始操作</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的数据库—查询构造器.html">53. 数据库-查询构建器</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的数据分页.html">54. 数据分页</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的数据分页原理分析.html">55. 数据分页原理分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的数据库迁移.html">56. 数据库迁移</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的数据库填充.html">57. 数据库填充</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的Redis.html">58. Redis</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的Redis原理分析.html">59. Redis原理分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的数据库—Eloquent.html">60. Eloquent</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的数据库—Eloquent关联.html">61. Eloquent关联</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的数据库—Eloquent修改器.html">62. Eloquent修改器</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的验证规则.html">63. 验证规则</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">laravel</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>1. 请求到web响应的生命周期</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            
        
        <a href="http://blog.liaozhonghao.cn" rel="nofollow"> 返回主页</a>
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="web">
<h1><a class="toc-backref" href="#id28">1. 请求到web响应的生命周期</a><a class="headerlink" href="#web" title="永久链接至标题">¶</a></h1>
<div class="contents topic" id="id1">
<p class="topic-title first">目录</p>
<ul class="simple">
<li><a class="reference internal" href="#web" id="id28">请求到web响应的生命周期</a><ul>
<li><a class="reference internal" href="#id2" id="id29">程序启动准备</a><ul>
<li><a class="reference internal" href="#id3" id="id30">服务容器实例化</a><ul>
<li><a class="reference internal" href="#id4" id="id31">注册应用的基础路径</a></li>
<li><a class="reference internal" href="#id5" id="id32">注册基础绑定</a></li>
<li><a class="reference internal" href="#id6" id="id33">注册基础服务提供者</a></li>
<li><a class="reference internal" href="#id7" id="id34">注册核心类别名</a></li>
</ul>
</li>
<li><a class="reference internal" href="#kernel" id="id35">核心类(Kernel类)实例化</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id8" id="id36">请求实例化</a></li>
<li><a class="reference internal" href="#id9" id="id37">处理请求</a><ul>
<li><a class="reference internal" href="#id10" id="id38">请求处理准备工作</a><ul>
<li><a class="reference internal" href="#id11" id="id39">环境检测和配置加载</a></li>
<li><a class="reference internal" href="#id13" id="id40">配置文件的加载</a></li>
<li><a class="reference internal" href="#id14" id="id41">异常处理</a></li>
<li><a class="reference internal" href="#id15" id="id42">外观注册</a></li>
<li><a class="reference internal" href="#id18" id="id43">服务提供者注册</a></li>
<li><a class="reference internal" href="#id19" id="id44">启动服务</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id20" id="id45">中间件</a></li>
<li><a class="reference internal" href="#id21" id="id46">路由处理生成响应</a><ul>
<li><a class="reference internal" href="#id22" id="id47">路由匹配</a></li>
<li><a class="reference internal" href="#id23" id="id48">控制器生成</a></li>
<li><a class="reference internal" href="#id24" id="id49">响应生成</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#id25" id="id50">响应的发送和程序终止</a><ul>
<li><a class="reference internal" href="#id26" id="id51">响应的发送</a></li>
<li><a class="reference internal" href="#id27" id="id52">程序终止</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<p>这里介绍了请求到响应的整个执行过程，主要分为四个阶段，即程序启动准备阶段、请求实例化阶段、请求处理阶段、响应发送和程序终止阶段。每个阶段都有相应的职责功能。</p>
<ul class="simple">
<li>程序启动准备阶段：主要完成文件自动加载的实现、服务容器的实例化、基础服务器提供者的注册及核心类的实例化等，核心类实例对象用于控制请求实例对象生成和处理过程的各个环节，而服务容器实例化是为整个过程提供资源服务。</li>
<li>请求实例化阶段：将请求信息以对象的形式进行记录保存的过程。</li>
<li>请求处理阶段：首先是准备请求处理的环境，包括环境检测、配置加载、日志管理、异常处理、外观注册、服务提供者注册、启动服务器提供者等七个环节，然后将请求实例通过中间件处理及通过路由和控制器的分发控制，使得不同请求通过相应的处理函数进行处理并生成响应的过程。</li>
<li>响应的发送和程序终止阶段：将响应返回给客户端并记录与客户端有关的信息等工作。</li>
</ul>
<div class="section" id="id2">
<h2><a class="toc-backref" href="#id29">1.1. 程序启动准备</a><a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>在Laravel框架中，所有的请求入口文件是 <code class="docutils literal"><span class="pre">public</span></code> 目录下的 <code class="docutils literal"><span class="pre">index.php</span></code> 文件。</p>
<p>文件 <code class="docutils literal"><span class="pre">laravel\public\index.php</span></code></p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>

    <span class="nb">define</span><span class="p">(</span><span class="s1">&#39;LARAVEL_START&#39;</span><span class="p">,</span> <span class="nb">microtime</span><span class="p">(</span><span class="k">true</span><span class="p">));</span>

    <span class="c1">// 注册composer的自动加载器</span>
    <span class="k">require</span> <span class="no">__DIR__</span><span class="o">.</span><span class="s1">&#39;/../vendor/autoload.php&#39;</span><span class="p">;</span>

    <span class="c1">// 程序启动准备阶段入口文件</span>
    <span class="nv">$app</span> <span class="o">=</span> <span class="k">require_once</span> <span class="no">__DIR__</span><span class="o">.</span><span class="s1">&#39;/../bootstrap/app.php&#39;</span><span class="p">;</span>

    <span class="c1">// 使用容器创建内核对象</span>
    <span class="nv">$kernel</span> <span class="o">=</span> <span class="nv">$app</span><span class="o">-&gt;</span><span class="na">make</span><span class="p">(</span><span class="nx">Illuminate\Contracts\Http\Kernel</span><span class="o">::</span><span class="na">class</span><span class="p">);</span>
    <span class="c1">// 处理请求</span>
    <span class="nv">$response</span> <span class="o">=</span> <span class="nv">$kernel</span><span class="o">-&gt;</span><span class="na">handle</span><span class="p">(</span>
        <span class="nv">$request</span> <span class="o">=</span> <span class="nx">Illuminate\Http\Request</span><span class="o">::</span><span class="na">capture</span><span class="p">()</span>
    <span class="p">);</span>
    <span class="c1">// 返回响应给浏览器</span>
    <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">send</span><span class="p">();</span>
    <span class="c1">// 响应后的处理，如调用中间件的terminate()方法</span>
    <span class="nv">$kernel</span><span class="o">-&gt;</span><span class="na">terminate</span><span class="p">(</span><span class="nv">$request</span><span class="p">,</span> <span class="nv">$response</span><span class="p">);</span>
</pre></div>
</div>
<p>程序的启动准备阶段是入口文件中的代码 <code class="docutils literal"><span class="pre">require_once</span> <span class="pre">__DIR__.'/../bootstrap/app.php'</span></code> 部分，主要实现了服务容器的实例化和基本注册，包括基础路径注册、服务容器本身注册、基础服务提供者注册、核心类别名注册。在注册过程中，服务容器会在对应属性中记录注册的内容，以便在程序运行期间提供对应的服务。</p>
<p>程序启动准备阶段具体过程如图所示：</p>
<p>(图片)</p>
<div class="section" id="id3">
<h3><a class="toc-backref" href="#id30">1.1.1. 服务容器实例化</a><a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<p>入口文件 <code class="docutils literal"><span class="pre">index.php</span></code> 的第一句为加载composer的自动加载器。文件的第二句是调用 <code class="docutils literal"><span class="pre">bootstrap</span></code> 文件夹下的 <code class="docutils literal"><span class="pre">app.php</span></code> 中的代码，主要用来实例化服务容器，并注册 <code class="docutils literal"><span class="pre">laravel</span></code> 框架的核心类服务，为后面自动生成 <code class="docutils literal"><span class="pre">$kernel</span></code> 核心类实例提供基础。</p>
<p>文件 <code class="docutils literal"><span class="pre">laravel\bootstrap\app.php</span></code></p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>

    <span class="c1">// 创建应用容器</span>
    <span class="nv">$app</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Illuminate\Foundation\Application</span><span class="p">(</span>
        <span class="nb">realpath</span><span class="p">(</span><span class="no">__DIR__</span><span class="o">.</span><span class="s1">&#39;/../&#39;</span><span class="p">)</span>
    <span class="p">);</span>

    <span class="c1">// 在容器中为重要的接口绑定实现类</span>
    <span class="c1">// 绑定处理web请求的内核</span>
    <span class="nv">$app</span><span class="o">-&gt;</span><span class="na">singleton</span><span class="p">(</span>
        <span class="nx">Illuminate\Contracts\Http\Kernel</span><span class="o">::</span><span class="na">class</span><span class="p">,</span>
        <span class="nx">App\Http\Kernel</span><span class="o">::</span><span class="na">class</span>
    <span class="p">);</span>
    <span class="c1">// 绑定处理CLI请求的内核</span>
    <span class="nv">$app</span><span class="o">-&gt;</span><span class="na">singleton</span><span class="p">(</span>
        <span class="nx">Illuminate\Contracts\Console\Kernel</span><span class="o">::</span><span class="na">class</span><span class="p">,</span>
        <span class="nx">App\Console\Kernel</span><span class="o">::</span><span class="na">class</span>
    <span class="p">);</span>
    <span class="c1">// 绑定异常处理接口</span>
    <span class="nv">$app</span><span class="o">-&gt;</span><span class="na">singleton</span><span class="p">(</span>
        <span class="nx">Illuminate\Contracts\Debug\ExceptionHandler</span><span class="o">::</span><span class="na">class</span><span class="p">,</span>
        <span class="nx">App\Exceptions\Handler</span><span class="o">::</span><span class="na">class</span>
    <span class="p">);</span>

    <span class="k">return</span> <span class="nv">$app</span><span class="p">;</span>
</pre></div>
</div>
<p>在服务容器的实例化过程中，在构造函数中对服务容器中的服务进行了绑定。那么，服务容器的构造函数绑定了那些服务。需要注意的是，服务容器的实例化参数是 <code class="docutils literal"><span class="pre">Laravel</span></code> 框架的根目录地址。</p>
<p>文件 <code class="docutils literal"><span class="pre">Illuminate\Foundation\Application.php</span></code></p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
    <span class="k">public</span> <span class="k">function</span> <span class="fm">__construct</span><span class="p">(</span><span class="nv">$basePath</span> <span class="o">=</span> <span class="k">null</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nv">$basePath</span><span class="p">)</span> <span class="p">{</span>
            <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">setBasePath</span><span class="p">(</span><span class="nv">$basePath</span><span class="p">);</span> <span class="c1">// 设置各个文件夹路径</span>
        <span class="p">}</span>

        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">registerBaseBindings</span><span class="p">();</span> <span class="c1">// 绑定基础实例</span>

        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">registerBaseServiceProviders</span><span class="p">();</span> <span class="c1">// 注册事件、日志、路由服务提供器</span>

        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">registerCoreContainerAliases</span><span class="p">();</span> <span class="c1">// 注册服务绑定名称的别名</span>
    <span class="p">}</span>
</pre></div>
</div>
<div class="section" id="id4">
<h4><a class="toc-backref" href="#id31">1.1.1.1. 注册应用的基础路径</a><a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="c1">//注册应用的基础路径</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">setBasePath</span><span class="p">(</span><span class="nv">$basePath</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">basePath</span> <span class="o">=</span> <span class="nb">rtrim</span><span class="p">(</span><span class="nv">$basePath</span><span class="p">,</span> <span class="s1">&#39;\/&#39;</span><span class="p">);</span>

    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">bindPathsInContainer</span><span class="p">();</span>

    <span class="k">return</span> <span class="nv">$this</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 在容器中绑定应用程序的基础路径</span>
<span class="k">protected</span> <span class="k">function</span> <span class="nf">bindPathsInContainer</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">instance</span><span class="p">(</span><span class="s1">&#39;path&#39;</span><span class="p">,</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">path</span><span class="p">());</span>  <span class="c1">// 设置App目录路径，默认为app</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">instance</span><span class="p">(</span><span class="s1">&#39;path.base&#39;</span><span class="p">,</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">basePath</span><span class="p">());</span> <span class="c1">// 设置应用所在路径，默认为项目所在的路径</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">instance</span><span class="p">(</span><span class="s1">&#39;path.lang&#39;</span><span class="p">,</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">langPath</span><span class="p">());</span> <span class="c1">// 设置语言包所在路径，默认为resources/lang</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">instance</span><span class="p">(</span><span class="s1">&#39;path.config&#39;</span><span class="p">,</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">configPath</span><span class="p">());</span> <span class="c1">// 设置配置所在的路径，默认为config</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">instance</span><span class="p">(</span><span class="s1">&#39;path.public&#39;</span><span class="p">,</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">publicPath</span><span class="p">());</span> <span class="c1">// 设置public所在的路径，默认为public</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">instance</span><span class="p">(</span><span class="s1">&#39;path.storage&#39;</span><span class="p">,</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">storagePath</span><span class="p">());</span> <span class="c1">// 设置存储所在的路径，默认为storage</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">instance</span><span class="p">(</span><span class="s1">&#39;path.database&#39;</span><span class="p">,</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">databasePath</span><span class="p">());</span> <span class="c1">// 设置数据库相关的路径，默认为database</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">instance</span><span class="p">(</span><span class="s1">&#39;path.resources&#39;</span><span class="p">,</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">resourcePath</span><span class="p">());</span> <span class="c1">// 设置资源所在的路径，默认为resources</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">instance</span><span class="p">(</span><span class="s1">&#39;path.bootstrap&#39;</span><span class="p">,</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">bootstrapPath</span><span class="p">());</span> <span class="c1">// 设置启动文件所在路径，默认为bootstrap</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h4><a class="toc-backref" href="#id32">1.1.1.2. 注册基础绑定</a><a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h4>
<p>主要是绑定容器实例本身，使得其他的对象可以很容易得到服务容器实例，其中服务容器中设置了一个静态变量 <code class="docutils literal"><span class="pre">$instance</span></code> ，该变量是在 <code class="docutils literal"><span class="pre">Container</span></code> 容器类中定义的，因为 <code class="docutils literal"><span class="pre">Application</span></code> 类继承了 <code class="docutils literal"><span class="pre">Container</span></code> 容器类，所以继承该静态变量，可以通过 <code class="docutils literal"><span class="pre">Container</span></code> 中的静态函数 <code class="docutils literal"><span class="pre">getInstance()</span></code> 直接获取服务容器实例。另外，为服务容器实例绑定了不同的服务别名，记录在 <code class="docutils literal"><span class="pre">$instances</span></code> 共享实例数组中，可以通过这些别名的任何一个找到服务容器实例。源码如下：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">protected</span> <span class="k">function</span> <span class="nf">registerBaseBindings</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">static</span><span class="o">::</span><span class="na">setInstance</span><span class="p">(</span><span class="nv">$this</span><span class="p">);</span> <span class="c1">// 保存容器到$instance中，实现容器的单实例</span>

    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">instance</span><span class="p">(</span><span class="s1">&#39;app&#39;</span><span class="p">,</span> <span class="nv">$this</span><span class="p">);</span> <span class="c1">// 绑定容器别名为app</span>

    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">instance</span><span class="p">(</span><span class="nx">Container</span><span class="o">::</span><span class="na">class</span><span class="p">,</span> <span class="nv">$this</span><span class="p">);</span> <span class="c1">// 绑定容器实例到Container类</span>

    <span class="c1">// laravel5.5 包自动发现机制，http://www.jb51.net/article/123598.htm</span>
    <span class="c1">// 运行时该机制会自动注册包中的provider和alias</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">instance</span><span class="p">(</span><span class="nx">PackageManifest</span><span class="o">::</span><span class="na">class</span><span class="p">,</span> <span class="k">new</span> <span class="nx">PackageManifest</span><span class="p">(</span>
        <span class="k">new</span> <span class="nx">Filesystem</span><span class="p">,</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">basePath</span><span class="p">(),</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">getCachedPackagesPath</span><span class="p">()</span>
    <span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>文件 <code class="docutils literal"><span class="pre">Illuminate\Container\Container.php</span></code></p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">instance</span><span class="p">(</span><span class="nv">$abstract</span><span class="p">,</span> <span class="nv">$instance</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">removeAbstractAlias</span><span class="p">(</span><span class="nv">$abstract</span><span class="p">);</span> <span class="c1">// 删除抽象别名数组中的别名</span>

    <span class="nv">$isBound</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">bound</span><span class="p">(</span><span class="nv">$abstract</span><span class="p">);</span> <span class="c1">// 判断该别名是否绑定</span>

    <span class="nb">unset</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">aliases</span><span class="p">[</span><span class="nv">$abstract</span><span class="p">]);</span> <span class="c1">// 删除别名数组中的别名</span>

    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">instances</span><span class="p">[</span><span class="nv">$abstract</span><span class="p">]</span> <span class="o">=</span> <span class="nv">$instance</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="nv">$isBound</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 重新绑定该命名别名实例</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">rebound</span><span class="p">(</span><span class="nv">$abstract</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nv">$instance</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h4><a class="toc-backref" href="#id33">1.1.1.3. 注册基础服务提供者</a><a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h4>
<p>接下来，将进行基础服务提供者的注册。服务器提供者的注册是 <code class="docutils literal"><span class="pre">Laravel</span></code> 应用程序的启动和运行中最重要的行为之一，因为它为服务容器添加应用需要的各种服务。在服务容器的构造函数中只注册了最基础的两个服务提供者，随着 <code class="docutils literal"><span class="pre">Laravel</span></code> 应用程序的运行还会有很多服务提供者被加载注册。</p>
<p>文件 <code class="docutils literal"><span class="pre">Illuminate\Foundation\Application.php</span></code></p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="c1">// 注册基础服务提供者</span>
<span class="k">protected</span> <span class="k">function</span> <span class="nf">registerBaseServiceProviders</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">register</span><span class="p">(</span><span class="k">new</span> <span class="nx">EventServiceProvider</span><span class="p">(</span><span class="nv">$this</span><span class="p">));</span> <span class="c1">// 注册事件服务提供器</span>

    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">register</span><span class="p">(</span><span class="k">new</span> <span class="nx">LogServiceProvider</span><span class="p">(</span><span class="nv">$this</span><span class="p">));</span> <span class="c1">// 注册日志服务提供器</span>

    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">register</span><span class="p">(</span><span class="k">new</span> <span class="nx">RoutingServiceProvider</span><span class="p">(</span><span class="nv">$this</span><span class="p">));</span> <span class="c1">// 注册路由服务提供器</span>
<span class="p">}</span>
<span class="c1">// 在服务容器中注册一个服务提供者</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">register</span><span class="p">(</span><span class="nv">$provider</span><span class="p">,</span> <span class="nv">$options</span> <span class="o">=</span> <span class="p">[],</span> <span class="nv">$force</span> <span class="o">=</span> <span class="k">false</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 如果容器中已经注册，则直接返回该服务提供者</span>
    <span class="k">if</span> <span class="p">((</span><span class="nv">$registered</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">getProvider</span><span class="p">(</span><span class="nv">$provider</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="o">!</span> <span class="nv">$force</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nv">$registered</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">is_string</span><span class="p">(</span><span class="nv">$provider</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// 根据类名来解析服务提供者实例</span>
        <span class="nv">$provider</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">resolveProvider</span><span class="p">(</span><span class="nv">$provider</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">method_exists</span><span class="p">(</span><span class="nv">$provider</span><span class="p">,</span> <span class="s1">&#39;register&#39;</span><span class="p">))</span> <span class="p">{</span>
        <span class="nv">$provider</span><span class="o">-&gt;</span><span class="na">register</span><span class="p">();</span> <span class="c1">// 调用服务提供者注册方法</span>
    <span class="p">}</span>

    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">markAsRegistered</span><span class="p">(</span><span class="nv">$provider</span><span class="p">);</span> <span class="c1">// 保存该实例到容器中，标记为已经加载</span>

    <span class="cm">/*</span>
<span class="cm">     * 如果应用程序已经启动，我们将在提供程序类中调用此引导方法，以便它有机会执行其引导逻辑，并且可以为此开发人员的应用程序逻辑的任何使用做好准备。</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">booted</span><span class="p">)</span> <span class="p">{</span><span class="c1">// 只有在应用已经启动时，才执行此逻辑</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">bootProvider</span><span class="p">(</span><span class="nv">$provider</span><span class="p">);</span> <span class="c1">// 调用服务提供者的boot方法</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nv">$provider</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>基础服务提供者注册所必须的步骤：</p>
<ol class="arabic simple">
<li>实例化服务提供者，由 <code class="docutils literal"><span class="pre">$this-&gt;resolveProvider($provider)</span></code> 函数完成；</li>
<li>调用服务提供者的 <code class="docutils literal"><span class="pre">register()</span></code> ，该函数用于向服务容器中注册服务；</li>
<li>标识该服务提供者已经注册过了，这部分内容通过 <code class="docutils literal"><span class="pre">markAsRegistered()</span></code> 函数实现的；</li>
<li>如果应用程序已经启动过了，则以后注册的服务提供者都会调用它的 <code class="docutils literal"><span class="pre">boot()</span></code> 方法；</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">(存在问题，这个类中根本没有定义register/boot抽象方法？？)每个服务提供者都继承自 <code class="docutils literal"><span class="pre">\Illuminate\Support\ServiceProvider</span></code> 类，该类有个 <code class="docutils literal"><span class="pre">register()</span></code> 虚函数，所以每个服务提供者必须实现这个函数，用来填充服务容器并提供服务。同时，应用程序会在适当时候统一调用服务提供者的 <code class="docutils literal"><span class="pre">boot()</span></code> 函数，但这个函数服务提供者可以不实现，因为在 <code class="docutils literal"><span class="pre">\Illuminate\Support\ServiceProvider</span></code> 类中的魔术方法 <code class="docutils literal"><span class="pre">__call()</span></code> 提供了该函数的处理。所以，如果自己需要设计服务提供者来进行服务注册，则需要继承该类并实现这个函数。</p>
</div>
</div>
<div class="section" id="id7">
<h4><a class="toc-backref" href="#id34">1.1.1.4. 注册核心类别名</a><a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h4>
<p>由于 <code class="docutils literal"><span class="pre">Laravel</span></code> 框架的类是基于命名空间的，所以类名都比较长，为此在服务容器中为一些常用的类注册了别名，在后面程序中会通过别名来代替这个类名。</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">registerCoreContainerAliases</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">foreach</span> <span class="p">([</span>
        <span class="s1">&#39;app&#39;</span>                  <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">\Illuminate\Foundation\Application</span><span class="o">::</span><span class="na">class</span><span class="p">,</span> <span class="nx">\Illuminate\Contracts\Container\Container</span><span class="o">::</span><span class="na">class</span><span class="p">,</span> <span class="nx">\Illuminate\Contracts\Foundation\Application</span><span class="o">::</span><span class="na">class</span><span class="p">,</span>  <span class="nx">\Psr\Container\ContainerInterface</span><span class="o">::</span><span class="na">class</span><span class="p">],</span>
        <span class="s1">&#39;auth&#39;</span>                 <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">\Illuminate\Auth\AuthManager</span><span class="o">::</span><span class="na">class</span><span class="p">,</span> <span class="nx">\Illuminate\Contracts\Auth\Factory</span><span class="o">::</span><span class="na">class</span><span class="p">],</span>
        <span class="s1">&#39;auth.driver&#39;</span>          <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">\Illuminate\Contracts\Auth\Guard</span><span class="o">::</span><span class="na">class</span><span class="p">],</span>
        <span class="s1">&#39;blade.compiler&#39;</span>       <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">\Illuminate\View\Compilers\BladeCompiler</span><span class="o">::</span><span class="na">class</span><span class="p">],</span>
        <span class="s1">&#39;cache&#39;</span>                <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">\Illuminate\Cache\CacheManager</span><span class="o">::</span><span class="na">class</span><span class="p">,</span> <span class="nx">\Illuminate\Contracts\Cache\Factory</span><span class="o">::</span><span class="na">class</span><span class="p">],</span>
        <span class="s1">&#39;cache.store&#39;</span>          <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">\Illuminate\Cache\Repository</span><span class="o">::</span><span class="na">class</span><span class="p">,</span> <span class="nx">\Illuminate\Contracts\Cache\Repository</span><span class="o">::</span><span class="na">class</span><span class="p">],</span>
        <span class="s1">&#39;config&#39;</span>               <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">\Illuminate\Config\Repository</span><span class="o">::</span><span class="na">class</span><span class="p">,</span> <span class="nx">\Illuminate\Contracts\Config\Repository</span><span class="o">::</span><span class="na">class</span><span class="p">],</span>
        <span class="s1">&#39;cookie&#39;</span>               <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">\Illuminate\Cookie\CookieJar</span><span class="o">::</span><span class="na">class</span><span class="p">,</span> <span class="nx">\Illuminate\Contracts\Cookie\Factory</span><span class="o">::</span><span class="na">class</span><span class="p">,</span> <span class="nx">\Illuminate\Contracts\Cookie\QueueingFactory</span><span class="o">::</span><span class="na">class</span><span class="p">],</span>
        <span class="s1">&#39;encrypter&#39;</span>            <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">\Illuminate\Encryption\Encrypter</span><span class="o">::</span><span class="na">class</span><span class="p">,</span> <span class="nx">\Illuminate\Contracts\Encryption\Encrypter</span><span class="o">::</span><span class="na">class</span><span class="p">],</span>
        <span class="s1">&#39;db&#39;</span>                   <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">\Illuminate\Database\DatabaseManager</span><span class="o">::</span><span class="na">class</span><span class="p">],</span>
        <span class="s1">&#39;db.connection&#39;</span>        <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">\Illuminate\Database\Connection</span><span class="o">::</span><span class="na">class</span><span class="p">,</span> <span class="nx">\Illuminate\Database\ConnectionInterface</span><span class="o">::</span><span class="na">class</span><span class="p">],</span>
        <span class="s1">&#39;events&#39;</span>               <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">\Illuminate\Events\Dispatcher</span><span class="o">::</span><span class="na">class</span><span class="p">,</span> <span class="nx">\Illuminate\Contracts\Events\Dispatcher</span><span class="o">::</span><span class="na">class</span><span class="p">],</span>
        <span class="s1">&#39;files&#39;</span>                <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">\Illuminate\Filesystem\Filesystem</span><span class="o">::</span><span class="na">class</span><span class="p">],</span>
        <span class="s1">&#39;filesystem&#39;</span>           <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">\Illuminate\Filesystem\FilesystemManager</span><span class="o">::</span><span class="na">class</span><span class="p">,</span> <span class="nx">\Illuminate\Contracts\Filesystem\Factory</span><span class="o">::</span><span class="na">class</span><span class="p">],</span>
        <span class="s1">&#39;filesystem.disk&#39;</span>      <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">\Illuminate\Contracts\Filesystem\Filesystem</span><span class="o">::</span><span class="na">class</span><span class="p">],</span>
        <span class="s1">&#39;filesystem.cloud&#39;</span>     <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">\Illuminate\Contracts\Filesystem\Cloud</span><span class="o">::</span><span class="na">class</span><span class="p">],</span>
        <span class="s1">&#39;hash&#39;</span>                 <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">\Illuminate\Contracts\Hashing\Hasher</span><span class="o">::</span><span class="na">class</span><span class="p">],</span>
        <span class="s1">&#39;translator&#39;</span>           <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">\Illuminate\Translation\Translator</span><span class="o">::</span><span class="na">class</span><span class="p">,</span> <span class="nx">\Illuminate\Contracts\Translation\Translator</span><span class="o">::</span><span class="na">class</span><span class="p">],</span>
        <span class="s1">&#39;log&#39;</span>                  <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">\Illuminate\Log\Writer</span><span class="o">::</span><span class="na">class</span><span class="p">,</span> <span class="nx">\Illuminate\Contracts\Logging\Log</span><span class="o">::</span><span class="na">class</span><span class="p">,</span> <span class="nx">\Psr\Log\LoggerInterface</span><span class="o">::</span><span class="na">class</span><span class="p">],</span>
        <span class="s1">&#39;mailer&#39;</span>               <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">\Illuminate\Mail\Mailer</span><span class="o">::</span><span class="na">class</span><span class="p">,</span> <span class="nx">\Illuminate\Contracts\Mail\Mailer</span><span class="o">::</span><span class="na">class</span><span class="p">,</span> <span class="nx">\Illuminate\Contracts\Mail\MailQueue</span><span class="o">::</span><span class="na">class</span><span class="p">],</span>
        <span class="s1">&#39;auth.password&#39;</span>        <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">\Illuminate\Auth\Passwords\PasswordBrokerManager</span><span class="o">::</span><span class="na">class</span><span class="p">,</span> <span class="nx">\Illuminate\Contracts\Auth\PasswordBrokerFactory</span><span class="o">::</span><span class="na">class</span><span class="p">],</span>
        <span class="s1">&#39;auth.password.broker&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">\Illuminate\Auth\Passwords\PasswordBroker</span><span class="o">::</span><span class="na">class</span><span class="p">,</span> <span class="nx">\Illuminate\Contracts\Auth\PasswordBroker</span><span class="o">::</span><span class="na">class</span><span class="p">],</span>
        <span class="s1">&#39;queue&#39;</span>                <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">\Illuminate\Queue\QueueManager</span><span class="o">::</span><span class="na">class</span><span class="p">,</span> <span class="nx">\Illuminate\Contracts\Queue\Factory</span><span class="o">::</span><span class="na">class</span><span class="p">,</span> <span class="nx">\Illuminate\Contracts\Queue\Monitor</span><span class="o">::</span><span class="na">class</span><span class="p">],</span>
        <span class="s1">&#39;queue.connection&#39;</span>     <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">\Illuminate\Contracts\Queue\Queue</span><span class="o">::</span><span class="na">class</span><span class="p">],</span>
        <span class="s1">&#39;queue.failer&#39;</span>         <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">\Illuminate\Queue\Failed\FailedJobProviderInterface</span><span class="o">::</span><span class="na">class</span><span class="p">],</span>
        <span class="s1">&#39;redirect&#39;</span>             <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">\Illuminate\Routing\Redirector</span><span class="o">::</span><span class="na">class</span><span class="p">],</span>
        <span class="s1">&#39;redis&#39;</span>                <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">\Illuminate\Redis\RedisManager</span><span class="o">::</span><span class="na">class</span><span class="p">,</span> <span class="nx">\Illuminate\Contracts\Redis\Factory</span><span class="o">::</span><span class="na">class</span><span class="p">],</span>
        <span class="s1">&#39;request&#39;</span>              <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">\Illuminate\Http\Request</span><span class="o">::</span><span class="na">class</span><span class="p">,</span> <span class="nx">\Symfony\Component\HttpFoundation\Request</span><span class="o">::</span><span class="na">class</span><span class="p">],</span>
        <span class="s1">&#39;router&#39;</span>               <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">\Illuminate\Routing\Router</span><span class="o">::</span><span class="na">class</span><span class="p">,</span> <span class="nx">\Illuminate\Contracts\Routing\Registrar</span><span class="o">::</span><span class="na">class</span><span class="p">,</span> <span class="nx">\Illuminate\Contracts\Routing\BindingRegistrar</span><span class="o">::</span><span class="na">class</span><span class="p">],</span>
        <span class="s1">&#39;session&#39;</span>              <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">\Illuminate\Session\SessionManager</span><span class="o">::</span><span class="na">class</span><span class="p">],</span>
        <span class="s1">&#39;session.store&#39;</span>        <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">\Illuminate\Session\Store</span><span class="o">::</span><span class="na">class</span><span class="p">,</span> <span class="nx">\Illuminate\Contracts\Session\Session</span><span class="o">::</span><span class="na">class</span><span class="p">],</span>
        <span class="s1">&#39;url&#39;</span>                  <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">\Illuminate\Routing\UrlGenerator</span><span class="o">::</span><span class="na">class</span><span class="p">,</span> <span class="nx">\Illuminate\Contracts\Routing\UrlGenerator</span><span class="o">::</span><span class="na">class</span><span class="p">],</span>
        <span class="s1">&#39;validator&#39;</span>            <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">\Illuminate\Validation\Factory</span><span class="o">::</span><span class="na">class</span><span class="p">,</span> <span class="nx">\Illuminate\Contracts\Validation\Factory</span><span class="o">::</span><span class="na">class</span><span class="p">],</span>
        <span class="s1">&#39;view&#39;</span>                 <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">\Illuminate\View\Factory</span><span class="o">::</span><span class="na">class</span><span class="p">,</span> <span class="nx">\Illuminate\Contracts\View\Factory</span><span class="o">::</span><span class="na">class</span><span class="p">],</span>
    <span class="p">]</span> <span class="k">as</span> <span class="nv">$key</span> <span class="o">=&gt;</span> <span class="nv">$aliases</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">foreach</span> <span class="p">(</span><span class="nv">$aliases</span> <span class="k">as</span> <span class="nv">$alias</span><span class="p">)</span> <span class="p">{</span>
            <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">alias</span><span class="p">(</span><span class="nv">$key</span><span class="p">,</span> <span class="nv">$alias</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 在容器中注册别名</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">alias</span><span class="p">(</span><span class="nv">$abstract</span><span class="p">,</span> <span class="nv">$alias</span><span class="p">)</span>
<span class="p">{</span>   <span class="c1">// 以类名作为key,别名作为值</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">aliases</span><span class="p">[</span><span class="nv">$alias</span><span class="p">]</span> <span class="o">=</span> <span class="nv">$abstract</span><span class="p">;</span>
    <span class="c1">// 以别名作为key，类名作为值</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">abstractAliases</span><span class="p">[</span><span class="nv">$abstract</span><span class="p">][]</span> <span class="o">=</span> <span class="nv">$alias</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在 <code class="docutils literal"><span class="pre">registerCoreContainerAliases()</span></code> 的 <code class="docutils literal"><span class="pre">$aliases</span></code> 数组变量中定义了整个框架的核心服务别名，在服务解析过程中，需要根据实例化的类或接口名称查找服务别名，然后通过服务别名获取具体的服务。至此，应用程序的准备工作已经完成了，这里已经生成了服务容器，在服务容器中注册绑定了基础的服务提供者、服务别名和基础路径。</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="nv">$app</span><span class="o">-&gt;</span><span class="na">singleton</span><span class="p">(</span>
    <span class="nx">Illuminate\Contracts\Http\Kernel</span><span class="o">::</span><span class="na">class</span><span class="p">,</span>
    <span class="nx">App\Http\Kernel</span><span class="o">::</span><span class="na">class</span>
<span class="p">);</span>
</pre></div>
</div>
<p>执行到这里并没有实例化 <code class="docutils literal"><span class="pre">App\Http\Kernel::class</span></code> 类，仅仅是生成了一个闭包。当需要的时候，使用该闭包生成实例对象。</p>
</div>
</div>
<div class="section" id="kernel">
<h3><a class="toc-backref" href="#id35">1.1.2. 核心类(Kernel类)实例化</a><a class="headerlink" href="#kernel" title="永久链接至标题">¶</a></h3>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
    <span class="c1">// 使用容器创建内核对象</span>
    <span class="nv">$kernel</span> <span class="o">=</span> <span class="nv">$app</span><span class="o">-&gt;</span><span class="na">make</span><span class="p">(</span><span class="nx">Illuminate\Contracts\Http\Kernel</span><span class="o">::</span><span class="na">class</span><span class="p">);</span>
</pre></div>
</div>
<p>服务容器实例化后，就可以通过服务容器来自动实例化对象了。 <code class="docutils literal"><span class="pre">Kernel</span></code> 类就是通过服务容器自动化创建而成的。那么我们又在什么时候绑定了映射？在 <code class="docutils literal"><span class="pre">laravel\bootstrap\app.php</span></code> 文件中，实例化服务容器之后就注册了三个服务，其中就包括这个核心类接口。在注册服务时，服务名一般是接口。在 <code class="docutils literal"><span class="pre">Contracts</span></code> 命名空间下存储的都是接口，而提供的服务则是具体类、实例对象或返回实例对象的回调函数。</p>
<p>由于注册的服务只是具体类名，所以可以通过反射机制来实例化，并通过反射机制自动解决构造函数中的依赖关系。于是，通过服务容器实例化 <code class="docutils literal"><span class="pre">App\Http\Kernel</span></code> 类时，这个类只是定义了 <code class="docutils literal"><span class="pre">$middleware</span></code> (全局中间件) 、 <code class="docutils literal"><span class="pre">$middlewareGroups</span></code> 和 <code class="docutils literal"><span class="pre">$routeMiddleware</span></code> (路由中间件)三个数组属性，其中中间件是请求进入路由处理前的处理类(全局的中间件)，中间件组是对中间件进行分组，从而方便使用。而路由中间件是请求进入路由处理后的处理类(路由中间件)，所以这里可以在路由中添加新的中间件处理类，只要按照中间件的设计原则进行设计，并在中间件类组的正确位置添加类名，在处理请求的过程中就会调用新添加的中间件处理过程。</p>
<p>因为 <code class="docutils literal"><span class="pre">App\Http\Kernel</span></code> 类继承了 <code class="docutils literal"><span class="pre">Illuminate\Foundation\Http\Kernel</span></code> 类，所以实例化过程中会调用该类中的构造函数，下面是构造函数源码。</p>
<p>文件 <code class="docutils literal"><span class="pre">Illuminate\Foundation\Http\Kernel.php</span></code></p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="c1">// 创建一个新的HTTP核心类实例</span>
<span class="k">public</span> <span class="k">function</span> <span class="fm">__construct</span><span class="p">(</span><span class="nx">Application</span> <span class="nv">$app</span><span class="p">,</span> <span class="nx">Router</span> <span class="nv">$router</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">app</span> <span class="o">=</span> <span class="nv">$app</span><span class="p">;</span> <span class="c1">// 传入容器实例</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">router</span> <span class="o">=</span> <span class="nv">$router</span><span class="p">;</span> <span class="c1">// 传入前面容器实例化的路由实例对象</span>

    <span class="nv">$router</span><span class="o">-&gt;</span><span class="na">middlewarePriority</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">middlewarePriority</span><span class="p">;</span> <span class="c1">// 设置路由实例中间件执行优先级</span>

    <span class="c1">// 传入配置的中间件组到路由实例对象中</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">middlewareGroups</span> <span class="k">as</span> <span class="nv">$key</span> <span class="o">=&gt;</span> <span class="nv">$middleware</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$router</span><span class="o">-&gt;</span><span class="na">middlewareGroup</span><span class="p">(</span><span class="nv">$key</span><span class="p">,</span> <span class="nv">$middleware</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 传入配置的路由中间件到路由实例对象中</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">routeMiddleware</span> <span class="k">as</span> <span class="nv">$key</span> <span class="o">=&gt;</span> <span class="nv">$middleware</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$router</span><span class="o">-&gt;</span><span class="na">aliasMiddleware</span><span class="p">(</span><span class="nv">$key</span><span class="p">,</span> <span class="nv">$middleware</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这里通过构造函数的类型提示使用容器来进行依赖注入，完成了服务容器和核心类的实例化之后，接下来该处理请求了。</p>
</div>
</div>
<div class="section" id="id8">
<h2><a class="toc-backref" href="#id36">1.2. 请求实例化</a><a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h2>
<p>在 <code class="docutils literal"><span class="pre">Laravel</span></code> 框架中，完成准备工作后，将进行请求的实例化。在 <code class="docutils literal"><span class="pre">Laravel</span></code> 框架中我们将请求信息分类并保存在 <code class="docutils literal"><span class="pre">Illuminate\Http\Request</span></code> 类的实例对象中，于是请求也就转换为一个实例对象。在处理请求的过程中，只需要处理这个实例对象就可以了。请求实例的创建时通过 <code class="docutils literal"><span class="pre">Illuminate\Http\Request</span></code> 类的 <code class="docutils literal"><span class="pre">capture()</span></code> 静态函数完成的，即 <code class="docutils literal"><span class="pre">$request</span> <span class="pre">=</span> <span class="pre">Illuminate\Http\Request::capture()</span></code> ，这个函数的源码如下：</p>
<p>文件 <code class="docutils literal"><span class="pre">Illuminate\Http\Request.php</span></code></p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="c1">// 通过服务器提供的变量创建一个HTTP请求实例对象</span>
<span class="k">public</span> <span class="k">static</span> <span class="k">function</span> <span class="nf">capture</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">static</span><span class="o">::</span><span class="na">enableHttpMethodParameterOverride</span><span class="p">();</span>  <span class="c1">// 开启表单方法重载</span>
    <span class="c1">// 先创建Symfony\Component\HttpFoundation\Request的对象，然后使用\Illuminate\Http\Request对象封装</span>
    <span class="k">return</span> <span class="k">static</span><span class="o">::</span><span class="na">createFromBase</span><span class="p">(</span><span class="nx">SymfonyRequest</span><span class="o">::</span><span class="na">createFromGlobals</span><span class="p">());</span>
<span class="p">}</span>
<span class="c1">// 创建并返回\Illuminate\Http\Request对象</span>
<span class="k">public</span> <span class="k">static</span> <span class="k">function</span> <span class="nf">createFromBase</span><span class="p">(</span><span class="nx">SymfonyRequest</span> <span class="nv">$request</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 首先确认是不是Illuminate\Http\Request实例，这里刚创建的是</span>
    <span class="c1">// Symfony\Component\HttpFoundation, 所以if判断为false,</span>
    <span class="k">if</span> <span class="p">(</span><span class="nv">$request</span> <span class="nx">instanceof</span> <span class="k">static</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nv">$request</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nv">$content</span> <span class="o">=</span> <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">content</span><span class="p">;</span>
    <span class="c1">// 因为不是Illuminate\Http\Request实例，所以这里创建一个laravel处理的Request类的实例</span>
    <span class="nv">$request</span> <span class="o">=</span> <span class="p">(</span><span class="k">new</span> <span class="k">static</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">duplicate</span><span class="p">(</span>
        <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">query</span><span class="o">-&gt;</span><span class="na">all</span><span class="p">(),</span> <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">request</span><span class="o">-&gt;</span><span class="na">all</span><span class="p">(),</span> <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">attributes</span><span class="o">-&gt;</span><span class="na">all</span><span class="p">(),</span>
        <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">cookies</span><span class="o">-&gt;</span><span class="na">all</span><span class="p">(),</span> <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">files</span><span class="o">-&gt;</span><span class="na">all</span><span class="p">(),</span> <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">server</span><span class="o">-&gt;</span><span class="na">all</span><span class="p">()</span>
    <span class="p">);</span>

    <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">content</span> <span class="o">=</span> <span class="nv">$content</span><span class="p">;</span>
    <span class="c1">// 有无请求参数，如果有的话，就在这里拿（刚生成是没有的，都从$_SERVER等参数那里拿）</span>
    <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">request</span> <span class="o">=</span> <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">getInputSource</span><span class="p">();</span>

    <span class="k">return</span> <span class="nv">$request</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>通过上面的代码可以看到， <code class="docutils literal"><span class="pre">Laravel</span></code> 框架的请求实例是在 <code class="docutils literal"><span class="pre">Symfony</span></code> 请求实例的基础上创建的。而 <code class="docutils literal"><span class="pre">Symfony</span></code> 框架的请求实例是通过 <code class="docutils literal"><span class="pre">createFromGlobals()</span></code> 静态函数实现的，接下来介绍 <code class="docutils literal"><span class="pre">Symfony</span></code> 框架对请求是如何进行实例化封装的，这也是请求实例化的重点。在 <code class="docutils literal"><span class="pre">Symfony</span></code> 框架中，是通过PHP的全局数组作为参数来实例化请求的，其中包括 <code class="docutils literal"><span class="pre">$_GET,</span> <span class="pre">$_POST,</span> <span class="pre">$_COOKIE,</span> <span class="pre">$_FILES,</span> <span class="pre">$_SERVER</span></code> 只是开始先对 <code class="docutils literal"><span class="pre">$_SERVER</span></code> 中的参数进行了一下处理，因为PHP的一个bug，当PHP的接口类型为cli-server时，会将 <code class="docutils literal"><span class="pre">Content-Type</span></code> 和 <code class="docutils literal"><span class="pre">Content-Length</span></code> 的值存储在 <code class="docutils literal"><span class="pre">HTTP_CONTENT_TYPE</span></code> 和 <code class="docutils literal"><span class="pre">HTTP_CONTENT_LENGTH</span></code> 两个字段中，这里需要对其进行修改，然后这些全局数组交给请求创建工厂。</p>
<p>文件 <code class="docutils literal"><span class="pre">symfony\http-foundation\Request.php</span></code></p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="c1">// 通过PHP全局变量创建一个新的请求实例</span>
<span class="k">public</span> <span class="k">static</span> <span class="k">function</span> <span class="nf">createFromGlobals</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// CLI mode 需要对字段调整</span>
    <span class="nv">$server</span> <span class="o">=</span> <span class="nv">$_SERVER</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;cli-server&#39;</span> <span class="o">===</span> <span class="nx">PHP_SAPI</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">array_key_exists</span><span class="p">(</span><span class="s1">&#39;HTTP_CONTENT_LENGTH&#39;</span><span class="p">,</span> <span class="nv">$_SERVER</span><span class="p">))</span> <span class="p">{</span>
            <span class="nv">$server</span><span class="p">[</span><span class="s1">&#39;CONTENT_LENGTH&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nv">$_SERVER</span><span class="p">[</span><span class="s1">&#39;HTTP_CONTENT_LENGTH&#39;</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">array_key_exists</span><span class="p">(</span><span class="s1">&#39;HTTP_CONTENT_TYPE&#39;</span><span class="p">,</span> <span class="nv">$_SERVER</span><span class="p">))</span> <span class="p">{</span>
            <span class="nv">$server</span><span class="p">[</span><span class="s1">&#39;CONTENT_TYPE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nv">$_SERVER</span><span class="p">[</span><span class="s1">&#39;HTTP_CONTENT_TYPE&#39;</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 创建并返回\Symfony\Component\HttpFoundation\Request对象，实际上是用全局变量来实例化对应的类（可以对全局变量进行安全过滤），在赋予Request对象</span>
    <span class="nv">$request</span> <span class="o">=</span> <span class="nx">self</span><span class="o">::</span><span class="na">createRequestFromFactory</span><span class="p">(</span><span class="nv">$_GET</span><span class="p">,</span> <span class="nv">$_POST</span><span class="p">,</span> <span class="k">array</span><span class="p">(),</span> <span class="nv">$_COOKIE</span><span class="p">,</span> <span class="nv">$_FILES</span><span class="p">,</span> <span class="nv">$server</span><span class="p">);</span>

    <span class="c1">// 如果是以PUT|DELETE|PATCH方法进行的标准编码传输方式，就从原始数据的只读流解析数据到request属性（此属性其实对应的是POST键值对，PUT|DELETE|PATCH传输方式会被转成POST方式进行统一处理）</span>
    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">===</span> <span class="nb">strpos</span><span class="p">(</span><span class="nv">$request</span><span class="o">-&gt;</span><span class="na">headers</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s1">&#39;CONTENT_TYPE&#39;</span><span class="p">),</span> <span class="s1">&#39;application/x-www-form-urlencoded&#39;</span><span class="p">)</span>
        <span class="o">&amp;&amp;</span> <span class="nb">in_array</span><span class="p">(</span><span class="nb">strtoupper</span><span class="p">(</span><span class="nv">$request</span><span class="o">-&gt;</span><span class="na">server</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s1">&#39;REQUEST_METHOD&#39;</span><span class="p">,</span> <span class="s1">&#39;GET&#39;</span><span class="p">)),</span> <span class="k">array</span><span class="p">(</span><span class="s1">&#39;PUT&#39;</span><span class="p">,</span> <span class="s1">&#39;DELETE&#39;</span><span class="p">,</span> <span class="s1">&#39;PATCH&#39;</span><span class="p">))</span>
    <span class="p">)</span> <span class="p">{</span>
        <span class="nb">parse_str</span><span class="p">(</span><span class="nv">$request</span><span class="o">-&gt;</span><span class="na">getContent</span><span class="p">(),</span> <span class="nv">$data</span><span class="p">);</span>
        <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">request</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ParameterBag</span><span class="p">(</span><span class="nv">$data</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nv">$request</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//</span>
<span class="k">private</span> <span class="k">static</span> <span class="k">function</span> <span class="nf">createRequestFromFactory</span><span class="p">(</span><span class="k">array</span> <span class="nv">$query</span> <span class="o">=</span> <span class="k">array</span><span class="p">(),</span> <span class="k">array</span> <span class="nv">$request</span> <span class="o">=</span> <span class="k">array</span><span class="p">(),</span> <span class="k">array</span> <span class="nv">$attributes</span> <span class="o">=</span> <span class="k">array</span><span class="p">(),</span> <span class="k">array</span> <span class="nv">$cookies</span> <span class="o">=</span> <span class="k">array</span><span class="p">(),</span> <span class="k">array</span> <span class="nv">$files</span> <span class="o">=</span> <span class="k">array</span><span class="p">(),</span> <span class="k">array</span> <span class="nv">$server</span> <span class="o">=</span> <span class="k">array</span><span class="p">(),</span> <span class="nv">$content</span> <span class="o">=</span> <span class="k">null</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 如果存在自定义的方法，则调用并返回相应的对象</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">self</span><span class="o">::</span><span class="nv">$requestFactory</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$request</span> <span class="o">=</span> <span class="nb">call_user_func</span><span class="p">(</span><span class="nx">self</span><span class="o">::</span><span class="nv">$requestFactory</span><span class="p">,</span> <span class="nv">$query</span><span class="p">,</span> <span class="nv">$request</span><span class="p">,</span> <span class="nv">$attributes</span><span class="p">,</span> <span class="nv">$cookies</span><span class="p">,</span> <span class="nv">$files</span><span class="p">,</span> <span class="nv">$server</span><span class="p">,</span> <span class="nv">$content</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nv">$request</span> <span class="nx">instanceof</span> <span class="nx">self</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nx">\LogicException</span><span class="p">(</span><span class="s1">&#39;The Request factory must return an instance of Symfony\Component\HttpFoundation\Request.&#39;</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nv">$request</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 后期静态绑定</span>
    <span class="k">return</span> <span class="k">new</span> <span class="k">static</span><span class="p">(</span><span class="nv">$query</span><span class="p">,</span> <span class="nv">$request</span><span class="p">,</span> <span class="nv">$attributes</span><span class="p">,</span> <span class="nv">$cookies</span><span class="p">,</span> <span class="nv">$files</span><span class="p">,</span> <span class="nv">$server</span><span class="p">,</span> <span class="nv">$content</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">getContent</span><span class="p">(</span><span class="nv">$asResource</span> <span class="o">=</span> <span class="k">false</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nv">$currentContentIsResource</span> <span class="o">=</span> <span class="nb">is_resource</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">content</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">\PHP_VERSION_ID</span> <span class="o">&lt;</span> <span class="mi">50600</span> <span class="o">&amp;&amp;</span> <span class="k">false</span> <span class="o">===</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">content</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nx">\LogicException</span><span class="p">(</span><span class="s1">&#39;getContent() can only be called once when using the resource return type and PHP below 5.6.&#39;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// 内容作为资源类型处理</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">true</span> <span class="o">===</span> <span class="nv">$asResource</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nv">$currentContentIsResource</span><span class="p">)</span> <span class="p">{</span>
            <span class="nb">rewind</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">content</span><span class="p">);</span> <span class="c1">// 重置文件指针</span>

            <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">content</span><span class="p">;</span> <span class="c1">// 返回资源流</span>
        <span class="p">}</span>

        <span class="c1">// Content passed in parameter (test)</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">is_string</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">content</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// 如果是字符串，写入临时文件中</span>
            <span class="nv">$resource</span> <span class="o">=</span> <span class="nb">fopen</span><span class="p">(</span><span class="s1">&#39;php://temp&#39;</span><span class="p">,</span> <span class="s1">&#39;r+&#39;</span><span class="p">);</span>
            <span class="nb">fwrite</span><span class="p">(</span><span class="nv">$resource</span><span class="p">,</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">content</span><span class="p">);</span>
            <span class="nb">rewind</span><span class="p">(</span><span class="nv">$resource</span><span class="p">);</span>

            <span class="k">return</span> <span class="nv">$resource</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">content</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>

        <span class="k">return</span> <span class="nb">fopen</span><span class="p">(</span><span class="s1">&#39;php://input&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="nv">$currentContentIsResource</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">rewind</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">content</span><span class="p">);</span>

        <span class="k">return</span> <span class="nb">stream_get_contents</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">content</span><span class="p">);</span> <span class="c1">// 从资源流中返回字符串</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="k">null</span> <span class="o">===</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">content</span> <span class="o">||</span> <span class="k">false</span> <span class="o">===</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">content</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">content</span> <span class="o">=</span> <span class="nb">file_get_contents</span><span class="p">(</span><span class="s1">&#39;php://input&#39;</span><span class="p">);</span> <span class="c1">// 从输入流中返回字符串</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">content</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>请求相关信息的参数是通过 <code class="docutils literal"><span class="pre">parameterBag</span></code> 、 <code class="docutils literal"><span class="pre">FileBag</span></code> 等类的实例来封装的，其中 <code class="docutils literal"><span class="pre">FileBag、ServerBag</span></code> 等类也继承了 <code class="docutils literal"><span class="pre">ParameterBag</span></code> 类，相应的参数存储方式是相同的，只是添加了更多的参数处理函数功能。</p>
<p>总之：最后创建了一个解析了 <code class="docutils literal"><span class="pre">$_GET,</span> <span class="pre">$_POST,</span> <span class="pre">$_COOKIE,</span> <span class="pre">$_FILES,</span> <span class="pre">$_SERVER</span></code> 等变量之后的 <code class="docutils literal"><span class="pre">Illuminate\Http\Request</span></code> 类的对象。</p>
<p>这里只是介绍了 <code class="docutils literal"><span class="pre">Laravel</span></code> 框架的请求实例化过程，在开发过程中还需要对请求的实例进行不同的操作，包括对请求参数的访问和存储等，这部分内容将在后续章节详细介绍。</p>
</div>
<div class="section" id="id9">
<h2><a class="toc-backref" href="#id37">1.3. 处理请求</a><a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h2>
<p>在完成了请求实例化后，将进入对请求实例的处理阶段，即 <code class="docutils literal"><span class="pre">$response</span> <span class="pre">=</span> <span class="pre">$kernel-&gt;handle($request)</span></code> 过程。请求的处理是服务器应用程序的核心功能，通过不同的处理方式最终返回各种响应，实现不同的功能。如何提供可扩展的请求分发处理模块是服务器框架程序成功的关键，具体代码如下：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="c1">// 处理一个输入HTTP请求</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">handle</span><span class="p">(</span><span class="nv">$request</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">enableHttpMethodParameterOverride</span><span class="p">();</span> <span class="c1">// 开启请求方法重载</span>
        <span class="c1">// 通过路由来发送请求</span>
        <span class="nv">$response</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">sendRequestThroughRouter</span><span class="p">(</span><span class="nv">$request</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">Exception</span> <span class="nv">$e</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">reportException</span><span class="p">(</span><span class="nv">$e</span><span class="p">);</span>

        <span class="nv">$response</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">renderException</span><span class="p">(</span><span class="nv">$request</span><span class="p">,</span> <span class="nv">$e</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">Throwable</span> <span class="nv">$e</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">reportException</span><span class="p">(</span><span class="nv">$e</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">FatalThrowableError</span><span class="p">(</span><span class="nv">$e</span><span class="p">));</span>

        <span class="nv">$response</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">renderException</span><span class="p">(</span><span class="nv">$request</span><span class="p">,</span> <span class="nv">$e</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// 分发请求已经处理的事件</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">app</span><span class="p">[</span><span class="s1">&#39;events&#39;</span><span class="p">]</span><span class="o">-&gt;</span><span class="na">dispatch</span><span class="p">(</span>
        <span class="k">new</span> <span class="nx">Events\RequestHandled</span><span class="p">(</span><span class="nv">$request</span><span class="p">,</span> <span class="nv">$response</span><span class="p">)</span>
    <span class="p">);</span>

    <span class="k">return</span> <span class="nv">$response</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>请求的处理是通过 <code class="docutils literal"><span class="pre">sendRequestThroughRouter()</span></code> 方法实现的，通过该方法名就可以看出来，即通过路由传输请求实例。这里需要注意的是， <code class="docutils literal"><span class="pre">enableHttpMethodParameterOverride()</span></code> 方法会拒绝请求，需要在请求处理过程中添加 <code class="docutils literal"><span class="pre">CSRF</span></code> 保护。</p>
<div class="section" id="id10">
<h3><a class="toc-backref" href="#id38">1.3.1. 请求处理准备工作</a><a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h3>
<p>前面介绍了应用程序运行的准备环节，而要实现请求的处理，还有很多基础工作要做，这里包括环境检测和变量加载、配置加载、异常处理、外观注册、服务提供者注册和启动服务共六哥步骤，下面将对其中几个步骤的关键环节进行介绍。首先看一下这七个步骤是如何启动的，具体源码如下：</p>
<p>文件 <code class="docutils literal"><span class="pre">Illuminate\Foundation\Http\Kernel.php</span></code></p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">protected</span> <span class="nv">$bootstrappers</span> <span class="o">=</span> <span class="p">[</span>
    <span class="nx">\Illuminate\Foundation\Bootstrap\LoadEnvironmentVariables</span><span class="o">::</span><span class="na">class</span><span class="p">,</span>
    <span class="nx">\Illuminate\Foundation\Bootstrap\LoadConfiguration</span><span class="o">::</span><span class="na">class</span><span class="p">,</span>
    <span class="nx">\Illuminate\Foundation\Bootstrap\HandleExceptions</span><span class="o">::</span><span class="na">class</span><span class="p">,</span>
    <span class="nx">\Illuminate\Foundation\Bootstrap\RegisterFacades</span><span class="o">::</span><span class="na">class</span><span class="p">,</span>
    <span class="nx">\Illuminate\Foundation\Bootstrap\RegisterProviders</span><span class="o">::</span><span class="na">class</span><span class="p">,</span>
    <span class="nx">\Illuminate\Foundation\Bootstrap\BootProviders</span><span class="o">::</span><span class="na">class</span><span class="p">,</span>
<span class="p">];</span>
<span class="c1">// 将请求通过中间件和路由处理</span>
<span class="k">protected</span> <span class="k">function</span> <span class="nf">sendRequestThroughRouter</span><span class="p">(</span><span class="nv">$request</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 注入请求对象到服务容器，供后面使用</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">app</span><span class="o">-&gt;</span><span class="na">instance</span><span class="p">(</span><span class="s1">&#39;request&#39;</span><span class="p">,</span> <span class="nv">$request</span><span class="p">);</span>
    <span class="c1">// 清空门面类中保存request实例</span>
    <span class="nx">Facade</span><span class="o">::</span><span class="na">clearResolvedInstance</span><span class="p">(</span><span class="s1">&#39;request&#39;</span><span class="p">);</span>
    <span class="c1">// 启动应用（包括加载设置环境变量、加载配置文件、设置系统错误异常、Facade、注册和启动各服务提供者等）</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">bootstrap</span><span class="p">();</span>
    <span class="c1">// 委托管道形式处理请求，这个是middleware实现的本质</span>
    <span class="k">return</span> <span class="p">(</span><span class="k">new</span> <span class="nx">Pipeline</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">app</span><span class="p">))</span>
                <span class="o">-&gt;</span><span class="na">send</span><span class="p">(</span><span class="nv">$request</span><span class="p">)</span>
                <span class="o">-&gt;</span><span class="na">through</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">app</span><span class="o">-&gt;</span><span class="na">shouldSkipMiddleware</span><span class="p">()</span> <span class="o">?</span> <span class="p">[]</span> <span class="o">:</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">middleware</span><span class="p">)</span>
                <span class="o">-&gt;</span><span class="na">then</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">dispatchToRouter</span><span class="p">());</span>
<span class="p">}</span>
<span class="c1">// 开始请求处理准备工作</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">bootstrap</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">app</span><span class="o">-&gt;</span><span class="na">hasBeenBootstrapped</span><span class="p">())</span> <span class="p">{</span><span class="c1">// 如果应用程序没有完全启动</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">app</span><span class="o">-&gt;</span><span class="na">bootstrapWith</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">bootstrappers</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>文件 <code class="docutils literal"><span class="pre">Illuminate\Foundation\Application.php</span></code></p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="c1">// 运行给定的启动类数组</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">bootstrapWith</span><span class="p">(</span><span class="k">array</span> <span class="nv">$bootstrappers</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">hasBeenBootstrapped</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>

    <span class="k">foreach</span> <span class="p">(</span><span class="nv">$bootstrappers</span> <span class="k">as</span> <span class="nv">$bootstrapper</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 启动前的事件触发</span>
        <span class="nv">$this</span><span class="p">[</span><span class="s1">&#39;events&#39;</span><span class="p">]</span><span class="o">-&gt;</span><span class="na">fire</span><span class="p">(</span><span class="s1">&#39;bootstrapping: &#39;</span><span class="o">.</span><span class="nv">$bootstrapper</span><span class="p">,</span> <span class="p">[</span><span class="nv">$this</span><span class="p">]);</span>
        <span class="c1">// 创建相应的对象并执行引导操作</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">make</span><span class="p">(</span><span class="nv">$bootstrapper</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">bootstrap</span><span class="p">(</span><span class="nv">$this</span><span class="p">);</span>
        <span class="c1">// 启动后的事件触发</span>
        <span class="nv">$this</span><span class="p">[</span><span class="s1">&#39;events&#39;</span><span class="p">]</span><span class="o">-&gt;</span><span class="na">fire</span><span class="p">(</span><span class="s1">&#39;bootstrapped: &#39;</span><span class="o">.</span><span class="nv">$bootstrapper</span><span class="p">,</span> <span class="p">[</span><span class="nv">$this</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面提到的，在请求处理的准备阶段共六个环节，每一个环节是由一个类来负责实现的，而每个类都会有一个 <code class="docutils literal"><span class="pre">bootstrap()</span></code> 函数用于实现准备工作，这六个类名就存储在 <code class="docutils literal"><span class="pre">Illuminate\Foundation\Http\Kernel.php</span></code> 类的 <code class="docutils literal"><span class="pre">$bootstrappers</span></code> 数组属性中。在请求发送路由之前，首先通过 <code class="docutils literal"><span class="pre">bootstrap()</span></code> 函数完成准备工作，该函数会调用服务容器实例中的 <code class="docutils literal"><span class="pre">bootstrapWith()</span></code> 函数，这里将通过代码 <code class="docutils literal"><span class="pre">$this-&gt;make($bootstrapper)</span></code> 完成每个准备类的实例化工作，然后调用准备类的 <code class="docutils literal"><span class="pre">bootstrap()</span></code> 方法实现准备工作。</p>
<div class="section" id="id11">
<h4><a class="toc-backref" href="#id39">1.3.1.1. 环境检测和配置加载</a><a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h4>
<p>环境检测阶段是对程序运行的环境进行总体配置，这部分内容实际上和配置加载的功能是相同的，都是配置应用程序的运行环境，包括系统配置、身份认证配置、缓存配置、数据库配置、文件系统配置和session配置等。这些配置都是以文件的形式提供的，其中环境检测文件是 <code class="docutils literal"><span class="pre">Laravel</span></code> 框架根目录下的 <code class="docutils literal"><span class="pre">.env</span></code> 文件，而配置加载的配置文件是 <code class="docutils literal"><span class="pre">laravel\config\目录</span></code> 下的所有文件，两者的关系可以看做是主从的关系，即在配置加载过程中设置的参数都可以在 <code class="docutils literal"><span class="pre">.env</span></code> 文件中进行设置，而 <code class="docutils literal"><span class="pre">.env</span></code> 中对环境的配置将会覆盖配置加载项，当然也可以修改成不覆盖。</p>
<p>文件 <code class="docutils literal"><span class="pre">Illuminate\Foundation\Bootstrap\LoadEnvironmentVariables.php</span></code></p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="c1">// 执行bootstrap()函数</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">bootstrap</span><span class="p">(</span><span class="nx">Application</span> <span class="nv">$app</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nv">$app</span><span class="o">-&gt;</span><span class="na">configurationIsCached</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// 检测配置是否缓存</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 通过检测设置的环境来获取指定的环境配置文件路径</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">checkForSpecificEnvironmentFile</span><span class="p">(</span><span class="nv">$app</span><span class="p">);</span>

    <span class="k">try</span> <span class="p">{</span> <span class="c1">// 通过读取指定路径环境文件来设置环境变量，默认是.env环境变量文件</span>
        <span class="p">(</span><span class="k">new</span> <span class="nx">Dotenv</span><span class="p">(</span><span class="nv">$app</span><span class="o">-&gt;</span><span class="na">environmentPath</span><span class="p">(),</span> <span class="nv">$app</span><span class="o">-&gt;</span><span class="na">environmentFile</span><span class="p">()))</span><span class="o">-&gt;</span><span class="na">load</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">InvalidPathException</span> <span class="nv">$e</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 检测是否存在与APP_ENV环境变量值匹配的自定义环境文件</span>
<span class="k">protected</span> <span class="k">function</span> <span class="nf">checkForSpecificEnvironmentFile</span><span class="p">(</span><span class="nv">$app</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nv">$app</span><span class="o">-&gt;</span><span class="na">runningInConsole</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nv">$input</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ArgvInput</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">hasParameterOption</span><span class="p">(</span><span class="s1">&#39;--env&#39;</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">setEnvironmentFilePath</span><span class="p">(</span> <span class="c1">// 如果是控制台命令，则获取环境文件路径</span>
            <span class="nv">$app</span><span class="p">,</span> <span class="nv">$app</span><span class="o">-&gt;</span><span class="na">environmentFile</span><span class="p">()</span><span class="o">.</span><span class="s1">&#39;.&#39;</span><span class="o">.</span><span class="nv">$input</span><span class="o">-&gt;</span><span class="na">getParameterOption</span><span class="p">(</span><span class="s1">&#39;--env&#39;</span><span class="p">)</span>
        <span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="nx">env</span><span class="p">(</span><span class="s1">&#39;APP_ENV&#39;</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// 如果没有设置该环境变量，则返回，直接使用.env环境配置文件</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 检测该指定路径环境配置文件是否存在，并设置该值</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">setEnvironmentFilePath</span><span class="p">(</span>
        <span class="nv">$app</span><span class="p">,</span> <span class="nv">$app</span><span class="o">-&gt;</span><span class="na">environmentFile</span><span class="p">()</span><span class="o">.</span><span class="s1">&#39;.&#39;</span><span class="o">.</span><span class="nx">env</span><span class="p">(</span><span class="s1">&#39;APP_ENV&#39;</span><span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">LoadEnvironmentVariables</span></code> 类的 <code class="docutils literal"><span class="pre">bootstrap()</span></code> 函数通过 <code class="docutils literal"><span class="pre">Dotenv</span></code> 类的 <code class="docutils literal"><span class="pre">load()</span></code> 函数实现环境文件的配置加载，在该文件中配置项以 <code class="docutils literal"><span class="pre">配置项=参数值</span></code> 的形式给出，最后通过 <code class="docutils literal"><span class="pre">Loader</span></code> 类的 <code class="docutils literal"><span class="pre">setEnvironmentVariable()</span></code> 的函数来设置环境变量，并在 <code class="docutils literal"><span class="pre">$_ENV</span></code> 和 <code class="docutils literal"><span class="pre">$_SERVER</span></code> 全局数组中记录。</p>
<p><a class="reference external" href="https://laravel-china.org/articles/5638/laravel-env-the-loading-of-environment-variables-and-source-code-analysis">环境变量使用教程</a></p>
</div>
<div class="section" id="id13">
<h4><a class="toc-backref" href="#id40">1.3.1.2. 配置文件的加载</a><a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h4>
<p>对于配置加载，是通过 <code class="docutils literal"><span class="pre">\Illuminate\Foundation\Bootstrap\LoadConfiguration</span></code> 类的 <code class="docutils literal"><span class="pre">bootstrap()</span></code> 函数实现的。部分源代码如下：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="c1">// 加载配置文件</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">bootstrap</span><span class="p">(</span><span class="nx">Application</span> <span class="nv">$app</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nv">$items</span> <span class="o">=</span> <span class="p">[];</span>

    <span class="sd">/**</span>
<span class="sd">     * 首先我们会看看我们是否有缓存配置文件。 如果我们这样做，我们将从该文件加载配置项目，以便它非常快速。 否则，我们需要遍历每个配置文件并加载它们。</span>
<span class="sd">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">file_exists</span><span class="p">(</span><span class="nv">$cached</span> <span class="o">=</span> <span class="nv">$app</span><span class="o">-&gt;</span><span class="na">getCachedConfigPath</span><span class="p">()))</span> <span class="p">{</span>
        <span class="nv">$items</span> <span class="o">=</span> <span class="k">require</span> <span class="nv">$cached</span><span class="p">;</span>

        <span class="nv">$loadedFromCache</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="sd">/**</span>
<span class="sd">     * 接下来，我们将遍历配置目录中的所有配置文件，并将每个配置文件加载到存储库中。 这将使开发人员可以在应用程序各个部分使用所有配置选项。</span>
<span class="sd">     */</span>
    <span class="nv">$app</span><span class="o">-&gt;</span><span class="na">instance</span><span class="p">(</span><span class="s1">&#39;config&#39;</span><span class="p">,</span> <span class="nv">$config</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Repository</span><span class="p">(</span><span class="nv">$items</span><span class="p">));</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="nb">isset</span><span class="p">(</span><span class="nv">$loadedFromCache</span><span class="p">))</span> <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">loadConfigurationFiles</span><span class="p">(</span><span class="nv">$app</span><span class="p">,</span> <span class="nv">$config</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="sd">/**</span>
<span class="sd">     * 最后，我们将根据加载的配置值设置应用程序的环境。 我们将传递一个回调函数，用于在不存在“--env”开关的Web上下文中获取环境。</span>
<span class="sd">     * 应用实例中保存当前环境</span>
<span class="sd">     */</span>
    <span class="nv">$app</span><span class="o">-&gt;</span><span class="na">detectEnvironment</span><span class="p">(</span><span class="k">function</span> <span class="p">()</span> <span class="k">use</span> <span class="p">(</span><span class="nv">$config</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nv">$config</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s1">&#39;app.env&#39;</span><span class="p">,</span> <span class="s1">&#39;production&#39;</span><span class="p">);</span> <span class="c1">// 返回当前应用使用的环境</span>
    <span class="p">});</span>
    <span class="c1">// 设置时区</span>
    <span class="nb">date_default_timezone_set</span><span class="p">(</span><span class="nv">$config</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s1">&#39;app.timezone&#39;</span><span class="p">,</span> <span class="s1">&#39;UTC&#39;</span><span class="p">));</span>
    <span class="c1">// 设置内部字符编码，字符编码名称使用于 HTTP 输入字符编码转换、HTTP 输出字符编码转换、mbstring 模块系列函数字符编码转换的默认编码</span>
    <span class="nb">mb_internal_encoding</span><span class="p">(</span><span class="s1">&#39;UTF-8&#39;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>首先会查找是否有缓存的配置文件，如果有将先加载，这样加载配置项速度快，否则将文件顺序加载。对于程序配置项，将会存放到一个仓库类 <code class="docutils literal"><span class="pre">Repository</span></code> 类实例中，而该类的实例被添加进服务容器的共享实例数组中，服务名称为 <code class="docutils literal"><span class="pre">config</span></code> ，以后就可以用该名称通过服务容器自动获得需要的配置参数。在完成仓库类的实例化和服务绑定后，将通过 <code class="docutils literal"><span class="pre">loadConfigurationFiles()</span></code> 函数进行配置项的加载。接下来介绍加载的实现过程。</p>
<p>文件 <code class="docutils literal"><span class="pre">\Illuminate\Foundation\Bootstrap\LoadConfiguration.php</span></code></p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="c1">// 加载所有配置文件的配置项</span>
 <span class="k">protected</span> <span class="k">function</span> <span class="nf">loadConfigurationFiles</span><span class="p">(</span><span class="nx">Application</span> <span class="nv">$app</span><span class="p">,</span> <span class="nx">RepositoryContract</span> <span class="nv">$repository</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 获取所有配置文件的绝对路径</span>
    <span class="nv">$files</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">getConfigurationFiles</span><span class="p">(</span><span class="nv">$app</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="nb">isset</span><span class="p">(</span><span class="nv">$files</span><span class="p">[</span><span class="s1">&#39;app&#39;</span><span class="p">]))</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nx">Exception</span><span class="p">(</span><span class="s1">&#39;Unable to load the &quot;app&quot; configuration file.&#39;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">foreach</span> <span class="p">(</span><span class="nv">$files</span> <span class="k">as</span> <span class="nv">$key</span> <span class="o">=&gt;</span> <span class="nv">$path</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$repository</span><span class="o">-&gt;</span><span class="na">set</span><span class="p">(</span><span class="nv">$key</span><span class="p">,</span> <span class="k">require</span> <span class="nv">$path</span><span class="p">);</span> <span class="c1">// 把所有配置文件的配置项放置到仓库类中</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>对于配置项的加载，首先需要获取配置文件，通过 <code class="docutils literal"><span class="pre">getConfigurationFiles()</span></code> 将 <code class="docutils literal"><span class="pre">Laravel</span></code> 框架下的配置文件全部读取出来并存储到 <code class="docutils literal"><span class="pre">$files</span></code> 数组中返回，该过程是通过服务容器获取配置文件的路径（代码 <code class="docutils literal"><span class="pre">$app-&gt;configPath()</span></code> ），然后通过 <code class="docutils literal"><span class="pre">Symfony</span></code> 组件中的探测类（ <code class="docutils literal"><span class="pre">Symfony\Component\Finder\Finder</span></code> 类）实现文件的识别，最后提取出文件名和文件路径并以关联数组的形式（如 <code class="docutils literal"><span class="pre">app</span> <span class="pre">=&gt;</span> <span class="pre">D：\WWW\laravel\config\app.php</span></code> ）存储到 <code class="docutils literal"><span class="pre">$files</span></code> 数组中返回。对于配置文件，每个文件返回一个数组，这里通过 <code class="docutils literal"><span class="pre">require'文件路径'</span></code> 的形式获取配置项数组，最后通过仓库实例的 <code class="docutils literal"><span class="pre">set()</span></code> 函数添加到仓库中。</p>
<p>前面讲到， <code class="docutils literal"><span class="pre">.env</span></code> 文件中的配置项会覆盖配置文件中的配置项，其实是通过 <code class="docutils literal"><span class="pre">env('APP_DEBUG',</span> <span class="pre">false)</span></code> 函数实现的， <code class="docutils literal"><span class="pre">env</span></code> 函数是 <code class="docutils literal"><span class="pre">Illuminate\Support\helpers.php</span></code> 文件中定义的，该文件定义了一些全局函数，可以在其它文件中调用。 <code class="docutils literal"><span class="pre">evn</span></code> 函数先检测环境变量，如果该环境变量存在，则返回环境变量，如果不存在则用第二个参数作为返回值。前面讲到，在环境检测过程中，配置项已经通过 <code class="docutils literal"><span class="pre">putenv()</span></code> 设置为环境变量。</p>
<p>这里加载配置的目的是为在后面的程序运行过程中经常用到这些配置项时，可以通过服务容器方便地获取这些配置， <code class="docutils literal"><span class="pre">$app['config']['app.aliases']</span></code> 和 <code class="docutils literal"><span class="pre">$app-&gt;make('config')-&gt;get('app.aliases')</span></code> 两种方法都是获取 <code class="docutils literal"><span class="pre">laravel\config\app.php</span></code> 文件中键名为 <code class="docutils literal"><span class="pre">aliases</span></code> 的值，即外观别名数组，因为在 <code class="docutils literal"><span class="pre">Container</span></code> 类和 <code class="docutils literal"><span class="pre">Repository</span></code> 类中都实现了 <code class="docutils literal"><span class="pre">ArrayAccess</span></code> (数组访问)接口，而 <code class="docutils literal"><span class="pre">$app['config']</span></code> 相当于调用该实例的 <code class="docutils literal"><span class="pre">offsetGet($key)</span></code> 方法。</p>
</div>
<div class="section" id="id14">
<h4><a class="toc-backref" href="#id41">1.3.1.3. 异常处理</a><a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h4>
<p>异常处理就是开启所有错误报告，并通过注册错误处理器、异常处理器和程序结束处理器来管理所有异常和错误。</p>
<p>文件 <code class="docutils literal"><span class="pre">Illuminate\Foundation\Bootstrap\HandleExceptions.php</span></code></p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">bootstrap</span><span class="p">(</span><span class="nx">Application</span> <span class="nv">$app</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">app</span> <span class="o">=</span> <span class="nv">$app</span><span class="p">;</span>

    <span class="nb">error_reporting</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>  <span class="c1">// 报告所有的php错误，方便以后添加新的错误类型</span>

    <span class="sd">/**</span>
<span class="sd">     * set_error_handler(error_function,error_types)</span>
<span class="sd">     * error_types  可选。规定在哪个错误报告级别会显示用户定义的错误。默认是 &quot;E_ALL&quot;。</span>
<span class="sd">     * 自定义的错误处理函数一定要有这４个输入变量$errno,$errstr,$errfile,$errline，否则无效。</span>
<span class="sd">     * 其中$errno为系统内置的错误，也可以是用户定义的错误号</span>
<span class="sd">     * 提示：如果使用了该函数，会完全绕过标准的 PHP 错误处理函数，如果必要，用户定义的错误处理程序必须终止 (die() ) 脚本。 注意：如果在脚本执行前发生错误，由于在那时自定义程序还没有注册，因此就不会用到这个自定义错误处理程序。</span>
<span class="sd">     * 不过注意两点是： （1）E_ERROR、 E_PARSE、E_CORE_ERROR、E_CORE_WARNING、E_COMPILE_ERROR、E_COMPILE_WARNING是不会 被这个句柄处理的，也就是会用最原始的方式显示出来。不过出现这些错误都是编译或PHP内核出错，在通常情况下不会发生。 （2）使用set_error_handler()后，error_reporting ()将会失效。也就是所有的错误（除上述的错误）都会交给自定义的函数处理。</span>
<span class="sd">     */</span>
    <span class="nb">set_error_handler</span><span class="p">([</span><span class="nv">$this</span><span class="p">,</span> <span class="s1">&#39;handleError&#39;</span><span class="p">]);</span> <span class="c1">// 注册错误处理器</span>

    <span class="nb">set_exception_handler</span><span class="p">([</span><span class="nv">$this</span><span class="p">,</span> <span class="s1">&#39;handleException&#39;</span><span class="p">]);</span> <span class="c1">// 注册异常处理器</span>
    <span class="sd">/**</span>
<span class="sd">     * PHP中止的情况有三种：执行完成；exit/die导致的中止；发生致命错误中止</span>
<span class="sd">     */</span>
    <span class="nb">register_shutdown_function</span><span class="p">([</span><span class="nv">$this</span><span class="p">,</span> <span class="s1">&#39;handleShutdown&#39;</span><span class="p">]);</span> <span class="c1">// 注册脚本结束处理器</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="nv">$app</span><span class="o">-&gt;</span><span class="na">environment</span><span class="p">(</span><span class="s1">&#39;testing&#39;</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// 非测试环境，则关闭客户端显示错误</span>
        <span class="nb">ini_set</span><span class="p">(</span><span class="s1">&#39;display_errors&#39;</span><span class="p">,</span> <span class="s1">&#39;Off&#39;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">function</span> <span class="nf">handleError</span><span class="p">(</span><span class="nv">$level</span><span class="p">,</span> <span class="nv">$message</span><span class="p">,</span> <span class="nv">$file</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="nv">$line</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">$context</span> <span class="o">=</span> <span class="p">[])</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">error_reporting</span><span class="p">()</span> <span class="o">&amp;</span> <span class="nv">$level</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 如果开启该错误，则抛出错误异常</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nx">ErrorException</span><span class="p">(</span><span class="nv">$message</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">$level</span><span class="p">,</span> <span class="nv">$file</span><span class="p">,</span> <span class="nv">$line</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">function</span> <span class="nf">handleException</span><span class="p">(</span><span class="nv">$e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Throwable 是 php7 新增的顶级异常 interface，包含了 Error 和 Exception。</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="nv">$e</span> <span class="nx">instanceof</span> <span class="nx">Exception</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//不是异常，则可能是Error</span>
        <span class="nv">$e</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">FatalThrowableError</span><span class="p">(</span><span class="nv">$e</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">try</span> <span class="p">{</span> <span class="c1">// 记录异常信息</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">getExceptionHandler</span><span class="p">()</span><span class="o">-&gt;</span><span class="na">report</span><span class="p">(</span><span class="nv">$e</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">Exception</span> <span class="nv">$e</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">app</span><span class="o">-&gt;</span><span class="na">runningInConsole</span><span class="p">())</span> <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">renderForConsole</span><span class="p">(</span><span class="nv">$e</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// 通过响应返回给浏览器</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">renderHttpResponse</span><span class="p">(</span><span class="nv">$e</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">function</span> <span class="nf">handleShutdown</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 处理程序结束存在的错误，将其转变为异常</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="nb">is_null</span><span class="p">(</span><span class="nv">$error</span> <span class="o">=</span> <span class="nb">error_get_last</span><span class="p">())</span> <span class="o">&amp;&amp;</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">isFatal</span><span class="p">(</span><span class="nv">$error</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]))</span> <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">handleException</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">fatalExceptionFromError</span><span class="p">(</span><span class="nv">$error</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id15">
<h4><a class="toc-backref" href="#id42">1.3.1.4. 外观注册</a><a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h4>
<p>接下来介绍一下外观注册，因为在后面很多地方都用到了外观别名，通过外观别名调用对应实例的属性和方法。主要是为了测试方便，但在程序中很多地方也用到了外观别名。比如路由。</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">bootstrap</span><span class="p">(</span><span class="nx">Application</span> <span class="nv">$app</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nx">Facade</span><span class="o">::</span><span class="na">clearResolvedInstances</span><span class="p">();</span> <span class="c1">// 清空所有解析的实例</span>

    <span class="nx">Facade</span><span class="o">::</span><span class="na">setFacadeApplication</span><span class="p">(</span><span class="nv">$app</span><span class="p">);</span> <span class="c1">// 保存容器实例</span>
    <span class="c1">// 读取 app.php 的 aliases 数组，然后与 bootstrap/cache/packages.php 的 packages 数组合并</span>
    <span class="nx">AliasLoader</span><span class="o">::</span><span class="na">getInstance</span><span class="p">(</span><span class="nb">array_merge</span><span class="p">(</span>
        <span class="nv">$app</span><span class="o">-&gt;</span><span class="na">make</span><span class="p">(</span><span class="s1">&#39;config&#39;</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s1">&#39;app.aliases&#39;</span><span class="p">,</span> <span class="p">[]),</span>
        <span class="nv">$app</span><span class="o">-&gt;</span><span class="na">make</span><span class="p">(</span><span class="nx">PackageManifest</span><span class="o">::</span><span class="na">class</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">aliases</span><span class="p">()</span>
    <span class="p">))</span><span class="o">-&gt;</span><span class="na">register</span><span class="p">();</span> <span class="c1">// 并注册load()方法到类的自动加载机制</span>
<span class="p">}</span>
</pre></div>
</div>
<p>你可以看到，它首先读取 <code class="docutils literal"><span class="pre">app.php</span></code> 的 <code class="docutils literal"><span class="pre">aliases</span></code> 数组，然后与 <code class="docutils literal"><span class="pre">bootstrap/cache/packages.php</span></code> 的 <code class="docutils literal"><span class="pre">packages</span></code> 数组合并，这个时候，就可以获取到所有的 <code class="docutils literal"><span class="pre">packages</span></code> 信息进行发现和自带加载了。这样合并的好处就是，你还是可以直接在 <code class="docutils literal"><span class="pre">app.php</span></code> 中定义你的 <code class="docutils literal"><span class="pre">alias</span></code> 来覆盖自动发现的 <code class="docutils literal"><span class="pre">package</span></code> ，从而保证你的项目还是可以运行得很流畅。</p>
<p>P142</p>
<p><a class="reference external" href="https://mp.weixin.qq.com/s?__biz=MzI5MDcyODM1OA%3D%3D&amp;mid=2247483730&amp;idx=1&amp;sn=dc97c25629da96fa94c33616cd42e4d0&amp;chksm=ec1a319bdb6db88d497d32d0ba61ce8462c92ac5b881ce5fcdb7785fea17fb0a74f30a21bd6d">包自动发现机制</a></p>
<p><a class="reference external" href="https://segmentfault.com/a/1190000009369566">门面原理</a></p>
</div>
<div class="section" id="id18">
<h4><a class="toc-backref" href="#id43">1.3.1.5. 服务提供者注册</a><a class="headerlink" href="#id18" title="永久链接至标题">¶</a></h4>
<p>服务提供者注册为应用程序运行提供服务支持，在应用程序启动的准备阶段进行了基础服务提供者的加载，但这些服务只能应对前期启动阶段，而对于后期请求处理需要用到的数据库服务、认证服务、session服务等还远远不够，所以这里会绑定后期使用的服务。源码如下：</p>
<p>文件 <code class="docutils literal"><span class="pre">config\app.php</span></code></p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="s1">&#39;providers&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span>

        <span class="cm">/*</span>
<span class="cm">         * Laravel Framework Service Providers...</span>
<span class="cm">         */</span>
        <span class="nx">Illuminate\Auth\AuthServiceProvider</span><span class="o">::</span><span class="na">class</span><span class="p">,</span>
        <span class="nx">Illuminate\Broadcasting\BroadcastServiceProvider</span><span class="o">::</span><span class="na">class</span><span class="p">,</span>
        <span class="nx">Illuminate\Bus\BusServiceProvider</span><span class="o">::</span><span class="na">class</span><span class="p">,</span>
        <span class="nx">Illuminate\Cache\CacheServiceProvider</span><span class="o">::</span><span class="na">class</span><span class="p">,</span>
        <span class="nx">Illuminate\Foundation\Providers\ConsoleSupportServiceProvider</span><span class="o">::</span><span class="na">class</span><span class="p">,</span>
        <span class="nx">Illuminate\Cookie\CookieServiceProvider</span><span class="o">::</span><span class="na">class</span><span class="p">,</span>
        <span class="nx">Illuminate\Database\DatabaseServiceProvider</span><span class="o">::</span><span class="na">class</span><span class="p">,</span>
        <span class="nx">Illuminate\Encryption\EncryptionServiceProvider</span><span class="o">::</span><span class="na">class</span><span class="p">,</span>
        <span class="nx">Illuminate\Filesystem\FilesystemServiceProvider</span><span class="o">::</span><span class="na">class</span><span class="p">,</span>
        <span class="nx">Illuminate\Foundation\Providers\FoundationServiceProvider</span><span class="o">::</span><span class="na">class</span><span class="p">,</span>
        <span class="nx">Illuminate\Hashing\HashServiceProvider</span><span class="o">::</span><span class="na">class</span><span class="p">,</span>
        <span class="nx">Illuminate\Mail\MailServiceProvider</span><span class="o">::</span><span class="na">class</span><span class="p">,</span>
        <span class="nx">Illuminate\Notifications\NotificationServiceProvider</span><span class="o">::</span><span class="na">class</span><span class="p">,</span>
        <span class="nx">Illuminate\Pagination\PaginationServiceProvider</span><span class="o">::</span><span class="na">class</span><span class="p">,</span>
        <span class="nx">Illuminate\Pipeline\PipelineServiceProvider</span><span class="o">::</span><span class="na">class</span><span class="p">,</span>
        <span class="nx">Illuminate\Queue\QueueServiceProvider</span><span class="o">::</span><span class="na">class</span><span class="p">,</span>
        <span class="nx">Illuminate\Redis\RedisServiceProvider</span><span class="o">::</span><span class="na">class</span><span class="p">,</span>
        <span class="nx">Illuminate\Auth\Passwords\PasswordResetServiceProvider</span><span class="o">::</span><span class="na">class</span><span class="p">,</span>
        <span class="nx">Illuminate\Session\SessionServiceProvider</span><span class="o">::</span><span class="na">class</span><span class="p">,</span>
        <span class="nx">Illuminate\Translation\TranslationServiceProvider</span><span class="o">::</span><span class="na">class</span><span class="p">,</span>
        <span class="nx">Illuminate\Validation\ValidationServiceProvider</span><span class="o">::</span><span class="na">class</span><span class="p">,</span>
        <span class="nx">Illuminate\View\ViewServiceProvider</span><span class="o">::</span><span class="na">class</span><span class="p">,</span>

        <span class="cm">/*</span>
<span class="cm">         * Package Service Providers...</span>
<span class="cm">         */</span>

        <span class="cm">/*</span>
<span class="cm">         * Application Service Providers...</span>
<span class="cm">         */</span>
        <span class="nx">App\Providers\AppServiceProvider</span><span class="o">::</span><span class="na">class</span><span class="p">,</span>
        <span class="nx">App\Providers\AuthServiceProvider</span><span class="o">::</span><span class="na">class</span><span class="p">,</span>
        <span class="c1">// App\Providers\BroadcastServiceProvider::class,</span>
        <span class="nx">App\Providers\EventServiceProvider</span><span class="o">::</span><span class="na">class</span><span class="p">,</span>
        <span class="nx">App\Providers\RouteServiceProvider</span><span class="o">::</span><span class="na">class</span><span class="p">,</span>
        <span class="c1">//App\Providers\DemoServiceProvider::class</span>

    <span class="p">],</span>
</pre></div>
</div>
<p>文件 <code class="docutils literal"><span class="pre">Illuminate\Foundation\Bootstrap\RegisterProviders.php</span></code></p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">bootstrap</span><span class="p">(</span><span class="nx">Application</span> <span class="nv">$app</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nv">$app</span><span class="o">-&gt;</span><span class="na">registerConfiguredProviders</span><span class="p">();</span>
<span class="p">}</span>
<span class="c1">// 注册所有配置的服务提供者</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">registerConfiguredProviders</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nv">$providers</span> <span class="o">=</span> <span class="nx">Collection</span><span class="o">::</span><span class="na">make</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">config</span><span class="p">[</span><span class="s1">&#39;app.providers&#39;</span><span class="p">])</span>
                    <span class="o">-&gt;</span><span class="na">partition</span><span class="p">(</span><span class="k">function</span> <span class="p">(</span><span class="nv">$provider</span><span class="p">)</span> <span class="p">{</span>
                        <span class="k">return</span> <span class="nx">Str</span><span class="o">::</span><span class="na">startsWith</span><span class="p">(</span><span class="nv">$provider</span><span class="p">,</span> <span class="s1">&#39;Illuminate\\&#39;</span><span class="p">);</span>
                    <span class="p">});</span> <span class="c1">// 分组</span>
    <span class="c1">// 插入包自动发现的服务提供者到集合中</span>
    <span class="nv">$providers</span><span class="o">-&gt;</span><span class="na">splice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">make</span><span class="p">(</span><span class="nx">PackageManifest</span><span class="o">::</span><span class="na">class</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">providers</span><span class="p">()]);</span>
    <span class="c1">// 使用缓存中服务清单来初始化一个提供器仓库，并用该对象来加载服务提供者的配置</span>
    <span class="p">(</span><span class="k">new</span> <span class="nx">ProviderRepository</span><span class="p">(</span><span class="nv">$this</span><span class="p">,</span> <span class="k">new</span> <span class="nx">Filesystem</span><span class="p">,</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">getCachedServicesPath</span><span class="p">()))</span>
                <span class="o">-&gt;</span><span class="na">load</span><span class="p">(</span><span class="nv">$providers</span><span class="o">-&gt;</span><span class="na">collapse</span><span class="p">()</span><span class="o">-&gt;</span><span class="na">toArray</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在服务提供者的注册过程中将服务提供者分为三类，即 <code class="docutils literal"><span class="pre">when</span></code> 类、 <code class="docutils literal"><span class="pre">eager</span></code> 类、 <code class="docutils literal"><span class="pre">deferred</span></code> 类。</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">when</span></code> 类是注册事件，只有当事件发生时才会自动注册这个服务提供者；</li>
<li><code class="docutils literal"><span class="pre">eager</span></code> 类会直接加载，加载方式和注册基础服务提供者的过程相同；</li>
<li><code class="docutils literal"><span class="pre">deferred</span></code> 类的服务提供者存储在列表中，需要使用时才会加载；</li>
</ul>
<p>在 <code class="docutils literal"><span class="pre">Laravel</span></code> 框架中，提供了一个文件记录服务提供者的类别信息，即 <code class="docutils literal"><span class="pre">bootstrap\cache\services.php</span></code> ，而该路径是通过 <code class="docutils literal"><span class="pre">getCachedServicesPath()</span></code> 函数获取的。</p>
<p>服务提供者的注册经过两个步骤：</p>
<ol class="arabic simple">
<li>第一步是服务提供者仓库的创建，即 <code class="docutils literal"><span class="pre">registerConfiguredProviders()</span></code> 函数中的 <code class="docutils literal"><span class="pre">new</span> <span class="pre">ProviderRepository()</span></code> 过程；</li>
<li>第二步是通过load()函数进行注册；</li>
</ol>
<p>创建服务提供者仓库时需要提供该文件的路径参数，同时调用 <code class="docutils literal"><span class="pre">load()</span></code> 函数时会添加 <code class="docutils literal"><span class="pre">app.php</span></code> 配置文件中关于服务提供者的内容。</p>
<p>文件 <code class="docutils literal"><span class="pre">Illuminate\Foundation\ProviderRepository.php</span></code></p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">load</span><span class="p">(</span><span class="k">array</span> <span class="nv">$providers</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 加载bootstrap\cache\services.php文件中的服务提供者</span>
    <span class="nv">$manifest</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">loadManifest</span><span class="p">();</span>

    <span class="sd">/**</span>
<span class="sd">     * 首先，我们将加载服务清单，其中包含有关在应用程序中注册的所有服务提供商以及它提供的服务的信息。 这用于知道哪些服务是“延迟”装载机。</span>
<span class="sd">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">shouldRecompile</span><span class="p">(</span><span class="nv">$manifest</span><span class="p">,</span> <span class="nv">$providers</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// 判断是否应该重新编译</span>
        <span class="nv">$manifest</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">compileManifest</span><span class="p">(</span><span class="nv">$providers</span><span class="p">);</span> <span class="c1">// 生成指定格式的服务清单</span>
    <span class="p">}</span>

    <span class="sd">/**</span>
<span class="sd">     * 接下来，我们将注册事件以加载它所请求的每个事件的服务提供者。 这允许服务提供者在发生某些事件时自动加载。</span>
<span class="sd">     */</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="nv">$manifest</span><span class="p">[</span><span class="s1">&#39;when&#39;</span><span class="p">]</span> <span class="k">as</span> <span class="nv">$provider</span> <span class="o">=&gt;</span> <span class="nv">$events</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">registerLoadEvents</span><span class="p">(</span><span class="nv">$provider</span><span class="p">,</span> <span class="nv">$events</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="sd">/**</span>
<span class="sd">     * 我们将继续向应用程序注册所有急切加载的服务提供者，以便他们的服务可以作为提供的服务在应用程序中注册。</span>
<span class="sd">     */</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="nv">$manifest</span><span class="p">[</span><span class="s1">&#39;eager&#39;</span><span class="p">]</span> <span class="k">as</span> <span class="nv">$provider</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">app</span><span class="o">-&gt;</span><span class="na">register</span><span class="p">(</span><span class="nv">$provider</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// 设置延迟服务提供者列表</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">app</span><span class="o">-&gt;</span><span class="na">addDeferredServices</span><span class="p">(</span><span class="nv">$manifest</span><span class="p">[</span><span class="s1">&#39;deferred&#39;</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>前面提到服务提供者的记录在两个地方存在，实际上在配置文件 <code class="docutils literal"><span class="pre">app.php</span></code> 的 <code class="docutils literal"><span class="pre">providers</span></code> 中存储的是应用程序运行过程中所有的服务提供者，但是对于服务提供者的类型没有进行划分。当进行服务提供者注册时，首先通过 <code class="docutils literal"><span class="pre">loadManifest()</span></code> 函数读取 <code class="docutils literal"><span class="pre">bootstrap/cache/services.php</span></code> 文件，该文件不仅记录服务提供者，还对服务提供者进行了分类，即前面提到的三种类型，但是该文件是一个临时记录文件，记录的是上一次运行时服务提供者加载的情况，所以需要与当前程序的服务提供者进行比对，通过 <code class="docutils literal"><span class="pre">shouldRecompile()</span></code> 函数实现，如果临时文件 <code class="docutils literal"><span class="pre">bootstrap/cache/services.php</span></code> 记录的服务提供者与配置文件 <code class="docutils literal"><span class="pre">app.php</span></code> 文件记录的相同，则直接使用临时文件中服务提供者的分类进行注册。对于 <code class="docutils literal"><span class="pre">when</span></code> 类服务提供者，通过 <code class="docutils literal"><span class="pre">registerLoadEvents()</span></code> 函数创建事件监听者，当事件发生时调用服务提供者的 <code class="docutils literal"><span class="pre">register()</span></code> 函数进行服务注册。对于 <code class="docutils literal"><span class="pre">deferred</span></code> 类服务提供者，则记录在服务容器实例的 <code class="docutils literal"><span class="pre">$deferredServices</span></code> 数组属性中，在使用服务容器的 <code class="docutils literal"><span class="pre">make()</span></code> 函数进行服务解析时，如果发现这个服务在延时服务数组中，则会注册这个服务提供者，再解析相应的服务。</p>
<p>文件 <code class="docutils literal"><span class="pre">Illuminate\Foundation\ProviderRepository.php</span></code></p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">protected</span> <span class="k">function</span> <span class="nf">registerLoadEvents</span><span class="p">(</span><span class="nv">$provider</span><span class="p">,</span> <span class="k">array</span> <span class="nv">$events</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">count</span><span class="p">(</span><span class="nv">$events</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 注册事件监听器，当事件发生时，调用回调函数来注册服务提供者，即调用服务提供器的register()方法</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">app</span><span class="o">-&gt;</span><span class="na">make</span><span class="p">(</span><span class="s1">&#39;events&#39;</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">listen</span><span class="p">(</span><span class="nv">$events</span><span class="p">,</span> <span class="k">function</span> <span class="p">()</span> <span class="k">use</span> <span class="p">(</span><span class="nv">$provider</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">app</span><span class="o">-&gt;</span><span class="na">register</span><span class="p">(</span><span class="nv">$provider</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id19">
<h4><a class="toc-backref" href="#id44">1.3.1.6. 启动服务</a><a class="headerlink" href="#id19" title="永久链接至标题">¶</a></h4>
<p>准备阶段的最后一个步骤是启动服务，服务提供者必须要实现 <code class="docutils literal"><span class="pre">register()</span></code> 函数，还有一个 <code class="docutils literal"><span class="pre">boot()</span></code> 函数根据需要决定是否实现(延迟服务提供者没有发现该方法？？？)，主要用于启动服务，而该函数不是必须的，如果不实现会在父类中统一处理。而对于实现 <code class="docutils literal"><span class="pre">boot()</span></code> 函数的服务提供者，会通过 <code class="docutils literal"><span class="pre">BootProviders</span></code> 类进行统一管理调用。源码如下：</p>
<p>文件 <code class="docutils literal"><span class="pre">Illuminate\Foundation\Bootstrap\BootProviders.php</span></code></p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">bootstrap</span><span class="p">(</span><span class="nx">Application</span> <span class="nv">$app</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nv">$app</span><span class="o">-&gt;</span><span class="na">boot</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>对于服务提供者启动管理类 <code class="docutils literal"><span class="pre">BootProviders</span></code> 来说，实现比较简单，只是调用服务容器中的 <code class="docutils literal"><span class="pre">boot()</span></code> 函数就可以了，因为服务提供者的注册信息都记录在服务容器中。下面给出服务容器启动服务提供者的代码：</p>
<p>文件 <code class="docutils literal"><span class="pre">Illuminate\Foundation\Application.php</span></code></p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="c1">// 启动应用程序的服务提供者</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">boot</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">booted</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="sd">/**</span>
<span class="sd">     * 一旦应用程序启动，我们还会为任何需要在初始启动完成后工作的侦听器启动一些“booted”回调。 这在定制我们运行的启动过程时非常有用。</span>
<span class="sd">     */</span>
    <span class="c1">// 服务启动之前的回调</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">fireAppCallbacks</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">bootingCallbacks</span><span class="p">);</span>

    <span class="nb">array_walk</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">serviceProviders</span><span class="p">,</span> <span class="k">function</span> <span class="p">(</span><span class="nv">$p</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">bootProvider</span><span class="p">(</span><span class="nv">$p</span><span class="p">);</span> <span class="c1">// 调用所有注册的服务提供者boot()方法</span>
    <span class="p">});</span>

    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">booted</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="c1">// 服务启动之后的回调</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">fireAppCallbacks</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">bootedCallbacks</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 启动给定的服务提供者</span>
<span class="k">protected</span> <span class="k">function</span> <span class="nf">bootProvider</span><span class="p">(</span><span class="nx">ServiceProvider</span> <span class="nv">$provider</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">method_exists</span><span class="p">(</span><span class="nv">$provider</span><span class="p">,</span> <span class="s1">&#39;boot&#39;</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">call</span><span class="p">([</span><span class="nv">$provider</span><span class="p">,</span> <span class="s1">&#39;boot&#39;</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>从上面可以看到，在 <code class="docutils literal"><span class="pre">Laravel</span></code> 应用程序的服务容器中保存了服务提供者的实例数组，即 <code class="docutils literal"><span class="pre">$serviceProviders</span></code> 属性。这里包含了服务容器实例化过程中的注册的两个基础服务提供者及在服务提供者注册过程中注册的 <code class="docutils literal"><span class="pre">eager</span></code> 类服务提供者，然后通过代码 <code class="docutils literal"><span class="pre">$this-&gt;call([$provider,</span> <span class="pre">'boot'])</span></code> 调用 <code class="docutils literal"><span class="pre">$serviceProviders</span></code> 属性中记录的每一个服务提供者实例的 <code class="docutils literal"><span class="pre">boot()</span></code> 函数，该函数主要是对服务进行初始化，如对于数据库提供者 <code class="docutils literal"><span class="pre">Illuminate\Database\DatabaseServiceProvider</span></code> 类来讲会建立数据库连接，而对于路由服务提供者 <code class="docutils literal"><span class="pre">App\Providers\RouteServiceProvider</span></code> 来讲会建立路由表等。这里介绍一下路由表的建立。</p>
<p>文件 <code class="docutils literal"><span class="pre">App\Providers\RouteServiceProvider.php</span></code></p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">boot</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">parent</span><span class="o">::</span><span class="na">boot</span><span class="p">();</span>
<span class="p">}</span>
<span class="c1">// 定义应用的路由</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">map</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">mapApiRoutes</span><span class="p">();</span> <span class="c1">// api路由映射</span>

    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">mapWebRoutes</span><span class="p">();</span> <span class="c1">// web路由映射</span>

    <span class="c1">//</span>
<span class="p">}</span>
</pre></div>
</div>
<p>文件 <code class="docutils literal"><span class="pre">Illuminate\Foundation\Support\Providers\RouteServiceProvider.php</span></code></p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">boot</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 设置路由UrlGenerator对象的控制器根命名空间</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">setRootControllerNamespace</span><span class="p">();</span>
    <span class="c1">// 是否存在 bootstrap/cache/routes.php文件</span>
    <span class="k">if</span> <span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">app</span><span class="o">-&gt;</span><span class="na">routesAreCached</span><span class="p">())</span> <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">loadCachedRoutes</span><span class="p">();</span> <span class="c1">// 当应用启动完成加载路由缓存文件</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">loadRoutes</span><span class="p">();</span> <span class="c1">// 调用路由提供器的map()方法</span>
        <span class="c1">// 应用启动后调用的函数</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">app</span><span class="o">-&gt;</span><span class="na">booted</span><span class="p">(</span><span class="k">function</span> <span class="p">()</span> <span class="p">{</span>
            <span class="c1">// Illuminate\Routing\Router.php</span>
            <span class="c1">// Illuminate\Routing\RouteCollection</span>
            <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">app</span><span class="p">[</span><span class="s1">&#39;router&#39;</span><span class="p">]</span><span class="o">-&gt;</span><span class="na">getRoutes</span><span class="p">()</span><span class="o">-&gt;</span><span class="na">refreshNameLookups</span><span class="p">();</span> <span class="c1">// 刷新路由名称和路由对象映射表</span>
            <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">app</span><span class="p">[</span><span class="s1">&#39;router&#39;</span><span class="p">]</span><span class="o">-&gt;</span><span class="na">getRoutes</span><span class="p">()</span><span class="o">-&gt;</span><span class="na">refreshActionLookups</span><span class="p">();</span> <span class="c1">// 刷新控制器动作和路由对象的映射表</span>
        <span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 加载应用的路由</span>
<span class="k">protected</span> <span class="k">function</span> <span class="nf">loadRoutes</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">method_exists</span><span class="p">(</span><span class="nv">$this</span><span class="p">,</span> <span class="s1">&#39;map&#39;</span><span class="p">))</span> <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">app</span><span class="o">-&gt;</span><span class="na">call</span><span class="p">([</span><span class="nv">$this</span><span class="p">,</span> <span class="s1">&#39;map&#39;</span><span class="p">]);</span> <span class="c1">// 调用路由提供器的map方法</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在 <code class="docutils literal"><span class="pre">Laravel</span></code> 框架中，默认情况下路由配置服务提供者是最后一个注册并启动的，该类位于 <code class="docutils literal"><span class="pre">app\Providers\</span></code> 文件夹下，通过上面的代码可以看出，该类调用父类的 <code class="docutils literal"><span class="pre">boot()</span></code> 函数，父类会通过 <code class="docutils literal"><span class="pre">loadRoutes()</span></code> 函数调用本实例对象的 <code class="docutils literal"><span class="pre">map()</span></code> 函数，这里需要注意的是，通过服务容器实例的 <code class="docutils literal"><span class="pre">call()</span></code> 函数调用一个函数时会解决函数的依赖问题。服务容器不但解决类实例化时构造函数的依赖注入问题，还可以解决函数调用的依赖注入问题，就是通过 <code class="docutils literal"><span class="pre">call()</span></code> 函数来实现，其内部机制基本相同，也是通过反射机制来解决依赖的。</p>
<p>文件 <code class="docutils literal"><span class="pre">app\Providers\RouteServiceProvider.php</span></code></p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">map</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">mapApiRoutes</span><span class="p">();</span> <span class="c1">// api路由映射</span>

    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">mapWebRoutes</span><span class="p">();</span> <span class="c1">// web路由映射</span>
<span class="p">}</span>
<span class="k">protected</span> <span class="k">function</span> <span class="nf">mapWebRoutes</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 通过门面来调用</span>
    <span class="nx">Route</span><span class="o">::</span><span class="na">middleware</span><span class="p">(</span><span class="s1">&#39;web&#39;</span><span class="p">)</span>
         <span class="o">-&gt;</span><span class="na">namespace</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">namespace</span><span class="p">)</span>
         <span class="o">-&gt;</span><span class="na">group</span><span class="p">(</span><span class="nx">base_path</span><span class="p">(</span><span class="s1">&#39;routes/web.php&#39;</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>文件 <code class="docutils literal"><span class="pre">Illuminate\Routing\Router.php</span></code></p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">group</span><span class="p">(</span><span class="k">array</span> <span class="nv">$attributes</span><span class="p">,</span> <span class="nv">$routes</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 合并prefix/namespace/as/where/中间件，形成新的attribute</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">updateGroupStack</span><span class="p">(</span><span class="nv">$attributes</span><span class="p">);</span>

    <span class="sd">/**</span>
<span class="sd">     * 一旦我们更新了组堆栈，我们将加载提供的路由并在创建路由时合并组的属性。 在创建路由之后，我们将弹出堆栈中的属性。</span>
<span class="sd">     */</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">loadRoutes</span><span class="p">(</span><span class="nv">$routes</span><span class="p">);</span> <span class="c1">// 加载的配置文件可能包含分组</span>

    <span class="nb">array_pop</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">groupStack</span><span class="p">);</span> <span class="c1">// 弹出当前分组的属性信息</span>
<span class="p">}</span>
<span class="c1">// 增加get方法路由</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">get</span><span class="p">(</span><span class="nv">$uri</span><span class="p">,</span> <span class="nv">$action</span> <span class="o">=</span> <span class="k">null</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">addRoute</span><span class="p">([</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="s1">&#39;HEAD&#39;</span><span class="p">],</span> <span class="nv">$uri</span><span class="p">,</span> <span class="nv">$action</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 增加一个路由到底层路由集合</span>
<span class="k">protected</span> <span class="k">function</span> <span class="nf">addRoute</span><span class="p">(</span><span class="nv">$methods</span><span class="p">,</span> <span class="nv">$uri</span><span class="p">,</span> <span class="nv">$action</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">routes</span><span class="o">-&gt;</span><span class="na">add</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">createRoute</span><span class="p">(</span><span class="nv">$methods</span><span class="p">,</span> <span class="nv">$uri</span><span class="p">,</span> <span class="nv">$action</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在 <code class="docutils literal"><span class="pre">map()</span></code> 函数中，依赖一个参数为 <code class="docutils literal"><span class="pre">Illuminate\Routing\Router.php</span></code> 类的实例，会通过服务容器来解决这个依赖，而这个实现对象管理应用程序的路由情况，所有的路由配置信息最终都会记录在路由器实例对象中。 注意，路由分组可以嵌套定义，解析路由时遇到路由分组中定义的公共信息时，路由实例会自动添加对应的信息。</p>
</div>
</div>
<div class="section" id="id20">
<h3><a class="toc-backref" href="#id45">1.3.2. 中间件</a><a class="headerlink" href="#id20" title="永久链接至标题">¶</a></h3>
<p>在请求处理的过程中，经过繁琐的准备工作，应用程序开始对请求进行处理了。对请求的处理， <code class="docutils literal"><span class="pre">Laravel</span></code> 框架是逐级进行的，首先是经过中间件的处理，然后经过路由处理，最后到控制器生成响应，对请求从中间件到路由处理再到响应生成整个过程中基本是以装饰模式进行处理的。</p>
<p>文件 <code class="docutils literal"><span class="pre">app\Http\Kernel.php</span></code></p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">protected</span> <span class="nv">$middleware</span> <span class="o">=</span> <span class="p">[</span>
    <span class="nx">\Illuminate\Foundation\Http\Middleware\CheckForMaintenanceMode</span><span class="o">::</span><span class="na">class</span><span class="p">,</span>
    <span class="nx">\Illuminate\Foundation\Http\Middleware\ValidatePostSize</span><span class="o">::</span><span class="na">class</span><span class="p">,</span>
    <span class="nx">\App\Http\Middleware\TrimStrings</span><span class="o">::</span><span class="na">class</span><span class="p">,</span>
    <span class="nx">\Illuminate\Foundation\Http\Middleware\ConvertEmptyStringsToNull</span><span class="o">::</span><span class="na">class</span><span class="p">,</span>
    <span class="nx">\App\Http\Middleware\TrustProxies</span><span class="o">::</span><span class="na">class</span><span class="p">,</span>
<span class="p">];</span>
</pre></div>
</div>
<p>文件 <code class="docutils literal"><span class="pre">Illuminate\Foundation\Http\Kernel.php</span></code></p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="c1">// 将请求通过中间件和路由处理</span>
<span class="k">protected</span> <span class="k">function</span> <span class="nf">sendRequestThroughRouter</span><span class="p">(</span><span class="nv">$request</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 注入请求对象到服务容器，供后面使用</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">app</span><span class="o">-&gt;</span><span class="na">instance</span><span class="p">(</span><span class="s1">&#39;request&#39;</span><span class="p">,</span> <span class="nv">$request</span><span class="p">);</span>
    <span class="c1">// 清空门面类中保存request实例</span>
    <span class="nx">Facade</span><span class="o">::</span><span class="na">clearResolvedInstance</span><span class="p">(</span><span class="s1">&#39;request&#39;</span><span class="p">);</span>
    <span class="c1">// 启动应用（包括加载设置环境变量、加载配置文件、设置系统错误异常、Facade、注册和启动各服务提供者等）</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">bootstrap</span><span class="p">();</span>
    <span class="c1">// 委托管道形式处理请求，这个是middleware实现的本质</span>
    <span class="k">return</span> <span class="p">(</span><span class="k">new</span> <span class="nx">Pipeline</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">app</span><span class="p">))</span>
                <span class="o">-&gt;</span><span class="na">send</span><span class="p">(</span><span class="nv">$request</span><span class="p">)</span>
                <span class="o">-&gt;</span><span class="na">through</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">app</span><span class="o">-&gt;</span><span class="na">shouldSkipMiddleware</span><span class="p">()</span> <span class="o">?</span> <span class="p">[]</span> <span class="o">:</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">middleware</span><span class="p">)</span>
                <span class="o">-&gt;</span><span class="na">then</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">dispatchToRouter</span><span class="p">());</span>
<span class="p">}</span>
<span class="c1">// 设置路由分发回调函数</span>
<span class="k">protected</span> <span class="k">function</span> <span class="nf">dispatchToRouter</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="k">function</span> <span class="p">(</span><span class="nv">$request</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">app</span><span class="o">-&gt;</span><span class="na">instance</span><span class="p">(</span><span class="s1">&#39;request&#39;</span><span class="p">,</span> <span class="nv">$request</span><span class="p">);</span> <span class="c1">// 保存请求实例到容器中</span>

        <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">router</span><span class="o">-&gt;</span><span class="na">dispatch</span><span class="p">(</span><span class="nv">$request</span><span class="p">);</span> <span class="c1">// 路由分发请求</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>文件 <code class="docutils literal"><span class="pre">Illuminate\Routing\Pipeline.php</span></code></p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">protected</span> <span class="k">function</span> <span class="nf">carry</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="k">function</span> <span class="p">(</span><span class="nv">$stack</span><span class="p">,</span> <span class="nv">$pipe</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">function</span> <span class="p">(</span><span class="nv">$passable</span><span class="p">)</span> <span class="k">use</span> <span class="p">(</span><span class="nv">$stack</span><span class="p">,</span> <span class="nv">$pipe</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">try</span> <span class="p">{</span>
                <span class="nv">$slice</span> <span class="o">=</span> <span class="k">parent</span><span class="o">::</span><span class="na">carry</span><span class="p">();</span> <span class="c1">// 构造闭包</span>

                <span class="nv">$callable</span> <span class="o">=</span> <span class="nv">$slice</span><span class="p">(</span><span class="nv">$stack</span><span class="p">,</span> <span class="nv">$pipe</span><span class="p">);</span> <span class="c1">// 调用闭包并传入参数，返回一个闭包</span>

                <span class="k">return</span> <span class="nv">$callable</span><span class="p">(</span><span class="nv">$passable</span><span class="p">);</span> <span class="c1">// 调用该闭包并传入请求对象</span>
            <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">Exception</span> <span class="nv">$e</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">handleException</span><span class="p">(</span><span class="nv">$passable</span><span class="p">,</span> <span class="nv">$e</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">Throwable</span> <span class="nv">$e</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">handleException</span><span class="p">(</span><span class="nv">$passable</span><span class="p">,</span> <span class="k">new</span> <span class="nx">FatalThrowableError</span><span class="p">(</span><span class="nv">$e</span><span class="p">));</span>
            <span class="p">}</span>
        <span class="p">};</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>文件 <code class="docutils literal"><span class="pre">Illuminate\Pipeline\Pipeline.php</span></code></p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">public</span> <span class="k">function</span> <span class="fm">__construct</span><span class="p">(</span><span class="nx">Container</span> <span class="nv">$container</span> <span class="o">=</span> <span class="k">null</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">container</span> <span class="o">=</span> <span class="nv">$container</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 设置被送入管道的对象，这里是请求对象</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">send</span><span class="p">(</span><span class="nv">$passable</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">passable</span> <span class="o">=</span> <span class="nv">$passable</span><span class="p">;</span>

    <span class="k">return</span> <span class="nv">$this</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 设置导管数组，即被送入管道的对象需要通过的导管，这里是中间件数组</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">through</span><span class="p">(</span><span class="nv">$pipes</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">pipes</span> <span class="o">=</span> <span class="nb">is_array</span><span class="p">(</span><span class="nv">$pipes</span><span class="p">)</span> <span class="o">?</span> <span class="nv">$pipes</span> <span class="o">:</span> <span class="nb">func_get_args</span><span class="p">();</span>

    <span class="k">return</span> <span class="nv">$this</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 以一个回调函数为终点执行“管道”处理</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">then</span><span class="p">(</span><span class="nx">Closure</span> <span class="nv">$destination</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 反转中间件，通过carry()函数聚合为多次嵌套的函数，然后调用该函数</span>
    <span class="nv">$pipeline</span> <span class="o">=</span> <span class="nb">array_reduce</span><span class="p">(</span>
        <span class="nb">array_reverse</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">pipes</span><span class="p">),</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">carry</span><span class="p">(),</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">prepareDestination</span><span class="p">(</span><span class="nv">$destination</span><span class="p">)</span>
    <span class="p">);</span>

    <span class="k">return</span> <span class="nv">$pipeline</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">passable</span><span class="p">);</span> <span class="c1">// 调用函数，并传入Request对象</span>
<span class="p">}</span>
<span class="c1">// 最内层调用函数</span>
<span class="k">protected</span> <span class="k">function</span> <span class="nf">prepareDestination</span><span class="p">(</span><span class="nx">Closure</span> <span class="nv">$destination</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="k">function</span> <span class="p">(</span><span class="nv">$passable</span><span class="p">)</span> <span class="k">use</span> <span class="p">(</span><span class="nv">$destination</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nv">$destination</span><span class="p">(</span><span class="nv">$passable</span><span class="p">);</span> <span class="c1">// 最内层调用函数，并传入Request对象</span>
    <span class="p">};</span>
<span class="p">}</span>
<span class="c1">// 获取一个用来代替应用处理“洋葱”层的回调函数</span>
<span class="k">protected</span> <span class="k">function</span> <span class="nf">carry</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="k">function</span> <span class="p">(</span><span class="nv">$stack</span><span class="p">,</span> <span class="nv">$pipe</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">function</span> <span class="p">(</span><span class="nv">$passable</span><span class="p">)</span> <span class="k">use</span> <span class="p">(</span><span class="nv">$stack</span><span class="p">,</span> <span class="nv">$pipe</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">is_callable</span><span class="p">(</span><span class="nv">$pipe</span><span class="p">))</span> <span class="p">{</span>
                <span class="sd">/**</span>
<span class="sd">                 * 如果管道是闭包的一个实例，我们将直接调用它，否则我们会将这些管道从容器中解析出来，并用适当的方法和参数调用它，并将结果返回。</span>
<span class="sd">                 */</span>
                <span class="k">return</span> <span class="nv">$pipe</span><span class="p">(</span><span class="nv">$passable</span><span class="p">,</span> <span class="nv">$stack</span><span class="p">);</span> <span class="c1">// 其中$passable为请求对象，$stack为中间件的嵌套函数</span>
            <span class="p">}</span> <span class="k">elseif</span> <span class="p">(</span><span class="o">!</span> <span class="nb">is_object</span><span class="p">(</span><span class="nv">$pipe</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">list</span><span class="p">(</span><span class="nv">$name</span><span class="p">,</span> <span class="nv">$parameters</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">parsePipeString</span><span class="p">(</span><span class="nv">$pipe</span><span class="p">);</span>

                <span class="sd">/**</span>
<span class="sd">                 * 如果管道是字符串，我们将解析字符串并将该类从依赖注入容器中解析出来。 然后，我们可以构建一个可调用的函数，并传入所需的参数到管道函数中来执行。</span>
<span class="sd">                 */</span>
                <span class="nv">$pipe</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">getContainer</span><span class="p">()</span><span class="o">-&gt;</span><span class="na">make</span><span class="p">(</span><span class="nv">$name</span><span class="p">);</span>
                <span class="c1">// 合并传入调用方法的参数，包括请求对象，中间件的嵌套函数，用户自定义的参数</span>
                <span class="nv">$parameters</span> <span class="o">=</span> <span class="nb">array_merge</span><span class="p">([</span><span class="nv">$passable</span><span class="p">,</span> <span class="nv">$stack</span><span class="p">],</span> <span class="nv">$parameters</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="sd">/**</span>
<span class="sd">                 * 如果管道已经是一个对象，我们只需创建一个闭包，然后将它传递给管道。 没有必要做任何额外的解析和格式化，因为我们提供的对象已经是完全实例化的对象。</span>
<span class="sd">                 */</span>
                <span class="nv">$parameters</span> <span class="o">=</span> <span class="p">[</span><span class="nv">$passable</span><span class="p">,</span> <span class="nv">$stack</span><span class="p">];</span> <span class="c1">// 只包含请求对象和中间件的嵌套函数，这两个参数</span>
            <span class="p">}</span>
            <span class="c1">// 如果存在handle方法，则使用handle方法来处理，否则使用构造函数</span>
            <span class="k">return</span> <span class="nb">method_exists</span><span class="p">(</span><span class="nv">$pipe</span><span class="p">,</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">method</span><span class="p">)</span>
                            <span class="o">?</span> <span class="nv">$pipe</span><span class="o">-&gt;</span><span class="p">{</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">method</span><span class="p">}(</span><span class="o">...</span><span class="nv">$parameters</span><span class="p">)</span>
                            <span class="o">:</span> <span class="nv">$pipe</span><span class="p">(</span><span class="o">...</span><span class="nv">$parameters</span><span class="p">);</span>
        <span class="p">};</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在 <code class="docutils literal"><span class="pre">Laravel</span></code> 框架中，很多注释和代码名称已经非常形象地表达了程序代码的功能，代码注释中将中间件称为&quot;洋葱&quot;层，将整个处理流程称为“管道”，有些地方会用到这些名称，如果读者理解了真正的含义就会更容易理解程序。对请求的处理阶段，首先对管道类进行了实例化，分别通过 <code class="docutils literal"><span class="pre">send()</span></code> 函数和 <code class="docutils literal"><span class="pre">through()</span></code> 函数将请求实例和中间件数组赋值给管道实例，而最终的处理是通过 <code class="docutils literal"><span class="pre">then()</span></code> 函数完成的，该函数有一个参数，这个参数是经过“管道后”的终点处理函数，即下一步的路由处理。而 <code class="docutils literal"><span class="pre">then()</span></code> 函数其实就是将整个中间件数组通过服务容器生成实例，并对这些实例的 <code class="docutils literal"><span class="pre">handle()</span></code> 函数和传入的终点处理回调函数进行组装，形成一个递归调用的回调函数，再进行调用，最终完成“管道”的逐级处理。</p>
<p>对于初始的 <code class="docutils literal"><span class="pre">Laravel</span></code> 框架程序，中间件包括 <code class="docutils literal"><span class="pre">CheckForMaintenanceMode</span></code> 、 <code class="docutils literal"><span class="pre">ValidatePostSize</span></code> 、 <code class="docutils literal"><span class="pre">TrimStrings</span></code> 、 <code class="docutils literal"><span class="pre">ConvertEmptyStringsToNull</span></code> 、 <code class="docutils literal"><span class="pre">TrustProxies</span></code> 。定义在 <code class="docutils literal"><span class="pre">app\Http\Kernel.php</span></code> 文件中的 <code class="docutils literal"><span class="pre">$middleware</span></code> 数组中，分别用来完成验证维护模式、验证 post 数据大小、去除首尾空白字符、转换空字符串为 null、信任代理设置。如果在程序开发过程中需要添加新的中间件，可以按照这几个类进行设计并添加到中间件数组中。</p>
</div>
<div class="section" id="id21">
<h3><a class="toc-backref" href="#id46">1.3.3. 路由处理生成响应</a><a class="headerlink" href="#id21" title="永久链接至标题">¶</a></h3>
<p>对于 <code class="docutils literal"><span class="pre">Laravel</span></code> 框架，请求是通过路由与控制器的响应函数对应的，整个路由表的生成是在请求处理的准备工作中的启动服务过程中完成的，通过 <code class="docutils literal"><span class="pre">RouteServiceProvider</span></code> 中的 <code class="docutils literal"><span class="pre">boot()</span></code> 函数实现。下面将按请求处理的步骤逐步介绍。</p>
<div class="section" id="id22">
<h4><a class="toc-backref" href="#id47">1.3.3.1. 路由匹配</a><a class="headerlink" href="#id22" title="永久链接至标题">¶</a></h4>
<p>在路由的定义过程中，通常有两个参数，一个是URI(唯一资源标识符)，另一个是处理函数或处理函数定位，而大部分是处理函数定位，即控制器中相应的函数。那么，在路由表中就是请求与处理函数的对应信息，每一个对应信息为一个路由，通过 <code class="docutils literal"><span class="pre">Illuminate\Routing\Route</span></code> 实例进行保存，而所有的路由信息又通过 <code class="docutils literal"><span class="pre">Illuminate\Routing\RouteCollection</span></code> 实例保存形成路由表，而路由表则由 <code class="docutils literal"><span class="pre">Illuminate\Routing\Router</span></code> 类实例保存，这就是路由信息的结构。对于请求的处理，首先是在路由信息结构中找到对应的路由，即对应的 <code class="docutils literal"><span class="pre">Illuminate\Routing\Route</span></code> 实例，下面是这部分源码：</p>
<p>文件 <code class="docutils literal"><span class="pre">Illuminate\Foundation\Http\Kernel.php</span></code></p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">protected</span> <span class="k">function</span> <span class="nf">dispatchToRouter</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="k">function</span> <span class="p">(</span><span class="nv">$request</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">app</span><span class="o">-&gt;</span><span class="na">instance</span><span class="p">(</span><span class="s1">&#39;request&#39;</span><span class="p">,</span> <span class="nv">$request</span><span class="p">);</span> <span class="c1">// 保存请求实例到容器中</span>

        <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">router</span><span class="o">-&gt;</span><span class="na">dispatch</span><span class="p">(</span><span class="nv">$request</span><span class="p">);</span> <span class="c1">// 路由分发请求</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面提到，所有的路由信息其实都保存在一个 <code class="docutils literal"><span class="pre">Illuminate\Routing\Router</span></code> 类实例中，而这个类实例存储在 <code class="docutils literal"><span class="pre">Kernel</span></code> 类的实例中，于是通过 <code class="docutils literal"><span class="pre">$this-&gt;router-&gt;dispatch($request)</span></code> 将请求信息传递给路由信息存储实例。</p>
<p>文件 <code class="docutils literal"><span class="pre">Illuminate\Routing\Router.php</span></code></p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">dispatch</span><span class="p">(</span><span class="nx">Request</span> <span class="nv">$request</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">currentRequest</span> <span class="o">=</span> <span class="nv">$request</span><span class="p">;</span> <span class="c1">// 传递请求对象给路由管理对象</span>

    <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">dispatchToRoute</span><span class="p">(</span><span class="nv">$request</span><span class="p">);</span> <span class="c1">// 分发请求到路由实例并返回响应</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">function</span> <span class="nf">dispatchToRoute</span><span class="p">(</span><span class="nx">Request</span> <span class="nv">$request</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">runRoute</span><span class="p">(</span><span class="nv">$request</span><span class="p">,</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">findRoute</span><span class="p">(</span><span class="nv">$request</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">protected</span> <span class="k">function</span> <span class="nf">findRoute</span><span class="p">(</span><span class="nv">$request</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 根据请求对象找到匹配的路由</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">current</span> <span class="o">=</span> <span class="nv">$route</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">routes</span><span class="o">-&gt;</span><span class="na">match</span><span class="p">(</span><span class="nv">$request</span><span class="p">);</span>
    <span class="c1">// 把匹配路由对象记录到容器中</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">container</span><span class="o">-&gt;</span><span class="na">instance</span><span class="p">(</span><span class="nx">Route</span><span class="o">::</span><span class="na">class</span><span class="p">,</span> <span class="nv">$route</span><span class="p">);</span>

    <span class="k">return</span> <span class="nv">$route</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">protected</span> <span class="k">function</span> <span class="nf">runRoute</span><span class="p">(</span><span class="nx">Request</span> <span class="nv">$request</span><span class="p">,</span> <span class="nx">Route</span> <span class="nv">$route</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 设置请求对象的路由解析器</span>
    <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">setRouteResolver</span><span class="p">(</span><span class="k">function</span> <span class="p">()</span> <span class="k">use</span> <span class="p">(</span><span class="nv">$route</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nv">$route</span><span class="p">;</span>
    <span class="p">});</span>
    <span class="c1">// 发送路由匹配事件</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">events</span><span class="o">-&gt;</span><span class="na">dispatch</span><span class="p">(</span><span class="k">new</span> <span class="nx">Events\RouteMatched</span><span class="p">(</span><span class="nv">$route</span><span class="p">,</span> <span class="nv">$request</span><span class="p">));</span>

    <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">prepareResponse</span><span class="p">(</span><span class="nv">$request</span><span class="p">,</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">runRouteWithinStack</span><span class="p">(</span><span class="nv">$route</span><span class="p">,</span> <span class="nv">$request</span><span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>
<span class="k">protected</span> <span class="k">function</span> <span class="nf">runRouteWithinStack</span><span class="p">(</span><span class="nx">Route</span> <span class="nv">$route</span><span class="p">,</span> <span class="nx">Request</span> <span class="nv">$request</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 如果middleware.disable实例已经绑定，且值为Boolean类型的true，则关闭中间件</span>
    <span class="nv">$shouldSkipMiddleware</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">container</span><span class="o">-&gt;</span><span class="na">bound</span><span class="p">(</span><span class="s1">&#39;middleware.disable&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                            <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">container</span><span class="o">-&gt;</span><span class="na">make</span><span class="p">(</span><span class="s1">&#39;middleware.disable&#39;</span><span class="p">)</span> <span class="o">===</span> <span class="k">true</span><span class="p">;</span>
    <span class="c1">// 是否关闭中间件</span>
    <span class="nv">$middleware</span> <span class="o">=</span> <span class="nv">$shouldSkipMiddleware</span> <span class="o">?</span> <span class="p">[]</span> <span class="o">:</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">gatherRouteMiddleware</span><span class="p">(</span><span class="nv">$route</span><span class="p">);</span>
    <span class="c1">// 执行路由中间件</span>
    <span class="k">return</span> <span class="p">(</span><span class="k">new</span> <span class="nx">Pipeline</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">container</span><span class="p">))</span>
                    <span class="o">-&gt;</span><span class="na">send</span><span class="p">(</span><span class="nv">$request</span><span class="p">)</span>
                    <span class="o">-&gt;</span><span class="na">through</span><span class="p">(</span><span class="nv">$middleware</span><span class="p">)</span>
                    <span class="o">-&gt;</span><span class="na">then</span><span class="p">(</span><span class="k">function</span> <span class="p">(</span><span class="nv">$request</span><span class="p">)</span> <span class="k">use</span> <span class="p">(</span><span class="nv">$route</span><span class="p">)</span> <span class="p">{</span>
                        <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">prepareResponse</span><span class="p">(</span>
                            <span class="nv">$request</span><span class="p">,</span> <span class="nv">$route</span><span class="o">-&gt;</span><span class="na">run</span><span class="p">()</span>
                        <span class="p">);</span>
                    <span class="p">});</span>
<span class="p">}</span>
<span class="c1">// 收集路由和控制器中该动作的中间件</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">gatherRouteMiddleware</span><span class="p">(</span><span class="nx">Route</span> <span class="nv">$route</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 这里面的中间件包含控制器和路由中定义的中间件</span>
    <span class="nv">$middleware</span> <span class="o">=</span> <span class="nx">collect</span><span class="p">(</span><span class="nv">$route</span><span class="o">-&gt;</span><span class="na">gatherMiddleware</span><span class="p">())</span><span class="o">-&gt;</span><span class="na">map</span><span class="p">(</span><span class="k">function</span> <span class="p">(</span><span class="nv">$name</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="k">array</span><span class="p">)</span> <span class="nx">MiddlewareNameResolver</span><span class="o">::</span><span class="na">resolve</span><span class="p">(</span><span class="nv">$name</span><span class="p">,</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">middleware</span><span class="p">,</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">middlewareGroups</span><span class="p">);</span>
    <span class="p">})</span><span class="o">-&gt;</span><span class="na">flatten</span><span class="p">();</span>
    <span class="c1">// 根据中间件优先级对所有中间件进行排序</span>
    <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">sortMiddleware</span><span class="p">(</span><span class="nv">$middleware</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在路由信息存储实例中，通过 <code class="docutils literal"><span class="pre">$this-&gt;findRoute($request)</span></code> 来查找请求对应的路由实例，查找主要是根据请求的方法和请求的URI来实现对应，当查找到请求对应的路由后，请求将会传递到对应的路由中去处理，即 <code class="docutils literal"><span class="pre">$route-&gt;run()</span></code> 。</p>
<p>文件 <code class="docutils literal"><span class="pre">Illuminate\Routing\Route.php</span></code></p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">run</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">container</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">container</span> <span class="o">?:</span> <span class="k">new</span> <span class="nx">Container</span><span class="p">;</span>

    <span class="k">try</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">isControllerAction</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">runController</span><span class="p">();</span> <span class="c1">// 执行控制器动作</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">runCallable</span><span class="p">();</span> <span class="c1">// 执行闭包</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">HttpResponseException</span> <span class="nv">$e</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nv">$e</span><span class="o">-&gt;</span><span class="na">getResponse</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 执行控制器动作</span>
<span class="k">protected</span> <span class="k">function</span> <span class="nf">runController</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">controllerDispatcher</span><span class="p">()</span><span class="o">-&gt;</span><span class="na">dispatch</span><span class="p">(</span>
        <span class="nv">$this</span><span class="p">,</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">getController</span><span class="p">(),</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">getControllerMethod</span><span class="p">()</span>
    <span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 生成控制器对象</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">getController</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">controller</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$class</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">parseControllerCallback</span><span class="p">()[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// 解析路由中控制器名称</span>
        <span class="c1">// 使用容器创建控制器对象</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">controller</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">container</span><span class="o">-&gt;</span><span class="na">make</span><span class="p">(</span><span class="nb">ltrim</span><span class="p">(</span><span class="nv">$class</span><span class="p">,</span> <span class="s1">&#39;\\&#39;</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">controller</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 返回方法名称</span>
<span class="k">protected</span> <span class="k">function</span> <span class="nf">getControllerMethod</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">parseControllerCallback</span><span class="p">()[</span><span class="mi">1</span><span class="p">];</span> <span class="c1">// 解析路由中方法名称</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在请求对应的路由中，会使用控制器分发器处理，在初始的 <code class="docutils literal"><span class="pre">Laravel</span></code> 框架中使用的是控制器分发器，通过服务容器自动生成这个分发器，这个服务是通过服务提供者 <code class="docutils literal"><span class="pre">ControllerServiceProvider</span></code> 注册的，下一步将会把请求及路由中关于处理函数的信息交给 控制分发器去处理。</p>
</div>
<div class="section" id="id23">
<h4><a class="toc-backref" href="#id48">1.3.3.2. 控制器生成</a><a class="headerlink" href="#id23" title="永久链接至标题">¶</a></h4>
<p>在控制分发器中，将会根据路由提供的响应函数信息来实例化控制类，并调用对应的响应函数生成响应的内容部分。下面给出部分源码：</p>
<p>文件 <code class="docutils literal"><span class="pre">Illuminate\Routing\ControllerDispatcher.php</span></code></p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">dispatch</span><span class="p">(</span><span class="nx">Route</span> <span class="nv">$route</span><span class="p">,</span> <span class="nv">$controller</span><span class="p">,</span> <span class="nv">$method</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nv">$parameters</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">resolveClassMethodDependencies</span><span class="p">(</span>
        <span class="nv">$route</span><span class="o">-&gt;</span><span class="na">parametersWithoutNulls</span><span class="p">(),</span> <span class="nv">$controller</span><span class="p">,</span> <span class="nv">$method</span>
    <span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">method_exists</span><span class="p">(</span><span class="nv">$controller</span><span class="p">,</span> <span class="s1">&#39;callAction&#39;</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nv">$controller</span><span class="o">-&gt;</span><span class="na">callAction</span><span class="p">(</span><span class="nv">$method</span><span class="p">,</span> <span class="nv">$parameters</span><span class="p">);</span> <span class="c1">// 通过BaseController中的callAction来间接调用该方法</span>
    <span class="p">}</span>
    <span class="c1">// 如果没有继承基类，则直接调用动作方法</span>
    <span class="k">return</span> <span class="nv">$controller</span><span class="o">-&gt;</span><span class="p">{</span><span class="nv">$method</span><span class="p">}(</span><span class="o">...</span><span class="nb">array_values</span><span class="p">(</span><span class="nv">$parameters</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在控制分发器中，首先根据控制器类名，通过服务容器进行实例化，再通过调用控制器实例对应的方法来生成响应的主体部分。</p>
<p>这里需要注意：可以定义控制器层次的中间件，通过在构造函数中 <code class="docutils literal"><span class="pre">$this-&gt;middleware('auth')</span></code> 或者 <code class="docutils literal"><span class="pre">$this-&gt;middleware('guest')-&gt;except('logout')</span></code> 来声明该控制器中处理请求过程中需要进行对应中间件的处理，即权限验证。当声明了中间件后，就会在 <code class="docutils literal"><span class="pre">callWithinStack()</span></code> 函数中获取对应的中间件信息，然后通过管道方式进行处理。在 <code class="docutils literal"><span class="pre">Laravel</span></code> 框架中，对于身份验证等功能就是这样实现的，在响应之前首先经过 <code class="docutils literal"><span class="pre">auth</span></code> 中间件的 <code class="docutils literal"><span class="pre">handle()</span></code> 函数进行处理，如果验证通过将会进行响应处理，否则重定向到登陆页面。</p>
</div>
<div class="section" id="id24">
<h4><a class="toc-backref" href="#id49">1.3.3.3. 响应生成</a><a class="headerlink" href="#id24" title="永久链接至标题">¶</a></h4>
<p>经历了层层的处理，应用程序终于找到了对应请求的处理函数，这里假设就是 <code class="docutils literal"><span class="pre">Laravel</span></code> 框架的欢迎页面。对于不同的应用可能生成的响应主体是不同的，对于移动应用可能响应的就是一些 <code class="docutils literal"><span class="pre">JSON</span></code> 格式的数据，而对于网页应用响应的可能是一个 <code class="docutils literal"><span class="pre">HTML</span></code> 页面。下面是部分源码:</p>
<p>文件 <code class="docutils literal"><span class="pre">app\Http\Controllers\WelcomeController.php</span></code></p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="c1">// 显示视图到屏幕</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">index</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">view</span><span class="p">(</span><span class="s1">&#39;welcome&#39;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>文件 <code class="docutils literal"><span class="pre">Illuminate\Foundation\helpers.php</span></code></p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">function</span> <span class="nf">view</span><span class="p">(</span><span class="nv">$view</span> <span class="o">=</span> <span class="k">null</span><span class="p">,</span> <span class="nv">$data</span> <span class="o">=</span> <span class="p">[],</span> <span class="nv">$mergeData</span> <span class="o">=</span> <span class="p">[])</span>
<span class="p">{</span>
    <span class="nv">$factory</span> <span class="o">=</span> <span class="nx">app</span><span class="p">(</span><span class="nx">ViewFactory</span><span class="o">::</span><span class="na">class</span><span class="p">);</span> <span class="c1">// 获取视图工厂的实例</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">func_num_args</span><span class="p">()</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 如果函数参数为0，则直接返回视图工厂对象，用来支持链式操作</span>
        <span class="k">return</span> <span class="nv">$factory</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 使用视图工厂创建视图对象</span>
    <span class="k">return</span> <span class="nv">$factory</span><span class="o">-&gt;</span><span class="na">make</span><span class="p">(</span><span class="nv">$view</span><span class="p">,</span> <span class="nv">$data</span><span class="p">,</span> <span class="nv">$mergeData</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>文件 <code class="docutils literal"><span class="pre">Illuminate\View\Factory.php</span></code></p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">make</span><span class="p">(</span><span class="nv">$view</span><span class="p">,</span> <span class="nv">$data</span> <span class="o">=</span> <span class="p">[],</span> <span class="nv">$mergeData</span> <span class="o">=</span> <span class="p">[])</span>
<span class="p">{</span>
    <span class="c1">// 查找和规范模板文件的路径</span>
    <span class="nv">$path</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">finder</span><span class="o">-&gt;</span><span class="na">find</span><span class="p">(</span>
        <span class="nv">$view</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">normalizeName</span><span class="p">(</span><span class="nv">$view</span><span class="p">)</span>
    <span class="p">);</span>

    <span class="sd">/**</span>
<span class="sd">     * 接下来，我们将创建视图实例并为可以设置任何数据的视图调用视图创建器等。</span>
<span class="sd">     * 然后，我们将视图实例返回给调用者以进行渲染或对其执行其他视图操作。</span>
<span class="sd">     */</span>
    <span class="nv">$data</span> <span class="o">=</span> <span class="nb">array_merge</span><span class="p">(</span><span class="nv">$mergeData</span><span class="p">,</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">parseData</span><span class="p">(</span><span class="nv">$data</span><span class="p">));</span>

    <span class="c1">// 传入视图实例到闭包函数，该函数主要发出创建视图事件</span>
    <span class="k">return</span> <span class="nx">tap</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">viewInstance</span><span class="p">(</span><span class="nv">$view</span><span class="p">,</span> <span class="nv">$path</span><span class="p">,</span> <span class="nv">$data</span><span class="p">),</span> <span class="k">function</span> <span class="p">(</span><span class="nv">$view</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">callCreator</span><span class="p">(</span><span class="nv">$view</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
<p>对于视图的生成实际上是通过实例化 <code class="docutils literal"><span class="pre">Illuminate\View\View</span></code> 类实现的，在 <code class="docutils literal"><span class="pre">View</span></code> 实例中包含了视图文件路径、名称、数据及它的编译引擎等，接下来将会根据生成的响应主体生成响应实例。在 <code class="docutils literal"><span class="pre">Laravel</span></code> 框架中对响应的封装是通过 <code class="docutils literal"><span class="pre">Illuminate\Http\Response</span></code> 类完成的，而该类的底层也用到了 <code class="docutils literal"><span class="pre">Symfony</span></code> 框架中的 <code class="docutils literal"><span class="pre">Response</span></code> 类，即 <code class="docutils literal"><span class="pre">Symfony\Component\HttpFoundation\Response</span></code> 类。</p>
<p>文件 <code class="docutils literal"><span class="pre">Illuminate\Routing\Router.php</span></code></p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">protected</span> <span class="k">function</span> <span class="nf">runRouteWithinStack</span><span class="p">(</span><span class="nx">Route</span> <span class="nv">$route</span><span class="p">,</span> <span class="nx">Request</span> <span class="nv">$request</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 如果middleware.disable实例已经绑定，且值为Boolean类型的true，则关闭中间件</span>
    <span class="nv">$shouldSkipMiddleware</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">container</span><span class="o">-&gt;</span><span class="na">bound</span><span class="p">(</span><span class="s1">&#39;middleware.disable&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                            <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">container</span><span class="o">-&gt;</span><span class="na">make</span><span class="p">(</span><span class="s1">&#39;middleware.disable&#39;</span><span class="p">)</span> <span class="o">===</span> <span class="k">true</span><span class="p">;</span>
    <span class="c1">// 是否关闭中间件</span>
    <span class="nv">$middleware</span> <span class="o">=</span> <span class="nv">$shouldSkipMiddleware</span> <span class="o">?</span> <span class="p">[]</span> <span class="o">:</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">gatherRouteMiddleware</span><span class="p">(</span><span class="nv">$route</span><span class="p">);</span>
    <span class="c1">// 执行路由中间件</span>
    <span class="k">return</span> <span class="p">(</span><span class="k">new</span> <span class="nx">Pipeline</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">container</span><span class="p">))</span>
                    <span class="o">-&gt;</span><span class="na">send</span><span class="p">(</span><span class="nv">$request</span><span class="p">)</span>
                    <span class="o">-&gt;</span><span class="na">through</span><span class="p">(</span><span class="nv">$middleware</span><span class="p">)</span>
                    <span class="o">-&gt;</span><span class="na">then</span><span class="p">(</span><span class="k">function</span> <span class="p">(</span><span class="nv">$request</span><span class="p">)</span> <span class="k">use</span> <span class="p">(</span><span class="nv">$route</span><span class="p">)</span> <span class="p">{</span>
                        <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">prepareResponse</span><span class="p">(</span>
                            <span class="nv">$request</span><span class="p">,</span> <span class="nv">$route</span><span class="o">-&gt;</span><span class="na">run</span><span class="p">()</span>
                        <span class="p">);</span>
                    <span class="p">});</span>
<span class="p">}</span>
<span class="c1">// 用给定的视图对象创建一个响应对象</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">prepareResponse</span><span class="p">(</span><span class="nv">$request</span><span class="p">,</span> <span class="nv">$response</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="k">static</span><span class="o">::</span><span class="na">toResponse</span><span class="p">(</span><span class="nv">$request</span><span class="p">,</span> <span class="nv">$response</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">static</span> <span class="k">function</span> <span class="nf">toResponse</span><span class="p">(</span><span class="nv">$request</span><span class="p">,</span> <span class="nv">$response</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nv">$response</span> <span class="nx">instanceof</span> <span class="nx">Responsable</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$response</span> <span class="o">=</span> <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">toResponse</span><span class="p">(</span><span class="nv">$request</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="nv">$response</span> <span class="nx">instanceof</span> <span class="nx">PsrResponseInterface</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$response</span> <span class="o">=</span> <span class="p">(</span><span class="k">new</span> <span class="nx">HttpFoundationFactory</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">createResponse</span><span class="p">(</span><span class="nv">$response</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">elseif</span> <span class="p">(</span><span class="o">!</span> <span class="nv">$response</span> <span class="nx">instanceof</span> <span class="nx">SymfonyResponse</span> <span class="o">&amp;&amp;</span>
               <span class="p">(</span><span class="nv">$response</span> <span class="nx">instanceof</span> <span class="nx">Arrayable</span> <span class="o">||</span>
                <span class="nv">$response</span> <span class="nx">instanceof</span> <span class="nx">Jsonable</span> <span class="o">||</span>
                <span class="nv">$response</span> <span class="nx">instanceof</span> <span class="nx">ArrayObject</span> <span class="o">||</span>
                <span class="nv">$response</span> <span class="nx">instanceof</span> <span class="nx">JsonSerializable</span> <span class="o">||</span>
                <span class="nb">is_array</span><span class="p">(</span><span class="nv">$response</span><span class="p">)))</span> <span class="p">{</span>
        <span class="nv">$response</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">JsonResponse</span><span class="p">(</span><span class="nv">$response</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">elseif</span> <span class="p">(</span><span class="o">!</span> <span class="nv">$response</span> <span class="nx">instanceof</span> <span class="nx">SymfonyResponse</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$response</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Response</span><span class="p">(</span><span class="nv">$response</span><span class="p">);</span> <span class="c1">// 把view对象传入响应对象中，Illuminate\http\Response对象</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="nv">$response</span><span class="o">-&gt;</span><span class="na">getStatusCode</span><span class="p">()</span> <span class="o">===</span> <span class="nx">Response</span><span class="o">::</span><span class="na">HTTP_NOT_MODIFIED</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setNotModified</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">prepare</span><span class="p">(</span><span class="nv">$request</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>文件 <code class="docutils literal"><span class="pre">Illuminate\Http\Response.php</span></code></p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">setContent</span><span class="p">(</span><span class="nv">$content</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">original</span> <span class="o">=</span> <span class="nv">$content</span><span class="p">;</span>

    <span class="sd">/**</span>
<span class="sd">     * 如果内容是“JSONable”，我们将设置适当的header并将内容转换为JSON。</span>
<span class="sd">     *  当从路由中返回类似于模型的东西时，这将很有用，它将自动转换为JSON格式。</span>
<span class="sd">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">shouldBeJson</span><span class="p">(</span><span class="nv">$content</span><span class="p">))</span> <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">header</span><span class="p">(</span><span class="s1">&#39;Content-Type&#39;</span><span class="p">,</span> <span class="s1">&#39;application/json&#39;</span><span class="p">);</span>

        <span class="nv">$content</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">morphToJson</span><span class="p">(</span><span class="nv">$content</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="sd">/**</span>
<span class="sd">     * 如果这个内容实现了“Renderable”接口，那么我们将在对象上调用render方法，</span>
<span class="sd">     * 这样我们就可以避免任何可能抛出的“__toString”异常，并且它们的错误被PHP的处理所掩盖。</span>
<span class="sd">     */</span>
    <span class="k">elseif</span> <span class="p">(</span><span class="nv">$content</span> <span class="nx">instanceof</span> <span class="nx">Renderable</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$content</span> <span class="o">=</span> <span class="nv">$content</span><span class="o">-&gt;</span><span class="na">render</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">parent</span><span class="o">::</span><span class="na">setContent</span><span class="p">(</span><span class="nv">$content</span><span class="p">);</span>

    <span class="k">return</span> <span class="nv">$this</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>文件 <code class="docutils literal"><span class="pre">symfony/http-foundation/Response.php</span></code></p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="c1">// 通过传入内容来构造响应对象</span>
<span class="k">public</span> <span class="k">function</span> <span class="fm">__construct</span><span class="p">(</span><span class="nv">$content</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="nv">$status</span> <span class="o">=</span> <span class="mi">200</span><span class="p">,</span> <span class="nv">$headers</span> <span class="o">=</span> <span class="k">array</span><span class="p">())</span>
<span class="p">{</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">headers</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ResponseHeaderBag</span><span class="p">(</span><span class="nv">$headers</span><span class="p">);</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">setContent</span><span class="p">(</span><span class="nv">$content</span><span class="p">);</span> <span class="c1">// 这里会解析视图对象为字符串</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">setStatusCode</span><span class="p">(</span><span class="nv">$status</span><span class="p">);</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">setProtocolVersion</span><span class="p">(</span><span class="s1">&#39;1.0&#39;</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 在响应传输到客户端之前进行准备</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">prepare</span><span class="p">(</span><span class="nx">Request</span> <span class="nv">$request</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nv">$headers</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">headers</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">isInformational</span><span class="p">()</span> <span class="o">||</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">isEmpty</span><span class="p">())</span> <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">setContent</span><span class="p">(</span><span class="k">null</span><span class="p">);</span>
        <span class="nv">$headers</span><span class="o">-&gt;</span><span class="na">remove</span><span class="p">(</span><span class="s1">&#39;Content-Type&#39;</span><span class="p">);</span>
        <span class="nv">$headers</span><span class="o">-&gt;</span><span class="na">remove</span><span class="p">(</span><span class="s1">&#39;Content-Length&#39;</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// Content-type based on the Request</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nv">$headers</span><span class="o">-&gt;</span><span class="na">has</span><span class="p">(</span><span class="s1">&#39;Content-Type&#39;</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// 设置响应的内容类型</span>
            <span class="nv">$format</span> <span class="o">=</span> <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">getRequestFormat</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="k">null</span> <span class="o">!==</span> <span class="nv">$format</span> <span class="o">&amp;&amp;</span> <span class="nv">$mimeType</span> <span class="o">=</span> <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">getMimeType</span><span class="p">(</span><span class="nv">$format</span><span class="p">))</span> <span class="p">{</span>
                <span class="nv">$headers</span><span class="o">-&gt;</span><span class="na">set</span><span class="p">(</span><span class="s1">&#39;Content-Type&#39;</span><span class="p">,</span> <span class="nv">$mimeType</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// Fix Content-Type，设置响应编码</span>
        <span class="nv">$charset</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">charset</span> <span class="o">?:</span> <span class="s1">&#39;UTF-8&#39;</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nv">$headers</span><span class="o">-&gt;</span><span class="na">has</span><span class="p">(</span><span class="s1">&#39;Content-Type&#39;</span><span class="p">))</span> <span class="p">{</span>
            <span class="nv">$headers</span><span class="o">-&gt;</span><span class="na">set</span><span class="p">(</span><span class="s1">&#39;Content-Type&#39;</span><span class="p">,</span> <span class="s1">&#39;text/html; charset=&#39;</span><span class="o">.</span><span class="nv">$charset</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">elseif</span> <span class="p">(</span><span class="mi">0</span> <span class="o">===</span> <span class="nb">stripos</span><span class="p">(</span><span class="nv">$headers</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s1">&#39;Content-Type&#39;</span><span class="p">),</span> <span class="s1">&#39;text/&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="k">false</span> <span class="o">===</span> <span class="nb">stripos</span><span class="p">(</span><span class="nv">$headers</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s1">&#39;Content-Type&#39;</span><span class="p">),</span> <span class="s1">&#39;charset&#39;</span><span class="p">))</span> <span class="p">{</span>
            <span class="c1">// add the charset</span>
            <span class="nv">$headers</span><span class="o">-&gt;</span><span class="na">set</span><span class="p">(</span><span class="s1">&#39;Content-Type&#39;</span><span class="p">,</span> <span class="nv">$headers</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s1">&#39;Content-Type&#39;</span><span class="p">)</span><span class="o">.</span><span class="s1">&#39;; charset=&#39;</span><span class="o">.</span><span class="nv">$charset</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// Fix Content-Length</span>
        <span class="k">if</span> <span class="p">(</span><span class="nv">$headers</span><span class="o">-&gt;</span><span class="na">has</span><span class="p">(</span><span class="s1">&#39;Transfer-Encoding&#39;</span><span class="p">))</span> <span class="p">{</span>
            <span class="nv">$headers</span><span class="o">-&gt;</span><span class="na">remove</span><span class="p">(</span><span class="s1">&#39;Content-Length&#39;</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="nv">$request</span><span class="o">-&gt;</span><span class="na">isMethod</span><span class="p">(</span><span class="s1">&#39;HEAD&#39;</span><span class="p">))</span> <span class="p">{</span>
            <span class="c1">// cf. RFC2616 14.13</span>
            <span class="nv">$length</span> <span class="o">=</span> <span class="nv">$headers</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s1">&#39;Content-Length&#39;</span><span class="p">);</span>
            <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">setContent</span><span class="p">(</span><span class="k">null</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="nv">$length</span><span class="p">)</span> <span class="p">{</span>
                <span class="nv">$headers</span><span class="o">-&gt;</span><span class="na">set</span><span class="p">(</span><span class="s1">&#39;Content-Length&#39;</span><span class="p">,</span> <span class="nv">$length</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Fix protocol</span>
    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;HTTP/1.0&#39;</span> <span class="o">!=</span> <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">server</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s1">&#39;SERVER_PROTOCOL&#39;</span><span class="p">))</span> <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">setProtocolVersion</span><span class="p">(</span><span class="s1">&#39;1.1&#39;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Check if we need to send extra expire info headers</span>
    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;1.0&#39;</span> <span class="o">==</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">getProtocolVersion</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="k">false</span> <span class="o">!==</span> <span class="nb">strpos</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">headers</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s1">&#39;Cache-Control&#39;</span><span class="p">),</span> <span class="s1">&#39;no-cache&#39;</span><span class="p">))</span> <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">headers</span><span class="o">-&gt;</span><span class="na">set</span><span class="p">(</span><span class="s1">&#39;pragma&#39;</span><span class="p">,</span> <span class="s1">&#39;no-cache&#39;</span><span class="p">);</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">headers</span><span class="o">-&gt;</span><span class="na">set</span><span class="p">(</span><span class="s1">&#39;expires&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">ensureIEOverSSLCompatibility</span><span class="p">(</span><span class="nv">$request</span><span class="p">);</span>

    <span class="k">return</span> <span class="nv">$this</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>从上面可以看到，响应最终是封装在 <code class="docutils literal"><span class="pre">Illuminate\Http\Response</span></code> 实例中的，其中不仅包括了控制器处理函数得到的响应主体，还包括根据请求生成的响应头的内容。至此，从请求的发出到响应的生成就已经完成了，接下来就是将响应发给客户端并记录相关的信息。</p>
</div>
</div>
</div>
<div class="section" id="id25">
<h2><a class="toc-backref" href="#id50">1.4. 响应的发送和程序终止</a><a class="headerlink" href="#id25" title="永久链接至标题">¶</a></h2>
<div class="section" id="id26">
<h3><a class="toc-backref" href="#id51">1.4.1. 响应的发送</a><a class="headerlink" href="#id26" title="永久链接至标题">¶</a></h3>
<p>到这里，对HTTP请求的响应已经生成了，接下来需要将封装在 <code class="docutils literal"><span class="pre">Illuminate\Http\Response</span></code> 实例中的响应以 <code class="docutils literal"><span class="pre">HTTP</span></code> 响应的形式发送给客户端，实现一个请求生命周期的最后环节。响应的发送是在 <code class="docutils literal"><span class="pre">public\index.php</span></code> 文件中通过 <code class="docutils literal"><span class="pre">$response-&gt;send()</span></code> 实现的。</p>
<p>文件 <code class="docutils literal"><span class="pre">public\index.php</span></code></p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="nv">$response</span><span class="o">-&gt;</span><span class="na">send</span><span class="p">();</span>
</pre></div>
</div>
<p>文件 <code class="docutils literal"><span class="pre">symfony\http-foundation\Response.php</span></code></p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">send</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">sendHeaders</span><span class="p">();</span> <span class="c1">//发送头到输出缓冲区</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">sendContent</span><span class="p">();</span> <span class="c1">// 发送内容到输出缓冲区</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">function_exists</span><span class="p">(</span><span class="s1">&#39;fastcgi_finish_request&#39;</span><span class="p">))</span> <span class="p">{</span>
        <span class="nb">fastcgi_finish_request</span><span class="p">();</span> <span class="c1">// 不等脚本结束，快速发送响应到浏览器端</span>
    <span class="p">}</span> <span class="k">elseif</span> <span class="p">(</span><span class="s1">&#39;cli&#39;</span> <span class="o">!==</span> <span class="nx">PHP_SAPI</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 通过关闭输出缓冲区来发送响应到浏览器</span>
        <span class="k">static</span><span class="o">::</span><span class="na">closeOutputBuffers</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nv">$this</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 发送HTTP头部内容</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">sendHeaders</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// headers have already been sent by the developer</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">headers_sent</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nv">$this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// headers</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">headers</span><span class="o">-&gt;</span><span class="na">allPreserveCaseWithoutCookies</span><span class="p">()</span> <span class="k">as</span> <span class="nv">$name</span> <span class="o">=&gt;</span> <span class="nv">$values</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">foreach</span> <span class="p">(</span><span class="nv">$values</span> <span class="k">as</span> <span class="nv">$value</span><span class="p">)</span> <span class="p">{</span>
            <span class="nb">header</span><span class="p">(</span><span class="nv">$name</span><span class="o">.</span><span class="s1">&#39;: &#39;</span><span class="o">.</span><span class="nv">$value</span><span class="p">,</span> <span class="k">false</span><span class="p">,</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">statusCode</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// status</span>
    <span class="nb">header</span><span class="p">(</span><span class="nb">sprintf</span><span class="p">(</span><span class="s1">&#39;HTTP/%s %s %s&#39;</span><span class="p">,</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">version</span><span class="p">,</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">statusCode</span><span class="p">,</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">statusText</span><span class="p">),</span> <span class="k">true</span><span class="p">,</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">statusCode</span><span class="p">);</span>

    <span class="c1">// cookies</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">headers</span><span class="o">-&gt;</span><span class="na">getCookies</span><span class="p">()</span> <span class="k">as</span> <span class="nv">$cookie</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nv">$cookie</span><span class="o">-&gt;</span><span class="na">isRaw</span><span class="p">())</span> <span class="p">{</span>
            <span class="nb">setrawcookie</span><span class="p">(</span><span class="nv">$cookie</span><span class="o">-&gt;</span><span class="na">getName</span><span class="p">(),</span> <span class="nv">$cookie</span><span class="o">-&gt;</span><span class="na">getValue</span><span class="p">(),</span> <span class="nv">$cookie</span><span class="o">-&gt;</span><span class="na">getExpiresTime</span><span class="p">(),</span> <span class="nv">$cookie</span><span class="o">-&gt;</span><span class="na">getPath</span><span class="p">(),</span> <span class="nv">$cookie</span><span class="o">-&gt;</span><span class="na">getDomain</span><span class="p">(),</span> <span class="nv">$cookie</span><span class="o">-&gt;</span><span class="na">isSecure</span><span class="p">(),</span> <span class="nv">$cookie</span><span class="o">-&gt;</span><span class="na">isHttpOnly</span><span class="p">());</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nb">setcookie</span><span class="p">(</span><span class="nv">$cookie</span><span class="o">-&gt;</span><span class="na">getName</span><span class="p">(),</span> <span class="nv">$cookie</span><span class="o">-&gt;</span><span class="na">getValue</span><span class="p">(),</span> <span class="nv">$cookie</span><span class="o">-&gt;</span><span class="na">getExpiresTime</span><span class="p">(),</span> <span class="nv">$cookie</span><span class="o">-&gt;</span><span class="na">getPath</span><span class="p">(),</span> <span class="nv">$cookie</span><span class="o">-&gt;</span><span class="na">getDomain</span><span class="p">(),</span> <span class="nv">$cookie</span><span class="o">-&gt;</span><span class="na">isSecure</span><span class="p">(),</span> <span class="nv">$cookie</span><span class="o">-&gt;</span><span class="na">isHttpOnly</span><span class="p">());</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nv">$this</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 发送Web响应的内容</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">sendContent</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">echo</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">content</span><span class="p">;</span>

    <span class="k">return</span> <span class="nv">$this</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>响应的发送包括两部分内容，分别是响应头信息的发送和响应主体内容的发送。响应头信息包括状态行、首部字段和 <code class="docutils literal"><span class="pre">Cookie</span></code> 的发送，状态行和首部字段是通过 <code class="docutils literal"><span class="pre">header()</span></code> 函数完成的， <code class="docutils literal"><span class="pre">Cookie</span></code> 的发送是通过 <code class="docutils literal"><span class="pre">setCookie()</span></code> 函数完成的，这里的 <code class="docutils literal"><span class="pre">Cookie</span></code> 内容主要是 <code class="docutils literal"><span class="pre">session</span></code> 的 <code class="docutils literal"><span class="pre">ID</span></code> 以及 <code class="docutils literal"><span class="pre">CSRF</span></code> 令牌，一个用于会话控制，另一个是防止 <code class="docutils literal"><span class="pre">CSRF</span></code> 攻击。在响应发送完成后，通过调用 <code class="docutils literal"><span class="pre">closeOutputBuffers()</span></code> 静态函数完成缓冲区的释放。</p>
</div>
<div class="section" id="id27">
<h3><a class="toc-backref" href="#id52">1.4.2. 程序终止</a><a class="headerlink" href="#id27" title="永久链接至标题">¶</a></h3>
<p>在完成 <code class="docutils literal"><span class="pre">HTTP</span></code> 响应的发送后，接下来进入程序生命周期的最后阶段——程序终止，对于 <code class="docutils literal"><span class="pre">Laravel</span></code> 框架，程序终止主要是完成终止中间件的调用。</p>
<p>文件 <code class="docutils literal"><span class="pre">public\index.php</span></code></p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="nv">$kernel</span><span class="o">-&gt;</span><span class="na">terminate</span><span class="p">(</span><span class="nv">$request</span><span class="p">,</span> <span class="nv">$response</span><span class="p">);</span>
</pre></div>
</div>
<p>文件 <code class="docutils literal"><span class="pre">Illuminate\Foundation\Http\Kernel.php</span></code></p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">terminate</span><span class="p">(</span><span class="nv">$request</span><span class="p">,</span> <span class="nv">$response</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 调用所有中间件(包含全局、路由、控制器中的中间件)的terminate()方法</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">terminateMiddleware</span><span class="p">(</span><span class="nv">$request</span><span class="p">,</span> <span class="nv">$response</span><span class="p">);</span>
    <span class="c1">// 调用容器注册的所有结束回调方法</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">app</span><span class="o">-&gt;</span><span class="na">terminate</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在 <code class="docutils literal"><span class="pre">Laravel</span></code> 框架默认情况下，只有会话中间件存在该函数，主要用于会话记录、即用户状态信息的记录。</p>
</div>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="请求到响应的生命周期-console.html" class="btn btn-neutral float-right" title="2. 请求到console响应的生命周期" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral" title="Welcome to laravel&#39;s documentation!" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, lzh.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.0',
            LANGUAGE:'zh',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  

<script type="text/javascript">
  
      $(document).ready(function(){
        var offset = sessionStorage.getItem("offsetTop");
        $('.wy-side-scroll').scrollTop(offset);
        sessionStorage.setItem("offsetTop", 0);


        $('.wy-menu > ul').click(function(){
            sessionStorage.setItem("offsetTop", $('.wy-side-scroll').scrollTop());
        });
      })

  </script> 

</body>
</html>