

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>31. Laravel 的用户认证系统 &mdash; laravel 1.0 文档</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="索引"
              href="genindex.html"/>
        <link rel="search" title="搜索" href="search.html"/>
    <link rel="top" title="laravel 1.0 文档" href="index.html"/>
        <link rel="next" title="32. 用户认证JWT" href="用户认证JWT.html"/>
        <link rel="prev" title="30. mix使用手册" href="laravel-mix.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> laravel
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">目录:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="请求到响应的生命周期-web.html">1. 请求到web响应的生命周期</a></li>
<li class="toctree-l1"><a class="reference internal" href="请求到响应的生命周期-console.html">2. 请求到console响应的生命周期</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的容器.html">3. 容器</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的Facades.html">4. Facades</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的Facades原理分析.html">5. Facade的原理</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的服务提供器.html">6. 服务提供器</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的路由.html">7. 路由</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的路由—路由的正则编译.html">8. 路由的正则编译</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的路由—路由的匹配与参数绑定.html">9. 路由的匹配与参数绑定</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的路由—路由中间件.html">10. 路由的中间件</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的中间件.html">11. 中间件</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的中间件-SubstituteBindings.html">12. 中间件SubstituteBindings</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的中间件-CSRF.html">13. 中间件CSRF</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的请求.html">14. 请求</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的控制器.html">15. 控制器</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的控制器—控制器方法的参数构建与运行.html">16. 控制器方法的参数构建与运行</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的响应.html">17. 响应</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的视图.html">18. 视图</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的生成URL.html">19. URL</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的Session.html">20. Session</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的Session原理分析.html">21. Session原理分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的表单验证机制详解.html">22. 表单验证机制详解</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的日志.html">23. 日志</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的异常和错误处理.html">24. 异常和错误处理</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的异常和错误处理原理分析.html">25. 异常和错误处理原理分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的Blade.html">26. Blade</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的blade原理分析.html">27. Blade原理分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的前端.html">28. 前端</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的Mix.html">29. Mix</a></li>
<li class="toctree-l1"><a class="reference internal" href="laravel-mix.html">30. mix使用手册</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">31. Laravel 的用户认证系统</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1">31.1. 简介</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">31.1.1. 数据库注意事项</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id3">31.2. 快速构建认证系统</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id4">31.2.1. 路由</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">31.2.2. 视图</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id6">31.2.3. 注册和登陆</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id11">31.2.4. 检索认证用户</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id13">31.2.5. 保护路由</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id15">31.2.6. 登录限制</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id16">31.3. 手动认证用户</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id17">31.3.1. 自定义控制器</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id21">31.3.2. 记住用户</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id22">31.3.3. 其它认证方法</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#http">31.4. HTTP 基础认证</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#fastcgi">31.4.1. FastCGI 的注意事项</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id25">31.4.2. 无状态 HTTP 基础认证</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id26">31.5. 社交认证</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id27">31.6. 增加自定义看守器</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#guard">31.6.1. Guard 接口</a></li>
<li class="toctree-l3"><a class="reference internal" href="#statefulguard">31.6.2. StatefulGuard 接口</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id29">31.7. 增加自定义用户提供器</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id30">31.7.1. 用户提供器契约</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id31">31.7.2. 认证契约</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#authmanager">31.8. AuthManager</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id32">31.9. 自定义认证</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id33">31.10. 事件</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="用户认证JWT.html">32. 用户认证JWT</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的API认证系统Passport.html">33. Laravel 的 API 认证系统 Passport</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的用户授权系统.html">34. Laravel用户授权系统</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的命令行.html">35. 命令行</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的广播系统.html">36. 广播</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的广播系统原理分析.html">37. 广播系统原理分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的缓存系统.html">38. 缓存</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的集合Collection.html">39. 集合</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的事件系统.html">40. 事件</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的事件系统原理分析.html">41. 事件系统原理分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的文件存储.html">42. 文件存储</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的辅助函数-字符串操作.html">43. 辅助函数-字符串函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的辅助函数-数组和对象操作.html">44. 辅助函数-数组和对象函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的辅助函数-路径操作.html">45. 辅助函数-路径函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的辅助函数-tap分析.html">46. 辅助函数-Tap函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的辅助函数-其它.html">47. 辅助函数-其它杂项</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的邮件发送功能.html">48. 邮件</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的消息通知.html">49. 通知</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel Queue——消息队列任务与分发源码剖析.html">50. 消息队列任务与分发源码剖析</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的任务调度.html">51. 任务调度</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的数据库—原始方式.html">52. 数据库-原始操作</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的数据库—查询构造器.html">53. 数据库-查询构建器</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的数据分页.html">54. 数据分页</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的数据分页原理分析.html">55. 数据分页原理分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的数据库迁移.html">56. 数据库迁移</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的数据库填充.html">57. 数据库填充</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的Redis.html">58. Redis</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的Redis原理分析.html">59. Redis原理分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的数据库—Eloquent.html">60. Eloquent</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的数据库—Eloquent关联.html">61. Eloquent关联</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的数据库—Eloquent修改器.html">62. Eloquent修改器</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的验证规则.html">63. 验证规则</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">laravel</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>31. Laravel 的用户认证系统</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            
        
        <a href="http://blog.liaozhonghao.cn" rel="nofollow"> 返回主页</a>
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="laravel">
<h1>31. Laravel 的用户认证系统<a class="headerlink" href="#laravel" title="永久链接至标题">¶</a></h1>
<div class="section" id="id1">
<h2>31.1. 简介<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p><code class="docutils literal"><span class="pre">Laravel</span></code> 中实现用户认证非常简单。实际上，几乎所有东西都已经为你配置好了。其配置文件位于 <code class="docutils literal"><span class="pre">config/auth.php</span></code> ，其中包含了用于调整认证服务行为的注释清晰的选项配置。</p>
<p>其核心是由 <code class="docutils literal"><span class="pre">Laravel</span></code> 的认证组件的 <strong>「看守器」</strong> 和 <strong>「提供器」</strong> 组成。 <strong>看守器定义了该如何认证每个请求中用户。</strong> 例如， <code class="docutils literal"><span class="pre">Laravel</span></code>  自带的 <code class="docutils literal"><span class="pre">session</span></code> 看守器会使用 <code class="docutils literal"><span class="pre">session</span></code> 存储和 <code class="docutils literal"><span class="pre">cookies</span></code> 来维护状态。</p>
<p><strong>提供器中定义了该如何从持久化的存储数据中检索用户。</strong> <code class="docutils literal"><span class="pre">Laravel</span></code> 自带支持使用 <code class="docutils literal"><span class="pre">Eloquent</span></code> 和数据库查询构造器来检索用户。当然，你可以根据需要自定义其他提供器。</p>
<p>不过对大多数应用而言，可能永远都不需要修改默认身份认证配置。</p>
<div class="section" id="id2">
<h3>31.1.1. 数据库注意事项<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<p>默认情况下， <code class="docutils literal"><span class="pre">Laravel</span></code> 在 <code class="docutils literal"><span class="pre">app</span></code> 目录中包含了一个 <code class="docutils literal"><span class="pre">Eloquent</span></code> 模型 <code class="docutils literal"><span class="pre">App\User</span></code> 。这个模型和默认的 <code class="docutils literal"><span class="pre">Eloquent</span></code> 认证驱动一起使用。如果你的应用不使用 <code class="docutils literal"><span class="pre">Eloquent</span></code> ，也可以使用 <code class="docutils literal"><span class="pre">Laravel</span></code> 查询构造器的 <code class="docutils literal"><span class="pre">database</span></code> 认证驱动。</p>
<p>为 <code class="docutils literal"><span class="pre">App\User</span></code> 模型创建数据库表结构时，确保密码字段长度至少为 60 个字符以及默认字符串列长度为 255 个字符。</p>
<p>此外，你要验证的用户（或等效的）表要包含一个可空的、长度为 100 的字符串 <code class="docutils literal"><span class="pre">remember_token</span></code> 。这个字段将用于存储当用户登录应用并勾选「记住我」时的令牌。</p>
</div>
</div>
<div class="section" id="id3">
<h2>31.2. 快速构建认证系统<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>想要快点开始？ 只需在新的 <code class="docutils literal"><span class="pre">Laravel</span></code> 应用上运行 <code class="docutils literal"><span class="pre">php</span> <span class="pre">artisan</span> <span class="pre">make:auth</span></code> (实际调用 <code class="docutils literal"><span class="pre">\Illuminate\Auth\Console\AuthMakeCommand</span></code> )和 <code class="docutils literal"><span class="pre">php</span> <span class="pre">artisan</span> <span class="pre">migrate</span></code> 命令。然后可以用浏览器访问 <code class="docutils literal"><span class="pre">http://your-app.dev/register</span></code> 或者你在程序中定义的其它 <code class="docutils literal"><span class="pre">URL</span></code> 。这两个命令就可以构建好整个认证系统。</p>
<p><code class="docutils literal"><span class="pre">Laravel</span></code> 自带几个预构建的认证控制器，它们被放置在 <code class="docutils literal"><span class="pre">App\Http\Controllers\Auth</span></code> 命名空间内。 <code class="docutils literal"><span class="pre">RegisterController</span></code> 处理新用户注册， <code class="docutils literal"><span class="pre">LoginController</span></code> 处理用户登陆， <code class="docutils literal"><span class="pre">ForgotPasswordController</span></code> 处理用于重置密码的邮件链接，而 <code class="docutils literal"><span class="pre">ResetPasswordController</span></code> 包含重置密码的逻辑。这些控制器都使用 <code class="docutils literal"><span class="pre">trait</span></code> 来引入所必要的方法。对于大多数应用而言，你根本不需要修改这些控制器。</p>
<div class="section" id="id4">
<h3>31.2.1. 路由<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal"><span class="pre">Laravel</span></code> 提供了一个简单的命令来快速生成身份验证所需的路由和视图：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>php artisan make:auth
</pre></div>
</div>
<p>该命令最好在新的应用下使用， <strong>它会生成布局、注册和登录视图以及所有的认证接口的路由。同时它还会生成 HomeController 来处理应用的登录请求。（不会生成auth目录下的其它控制器）</strong></p>
</div>
<div class="section" id="id5">
<h3>31.2.2. 视图<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal"><span class="pre">php</span> <span class="pre">artisan</span> <span class="pre">make:auth</span></code> 命令会在 <code class="docutils literal"><span class="pre">resources/views/auth</span></code> 目录创建所有认证需要的视图。</p>
<p>同时， <code class="docutils literal"><span class="pre">make:auth</span></code> 命令还创建了 <code class="docutils literal"><span class="pre">resources/views/layouts</span></code> 目录，该目录包含了应用的基本布局视图。所有这些视图都是用 <code class="docutils literal"><span class="pre">Bootstrap</span> <span class="pre">CSS</span></code> 框架，你也可以根据需要对其自定义。</p>
</div>
<div class="section" id="id6">
<h3>31.2.3. 注册和登陆<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<p>现在你已经为自带的认证控制器设置好了路由和视图，可以为应用注册和验证新用户了。你可以简单地在浏览器中访问应用，因为身份验证控制器已包含了（通过 traits）验证现有用户并将新用户存储在数据库中的逻辑了。</p>
<div class="section" id="id7">
<h4>31.2.3.1. 自定义路径<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h4>
<p>当用户成功通过身份认证后，他们会被重定向到 <code class="docutils literal"><span class="pre">/home</span> <span class="pre">URI</span></code> 。你可以通过在 <code class="docutils literal"><span class="pre">LoginController、RegisterController</span></code> 和 <code class="docutils literal"><span class="pre">ResetPasswordController</span></code> 中设置 <code class="docutils literal"><span class="pre">redirectTo</span></code> 属性来自定义重定向的位置：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">protected</span> <span class="nv">$redirectTo</span> <span class="o">=</span> <span class="s1">&#39;/&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>如果重定向路径需要自定义生成逻辑，你可以定义 <code class="docutils literal"><span class="pre">redirectTo</span></code> 方法来代替 <code class="docutils literal"><span class="pre">redirectTo</span></code> 属性：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">protected</span> <span class="k">function</span> <span class="nf">redirectTo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="s1">&#39;/path&#39;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last"><code class="docutils literal"><span class="pre">redirectTo</span></code> 方法优先于 <code class="docutils literal"><span class="pre">redirectTo</span></code> 属性。</p>
</div>
<p>该方法提供给 <code class="docutils literal"><span class="pre">Illuminate\Foundation\Auth\RedirectsUsers</span></code> 类中的 <code class="docutils literal"><span class="pre">redirectPath()</span></code> 方法调用。</p>
</div>
<div class="section" id="id8">
<h4>31.2.3.2. 自定义用户名<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">Laravel</span></code> 默认使用 <code class="docutils literal"><span class="pre">email</span></code> 字段来作为用户名进行认证。如果你想用其他字段认证，可以在 <code class="docutils literal"><span class="pre">LoginController</span></code> 里面定义一个 <code class="docutils literal"><span class="pre">username</span></code> 方法：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">username</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="s1">&#39;username&#39;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>该方法覆盖 <code class="docutils literal"><span class="pre">Illuminate\Foundation\Auth\AuthenticatesUsers</span></code> 类中的 <code class="docutils literal"><span class="pre">username()</span></code> 方法。</p>
</div>
<div class="section" id="id9">
<h4>31.2.3.3. 自定义看守器<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h4>
<p>你还可以自定义用于认证和注册用户的「看守器」。要实现这一功能，需要在 <code class="docutils literal"><span class="pre">LoginController、RegisterController</span></code> 和 <code class="docutils literal"><span class="pre">ResetPasswordController</span></code> 中定义 <code class="docutils literal"><span class="pre">guard</span></code> 方法。该方法需要返回一个看守器实例：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">use</span> <span class="nx">Illuminate\Support\Facades\Auth</span><span class="p">;</span>

<span class="k">protected</span> <span class="k">function</span> <span class="nf">guard</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nx">Auth</span><span class="o">::</span><span class="na">guard</span><span class="p">(</span><span class="s1">&#39;guard-name&#39;</span><span class="p">);</span> <span class="c1">// 调用\Illuminate\Auth\AuthManager中的guard()方法</span>
<span class="p">}</span>
</pre></div>
</div>
<p>该方法覆盖 <code class="docutils literal"><span class="pre">Illuminate\Foundation\Auth\AuthenticatesUsers</span></code> 类中的 <code class="docutils literal"><span class="pre">guard()</span></code> 方法。这里的 <code class="docutils literal"><span class="pre">Auth</span></code> 门面底层调用的是 <code class="docutils literal"><span class="pre">\Illuminate\Auth\AuthManager</span></code> 类。</p>
</div>
<div class="section" id="id10">
<h4>31.2.3.4. 自定义验证／存储<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h4>
<p>要修改新用户在应用注册时所需的表单字段，或者自定义如何将新用户存储到数据库中，你可以修改 <code class="docutils literal"><span class="pre">RegisterController</span></code> 类。该类负责验证和创建应用的新用户。</p>
<p><code class="docutils literal"><span class="pre">RegisterController</span></code> 的 <code class="docutils literal"><span class="pre">validator</span></code> 方法包含了应用验证新用户字段的规则，你可以按需要自定义该方法。</p>
<p><code class="docutils literal"><span class="pre">RegisterController</span></code> 的 <code class="docutils literal"><span class="pre">create</span></code> 方法负责使用 <code class="docutils literal"><span class="pre">Eloquent</span> <span class="pre">ORM</span></code> 在数据库中创建新的 <code class="docutils literal"><span class="pre">App\User</span></code> 记录。你可以根据数据库的需要自定义该方法。</p>
</div>
</div>
<div class="section" id="id11">
<h3>31.2.4. 检索认证用户<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h3>
<p>你可以通过 <code class="docutils literal"><span class="pre">Auth</span></code> 面板来访问认证的用户：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">use</span> <span class="nx">Illuminate\Support\Facades\Auth</span><span class="p">;</span>

<span class="c1">// 获取当前已认证的用户...</span>
<span class="nv">$user</span> <span class="o">=</span> <span class="nx">Auth</span><span class="o">::</span><span class="na">user</span><span class="p">();</span> <span class="c1">// 底层实际调用的是 \Illuminate\Contracts\Auth\Guard 接口的 user() 方法，即 \Illuminate\Auth\SessionGuard 对象的 user() 方法</span>

<span class="c1">// 获取当前已认证的用户 ID...</span>
<span class="nv">$id</span> <span class="o">=</span> <span class="nx">Auth</span><span class="o">::</span><span class="na">id</span><span class="p">();</span> <span class="c1">// 底层实际调用的是 \Illuminate\Contracts\Auth\Guard 接口的 id()方法，即 \Illuminate\Auth\SessionGuard 对象的 id() 方法</span>
</pre></div>
</div>
<p>或者，你还可以通过 <code class="docutils literal"><span class="pre">Illuminate\Http\Request</span></code> 实例来访问已认证的用户。请记住，类型提示的类会被自动注入到您的控制器方法中：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">namespace</span> <span class="nx">App\Http\Controllers</span><span class="p">;</span>

<span class="k">use</span> <span class="nx">Illuminate\Http\Request</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">ProfileController</span> <span class="k">extends</span> <span class="nx">Controller</span>
<span class="p">{</span>
    <span class="sd">/**</span>
<span class="sd">     * 更新用户的简介。</span>
<span class="sd">     *</span>
<span class="sd">     * @param  Request  $request</span>
<span class="sd">     * @return Response</span>
<span class="sd">     */</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">update</span><span class="p">(</span><span class="nx">Request</span> <span class="nv">$request</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">user</span><span class="p">()</span> <span class="c1">//返回已认证的用户的实例。这在\Illuminate\Auth\AuthServiceProvider的registerRequestRebindHandler方法中被传入</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="id12">
<h4>31.2.4.1. 确定当前用户是否认证<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h4>
<p>你可以使用 <code class="docutils literal"><span class="pre">Auth</span></code> 门面的 <code class="docutils literal"><span class="pre">check</span></code> 方法来检查用户是否登录，如果已经认证，将会返回 <code class="docutils literal"><span class="pre">true</span></code> ：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">use</span> <span class="nx">Illuminate\Support\Facades\Auth</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="nx">Auth</span><span class="o">::</span><span class="na">check</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// 底层实际调用的是 \Illuminate\Contracts\Auth\Guard 接口的 check() 方法，即 \Illuminate\Auth\SessionGuard 对象的 check() 方法</span>
    <span class="c1">// 用户已登录...</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">除了可以使用 <code class="docutils literal"><span class="pre">check</span></code> 方法确定用户是否被认证，在允许用户访问某些路由／控制器之前，通常还是会使用中间件来验证用户是否进行身份验证。</p>
</div>
</div>
</div>
<div class="section" id="id13">
<h3>31.2.5. 保护路由<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h3>
<p>路由中间件 用于只允许通过认证的用户访问指定的路由。 <code class="docutils literal"><span class="pre">Laravel</span></code> 自带了在 <code class="docutils literal"><span class="pre">Illuminate\Auth\Middleware\Authenticate</span></code> 中定义的 <code class="docutils literal"><span class="pre">auth</span></code> 中间件。由于这个中间件已经在 <code class="docutils literal"><span class="pre">HTTP</span></code> 内核中注册，所以只需要将中间件附加到路由定义中：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="nx">Route</span><span class="o">::</span><span class="na">get</span><span class="p">(</span><span class="s1">&#39;profile&#39;</span><span class="p">,</span> <span class="k">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 只有认证过的用户可以...</span>
<span class="p">})</span><span class="o">-&gt;</span><span class="na">middleware</span><span class="p">(</span><span class="s1">&#39;auth&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>当然，如果使用 控制器，则可以在构造器中调用 <code class="docutils literal"><span class="pre">middleware</span></code> 方法来代替在路由中直接定义：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">public</span> <span class="k">function</span> <span class="fm">__construct</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">middleware</span><span class="p">(</span><span class="s1">&#39;auth&#39;</span><span class="p">);</span> <span class="c1">// 当前控制器所有方法都需要认证</span>
<span class="p">}</span>
</pre></div>
</div>
<p>该中间件位于 <code class="docutils literal"><span class="pre">\Illuminate\Auth\Middleware\Authenticate</span></code> 文件中。</p>
<div class="section" id="id14">
<h4>31.2.5.1. 指定看守器<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h4>
<p>将 <code class="docutils literal"><span class="pre">auth</span></code> 中间件添加到路由时，还需要指定使用哪个看守器来认证用户。指定的看守器对应配置文件 <code class="docutils literal"><span class="pre">auth.php</span></code> 中 <code class="docutils literal"><span class="pre">guards</span></code> 数组的某个键：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="nx">Route</span><span class="o">::</span><span class="na">get</span><span class="p">(</span><span class="s1">&#39;profile&#39;</span><span class="p">,</span> <span class="k">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 只有认证过的用户可以...</span>
<span class="p">})</span><span class="o">-&gt;</span><span class="na">middleware</span><span class="p">(</span><span class="s1">&#39;auth:api&#39;</span><span class="p">);</span>

<span class="k">public</span> <span class="k">function</span> <span class="fm">__construct</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">middleware</span><span class="p">(</span><span class="s1">&#39;auth:api&#39;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id15">
<h3>31.2.6. 登录限制<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal"><span class="pre">Laravel</span></code> 内置的控制器 <code class="docutils literal"><span class="pre">LoginController</span></code> 已经包含了 <code class="docutils literal"><span class="pre">Illuminate\Foundation\Auth\ThrottlesLogins</span> <span class="pre">trait</span></code> 。默认情况下，如果用户在进行几次尝试后仍不能提供正确的凭证，该用户将在一分钟内无法进行登录。这个限制基于用户的用户名／邮件地址和 <code class="docutils literal"><span class="pre">IP</span></code> 地址。</p>
</div>
</div>
<div class="section" id="id16">
<h2>31.3. 手动认证用户<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h2>
<div class="section" id="id17">
<h3>31.3.1. 自定义控制器<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h3>
<p>当然，不一定要使用 <code class="docutils literal"><span class="pre">Laravel</span></code> 内置的认证控制器。如果选择删除这些控制器，你可以直接调用 <code class="docutils literal"><span class="pre">Laravel</span></code> 的认证类来管理用户认证。别担心，这简单得很。</p>
<p>我们可以通过 <code class="docutils literal"><span class="pre">Auth</span></code> 门面来访问 <code class="docutils literal"><span class="pre">Laravel</span></code> 的认证服务，因此需要确认类的顶部引入了 <code class="docutils literal"><span class="pre">Auth</span></code> 门面。接下来让我们看一下 <code class="docutils literal"><span class="pre">attempt</span></code> 方法：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">namespace</span> <span class="nx">App\Http\Controllers</span><span class="p">;</span>

<span class="k">use</span> <span class="nx">Illuminate\Support\Facades\Auth</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">LoginController</span> <span class="k">extends</span> <span class="nx">Controller</span>
<span class="p">{</span>
    <span class="sd">/**</span>
<span class="sd">     * 处理身份认证尝试.</span>
<span class="sd">     *</span>
<span class="sd">     * @return Response</span>
<span class="sd">     */</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">authenticate</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">Auth</span><span class="o">::</span><span class="na">attempt</span><span class="p">([</span><span class="s1">&#39;email&#39;</span> <span class="o">=&gt;</span> <span class="nv">$email</span><span class="p">,</span> <span class="s1">&#39;password&#39;</span> <span class="o">=&gt;</span> <span class="nv">$password</span><span class="p">]))</span> <span class="p">{</span>
            <span class="c1">// 认证通过...</span>
            <span class="k">return</span> <span class="nx">redirect</span><span class="p">()</span><span class="o">-&gt;</span><span class="na">intended</span><span class="p">(</span><span class="s1">&#39;dashboard&#39;</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">attempt</span></code> 方法会接受一个键值对数组作为其第一个参数。这个数组的值将用来在数据库表中查找用户。所以在上面的例子中，用户将被 <code class="docutils literal"><span class="pre">email</span></code> 字段的值检索。如果用户被找到了，数据库中存储的散列密码将与通过数组传递给方法的散列 <code class="docutils literal"><span class="pre">password</span></code> 进行比较。 如果两个散列密码匹配，就会为用户启动一个已认证的会话。</p>
<p>如果认证成功， <code class="docutils literal"><span class="pre">attempt</span></code> 方法将返回 <code class="docutils literal"><span class="pre">true</span></code> ，反之则返回 <code class="docutils literal"><span class="pre">false</span></code> 。</p>
<p>在身份验证中间件拦截之前，重定向器上的 <code class="docutils literal"><span class="pre">intended</span></code> 方法将重定向到用户尝试访问的 <code class="docutils literal"><span class="pre">URL</span></code> 。如果该 <code class="docutils literal"><span class="pre">URL</span></code> 无效，会给该方法传递回退 <code class="docutils literal"><span class="pre">URI</span></code> 。</p>
<div class="section" id="id18">
<h4>31.3.1.1. 指定额外条件<a class="headerlink" href="#id18" title="永久链接至标题">¶</a></h4>
<p>除了用户的电子邮件和密码之外，你还可以向身份验证查询添加额外的条件。例如，我们可能会验证用户是否被标记为「活动」状态：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">Auth</span><span class="o">::</span><span class="na">attempt</span><span class="p">([</span><span class="s1">&#39;email&#39;</span> <span class="o">=&gt;</span> <span class="nv">$email</span><span class="p">,</span> <span class="s1">&#39;password&#39;</span> <span class="o">=&gt;</span> <span class="nv">$password</span><span class="p">,</span> <span class="s1">&#39;active&#39;</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">]))</span> <span class="p">{</span>
    <span class="c1">// 用户处于活动状态，不被暂停，并且存在。</span>
<span class="p">}</span>
</pre></div>
</div>
<p>底层实际调用的是 <code class="docutils literal"><span class="pre">\Illuminate\Contracts\Auth\UserProvider</span></code> 接口的 <code class="docutils literal"><span class="pre">retrieveByCredentials()</span></code> 方法，即 <code class="docutils literal"><span class="pre">\Illuminate\Auth\DatabaseUserProvider</span></code> 对象的 <code class="docutils literal"><span class="pre">retrieveByCredentials()</span></code> 方法。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">在这些例子中， <code class="docutils literal"><span class="pre">email</span></code> 不是必需的选项，仅作为示例使用。你应该使用与数据库中的「用户名」对应的任何字段的名称。</p>
</div>
</div>
<div class="section" id="id19">
<h4>31.3.1.2. 访问指定的看守器实例<a class="headerlink" href="#id19" title="永久链接至标题">¶</a></h4>
<p>可以通过 <code class="docutils literal"><span class="pre">Auth</span></code> 门面的 <code class="docutils literal"><span class="pre">guard</span></code> 方法来指定要使用哪个看守器实例。这允许你使用完全独立的可认证模型或用户表来管理应用的抽离出来的身份验证。</p>
<p>传递给 <code class="docutils literal"><span class="pre">guard</span></code> 方法的看守器名称应该与 <code class="docutils literal"><span class="pre">auth.php</span></code> 配置文件中 <code class="docutils literal"><span class="pre">guards</span></code> 中的其中一个值相对应：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">Auth</span><span class="o">::</span><span class="na">guard</span><span class="p">(</span><span class="s1">&#39;admin&#39;</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">attempt</span><span class="p">(</span><span class="nv">$credentials</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">//</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id20">
<h4>31.3.1.3. 注销用户<a class="headerlink" href="#id20" title="永久链接至标题">¶</a></h4>
<p>要让用户从应用中注销，可以在 <code class="docutils literal"><span class="pre">Auth</span></code> 门面上使用 <code class="docutils literal"><span class="pre">logout</span></code> 方法。这会清除用户会话中的身份验证信息：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="nx">Auth</span><span class="o">::</span><span class="na">logout</span><span class="p">();</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id21">
<h3>31.3.2. 记住用户<a class="headerlink" href="#id21" title="永久链接至标题">¶</a></h3>
<p>如果你想要在应用中提供「记住我」的功能 ， 则可以传递一个布尔值作为 <code class="docutils literal"><span class="pre">attempt</span></code>  方法的第二个参数，这会使在用户手动注销前一直保持已验证状态。当然， <code class="docutils literal"><span class="pre">users</span></code>  数据表必须包含 <code class="docutils literal"><span class="pre">remember_token</span></code> 字段，这是用来保存「记住我」的令牌。本质就是通过该字段来检索用户信息。</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">if</span> <span class="p">(</span> <span class="nx">Auth</span><span class="o">::</span><span class="na">attempt</span><span class="p">([</span> <span class="s1">&#39;email&#39;</span> <span class="o">=&gt;</span> <span class="nv">$email</span><span class="p">,</span> <span class="s1">&#39;password&#39;</span> <span class="o">=&gt;</span> <span class="nv">$password</span><span class="p">],</span> <span class="nv">$remember</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// 这个用户被记住了...</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">如果你使用 <code class="docutils literal"><span class="pre">Laravel</span></code> 内置的 <code class="docutils literal"><span class="pre">LoginController</span></code> ，则「记住」用户的逻辑已经由控制器使用的 <code class="docutils literal"><span class="pre">traits</span></code> 来实现。</p>
</div>
<p>如果你「记住」用户，可以使用 <code class="docutils literal"><span class="pre">viaRemember</span></code> 方法来检查这个用户是否使用「记住我」`` cookie`` 进行认证：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">Auth</span><span class="o">::</span><span class="na">viaRemember</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">//</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id22">
<h3>31.3.3. 其它认证方法<a class="headerlink" href="#id22" title="永久链接至标题">¶</a></h3>
<div class="section" id="id23">
<h4>31.3.3.1. 验证用户实例<a class="headerlink" href="#id23" title="永久链接至标题">¶</a></h4>
<p>如果需要将现有用户实例记录到应用，可以使用用户实例调用 <code class="docutils literal"><span class="pre">login</span></code> 方法。给定的对象必须实现了 <code class="docutils literal"><span class="pre">Illuminate\Contracts\Auth\Authenticatable</span></code> 契约 。当然， <code class="docutils literal"><span class="pre">Laravel</span></code> 自带的 <code class="docutils literal"><span class="pre">App\User</span></code> 模型已经实现了这个接口：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="nx">Auth</span><span class="o">::</span><span class="na">login</span><span class="p">(</span><span class="nv">$user</span><span class="p">);</span> <span class="c1">// 这里是切换用户</span>

<span class="c1">// 登录并且「记住」给定用户...</span>
<span class="nx">Auth</span><span class="o">::</span><span class="na">login</span><span class="p">(</span><span class="nv">$user</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>
</pre></div>
</div>
<p>该方法调用的是 <code class="docutils literal"><span class="pre">Illuminate\Auth\SessionGuard</span></code> 类中的 <code class="docutils literal"><span class="pre">login()</span></code> 方法。</p>
<p>当然，你也可以指定要使用的看守器实例：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="nx">Auth</span><span class="o">::</span><span class="na">guard</span><span class="p">(</span><span class="s1">&#39;admin&#39;</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">login</span><span class="p">(</span><span class="nv">$user</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="id">
<h4>31.3.3.2. 通过 ID 验证用户<a class="headerlink" href="#id" title="永久链接至标题">¶</a></h4>
<p>你可以使用 <code class="docutils literal"><span class="pre">loginUsingId</span></code> 方法通过其 <code class="docutils literal"><span class="pre">ID</span></code> 将用户记录到应用中。这个方法只接受要验证的用户的主键：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="nx">Auth</span><span class="o">::</span><span class="na">loginUsingId</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="c1">//登录并且「记住」给定的用户...</span>
<span class="nx">Auth</span><span class="o">::</span><span class="na">loginUsingId</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">loginUsingId</span></code> 函数内部调用 <code class="docutils literal"><span class="pre">login()</span></code> 函数来登陆。</p>
</div>
<div class="section" id="id24">
<h4>31.3.3.3. 仅验证用户一次<a class="headerlink" href="#id24" title="永久链接至标题">¶</a></h4>
<p>你可以使用 <code class="docutils literal"><span class="pre">once</span></code> 方法将用户记录到单个请求的应用中。不会使用任何会话或 <code class="docutils literal"><span class="pre">cookies</span></code> ， 这个对于构建无状态的 <code class="docutils literal"><span class="pre">API</span></code> 非常的有用：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">Auth</span><span class="o">::</span><span class="na">once</span><span class="p">(</span><span class="nv">$credentials</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">//</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="http">
<h2>31.4. HTTP 基础认证<a class="headerlink" href="#http" title="永久链接至标题">¶</a></h2>
<p>HTTP 基础认证 提供一种快速方式来认证应用的用户，而且不需要设置专用的「登录」页面。开始之前，先把 <code class="docutils literal"><span class="pre">auth.basic</span></code> 中间件 添加到你的路由。 <code class="docutils literal"><span class="pre">auth.basic</span></code> 中间件已经被包含在 <code class="docutils literal"><span class="pre">Laravel</span></code> 框架中，所以你不需要定义它：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="nx">Route</span><span class="o">::</span><span class="na">get</span><span class="p">(</span><span class="s1">&#39;profile&#39;</span><span class="p">,</span> <span class="k">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 只有认证过的用户可进入...</span>
<span class="p">})</span><span class="o">-&gt;</span><span class="na">middleware</span><span class="p">(</span><span class="s1">&#39;auth.basic&#39;</span><span class="p">);</span> <span class="c1">// 通过basic中间件来认证用户</span>
</pre></div>
</div>
<p>中间件被增加到路由后，在浏览器中访问路由时，将自动提示你输入凭证。默认情况下， <code class="docutils literal"><span class="pre">auth.basic</span></code> 中间件将会使用用户记录上的 <code class="docutils literal"><span class="pre">email</span></code> 字段作为「用户名」。</p>
<div class="section" id="fastcgi">
<h3>31.4.1. FastCGI 的注意事项<a class="headerlink" href="#fastcgi" title="永久链接至标题">¶</a></h3>
<p>如果使用了 <code class="docutils literal"><span class="pre">PHP</span> <span class="pre">FastCGI</span></code> ， <code class="docutils literal"><span class="pre">HTTP</span></code> 基础认证可能无法正常工作。你需要将下面这几行加入你 <code class="docutils literal"><span class="pre">.htaccess</span></code> 文件中:</p>
<div class="highlight-php"><div class="highlight"><pre><span></span>&lt;?php
RewriteCond %{HTTP:Authorization} ^(.+)$
RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]
</pre></div>
</div>
</div>
<div class="section" id="id25">
<h3>31.4.2. 无状态 HTTP 基础认证<a class="headerlink" href="#id25" title="永久链接至标题">¶</a></h3>
<p>你可以使用 <code class="docutils literal"><span class="pre">HTTP</span></code> 基础认证，而不在会话中设置用户标识符 <code class="docutils literal"><span class="pre">cookie</span></code> ，这对于 <code class="docutils literal"><span class="pre">API</span></code> 认证来说特别有用。为此，请定义一个中间件并调用 <code class="docutils literal"><span class="pre">onceBasic</span></code> 方法。如果 <code class="docutils literal"><span class="pre">onceBasic</span></code> 方法没有返回任何响应的话，这个请求可以进一步传递到应用程序中：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">namespace</span> <span class="nx">Illuminate\Auth\Middleware</span><span class="p">;</span>

<span class="k">use</span> <span class="nx">Illuminate\Support\Facades\Auth</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">AuthenticateOnceWithBasicAuth</span>
<span class="p">{</span>
    <span class="sd">/**</span>
<span class="sd">     * 处理传入的请求。</span>
<span class="sd">     *</span>
<span class="sd">     * @param  \Illuminate\Http\Request  $request</span>
<span class="sd">     * @param  \Closure  $next</span>
<span class="sd">     * @return mixed</span>
<span class="sd">     */</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">handle</span><span class="p">(</span><span class="nv">$request</span><span class="p">,</span> <span class="nv">$next</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nx">Auth</span><span class="o">::</span><span class="na">onceBasic</span><span class="p">()</span> <span class="o">?:</span> <span class="nv">$next</span><span class="p">(</span><span class="nv">$request</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>接着，注册路由中间件 ，然后将它附加到路由：</p>
<div class="highlight-language"><div class="highlight"><pre><span></span>protected $routeMiddleware = [
    &#39;auth&#39; =&gt; \Illuminate\Auth\Middleware\Authenticate::class,
    &#39;auth.basic&#39; =&gt; \Illuminate\Auth\Middleware\AuthenticateWithBasicAuth::class,
    &#39;bindings&#39; =&gt; \Illuminate\Routing\Middleware\SubstituteBindings::class,
    &#39;can&#39; =&gt; \Illuminate\Auth\Middleware\Authorize::class,
    &#39;guest&#39; =&gt; \App\Http\Middleware\RedirectIfAuthenticated::class,
    &#39;throttle&#39; =&gt; \Illuminate\Routing\Middleware\ThrottleRequests::class,
    &#39;auth.basic.once&#39; =&gt; Illuminate\Auth\Middleware\AuthenticateOnceWithBasicAuth::class
];

Route::get(&#39;api/user&#39;, function () {
    // 只有认证过的用户可以进入...
})-&gt;middleware(&#39;auth.basic.once&#39;);
</pre></div>
</div>
</div>
</div>
<div class="section" id="id26">
<h2>31.5. 社交认证<a class="headerlink" href="#id26" title="永久链接至标题">¶</a></h2>
</div>
<div class="section" id="id27">
<h2>31.6. 增加自定义看守器<a class="headerlink" href="#id27" title="永久链接至标题">¶</a></h2>
<div class="section" id="guard">
<h3>31.6.1. Guard 接口<a class="headerlink" href="#guard" title="永久链接至标题">¶</a></h3>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="nx">Illuminate\Contracts\Auth\Guard</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">Guard</span></code> 接口定义了某个实现了 <code class="docutils literal"><span class="pre">Authenticatable</span></code>  (可认证的) 模型或类的认证方法以及一些常用的接口。</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="c1">// 判断当前用户是否登录</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">check</span><span class="p">();</span>
<span class="c1">// 判断当前用户是否是游客（未登录）</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">guest</span><span class="p">();</span>
<span class="c1">// 获取当前认证的用户</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">user</span><span class="p">();</span>
<span class="c1">// 获取当前认证用户的 id，严格来说不一定是 id，应该是上个模型中定义的唯一的字段值</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">id</span><span class="p">();</span>
<span class="c1">// 根据提供的凭证认证用户</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">validate</span><span class="p">(</span><span class="k">array</span> <span class="nv">$credentials</span> <span class="o">=</span> <span class="p">[]);</span>
<span class="c1">// 设置当前用户</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">setUser</span><span class="p">(</span><span class="nx">Authenticatable</span> <span class="nv">$user</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="statefulguard">
<h3>31.6.2. StatefulGuard 接口<a class="headerlink" href="#statefulguard" title="永久链接至标题">¶</a></h3>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="nx">Illuminate\Contracts\Auth\StatefulGuard</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">StatefulGuard</span></code> 接口继承自 <code class="docutils literal"><span class="pre">Guard</span></code> 接口，除了 <code class="docutils literal"><span class="pre">Guard</span></code> 里面定义的一些基本接口外，还增加了更进一步、有状态的 <code class="docutils literal"><span class="pre">Guard</span></code> .</p>
<p>新添加的接口有这些：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="c1">// 尝试根据提供的凭证验证用户是否合法</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">attempt</span><span class="p">(</span><span class="k">array</span> <span class="nv">$credentials</span> <span class="o">=</span> <span class="p">[],</span> <span class="nv">$remember</span> <span class="o">=</span> <span class="k">false</span><span class="p">);</span>
<span class="c1">// 一次性登录，不记录session or cookie</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">once</span><span class="p">(</span><span class="k">array</span> <span class="nv">$credentials</span> <span class="o">=</span> <span class="p">[]);</span>
<span class="c1">// 登录用户，通常在验证成功后记录 session 和 cookie</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">login</span><span class="p">(</span><span class="nx">Authenticatable</span> <span class="nv">$user</span><span class="p">,</span> <span class="nv">$remember</span> <span class="o">=</span> <span class="k">false</span><span class="p">);</span>
<span class="c1">// 使用用户 id 登录，内部调用上面的login()</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">loginUsingId</span><span class="p">(</span><span class="nv">$id</span><span class="p">,</span> <span class="nv">$remember</span> <span class="o">=</span> <span class="k">false</span><span class="p">);</span>
<span class="c1">// 使用用户 ID 登录，但是不记录 session 和 cookie，内部调用前面的once()</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">onceUsingId</span><span class="p">(</span><span class="nv">$id</span><span class="p">);</span>
<span class="c1">// 通过 cookie 中的 remember token 自动登录</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">viaRemember</span><span class="p">();</span>
<span class="c1">// 登出</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">logout</span><span class="p">();</span>
</pre></div>
</div>
<p><strong>Laravel 中默认提供了 3 中 guard：RequestGuard，TokenGuard，SessionGuard</strong> ：</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">Illuminate\Auth\RequestGuard</span></code> RequestGuard 是一个非常简单的 guard。RequestGuard 是通过传入一个闭包来认证的。可以通过调用 <code class="docutils literal"><span class="pre">Auth::viaRequest</span></code> 添加一个自定义的 RequestGuard 。</li>
<li><code class="docutils literal"><span class="pre">Illuminate\Auth\SessionGuard</span></code> SessionGuard 是 Laravel web 认证默认的 guard 。</li>
<li><code class="docutils literal"><span class="pre">Illuminate\Auth\TokenGuard</span></code> TokenGuard 适用于无状态 api 认证，通过 token 认证。</li>
</ul>
<p>你可以使用 <code class="docutils literal"><span class="pre">Auth</span></code> 门面的 <code class="docutils literal"><span class="pre">extend</span></code> 方法来定义自己的身份验证提供器(守护器)。 你需要在 服务提供器 中调用这个提供器。由于 <code class="docutils literal"><span class="pre">Laravel</span></code> 已经配备了 <code class="docutils literal"><span class="pre">AuthServiceProvider</span></code> ，我们可以把代码放在这个提供器中：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">namespace</span> <span class="nx">App\Providers</span><span class="p">;</span>

<span class="k">use</span> <span class="nx">App\Services\Auth\JwtGuard</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Illuminate\Support\Facades\Auth</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Illuminate\Foundation\Support\Providers\AuthServiceProvider</span> <span class="k">as</span> <span class="nx">ServiceProvider</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">AuthServiceProvider</span> <span class="k">extends</span> <span class="nx">ServiceProvider</span>
<span class="p">{</span>
    <span class="sd">/**</span>
<span class="sd">     * 注册任意应用认证／授权服务。</span>
<span class="sd">     *</span>
<span class="sd">     * @return void</span>
<span class="sd">     */</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">boot</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">registerPolicies</span><span class="p">();</span>

        <span class="nx">Auth</span><span class="o">::</span><span class="na">extend</span><span class="p">(</span><span class="s1">&#39;jwt&#39;</span><span class="p">,</span> <span class="k">function</span> <span class="p">(</span><span class="nv">$app</span><span class="p">,</span> <span class="nv">$name</span><span class="p">,</span> <span class="k">array</span> <span class="nv">$config</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 返回一个 Illuminate\Contracts\Auth\Guard 实例...</span>

            <span class="k">return</span> <span class="k">new</span> <span class="nx">JwtGuard</span><span class="p">(</span><span class="nx">Auth</span><span class="o">::</span><span class="na">createUserProvider</span><span class="p">(</span><span class="nv">$config</span><span class="p">[</span><span class="s1">&#39;provider&#39;</span><span class="p">]));</span>
        <span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>正如上面的代码所示，传递给 <code class="docutils literal"><span class="pre">extend</span></code> 方法的回调应该返回 <code class="docutils literal"><span class="pre">Illuminate\Contracts\Auth\Guard</span></code> 的实现的实例。 这个接口包含你需要实现的方法来定义一个自定义看守器。定义完之后，你可以在 <code class="docutils literal"><span class="pre">auth.php</span></code> 配置文件的 <code class="docutils literal"><span class="pre">guards</span></code> 配置中使用这个看守器：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="s1">&#39;guards&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span>
    <span class="s1">&#39;api&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span>
        <span class="s1">&#39;driver&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;jwt&#39;</span><span class="p">,</span>
        <span class="s1">&#39;provider&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;users&#39;</span><span class="p">,</span>
    <span class="p">],</span>
<span class="p">],</span>
</pre></div>
</div>
<div class="section" id="id28">
<h4>31.6.2.1. 请求闭包看守器<a class="headerlink" href="#id28" title="永久链接至标题">¶</a></h4>
<p>一个最简的，基于 HTTP 请求的认证方案是使用 <code class="docutils literal"><span class="pre">Auth::viaRequest</span></code> 方法，此方法允许你使用闭包来快速定义一个看守器。</p>
<p>首先你需要在 <code class="docutils literal"><span class="pre">AuthServiceProvider</span></code> 的 <code class="docutils literal"><span class="pre">boot</span></code> 方法里调用 <code class="docutils literal"><span class="pre">Auth::viaRequest</span></code> ，这个 <code class="docutils literal"><span class="pre">viaRequest</span></code> 方法接受一个看守器名称为第一参数，看守器名称是有字符串组成的自定义名称。第二个参数是一个闭包函数，此函数接受一个 HTTP 请求实例，成功授权后返回一个用户实例，授权失败后返回 <code class="docutils literal"><span class="pre">null</span></code> :</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">use</span> <span class="nx">App\User</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Illuminate\Http\Request</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Illuminate\Support\Facades\Auth</span><span class="p">;</span>

<span class="sd">/**</span>
<span class="sd"> * 注册所有的应用授权服务</span>
<span class="sd"> *</span>
<span class="sd"> * @return void</span>
<span class="sd"> */</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">boot</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">registerPolicies</span><span class="p">();</span>

    <span class="nx">Auth</span><span class="o">::</span><span class="na">viaRequest</span><span class="p">(</span><span class="s1">&#39;custom-token&#39;</span><span class="p">,</span> <span class="k">function</span> <span class="p">(</span><span class="nv">$request</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">User</span><span class="o">::</span><span class="na">where</span><span class="p">(</span><span class="s1">&#39;token&#39;</span><span class="p">,</span> <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">token</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">first</span><span class="p">();</span>
    <span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
<p>成功定义看守器以后，你可以在 <code class="docutils literal"><span class="pre">auth.php</span></code> 里的 <code class="docutils literal"><span class="pre">guards</span></code> 选项中使用：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="s1">&#39;guards&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span>
    <span class="s1">&#39;api&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span>
        <span class="s1">&#39;driver&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;custom-token&#39;</span><span class="p">,</span>
    <span class="p">],</span>
<span class="p">],</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id29">
<h2>31.7. 增加自定义用户提供器<a class="headerlink" href="#id29" title="永久链接至标题">¶</a></h2>
<p>如果你没有使用传统的关系型数据库来存储用户信息，则需要使用自己的用户认证提供器来扩展 <code class="docutils literal"><span class="pre">Laravel</span></code> 。我们使用 <code class="docutils literal"><span class="pre">Auth</span></code> 门面上的 <code class="docutils literal"><span class="pre">provider</span></code> 方法定义自定义用户提供器：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">namespace</span> <span class="nx">App\Providers</span><span class="p">;</span>

<span class="k">use</span> <span class="nx">Illuminate\Support\Facades\Auth</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">App\Extensions\RiakUserProvider</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Illuminate\Foundation\Support\Providers\AuthServiceProvider</span> <span class="k">as</span> <span class="nx">ServiceProvider</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">AuthServiceProvider</span> <span class="k">extends</span> <span class="nx">ServiceProvider</span>
<span class="p">{</span>
    <span class="sd">/**</span>
<span class="sd">     * 注册任何应用认证／授权服务。</span>
<span class="sd">     *</span>
<span class="sd">     * @return void</span>
<span class="sd">     */</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">boot</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">registerPolicies</span><span class="p">();</span>

        <span class="nx">Auth</span><span class="o">::</span><span class="na">provider</span><span class="p">(</span><span class="s1">&#39;riak&#39;</span><span class="p">,</span> <span class="k">function</span> <span class="p">(</span><span class="nv">$app</span><span class="p">,</span> <span class="k">array</span> <span class="nv">$config</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 返回 Illuminate\Contracts\Auth\UserProvider 实例...</span>

            <span class="k">return</span> <span class="k">new</span> <span class="nx">RiakUserProvider</span><span class="p">(</span><span class="nv">$app</span><span class="o">-&gt;</span><span class="na">make</span><span class="p">(</span><span class="s1">&#39;riak.connection&#39;</span><span class="p">));</span>
        <span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>使用 <code class="docutils literal"><span class="pre">provider</span></code> 方法注册用户提供器后，你可以在配置文件 <code class="docutils literal"><span class="pre">auth.php</span></code> 中切换到新的用户提供器。首先，定义一个使用新驱动的 <code class="docutils literal"><span class="pre">provider</span></code> ：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="s1">&#39;providers&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span>
    <span class="s1">&#39;users&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span>
        <span class="s1">&#39;driver&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;riak&#39;</span><span class="p">,</span>
    <span class="p">],</span>
<span class="p">],</span>
</pre></div>
</div>
<p>最后，你可以在 <code class="docutils literal"><span class="pre">guards</span></code> 配置中使用这个提供器：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="s1">&#39;guards&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span>
    <span class="s1">&#39;web&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span>
        <span class="s1">&#39;driver&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;session&#39;</span><span class="p">,</span>
        <span class="s1">&#39;provider&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;users&#39;</span><span class="p">,</span>
    <span class="p">],</span>
<span class="p">],</span>
</pre></div>
</div>
<div class="section" id="id30">
<h3>31.7.1. 用户提供器契约<a class="headerlink" href="#id30" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal"><span class="pre">Illuminate\Contracts\Auth\UserProvider</span></code> 的实现只负责从永久存储系统（如 <code class="docutils literal"><span class="pre">MySQL、Riak</span></code> 等）中获取 <code class="docutils literal"><span class="pre">Illuminate\Contracts\Auth\Authenticatable</span></code> 的实现实例。这两个接口允许 <code class="docutils literal"><span class="pre">Laravel</span></code> 认证机制继续运行，无论用户数据如何被存储或使用什么类型的类实现它。</p>
<p><code class="docutils literal"><span class="pre">UserProvider</span></code> 接口定义了获取认证模型的方法，比如根据 <code class="docutils literal"><span class="pre">id</span></code> 获取模型，根据 <code class="docutils literal"><span class="pre">email</span></code> 获取模型等等。</p>
<p>让我们来看看 <code class="docutils literal"><span class="pre">Illuminate\Contracts\Auth\UserProvider</span></code> 契约：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">interface</span> <span class="nx">UserProvider</span> <span class="p">{</span>

    <span class="c1">// 通过唯一标示符获取认证模型</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">retrieveById</span><span class="p">(</span><span class="nv">$identifier</span><span class="p">);</span>
    <span class="c1">// 通过唯一标示符和 remember token 获取模型</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">retrieveByToken</span><span class="p">(</span><span class="nv">$identifier</span><span class="p">,</span> <span class="nv">$token</span><span class="p">);</span>
    <span class="c1">// 通过给定的认证模型更新 remember token</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">updateRememberToken</span><span class="p">(</span><span class="nx">Authenticatable</span> <span class="nv">$user</span><span class="p">,</span> <span class="nv">$token</span><span class="p">);</span>
    <span class="c1">// 通过给定的凭证获取用户，比如 email 或用户名等等</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">retrieveByCredentials</span><span class="p">(</span><span class="k">array</span> <span class="nv">$credentials</span><span class="p">);</span>
    <span class="c1">// 认证给定的用户和给定的凭证是否符合</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">validateCredentials</span><span class="p">(</span><span class="nx">Authenticatable</span> <span class="nv">$user</span><span class="p">,</span> <span class="k">array</span> <span class="nv">$credentials</span><span class="p">);</span>

<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">retrieveById</span></code> 函数通常接收代表用户的键，例如 <code class="docutils literal"><span class="pre">MySQL</span></code> 数据库中自增的 <code class="docutils literal"><span class="pre">ID</span></code> 。应该通过该方法检索和返回与 <code class="docutils literal"><span class="pre">ID</span></code> 匹配的 <code class="docutils literal"><span class="pre">Authenticatable</span></code> 的实现实例。</li>
<li><code class="docutils literal"><span class="pre">retrieveByToken</span></code> 函数通过其唯一的 <code class="docutils literal"><span class="pre">$identifier</span></code> 和存储在 remember_token 字段中的「记住我」 <code class="docutils literal"><span class="pre">$token</span></code> 来检索一个用户 。与以前的方法一样，应该返回 <code class="docutils literal"><span class="pre">Authenticatable</span></code> 实现的实例。</li>
<li><code class="docutils literal"><span class="pre">updateRememberToken</span></code> 方法使用新的 <code class="docutils literal"><span class="pre">$token</span></code> 更新了 <code class="docutils literal"><span class="pre">$user</span></code> 的 <code class="docutils literal"><span class="pre">remember_token</span></code> 字段。当使用「记住我」尝试登录成功时，或用户登出时，可以更新该令牌。</li>
<li>在尝试登录应用程序时，<code class="docutils literal"><span class="pre">retrieveByCredentials</span></code> 方法接收传递给 <code class="docutils literal"><span class="pre">Auth::attempt</span></code> 方法的凭据数组。然后该方法将「查询」底层持久存储匹配用户的这些凭据。通常，此方法会在 <code class="docutils literal"><span class="pre">$credentials['username']</span></code> 上运行「where」条件的查询。这个方法应该需要返回 <code class="docutils literal"><span class="pre">Authenticatable</span></code> 的实现的实例。此方法不应该尝试任何密码验证或认证。</li>
<li><code class="docutils literal"><span class="pre">validateCredentials</span></code> 方法将给定的 <code class="docutils literal"><span class="pre">$user</span></code> 和 <code class="docutils literal"><span class="pre">$credentials</span></code> 进行匹配，以此来验证用户。例如，这个方法可以使用 <code class="docutils literal"><span class="pre">Hash::check</span></code> 比较 <code class="docutils literal"><span class="pre">$user-&gt;getAuthPassword()</span></code> 和 <code class="docutils literal"><span class="pre">$credentials['password']</span></code> 的值。此方法通过返回 <code class="docutils literal"><span class="pre">true</span></code> 或 <code class="docutils literal"><span class="pre">false</span></code> 来显示密码是否有效。</li>
</ul>
<p><code class="docutils literal"><span class="pre">Laravel</span></code> 中默认有两个 <code class="docutils literal"><span class="pre">user</span> <span class="pre">provider:</span> <span class="pre">DatabaseUserProvider</span> <span class="pre">&amp;</span> <span class="pre">EloquentUserProvider</span></code> ：</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">Illuminate\Auth\DatabaseUserProvider</span></code> 直接通过数据库表来获取认证模型；</li>
<li><code class="docutils literal"><span class="pre">Illuminate\Auth\EloquentUserProvider</span></code> 通过 <code class="docutils literal"><span class="pre">eloquent</span></code> 模型来获取认证模型；</li>
</ul>
</div>
<div class="section" id="id31">
<h3>31.7.2. 认证契约<a class="headerlink" href="#id31" title="永久链接至标题">¶</a></h3>
<p>现在我们已经探讨了 <code class="docutils literal"><span class="pre">UserProvider</span></code> 中的每个方法，让我们来看看 <code class="docutils literal"><span class="pre">Authenticatable</span></code> 契约。记住，提供器需要从 <code class="docutils literal"><span class="pre">retrieveById</span></code> 和 <code class="docutils literal"><span class="pre">retrieveByCredentials</span></code> 方法来返回这个接口的实现：</p>
<p><code class="docutils literal"><span class="pre">Authenticatable</span></code> 定义了一个可以被用来认证的模型或类需要实现的接口，也就是说，如果需要用一个自定义的类来做认证，需要实现这个接口定义的方法。</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">interface</span> <span class="nx">Authenticatable</span> <span class="p">{</span>

    <span class="c1">// 获取唯一标识的，可以用来认证的字段名，比如 id，uuid</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">getAuthIdentifierName</span><span class="p">();</span>
    <span class="c1">// 获取该标示符对应的值</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">getAuthIdentifier</span><span class="p">();</span>
    <span class="c1">// 获取认证的密码</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">getAuthPassword</span><span class="p">();</span>
    <span class="c1">// 获取remember token</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">getRememberToken</span><span class="p">();</span>
    <span class="c1">// 设置 remember token</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">setRememberToken</span><span class="p">(</span><span class="nv">$value</span><span class="p">);</span>
    <span class="c1">// 获取 remember token 对应的字段名，比如默认的 &#39;remember_token&#39;</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">getRememberTokenName</span><span class="p">();</span>

<span class="p">}</span>
</pre></div>
</div>
<p>这个接口很简单。 <code class="docutils literal"><span class="pre">getAuthIdentifierName</span></code> 方法返回用户的「主键」字段的名称，而 <code class="docutils literal"><span class="pre">getAuthIdentifier</span></code> 方法返回用户的「主键」值。重申一次，在 <code class="docutils literal"><span class="pre">MySQL</span></code> 后台，这个主键是指自增的主键。 <code class="docutils literal"><span class="pre">getAuthPassword</span></code> 应该要返回用户的散列密码。这个接口允许认证系统和任何用户类一起工作，不用管你在使用什么 <code class="docutils literal"><span class="pre">ORM</span></code> 或存储抽象层。默认情况下， <code class="docutils literal"><span class="pre">Laravel</span></code> 的 <code class="docutils literal"><span class="pre">app</span></code> 目录中包含一个 <code class="docutils literal"><span class="pre">User</span></code> 类来实现此接口，因此你可以参考这个类来实现一个实例。</p>
<div class="section" id="authenticatable-trait">
<h4>31.7.2.1. Authenticatable trait<a class="headerlink" href="#authenticatable-trait" title="永久链接至标题">¶</a></h4>
<p>该 <code class="docutils literal"><span class="pre">Authenticatable</span> <span class="pre">trait</span></code> 实现了 <code class="docutils literal"><span class="pre">Authenticatable</span></code> 接口的所有方法，并提供一些成员变量。</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="nx">Illuminate\Auth\Authenticatable</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">Laravel</span></code> 中定义的 <code class="docutils literal"><span class="pre">Authenticatable</span> <span class="pre">trait</span></code> ，也是 <code class="docutils literal"><span class="pre">Laravel</span> <span class="pre">auth</span></code> 默认的 <code class="docutils literal"><span class="pre">User</span></code> 模型使用的 <code class="docutils literal"><span class="pre">trait</span></code> ，这个 <code class="docutils literal"><span class="pre">trait</span></code> 定义了 <code class="docutils literal"><span class="pre">User</span></code> 模型默认认证标识符为 <code class="docutils literal"><span class="pre">id</span></code> ，密码字段为 <code class="docutils literal"><span class="pre">password</span></code> ， <code class="docutils literal"><span class="pre">remember</span> <span class="pre">token</span></code> 对应的字段为 <code class="docutils literal"><span class="pre">remember_token</span></code> 等等。</p>
<p>通过重写 <code class="docutils literal"><span class="pre">User</span></code> 模型的这些方法可以修改一些设置。</p>
</div>
</div>
</div>
<div class="section" id="authmanager">
<h2>31.8. AuthManager<a class="headerlink" href="#authmanager" title="永久链接至标题">¶</a></h2>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="x">Illuminate\Auth\AuthManager</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">Guard</span></code> 用来认证一个用户是否认证成功， <code class="docutils literal"><span class="pre">UserProvider</span></code> 用来提供认证模型的来源，而根据项目的 <code class="docutils literal"><span class="pre">config</span></code> 管理 <code class="docutils literal"><span class="pre">guard</span></code> 以及自定义 <code class="docutils literal"><span class="pre">guard</span></code> 等等功能，则是通过 <code class="docutils literal"><span class="pre">AuthManager</span></code> 来实现。</p>
<p><code class="docutils literal"><span class="pre">AuthManager</span></code> 应该是有点像策略模式里面的 <code class="docutils literal"><span class="pre">Context</span></code> 类以及工厂方法里面的工厂，一方面管理 <code class="docutils literal"><span class="pre">Guard</span></code> ，另外一方面通过 <code class="docutils literal"><span class="pre">__call</span></code> 魔术方法调用具体的策略( <code class="docutils literal"><span class="pre">Guard</span></code> )方法。</p>
<p><code class="docutils literal"><span class="pre">Auth</span></code> 门面对应的实现类就是 <code class="docutils literal"><span class="pre">AuthManager</span></code> ， <code class="docutils literal"><span class="pre">AuthManager</span></code> 在容器中注册为单例，用来管理所有的 <code class="docutils literal"><span class="pre">guard</span></code> 和 <code class="docutils literal"><span class="pre">user</span> <span class="pre">provider</span></code> 以及 <code class="docutils literal"><span class="pre">guard</span></code> 的代理工作。</p>
</div>
<div class="section" id="id32">
<h2>31.9. 自定义认证<a class="headerlink" href="#id32" title="永久链接至标题">¶</a></h2>
<p>根据上面的知识，可以知道要自定义一个认证很简单。</p>
<ol class="arabic">
<li><p class="first">创建认证模型。创建一个自定义的认证模型，实现 <code class="docutils literal"><span class="pre">Authenticatable</span></code> 接口；</p>
</li>
<li><p class="first">创建自定义的 <code class="docutils literal"><span class="pre">UserProvider</span></code> 。创建一个自定义的 <code class="docutils literal"><span class="pre">UserProvider</span></code> ，实现 <code class="docutils literal"><span class="pre">UserProvider</span></code> 接口，可以返回上面自定义的认证模型；</p>
</li>
<li><p class="first">创建自定义的 <code class="docutils literal"><span class="pre">Guard</span></code> 。创建一个自定义的 <code class="docutils literal"><span class="pre">Guard</span></code> ，实现 <code class="docutils literal"><span class="pre">Guard</span></code> 或 <code class="docutils literal"><span class="pre">StatefulGuard</span></code> 接口；</p>
</li>
<li><p class="first">添加 <code class="docutils literal"><span class="pre">guard</span> <span class="pre">creator</span></code> 和 <code class="docutils literal"><span class="pre">user</span> <span class="pre">provider</span> <span class="pre">creator</span></code> 到 <code class="docutils literal"><span class="pre">AuthManager</span></code> 中。</p>
<p>在 <code class="docutils literal"><span class="pre">AuthServiceProvider</span></code> 的 <code class="docutils literal"><span class="pre">boot</span></code> 方法添加如下代码：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="nx">Auth</span><span class="o">::</span><span class="na">extend</span><span class="p">(</span><span class="s1">&#39;myguard&#39;</span><span class="p">,</span> <span class="k">function</span><span class="p">(){</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">MyGuard</span><span class="p">();</span>   <span class="c1">//返回自定义 guard 实例</span>
    <span class="o">...</span>
<span class="p">});</span>

<span class="nx">Auth</span><span class="o">::</span><span class="na">provider</span><span class="p">(</span><span class="s1">&#39;myuserprovider&#39;</span><span class="p">,</span> <span class="k">function</span><span class="p">(){</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">MyUserProvider</span><span class="p">();</span>    <span class="c1">// 返回自定义的 user provider</span>
<span class="p">});</span>
</pre></div>
</div>
</li>
<li><p class="first">在 <code class="docutils literal"><span class="pre">config\auth.php</span></code> 的 <code class="docutils literal"><span class="pre">guards</span></code> 数组中添加自定义 <code class="docutils literal"><span class="pre">guard</span></code> ，一个自定义 <code class="docutils literal"><span class="pre">guard</span></code> 包括两部分： <code class="docutils literal"><span class="pre">driver</span></code> 和 <code class="docutils literal"><span class="pre">provider</span></code> 。</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="s1">&#39;oustn&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span>
    <span class="s1">&#39;driver&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;myguard&#39;</span><span class="p">,</span>
    <span class="s1">&#39;provider&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;myusers&#39;</span><span class="p">,</span>
<span class="p">],</span>
</pre></div>
</div>
</li>
<li><p class="first">在 <code class="docutils literal"><span class="pre">config\auth.php</span></code> 的 <code class="docutils literal"><span class="pre">providers</span></code> 数组中添加自定义 <code class="docutils literal"><span class="pre">user</span> <span class="pre">provider</span></code> 。</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="s1">&#39;myusers&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span>
    <span class="c1">// 里面具体的字段可以根据你创建 user provider 需要的信息自由添加，</span>
    <span class="c1">// 可以通过 Auth::createUserProvider(&#39;myuserprovider&#39;) 创建</span>
    <span class="s1">&#39;driver&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;myuserprovider&#39;</span>
<span class="p">],</span>
</pre></div>
</div>
</li>
<li><p class="first">设置 <code class="docutils literal"><span class="pre">config\auth.php</span></code> 的 <code class="docutils literal"><span class="pre">defaults.guard</span></code> 为 <code class="docutils literal"><span class="pre">oustn</span></code></p>
</li>
</ol>
</div>
<div class="section" id="id33">
<h2>31.10. 事件<a class="headerlink" href="#id33" title="永久链接至标题">¶</a></h2>
<p><code class="docutils literal"><span class="pre">Laravel</span></code> 在认证过程中引发了各种各样的事件。你可以在 <code class="docutils literal"><span class="pre">EventServiceProvider</span></code> 中对这些事件做监听：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="sd">/**</span>
<span class="sd"> * 应用程序的事件监听器映射。</span>
<span class="sd"> *</span>
<span class="sd"> * @var array</span>
<span class="sd"> */</span>
<span class="k">protected</span> <span class="nv">$listen</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;Illuminate\Auth\Events\Registered&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span>
        <span class="s1">&#39;App\Listeners\LogRegisteredUser&#39;</span><span class="p">,</span>
    <span class="p">],</span>

    <span class="s1">&#39;Illuminate\Auth\Events\Attempting&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span>
        <span class="s1">&#39;App\Listeners\LogAuthenticationAttempt&#39;</span><span class="p">,</span>
    <span class="p">],</span>

    <span class="s1">&#39;Illuminate\Auth\Events\Authenticated&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span>
        <span class="s1">&#39;App\Listeners\LogAuthenticated&#39;</span><span class="p">,</span>
    <span class="p">],</span>

    <span class="s1">&#39;Illuminate\Auth\Events\Login&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span>
        <span class="s1">&#39;App\Listeners\LogSuccessfulLogin&#39;</span><span class="p">,</span>
    <span class="p">],</span>

    <span class="s1">&#39;Illuminate\Auth\Events\Failed&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span>
        <span class="s1">&#39;App\Listeners\LogFailedLogin&#39;</span><span class="p">,</span>
    <span class="p">],</span>

    <span class="s1">&#39;Illuminate\Auth\Events\Logout&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span>
        <span class="s1">&#39;App\Listeners\LogSuccessfulLogout&#39;</span><span class="p">,</span>
    <span class="p">],</span>

    <span class="s1">&#39;Illuminate\Auth\Events\Lockout&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span>
        <span class="s1">&#39;App\Listeners\LogLockout&#39;</span><span class="p">,</span>
    <span class="p">],</span>
<span class="p">];</span>
</pre></div>
</div>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="用户认证JWT.html" class="btn btn-neutral float-right" title="32. 用户认证JWT" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="laravel-mix.html" class="btn btn-neutral" title="30. mix使用手册" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, lzh.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.0',
            LANGUAGE:'zh',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  

<script type="text/javascript">
  
      $(document).ready(function(){
        var offset = sessionStorage.getItem("offsetTop");
        $('.wy-side-scroll').scrollTop(offset);
        sessionStorage.setItem("offsetTop", 0);


        $('.wy-menu > ul').click(function(){
            sessionStorage.setItem("offsetTop", $('.wy-side-scroll').scrollTop());
        });
      })

  </script> 

</body>
</html>