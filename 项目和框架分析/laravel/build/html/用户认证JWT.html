

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>32. 用户认证JWT &mdash; laravel 1.0 文档</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="索引"
              href="genindex.html"/>
        <link rel="search" title="搜索" href="search.html"/>
    <link rel="top" title="laravel 1.0 文档" href="index.html"/>
        <link rel="next" title="33. Laravel 的 API 认证系统 Passport" href="Laravel的API认证系统Passport.html"/>
        <link rel="prev" title="31. Laravel 的用户认证系统" href="Laravel的用户认证系统.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> laravel
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">目录:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="请求到响应的生命周期-web.html">1. 请求到web响应的生命周期</a></li>
<li class="toctree-l1"><a class="reference internal" href="请求到响应的生命周期-console.html">2. 请求到console响应的生命周期</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的容器.html">3. 容器</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的Facades.html">4. Facades</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的Facades原理分析.html">5. Facade的原理</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的服务提供器.html">6. 服务提供器</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的路由.html">7. 路由</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的路由—路由的正则编译.html">8. 路由的正则编译</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的路由—路由的匹配与参数绑定.html">9. 路由的匹配与参数绑定</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的路由—路由中间件.html">10. 路由的中间件</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的中间件.html">11. 中间件</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的中间件-SubstituteBindings.html">12. 中间件SubstituteBindings</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的中间件-CSRF.html">13. 中间件CSRF</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的请求.html">14. 请求</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的控制器.html">15. 控制器</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的控制器—控制器方法的参数构建与运行.html">16. 控制器方法的参数构建与运行</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的响应.html">17. 响应</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的视图.html">18. 视图</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的生成URL.html">19. URL</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的Session.html">20. Session</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的Session原理分析.html">21. Session原理分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的表单验证机制详解.html">22. 表单验证机制详解</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的日志.html">23. 日志</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的异常和错误处理.html">24. 异常和错误处理</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的异常和错误处理原理分析.html">25. 异常和错误处理原理分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的Blade.html">26. Blade</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的blade原理分析.html">27. Blade原理分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的前端.html">28. 前端</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的Mix.html">29. Mix</a></li>
<li class="toctree-l1"><a class="reference internal" href="laravel-mix.html">30. mix使用手册</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的用户认证系统.html">31. Laravel 的用户认证系统</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">32. 用户认证JWT</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1">32.1. JWT</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#session">32.1.1. session 原理概述</a></li>
<li class="toctree-l3"><a class="reference internal" href="#token">32.1.2. Token 原理概述</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">32.1.3. JWT 概述</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">32.1.4. 什么是JWT</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id9">32.1.5. JWT长什么样？</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id10">32.1.6. JWT的构成</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id11">32.1.7. 如何应用</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id12">32.2. 总结</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id13">32.2.1. 优点</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id14">32.2.2. 安全相关</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#laravel">32.3. Laravel中认证</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#auth">32.3.1. auth</a></li>
<li class="toctree-l3"><a class="reference internal" href="#auth-basic">32.3.2. auth.basic</a></li>
<li class="toctree-l3"><a class="reference internal" href="#guest">32.3.3. guest</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#laravel-passport">32.4. Laravel 推出了自己的用户认证模块 &quot;Passport&quot;, 应该使用吗?</a></li>
<li class="toctree-l2"><a class="reference internal" href="#jwt-passport-laravel-token">32.5. 如果不想使用 JWT 和 Passport, Laravel 能快速实现使用 token 的用户认证机制吗?</a></li>
<li class="toctree-l2"><a class="reference internal" href="#laraveljwt">32.6. Laravel使用JWT认证</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id15">32.6.1. 安装</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id16">32.6.2. 配置</a></li>
<li class="toctree-l3"><a class="reference internal" href="#model">32.6.3. 更改 Model</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id20">32.6.4. 增加一些认证路由</a></li>
<li class="toctree-l3"><a class="reference internal" href="#authcontroller">32.6.5. 创建AuthController</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id21">32.7. 使用包中间件</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id22">32.7.1. 定义路由</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的API认证系统Passport.html">33. Laravel 的 API 认证系统 Passport</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的用户授权系统.html">34. Laravel用户授权系统</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的命令行.html">35. 命令行</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的广播系统.html">36. 广播</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的广播系统原理分析.html">37. 广播系统原理分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的缓存系统.html">38. 缓存</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的集合Collection.html">39. 集合</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的事件系统.html">40. 事件</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的事件系统原理分析.html">41. 事件系统原理分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的文件存储.html">42. 文件存储</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的辅助函数-字符串操作.html">43. 辅助函数-字符串函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的辅助函数-数组和对象操作.html">44. 辅助函数-数组和对象函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的辅助函数-路径操作.html">45. 辅助函数-路径函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的辅助函数-tap分析.html">46. 辅助函数-Tap函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的辅助函数-其它.html">47. 辅助函数-其它杂项</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的邮件发送功能.html">48. 邮件</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的消息通知.html">49. 通知</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel Queue——消息队列任务与分发源码剖析.html">50. 消息队列任务与分发源码剖析</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的任务调度.html">51. 任务调度</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的数据库—原始方式.html">52. 数据库-原始操作</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的数据库—查询构造器.html">53. 数据库-查询构建器</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的数据分页.html">54. 数据分页</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的数据分页原理分析.html">55. 数据分页原理分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的数据库迁移.html">56. 数据库迁移</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的数据库填充.html">57. 数据库填充</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的Redis.html">58. Redis</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的Redis原理分析.html">59. Redis原理分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的数据库—Eloquent.html">60. Eloquent</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的数据库—Eloquent关联.html">61. Eloquent关联</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的数据库—Eloquent修改器.html">62. Eloquent修改器</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的验证规则.html">63. 验证规则</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">laravel</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>32. 用户认证JWT</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            
        
        <a href="http://blog.liaozhonghao.cn" rel="nofollow"> 返回主页</a>
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="jwt">
<h1>32. 用户认证JWT<a class="headerlink" href="#jwt" title="永久链接至标题">¶</a></h1>
<div class="section" id="id1">
<h2>32.1. JWT<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>在介绍 <code class="docutils literal"><span class="pre">JWT</span></code> 之前, 我们首先介绍一下, 传统的服务器端使用 <code class="docutils literal"><span class="pre">session</span></code> 对多用户进行授权的方式. 当然在 <code class="docutils literal"><span class="pre">session</span></code> 之前还有 <code class="docutils literal"><span class="pre">cookie</span></code> 的方式来保存用户的授权信息在客户机(比如浏览器)上, 不过纯 <code class="docutils literal"><span class="pre">cookie</span></code> 的方式过于不安全, 我们就把 <code class="docutils literal"><span class="pre">cookie</span></code> 跟 <code class="docutils literal"><span class="pre">session</span></code> 一起说。</p>
<p>之所以需要授权机制, 是因为 <code class="docutils literal"><span class="pre">http</span></code> 的无状态性(stateless)。</p>
<p>也就是说当一个用户发送一次请求, 请求中附带账户名和密码登录成功之后, 如果这个这个用户再次发送一次请求, 服务器是不能知道这个用户是已经登录过的, 这个时候服务器就还需要用户再次提供授权信息, 也就是用户名和密码.</p>
<p>如果客户端能更少的把自己的身份授权信息在网络上传输, 那么客户端就能更大程度上避免自己的身份信息被泄露.</p>
<p>而 <code class="docutils literal"><span class="pre">session</span></code> 和 <code class="docutils literal"><span class="pre">token</span></code> 都是为了解决此问题出现的.</p>
<div class="section" id="session">
<h3>32.1.1. session 原理概述<a class="headerlink" href="#session" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>32.1.1.1. 认证流程<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<ol class="arabic simple">
<li>当用户使用用户名和密码登录之后，服务器就会生成一个 <code class="docutils literal"><span class="pre">session</span></code> 文件, <code class="docutils literal"><span class="pre">session</span></code> 文件中保存着对这个用户的授权信息，这个文件可以储存在硬盘/内存/数据库中。</li>
<li>同时还要生成一个对应这个 <code class="docutils literal"><span class="pre">session</span></code> 文件的 <code class="docutils literal"><span class="pre">sessionid</span></code> 。通过 <code class="docutils literal"><span class="pre">sessionid</span></code> 就能够找到这个 <code class="docutils literal"><span class="pre">session</span></code> 文件。</li>
<li>然后将 <code class="docutils literal"><span class="pre">sessionid</span></code> 发送给客户端，客户端就将 <code class="docutils literal"><span class="pre">sessionid</span></code> 保存起来，保存的方式有很多种。目前大多情况是通过 <code class="docutils literal"><span class="pre">cookie</span></code> 来保存 <code class="docutils literal"><span class="pre">sessionid</span></code> 。</li>
<li>保存之后，当客户机以后再向服务器发送请求的时候，请求携带上 <code class="docutils literal"><span class="pre">sessionid</span></code> ，这样服务器收到 <code class="docutils literal"><span class="pre">sessionid</span></code> 之后, 自己就会在服务区上查找对应的 <code class="docutils literal"><span class="pre">session</span></code> 文件，如果查找成功。就会得到该用户的授权信息, 从而完成一次授权。</li>
</ol>
<p><code class="docutils literal"><span class="pre">session</span></code> 的出现解决了一部分的问题，但随着时间的推移和互联网的发展，一些缺陷也随之暴露出来, 比如但不仅限于以下几点</p>
<ul class="simple">
<li>随着用户量的增加, 每个用户都需要在服务器上创建一个 <code class="docutils literal"><span class="pre">session</span></code> 文件, 这对服务器造成了压力；</li>
<li>对于服务器压力的分流问题, 如果一个用户的 <code class="docutils literal"><span class="pre">session</span></code> 被存储在某台服务器上, 那么当这个用户访问服务器时, 用户就只能在这台服务器上完成授权, 其他的分流服务器无法进行对这种请求进行分流；</li>
<li>同样也是 <code class="docutils literal"><span class="pre">session</span></code> 存储的问题, 当我们在一台服务器上成功登录, 如果我们想要另外的一台别的域名的服务器也能让用户不登录就能完成授权, 这个时候就会有很多麻烦；</li>
<li>CSRF 攻击的防范, 这点目前还没太懂, 不过可以先不做了解；</li>
</ul>
<p>为了解决此类问题， <code class="docutils literal"><span class="pre">token</span></code> 应运而生了。</p>
</div>
</div>
<div class="section" id="token">
<h3>32.1.2. Token 原理概述<a class="headerlink" href="#token" title="永久链接至标题">¶</a></h3>
<div class="section" id="id3">
<h4>32.1.2.1. 认证流程<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<ol class="arabic simple">
<li>客户端发送认证信息(一般就是用户名/密码)，向服务器发送请求；</li>
<li>服务器验证客户端的认证信息，验证成功之后，服务器向客户端返回一个加密的 <code class="docutils literal"><span class="pre">token</span></code> (一般情况下就是一个字符串)；</li>
<li>客户端存储( <code class="docutils literal"><span class="pre">cookie</span></code> ， <code class="docutils literal"><span class="pre">session</span></code> ， <code class="docutils literal"><span class="pre">app</span></code> 中都可以存储)这个 <code class="docutils literal"><span class="pre">token</span></code> ， 在之后每次向服务器发送请求时, 都携带上这个 <code class="docutils literal"><span class="pre">token</span></code> ；</li>
<li>服务器验证这个 <code class="docutils literal"><span class="pre">token</span></code> 的合法性，只要验证通过，服务器就认为该请求是一个合法的请求；</li>
</ol>
</div>
</div>
<div class="section" id="id4">
<h3>32.1.3. JWT 概述<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal"><span class="pre">token</span></code> 只是一种思路，一种解决用户授权问题的思考方式，基于这种思路，针对不同的场景可以有很多种的实现。而在众多的实现中， <code class="docutils literal"><span class="pre">JWT</span></code> (JSON Web Token) 的实现最为流行。</p>
<p><code class="docutils literal"><span class="pre">JWT</span></code> 这个标准提供了一系列如何创建具体 <code class="docutils literal"><span class="pre">token</span></code> 的方法，这些缘故方法和规范可以让我们创建 <code class="docutils literal"><span class="pre">token</span></code> 的过程变得更加合理和效率。</p>
<p>比如, 传统的做法中, 服务器会保存生成的 <code class="docutils literal"><span class="pre">token</span></code> ，当客户端发送来 <code class="docutils literal"><span class="pre">token</span></code> 时，与服务器的进行比对，但是 <code class="docutils literal"><span class="pre">jwt</span></code> 的不需要在服务器保存任何 <code class="docutils literal"><span class="pre">token</span></code> ，而是使用一套加密/解密算法 和 一个密钥 来对用户发来的 <code class="docutils literal"><span class="pre">token</span></code> 进行解密。解密成功后就可以得到这个用户的信息。</p>
<p>这样的做法同时也增加了多服务器时的扩展性，在传统的 <code class="docutils literal"><span class="pre">token</span></code> 验证中, 一旦用户发来 <code class="docutils literal"><span class="pre">token</span></code> , 那么必须要先找到存储这个 <code class="docutils literal"><span class="pre">token</span></code> 的服务器是哪台服务器，然后由那一台服务器进行验证用户身份。而 <code class="docutils literal"><span class="pre">jwt</span></code> 的存在, 只要每一台服务器都知道解密密钥, 那么每一台服务器都可以拥有验证用户身份的能力。</p>
<p>这样一来，服务器就不再保存任何用户授权的信息了，也就解决了 <code class="docutils literal"><span class="pre">session</span></code> 曾出现的问题。</p>
<p>Session   JWT
安全性   得考虑CSRF攻击   无需考虑
存储   需要俩端都存储   客户端存储即可
可控性   服务端可随时修改权限....    只能等待Token过期</p>
</div>
<div class="section" id="id5">
<h3>32.1.4. 什么是JWT<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<p>Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519)。该 <code class="docutils literal"><span class="pre">token</span></code> 被设计为紧凑且安全的，特别适用于分布式站点的单点登录( <code class="docutils literal"><span class="pre">SSO</span></code> )场景。 <code class="docutils literal"><span class="pre">JWT</span></code> 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该 <code class="docutils literal"><span class="pre">token</span></code> 也可直接被用于认证，也可被加密。</p>
<div class="section" id="id6">
<h4>32.1.4.1. 起源<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h4>
<p>说起 <code class="docutils literal"><span class="pre">JWT</span></code> ，我们应该来谈一谈基于 <code class="docutils literal"><span class="pre">token</span></code> 的认证和传统的 <code class="docutils literal"><span class="pre">session</span></code> 认证的区别。</p>
<div class="section" id="id7">
<h5>32.1.4.1.1. 传统的session认证<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h5>
<p>我们知道， <code class="docutils literal"><span class="pre">http</span></code> 协议本身是一种无状态的协议，而这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证，那么下一次请求时，用户还要再一次进行用户认证才行，因为根据 <code class="docutils literal"><span class="pre">http</span></code> 协议，我们并不能知道是哪个用户发出的请求，所以为了让我们的应用能识别是哪个用户发出的请求，我们只能在服务器存储一份用户登录的信息，这份登录信息会在响应时传递给浏览器，告诉其保存为 <code class="docutils literal"><span class="pre">cookie</span></code> ，以便下次请求时发送给我们的应用，这样我们的应用就能识别请求来自哪个用户了，这就是传统的基于session认证。</p>
<p>但是这种基于 <code class="docutils literal"><span class="pre">session</span></code> 的认证使应用本身很难得到扩展，随着不同客户端用户的增加，独立的服务器已无法承载更多的用户，而这时候基于 <code class="docutils literal"><span class="pre">session</span></code> 认证应用的问题就会暴露出来.</p>
<p>基于 session 认证所显露的问题</p>
<ul class="simple">
<li>Session: 每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以方便用户下次请求的鉴别，通常而言 <code class="docutils literal"><span class="pre">session</span></code> 都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大。</li>
<li>扩展性: 用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上，这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。</li>
<li>CSRF: 因为是基于 cookie 来进行用户识别的， <code class="docutils literal"><span class="pre">cookie</span></code> 如果被截获，用户就会很容易受到跨站请求伪造的攻击。</li>
</ul>
</div>
<div class="section" id="id8">
<h5>32.1.4.1.2. 基于token的鉴权机制<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h5>
<p>基于 <code class="docutils literal"><span class="pre">token</span></code> 的鉴权机制类似于 <code class="docutils literal"><span class="pre">http</span></code> 协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于 <code class="docutils literal"><span class="pre">token</span></code> 认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。</p>
<p>流程上是这样的：</p>
<ol class="arabic simple">
<li>用户使用用户名、密码来请求服务器；</li>
<li>服务器进行验证用户的信息；</li>
<li>服务器通过验证发送给用户一个 <code class="docutils literal"><span class="pre">token</span></code> ； 如何验证？？？</li>
<li>客户端存储 <code class="docutils literal"><span class="pre">token</span></code> ，并在每次请求时附送上这个 <code class="docutils literal"><span class="pre">token</span></code> 值；</li>
<li>服务端验证 <code class="docutils literal"><span class="pre">token</span></code> 值，并返回数据；</li>
</ol>
<p>这个 <code class="docutils literal"><span class="pre">token</span></code> 必须要在每次请求时传递给服务端，它应该保存在请求头里， 另外，服务端要支持 <code class="docutils literal"><span class="pre">CORS</span></code> (跨来源资源共享)策略，一般我们在服务端这么做就可以了 <code class="docutils literal"><span class="pre">Access-Control-Allow-Origin:</span> <span class="pre">*</span></code> 。</p>
<p>那么我们现在回到 <code class="docutils literal"><span class="pre">JWT</span></code> 的主题上。</p>
</div>
</div>
</div>
<div class="section" id="id9">
<h3>32.1.5. JWT长什么样？<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal"><span class="pre">JWT</span></code> 是由三段信息构成的，将这三段信息文本用 <code class="docutils literal"><span class="pre">.</span></code> 链接一起就构成了 <code class="docutils literal"><span class="pre">JWT</span></code> 字符串。就像这样：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
</pre></div>
</div>
</div>
<div class="section" id="id10">
<h3>32.1.6. JWT的构成<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h3>
<p>第一部分我们称它为头部( <code class="docutils literal"><span class="pre">header</span></code> ) ，第二部分我们称其为载荷( <code class="docutils literal"><span class="pre">payload</span></code> ，类似于飞机上承载的物品)，第三部分是签证( <code class="docutils literal"><span class="pre">signature</span></code> )。</p>
<div class="section" id="header">
<h4>32.1.6.1. header<a class="headerlink" href="#header" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">jwt</span></code> 的头部承载两部分信息：</p>
<ul class="simple">
<li>声明类型，这里是 <code class="docutils literal"><span class="pre">jwt</span></code> ；</li>
<li>声明加密的算法 通常直接使用 <code class="docutils literal"><span class="pre">HMAC</span> <span class="pre">SHA256</span></code> ；</li>
</ul>
<p>完整的头部就像下面这样的 <code class="docutils literal"><span class="pre">JSON</span></code> :</p>
<div class="highlight-json"><div class="highlight"><pre><span></span>{
  &#39;typ&#39;: &#39;JWT&#39;,
  &#39;alg&#39;: &#39;HS256&#39;
}
</pre></div>
</div>
<p>然后将头部进行 <code class="docutils literal"><span class="pre">base64</span></code> 加密（该加密是可以对称解密的)，构成了第一部分。</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9
</pre></div>
</div>
</div>
<div class="section" id="playload">
<h4>32.1.6.2. playload<a class="headerlink" href="#playload" title="永久链接至标题">¶</a></h4>
<p>载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分</p>
<ul class="simple">
<li>标准中注册的声明；</li>
<li>公共的声明；</li>
<li>私有的声明；</li>
</ul>
<p>标准中注册的声明 (建议但不强制使用) ：</p>
<ul class="simple">
<li>iss: jwt签发者</li>
<li>sub: jwt所面向的用户</li>
<li>aud: 接收jwt的一方</li>
<li>exp: jwt的过期时间，这个过期时间必须要大于签发时间</li>
<li>nbf: 定义在什么时间之前，该jwt都是不可用的.</li>
<li>iat: jwt的签发时间</li>
<li>jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。</li>
</ul>
<p>公共的声明：</p>
<p>公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息。但不建议添加敏感信息，因为该部分在客户端可解密。</p>
<p>私有的声明：</p>
<p>私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为 <code class="docutils literal"><span class="pre">base64</span></code> 是对称解密的，意味着该部分信息可以归类为明文信息。</p>
<p>定义一个payload:</p>
<div class="highlight-json"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;sub&quot;</span><span class="p">:</span> <span class="s2">&quot;1234567890&quot;</span><span class="p">,</span>
  <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;John Doe&quot;</span><span class="p">,</span>
  <span class="nt">&quot;admin&quot;</span><span class="p">:</span> <span class="kc">true</span>
<span class="p">}</span>
</pre></div>
</div>
<p>然后将其进行 <code class="docutils literal"><span class="pre">base64</span></code> 加密，得到 <code class="docutils literal"><span class="pre">Jwt</span></code> 的第二部分。</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9
</pre></div>
</div>
</div>
<div class="section" id="signature">
<h4>32.1.6.3. signature<a class="headerlink" href="#signature" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">jwt</span></code> 的第三部分是一个签证信息，这个签证信息由三部分组成：</p>
<ul class="simple">
<li>header (base64后的)</li>
<li>payload (base64后的)</li>
<li>secret</li>
</ul>
<p>这个部分需要 <code class="docutils literal"><span class="pre">base64</span></code> 加密后的 <code class="docutils literal"><span class="pre">header</span></code> 和 <code class="docutils literal"><span class="pre">base64</span></code> 加密后的 <code class="docutils literal"><span class="pre">payload</span></code> 使用 <code class="docutils literal"><span class="pre">.</span></code> 连接组成的字符串，然后通过 <code class="docutils literal"><span class="pre">header</span></code> 中声明的加密方式进行加盐 <code class="docutils literal"><span class="pre">secret</span></code> 组合加密，然后就构成了 <code class="docutils literal"><span class="pre">jwt</span></code> 的第三部分。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// javascript</span>
<span class="kd">var</span> <span class="nx">encodedString</span> <span class="o">=</span> <span class="nx">base64UrlEncode</span><span class="p">(</span><span class="nx">header</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="nx">base64UrlEncode</span><span class="p">(</span><span class="nx">payload</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">signature</span> <span class="o">=</span> <span class="nx">HMACSHA256</span><span class="p">(</span><span class="nx">encodedString</span><span class="p">,</span> <span class="s1">&#39;secret&#39;</span><span class="p">);</span> <span class="c1">// TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span>
</pre></div>
</div>
<p>将这三部分用 <code class="docutils literal"><span class="pre">.</span></code> 连接成一个完整的字符串，构成了最终的 <code class="docutils literal"><span class="pre">jwt</span></code> ：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last"><code class="docutils literal"><span class="pre">secret</span></code> 是保存在服务器端的， <code class="docutils literal"><span class="pre">jwt</span></code> 的签发生成也是在服务器端的， <code class="docutils literal"><span class="pre">secret</span></code> 就是用来进行 <code class="docutils literal"><span class="pre">jwt</span></code> 的签发和 <code class="docutils literal"><span class="pre">jwt</span></code> 的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个 <code class="docutils literal"><span class="pre">secret</span></code> ，那就意味着客户端是可以自我签发 <code class="docutils literal"><span class="pre">jwt</span></code> 了。</p>
</div>
</div>
</div>
<div class="section" id="id11">
<h3>32.1.7. 如何应用<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h3>
<p>一般是在请求头里加入 <code class="docutils literal"><span class="pre">Authorization</span></code> ，并加上 <code class="docutils literal"><span class="pre">Bearer</span></code> 标注：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;api/user/1&#39;</span><span class="p">,</span> <span class="p">{</span>
  <span class="nx">headers</span><span class="o">:</span> <span class="p">{</span>
    <span class="s1">&#39;Authorization&#39;</span><span class="o">:</span> <span class="s1">&#39;Bearer &#39;</span> <span class="o">+</span> <span class="nx">token</span>
  <span class="p">}</span>
<span class="p">})</span>
</pre></div>
</div>
<p>服务端会验证 <code class="docutils literal"><span class="pre">token</span></code> ，如果验证通过就会返回相应的资源。整个流程就是这样的:</p>
<p><a class="reference external" href="https://upload-images.jianshu.io/upload_images/1821058-2e28fe6c997a60c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700">https://upload-images.jianshu.io/upload_images/1821058-2e28fe6c997a60c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700</a></p>
</div>
</div>
<div class="section" id="id12">
<h2>32.2. 总结<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h2>
<div class="section" id="id13">
<h3>32.2.1. 优点<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li>因为 <code class="docutils literal"><span class="pre">json</span></code> 的通用性，所以 <code class="docutils literal"><span class="pre">JWT</span></code> 是可以进行跨语言支持的，像 <code class="docutils literal"><span class="pre">JAVA</span></code> ， <code class="docutils literal"><span class="pre">JavaScript</span></code> ， <code class="docutils literal"><span class="pre">NodeJS</span></code> ， <code class="docutils literal"><span class="pre">PHP</span></code> 等很多语言都可以使用。</li>
<li>因为有了 <code class="docutils literal"><span class="pre">payload</span></code> 部分，所以 <code class="docutils literal"><span class="pre">JWT</span></code> 可以在自身存储一些其他业务逻辑所必要的非敏感信息。</li>
<li>便于传输， <code class="docutils literal"><span class="pre">jwt</span></code> 的构成非常简单，字节占用很小，所以它是非常便于传输的。</li>
<li>它不需要在服务端保存会话信息，所以它易于应用的扩展。</li>
</ul>
</div>
<div class="section" id="id14">
<h3>32.2.2. 安全相关<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li>不应该在 <code class="docutils literal"><span class="pre">jwt</span></code> 的 <code class="docutils literal"><span class="pre">payload</span></code> 部分存放敏感信息，因为该部分是客户端可解密的部分。</li>
<li>保护好 <code class="docutils literal"><span class="pre">secret</span></code> 私钥，该私钥非常重要。</li>
<li>如果可以，请使用 <code class="docutils literal"><span class="pre">https</span></code> 协议。</li>
</ul>
</div>
</div>
<div class="section" id="laravel">
<h2>32.3. Laravel中认证<a class="headerlink" href="#laravel" title="永久链接至标题">¶</a></h2>
<p>说到这里。不妨了解一下 Laravel 中服务器授权方式有哪些.</p>
<p>打开一个 Laravel 项目 ,来到 <code class="docutils literal"><span class="pre">app/Http/Kernel</span></code> 文件中, 我们可以看到有：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">protected</span> <span class="nv">$routeMiddleware</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;auth&#39;</span> <span class="o">=&gt;</span> <span class="nx">\App\Http\Middleware\Authenticate</span><span class="o">::</span><span class="na">class</span><span class="p">,</span>
    <span class="s1">&#39;auth.basic&#39;</span> <span class="o">=&gt;</span> <span class="nx">\Illuminate\Auth\Middleware\AuthenticateWithBasicAuth</span><span class="o">::</span><span class="na">class</span><span class="p">,</span>
    <span class="s1">&#39;guest&#39;</span> <span class="o">=&gt;</span> <span class="nx">\App\Http\Middleware\RedirectIfAuthenticated</span><span class="o">::</span><span class="na">class</span><span class="p">,</span>
<span class="p">];</span>
</pre></div>
</div>
<p>Laravel 已经我们提供了 3 种授权方式, 并以中间件的方式来提供给我们使用。</p>
<div class="section" id="auth">
<h3>32.3.1. auth<a class="headerlink" href="#auth" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal"><span class="pre">auth</span></code> 中间件可以帮我们实现普通的 <code class="docutils literal"><span class="pre">Web</span></code> 页面中的用户密码验证，如果你使用 <code class="docutils literal"><span class="pre">API</span></code> 的方式来提供数据接口，也可以使用 <code class="docutils literal"><span class="pre">token</span></code> 的方式来进行验证。</p>
</div>
<div class="section" id="auth-basic">
<h3>32.3.2. auth.basic<a class="headerlink" href="#auth-basic" title="永久链接至标题">¶</a></h3>
<p>也是一种最基础的验证方式，当你请求一个要求授权的 <code class="docutils literal"><span class="pre">url</span></code> 时，需要在这个请求的 <code class="docutils literal"><span class="pre">Header</span></code> 中加入相关的授权信息，比如账号和密码。如果在 <code class="docutils literal"><span class="pre">web</span></code> 请求时加上这个中间件，会在页面中弹出一个输入账号密码的对话框，输入正确的信息后才能继续访问该页面。</p>
</div>
<div class="section" id="guest">
<h3>32.3.3. guest<a class="headerlink" href="#guest" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal"><span class="pre">guest</span></code> 中间件, 在代码中指向了 <code class="docutils literal"><span class="pre">RedirectIfAuthenticated::class</span></code> 这个类，从类名的定义我们就可以看出，这个中间件的作用就是 如果用户访问了这个中间件下的页面时已经授权成功了， 比如说已经登录过了，那么就会帮我们跳转到某个另外的 <code class="docutils literal"><span class="pre">url</span></code> , 如果没有登录，就继续当前的请求动作。</p>
<p>上面的这些中间件，帮我们管理了一部分的用户授权功能，他们的实现方式大都是通过 Laravel 框架的 <code class="docutils literal"><span class="pre">Auth</span></code> 组件(主要是通过 <code class="docutils literal"><span class="pre">AuthManager</span></code> 这个类)配合 <code class="docutils literal"><span class="pre">Guard</span></code> 类来实现的。</p>
<p>所以按照 Laravel 的思路，我们的授权功能应该还是用中间件的方式来完成。</p>
</div>
</div>
<div class="section" id="laravel-passport">
<h2>32.4. Laravel 推出了自己的用户认证模块 &quot;Passport&quot;, 应该使用吗?<a class="headerlink" href="#laravel-passport" title="永久链接至标题">¶</a></h2>
<p>在这篇文章完成之前, Laravel 又推出了一个用户认证的高级实现工具, 也就是 Laravel <code class="docutils literal"><span class="pre">Passport</span></code> , 毕竟是 Laravel 家族的产品, 所以刚发布的时候我也想要去使用他, 研究一番之后才发现,  <code class="docutils literal"><span class="pre">Passport</span></code> 并不是适合所有场景的, 下面我们就来对比一下.</p>
<p>这两者都是用来做用户认证的，但是有几点比较重要的不同点。</p>
<p>相比于 <code class="docutils literal"><span class="pre">jwt</span></code> ， <code class="docutils literal"><span class="pre">passport</span></code> 是一个大的多的抽象层，他被设计成一个完全成熟的(同时也要容易配置和使用)  <code class="docutils literal"><span class="pre">Oauth2</span></code> 服务来使用。因为在设计之初,  <code class="docutils literal"><span class="pre">passport</span></code> 的目标就被设计的非常专一，所以在别的使用场景下， <code class="docutils literal"><span class="pre">passport</span></code> 的功能也很难被复用。而且， <code class="docutils literal"><span class="pre">passport</span></code> 内部有一部分使用了 <code class="docutils literal"><span class="pre">jwt</span></code> 来实现认证。</p>
<p>而 <code class="docutils literal"><span class="pre">jwt</span></code> 的设计目的更倾向于，是一个简单的用户认证方式。当然 <code class="docutils literal"><span class="pre">jwt</span></code> 能实现的功能是十分强大的，但他跟 <code class="docutils literal"><span class="pre">Oauth</span></code> 并没有什么关系。</p>
<p>所以一般来说, 你能用 <code class="docutils literal"><span class="pre">jwt</span></code> 完成的需求，用 <code class="docutils literal"><span class="pre">passport</span></code> 一定也能完成，但是并不推荐使用 <code class="docutils literal"><span class="pre">passport</span></code> , 除非你有 <code class="docutils literal"><span class="pre">Oauth</span></code> 相关的需求。如果你真的需要一台支持 <code class="docutils literal"><span class="pre">Oauth</span></code> 的服务器，那么我完全推荐你使用 <code class="docutils literal"><span class="pre">Passport</span></code> ，因为他非常容易配置。</p>
<p>还有一点需要注意, 服务器允许其他 <code class="docutils literal"><span class="pre">Oauth</span></code> 用户登录, 跟服务器自身提供 <code class="docutils literal"><span class="pre">Oauth</span></code> 服务是2个概念。如果你想要的只是类似于 &quot;使用 Google 帐号登录&quot; 这种功能，那么你应该使用 <code class="docutils literal"><span class="pre">Laravel/socialite</span></code> 。服务器自身提供 <code class="docutils literal"><span class="pre">Oauth</span></code> 服务意味着，别的网站的开发者可以使用你提供的用户认证信息来登录到他们的服务器上。</p>
</div>
<div class="section" id="jwt-passport-laravel-token">
<h2>32.5. 如果不想使用 JWT 和 Passport, Laravel 能快速实现使用 token 的用户认证机制吗?<a class="headerlink" href="#jwt-passport-laravel-token" title="永久链接至标题">¶</a></h2>
<p>答案是可以的。 Larave 自身的代码已经实现了大部分功能, 所以我们只要稍作修改, 就能实现基本的 <code class="docutils literal"><span class="pre">token</span></code> 认证了。</p>
<p>步骤如下:</p>
<ol class="arabic">
<li><p class="first">新建一个 <code class="docutils literal"><span class="pre">Laravel</span> <span class="pre">5.5.*</span></code> 的项目；</p>
</li>
<li><p class="first">打开 <code class="docutils literal"><span class="pre">database/migrations/2014_10_12_000000_create_users_table.php</span></code> 这个 <code class="docutils literal"><span class="pre">migration</span></code> 文件，我们需要更改 <code class="docutils literal"><span class="pre">user</span></code> 表的结构；</p>
</li>
<li><p class="first">我们需要为 <code class="docutils literal"><span class="pre">user</span></code> 表添加 <code class="docutils literal"><span class="pre">api_token</span></code> 字段，也就是说我们的 <code class="docutils literal"><span class="pre">token</span></code> 是保存在数据库中的，在合适的位置， 添加一行 <code class="docutils literal"><span class="pre">$table-&gt;string('api_token',</span> <span class="pre">60)-&gt;unique();</span></code> ；</p>
</li>
<li><p class="first">配置好数据库，通过 <code class="docutils literal"><span class="pre">php</span> <span class="pre">artisan</span> <span class="pre">migrate</span></code> 命令生成 <code class="docutils literal"><span class="pre">user</span></code> 表；</p>
</li>
<li><p class="first">在 <code class="docutils literal"><span class="pre">user</span></code> 表中，随便添加一条记录，只要保证 <code class="docutils literal"><span class="pre">api_token</span></code> 这个字段设置为 <code class="docutils literal"><span class="pre">123456</span></code> 即可。这样我们就生成了一个用户，等下就可以使用 <code class="docutils literal"><span class="pre">123456</span></code> 这个 <code class="docutils literal"><span class="pre">token</span></code> 值来登录了；</p>
</li>
<li><p class="first">返回到 路由文件 <code class="docutils literal"><span class="pre">routes.php</span></code> ，在里面添加一条测试路由，并将其用 laravel 的中间件保护起来；</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="nx">Route</span><span class="o">::</span><span class="na">group</span><span class="p">([</span><span class="s1">&#39;middleware&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;auth:api&#39;</span><span class="p">],</span> <span class="k">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">Route</span><span class="o">::</span><span class="na">get</span><span class="p">(</span><span class="s1">&#39;/t&#39;</span><span class="p">,</span> <span class="k">function</span> <span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="s1">&#39;ok&#39;</span><span class="p">;</span>
  <span class="p">});</span>
<span class="p">});</span>
</pre></div>
</div>
<p>在此处, 使用的是 <code class="docutils literal"><span class="pre">auth</span></code> 中间件， <code class="docutils literal"><span class="pre">:api</span></code> 的意思是说，我们指定了 <code class="docutils literal"><span class="pre">auth</span></code> 中间件的 <code class="docutils literal"><span class="pre">driver</span></code> 为 <code class="docutils literal"><span class="pre">api</span></code> , 而如果不指定的话， <code class="docutils literal"><span class="pre">driver</span></code> 默认使用的是 <code class="docutils literal"><span class="pre">web</span></code> 。</p>
</li>
<li><p class="first">修改 <code class="docutils literal"><span class="pre">app/Http/Middleware/Authenticate.php</span></code> 文件, 精简一下 handle 这个方法, 精简之后成为下面的样子。</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">handle</span><span class="p">(</span><span class="nv">$request</span><span class="p">,</span> <span class="nx">Closure</span> <span class="nv">$next</span><span class="p">,</span> <span class="nv">$guard</span> <span class="o">=</span> <span class="k">null</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">Auth</span><span class="o">::</span><span class="na">guard</span><span class="p">(</span><span class="nv">$guard</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">guest</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">response</span><span class="p">(</span><span class="s1">&#39;没有设置token.&#39;</span><span class="p">,</span> <span class="mi">401</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nv">$next</span><span class="p">(</span><span class="nv">$request</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ol>
<p>8. 做了以上修改之后，当我们以 <code class="docutils literal"><span class="pre">/t</span></code> 这个 <code class="docutils literal"><span class="pre">url</span></code> 路径向服务器直接发起请求时，服务器就会返回一个 <code class="docutils literal"><span class="pre">401</span></code> 错误，并且会返回一条 <code class="docutils literal"><span class="pre">没有设置token.</span></code> 这样的消息，这也是我们之前在 <code class="docutils literal"><span class="pre">handle()</span></code> 方法中设置的。也就是说 <code class="docutils literal"><span class="pre">/t</span></code> 已经被我们的 <code class="docutils literal"><span class="pre">auth</span></code> 中间件保护起来了。如果想要我们的请求能够正常通过这个中间件，就要提供 <code class="docutils literal"><span class="pre">token</span></code> 。
由于我们之前在 <code class="docutils literal"><span class="pre">user</span></code> 表中添加了一条 <code class="docutils literal"><span class="pre">api_token</span></code> 为 <code class="docutils literal"><span class="pre">123456</span></code> 的数据，所以现在我们再次向服务器请求 <code class="docutils literal"><span class="pre">/t</span></code> ，但是这次我们加入 <code class="docutils literal"><span class="pre">api_token</span></code> ，也就是 <code class="docutils literal"><span class="pre">.../t?api_token=123456</span></code></p>
<p>正常情况下，服务器就会返回 'ok' 了，这也就是说明， <code class="docutils literal"><span class="pre">auth</span></code> 中间件允许这个请求通过。而当我们把 <code class="docutils literal"><span class="pre">123456</span></code> 修改为其他值时，这个请求也是无法通过 <code class="docutils literal"><span class="pre">auth</span></code> 中间件的。</p>
<p>当然，上面只是最简单的实现方式，在实际的应用中会比这个更加复杂。复杂的情况可以使用 <a href="#id23"><span class="problematic" id="id24">`jwt-auth &lt;&gt;`_</span></a></p>
</div>
<div class="section" id="laraveljwt">
<h2>32.6. Laravel使用JWT认证<a class="headerlink" href="#laraveljwt" title="永久链接至标题">¶</a></h2>
<p>我们可以提供使用 <code class="docutils literal"><span class="pre">JWT</span></code> 来轻松的实现我们需要的 <code class="docutils literal"><span class="pre">API</span></code> 级别的用户认证功能。在 Laravel 中使用 <code class="docutils literal"><span class="pre">JWT</span></code> 我们通常使用 <a class="reference external" href="https://github.com/tymondesigns/jwt-auth">jwt-auth</a></p>
<div class="section" id="id15">
<h3>32.6.1. 安装<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal"><span class="pre">jwt-auth</span></code> 最新版本是 <code class="docutils literal"><span class="pre">1.0.0</span> <span class="pre">rc.1</span></code> 版本，已经支持了 Laravel 5.5 。如果你使用的是 Laravel 5.5 版本，可以使用如下命令安装。根据评论区 &#64;tradzero 兄弟的建议，如果你是 Laravel 5.5 以下版本，也推荐使用最新版本， RC.1 前的版本都存在多用户 <code class="docutils literal"><span class="pre">token</span></code> 认证的安全问题。</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>$ composer require tymon/jwt-auth <span class="m">1</span>.0.0-rc.1
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">一定要注意带上版本，否则下载的包不匹配。</p>
</div>
</div>
<div class="section" id="id16">
<h3>32.6.2. 配置<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h3>
<div class="section" id="id17">
<h4>32.6.2.1. 添加服务提供商<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h4>
<p>将下面这行添加至 <code class="docutils literal"><span class="pre">config/app.php</span></code> 文件 <code class="docutils literal"><span class="pre">providers</span></code> 数组中：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="x">&#39;providers&#39; =&gt; [</span>

<span class="x">    ...</span>

<span class="x">    Tymon\JWTAuth\Providers\JWTAuthServiceProvider::class,</span>
<span class="x">]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">5.5存在自动包门面和服务提供器注册，所以没有必要手动添加。</p>
</div>
</div>
<div class="section" id="id18">
<h4>32.6.2.2. 发布配置文件<a class="headerlink" href="#id18" title="永久链接至标题">¶</a></h4>
<p>在你的 <code class="docutils literal"><span class="pre">shell</span></code> 中运行如下命令发布 <code class="docutils literal"><span class="pre">jwt-auth</span></code> 的配置文件：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>php artisan vendor:publish --provider<span class="o">=</span><span class="s2">&quot;Tymon\JWTAuth\Providers\LaravelServiceProvider&quot;</span>
</pre></div>
</div>
<p>此命令会在 <code class="docutils literal"><span class="pre">config</span></code> 目录下生成一个 <code class="docutils literal"><span class="pre">jwt.php</span></code> 配置文件，你可以在此进行自定义配置。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">由于前面已经添加了服务提供器，所以上面命令的参数可以省略。</p>
</div>
</div>
<div class="section" id="id19">
<h4>32.6.2.3. 生成密钥<a class="headerlink" href="#id19" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">jwt-auth</span></code> 已经预先定义好了一个 <code class="docutils literal"><span class="pre">Artisan</span></code> 命令方便你生成 <code class="docutils literal"><span class="pre">Secret</span></code> ，你只需要在你的 <code class="docutils literal"><span class="pre">shell</span></code> 中运行如下命令即可：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>php artisan jwt:secret
</pre></div>
</div>
<p>此命令会在你的 <code class="docutils literal"><span class="pre">.env</span></code> 文件中新增一行 <code class="docutils literal"><span class="pre">JWT_SECRET=secret</span></code> 。它是用于签署令牌的密钥。</p>
</div>
<div class="section" id="auth-guard">
<h4>32.6.2.4. 配置 Auth guard<a class="headerlink" href="#auth-guard" title="永久链接至标题">¶</a></h4>
<p>在 <code class="docutils literal"><span class="pre">config/auth.php</span></code> 文件中，你需要将 <code class="docutils literal"><span class="pre">guards/driver</span></code> 更新为 <code class="docutils literal"><span class="pre">jwt</span></code> ：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="s1">&#39;defaults&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span>
    <span class="s1">&#39;guard&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;api&#39;</span><span class="p">,</span>
    <span class="s1">&#39;passwords&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;users&#39;</span><span class="p">,</span>
<span class="p">],</span>

<span class="o">...</span>

<span class="s1">&#39;guards&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span>
    <span class="s1">&#39;api&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span>
        <span class="s1">&#39;driver&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;jwt&#39;</span><span class="p">,</span>
        <span class="s1">&#39;provider&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;users&#39;</span><span class="p">,</span>
    <span class="p">],</span>
<span class="p">],</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">只有在使用 Laravel 5.2 及以上版本的情况下才能使用。</p>
</div>
</div>
</div>
<div class="section" id="model">
<h3>32.6.3. 更改 Model<a class="headerlink" href="#model" title="永久链接至标题">¶</a></h3>
<p>如果需要使用 <code class="docutils literal"><span class="pre">jwt-auth</span></code> 作为用户认证，我们需要对我们的 <code class="docutils literal"><span class="pre">User</span></code> 模型进行一点小小的改变，实现一个接口，变更后的 <code class="docutils literal"><span class="pre">User</span></code> 模型如下：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>

<span class="k">namespace</span> <span class="nx">App</span><span class="p">;</span>

<span class="k">use</span> <span class="nx">Tymon\JWTAuth\Contracts\JWTSubject</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Illuminate\Notifications\Notifiable</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Illuminate\Foundation\Auth\User</span> <span class="k">as</span> <span class="nx">Authenticatable</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">User</span> <span class="k">extends</span> <span class="nx">Authenticatable</span> <span class="k">implements</span> <span class="nx">JWTSubject</span>
<span class="p">{</span>
    <span class="k">use</span> <span class="nx">Notifiable</span><span class="p">;</span>

    <span class="c1">// Rest omitted for brevity</span>

    <span class="sd">/**</span>
<span class="sd">     * Get the identifier that will be stored in the subject claim of the JWT.</span>
<span class="sd">     *</span>
<span class="sd">     * @return mixed</span>
<span class="sd">     */</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">getJWTIdentifier</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">getKey</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="sd">/**</span>
<span class="sd">     * Return a key value array, containing any custom claims to be added to the JWT.</span>
<span class="sd">     *</span>
<span class="sd">     * @return array</span>
<span class="sd">     */</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">getJWTCustomClaims</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="p">[];</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id20">
<h3>32.6.4. 增加一些认证路由<a class="headerlink" href="#id20" title="永久链接至标题">¶</a></h3>
<p>首先让我们在 <code class="docutils literal"><span class="pre">routes/api.php</span></code> 中添加一些路由，如下所示：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="nx">Route</span><span class="o">::</span><span class="na">group</span><span class="p">([</span>
    <span class="s1">&#39;prefix&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;auth&#39;</span>
<span class="p">],</span> <span class="k">function</span> <span class="p">()</span> <span class="p">{</span>

    <span class="nx">Route</span><span class="o">::</span><span class="na">post</span><span class="p">(</span><span class="s1">&#39;login&#39;</span><span class="p">,</span> <span class="s1">&#39;API\AuthController@login&#39;</span><span class="p">);</span>
    <span class="nx">Route</span><span class="o">::</span><span class="na">post</span><span class="p">(</span><span class="s1">&#39;logout&#39;</span><span class="p">,</span> <span class="s1">&#39;API\AuthController@logout&#39;</span><span class="p">);</span>
    <span class="nx">Route</span><span class="o">::</span><span class="na">post</span><span class="p">(</span><span class="s1">&#39;refresh&#39;</span><span class="p">,</span> <span class="s1">&#39;API\AuthController@refresh&#39;</span><span class="p">);</span>
    <span class="nx">Route</span><span class="o">::</span><span class="na">post</span><span class="p">(</span><span class="s1">&#39;me&#39;</span><span class="p">,</span> <span class="s1">&#39;API\AuthController@me&#39;</span><span class="p">);</span>

<span class="p">});</span>
</pre></div>
</div>
</div>
<div class="section" id="authcontroller">
<h3>32.6.5. 创建AuthController<a class="headerlink" href="#authcontroller" title="永久链接至标题">¶</a></h3>
<p>手动或者使用artisan命令创建控制器：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>php artisan make:controller API/AuthController
</pre></div>
</div>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>

<span class="k">namespace</span> <span class="nx">App\Http\Controllers\API</span><span class="p">;</span>

<span class="k">use</span> <span class="nx">Illuminate\Http\Request</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">App\Http\Controllers\Controller</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">AuthController</span> <span class="k">extends</span> <span class="nx">Controller</span>
<span class="p">{</span>
    <span class="sd">/**</span>
<span class="sd">     * Create a new AuthController instance.</span>
<span class="sd">     *</span>
<span class="sd">     * @return void</span>
<span class="sd">     */</span>
    <span class="k">public</span> <span class="k">function</span> <span class="fm">__construct</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">middleware</span><span class="p">(</span><span class="s1">&#39;auth:api&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;except&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">&#39;login&#39;</span><span class="p">]]);</span>
    <span class="p">}</span>

    <span class="sd">/**</span>
<span class="sd">     * Get a JWT via given credentials.</span>
<span class="sd">     *</span>
<span class="sd">     * @return \Illuminate\Http\JsonResponse</span>
<span class="sd">     */</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">login</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="nv">$credentials</span> <span class="o">=</span> <span class="nx">request</span><span class="p">([</span><span class="s1">&#39;email&#39;</span><span class="p">,</span> <span class="s1">&#39;password&#39;</span><span class="p">]);</span>
        <span class="c1">// 注意这里需要指定守护者，非默认的</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="nv">$token</span> <span class="o">=</span> <span class="nx">auth</span><span class="p">(</span><span class="s1">&#39;api&#39;</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">attempt</span><span class="p">(</span><span class="nv">$credentials</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">response</span><span class="p">()</span><span class="o">-&gt;</span><span class="na">json</span><span class="p">([</span><span class="s1">&#39;error&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;Unauthorized&#39;</span><span class="p">],</span> <span class="mi">401</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">respondWithToken</span><span class="p">(</span><span class="nv">$token</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="sd">/**</span>
<span class="sd">     * Get the authenticated User.</span>
<span class="sd">     *</span>
<span class="sd">     * @return \Illuminate\Http\JsonResponse</span>
<span class="sd">     */</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">me</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nx">response</span><span class="p">()</span><span class="o">-&gt;</span><span class="na">json</span><span class="p">(</span><span class="nx">auth</span><span class="p">()</span><span class="o">-&gt;</span><span class="na">user</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="sd">/**</span>
<span class="sd">     * Log the user out (Invalidate the token).</span>
<span class="sd">     *</span>
<span class="sd">     * @return \Illuminate\Http\JsonResponse</span>
<span class="sd">     */</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">logout</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="nx">auth</span><span class="p">()</span><span class="o">-&gt;</span><span class="na">logout</span><span class="p">();</span>

        <span class="k">return</span> <span class="nx">response</span><span class="p">()</span><span class="o">-&gt;</span><span class="na">json</span><span class="p">([</span><span class="s1">&#39;message&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;Successfully logged out&#39;</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="sd">/**</span>
<span class="sd">     * Refresh a token.</span>
<span class="sd">     *</span>
<span class="sd">     * @return \Illuminate\Http\JsonResponse</span>
<span class="sd">     */</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">refresh</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">respondWithToken</span><span class="p">(</span><span class="nx">auth</span><span class="p">()</span><span class="o">-&gt;</span><span class="na">refresh</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="sd">/**</span>
<span class="sd">     * Get the token array structure.</span>
<span class="sd">     *</span>
<span class="sd">     * @param  string $token</span>
<span class="sd">     *</span>
<span class="sd">     * @return \Illuminate\Http\JsonResponse</span>
<span class="sd">     */</span>
    <span class="k">protected</span> <span class="k">function</span> <span class="nf">respondWithToken</span><span class="p">(</span><span class="nv">$token</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nx">response</span><span class="p">()</span><span class="o">-&gt;</span><span class="na">json</span><span class="p">([</span>
            <span class="s1">&#39;access_token&#39;</span> <span class="o">=&gt;</span> <span class="nv">$token</span><span class="p">,</span>
            <span class="s1">&#39;token_type&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;bearer&#39;</span><span class="p">,</span>
            <span class="s1">&#39;expires_in&#39;</span> <span class="o">=&gt;</span> <span class="nx">auth</span><span class="p">(</span><span class="s1">&#39;api&#39;</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">factory</span><span class="p">()</span><span class="o">-&gt;</span><span class="na">getTTL</span><span class="p">()</span> <span class="o">*</span> <span class="mi">60</span>
        <span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id21">
<h2>32.7. 使用包中间件<a class="headerlink" href="#id21" title="永久链接至标题">¶</a></h2>
<p><code class="docutils literal"><span class="pre">jwt-auth</span></code> 包中存在如下的中间件：</p>
<ul class="simple">
<li>jwt.auth ：认证；</li>
<li>jwt.check ：检查认证；</li>
<li>jwt.refresh ： 刷新token；</li>
<li>jwt.renew ： 认证后立即刷新token；</li>
</ul>
<div class="section" id="id22">
<h3>32.7.1. 定义路由<a class="headerlink" href="#id22" title="永久链接至标题">¶</a></h3>
<p>在 <code class="docutils literal"><span class="pre">routes/api.php</span></code> 中，更新给定 <code class="docutils literal"><span class="pre">api</span></code> 路由：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="nx">Route</span><span class="o">::</span><span class="na">post</span><span class="p">(</span><span class="s1">&#39;login&#39;</span><span class="p">,</span> <span class="s1">&#39;API\AuthController@login&#39;</span><span class="p">);</span>
<span class="nx">Route</span><span class="o">::</span><span class="na">middleware</span><span class="p">(</span><span class="s1">&#39;jwt.auth&#39;</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">group</span><span class="p">(</span><span class="k">function</span><span class="p">(){</span>

    <span class="nx">Route</span><span class="o">::</span><span class="na">get</span><span class="p">(</span><span class="s1">&#39;logout&#39;</span><span class="p">,</span> <span class="s1">&#39;API\AuthController@logout&#39;</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>
</div>
<p>控制器代码如下：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">class</span> <span class="nc">AuthController</span> <span class="k">extends</span> <span class="nx">Controller</span>
<span class="p">{</span>
    <span class="sd">/**</span>
<span class="sd">     * API Login, on success return JWT Auth token</span>
<span class="sd">     * @param Request $request</span>
<span class="sd">     * @return JsonResponse</span>
<span class="sd">     */</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">login</span><span class="p">(</span><span class="nx">Request</span> <span class="nv">$request</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$credentials</span> <span class="o">=</span> <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">only</span><span class="p">(</span><span class="s1">&#39;email&#39;</span><span class="p">,</span> <span class="s1">&#39;password&#39;</span><span class="p">);</span>
        <span class="nv">$rules</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s1">&#39;email&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;required|email&#39;</span><span class="p">,</span>
            <span class="s1">&#39;password&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;required&#39;</span><span class="p">,</span>
        <span class="p">];</span>
        <span class="nv">$validator</span> <span class="o">=</span> <span class="nx">Validator</span><span class="o">::</span><span class="na">make</span><span class="p">(</span><span class="nv">$credentials</span><span class="p">,</span> <span class="nv">$rules</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="nv">$validator</span><span class="o">-&gt;</span><span class="na">fails</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">response</span><span class="p">()</span><span class="o">-&gt;</span><span class="na">json</span><span class="p">([</span>
                <span class="s1">&#39;status&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;error&#39;</span><span class="p">,</span>
                <span class="s1">&#39;message&#39;</span> <span class="o">=&gt;</span> <span class="nv">$validator</span><span class="o">-&gt;</span><span class="na">messages</span><span class="p">()</span>
            <span class="p">]);</span>
        <span class="p">}</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="c1">// Attempt to verify the credentials and create a token for the user</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="nv">$token</span> <span class="o">=</span> <span class="nx">JWTAuth</span><span class="o">::</span><span class="na">attempt</span><span class="p">(</span><span class="nv">$credentials</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">response</span><span class="p">()</span><span class="o">-&gt;</span><span class="na">json</span><span class="p">([</span>
                    <span class="s1">&#39;status&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;error&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;message&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;We can`t find an account with this credentials.&#39;</span>
                <span class="p">],</span> <span class="mi">401</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">JWTException</span> <span class="nv">$e</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Something went wrong with JWT Auth.</span>
            <span class="k">return</span> <span class="nx">response</span><span class="p">()</span><span class="o">-&gt;</span><span class="na">json</span><span class="p">([</span>
                <span class="s1">&#39;status&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;error&#39;</span><span class="p">,</span>
                <span class="s1">&#39;message&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;Failed to login, please try again.&#39;</span>
            <span class="p">],</span> <span class="mi">500</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">// All good so return the token</span>
        <span class="k">return</span> <span class="nx">response</span><span class="p">()</span><span class="o">-&gt;</span><span class="na">json</span><span class="p">([</span>
            <span class="s1">&#39;status&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;success&#39;</span><span class="p">,</span>
            <span class="s1">&#39;data&#39;</span><span class="o">=&gt;</span> <span class="p">[</span>
                <span class="s1">&#39;token&#39;</span> <span class="o">=&gt;</span> <span class="nv">$token</span>
                <span class="c1">// You can add more details here as per you requirment.</span>
            <span class="p">]</span>
        <span class="p">]);</span>
    <span class="p">}</span>
    <span class="sd">/**</span>
<span class="sd">     * Logout</span>
<span class="sd">     * Invalidate the token. User have to relogin to get a new token.</span>
<span class="sd">     * @param Request $request &#39;header&#39;</span>
<span class="sd">     */</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">logout</span><span class="p">(</span><span class="nx">Request</span> <span class="nv">$request</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Get JWT Token from the request header key &quot;Authorization&quot;</span>
        <span class="nv">$token</span> <span class="o">=</span> <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">header</span><span class="p">(</span><span class="s1">&#39;Authorization&#39;</span><span class="p">);</span>
        <span class="c1">// Invalidate the token</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="nx">JWTAuth</span><span class="o">::</span><span class="na">invalidate</span><span class="p">(</span><span class="nv">$token</span><span class="p">);</span>
            <span class="k">return</span> <span class="nx">response</span><span class="p">()</span><span class="o">-&gt;</span><span class="na">json</span><span class="p">([</span>
                <span class="s1">&#39;status&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;success&#39;</span><span class="p">,</span>
                <span class="s1">&#39;message&#39;</span><span class="o">=&gt;</span> <span class="s2">&quot;User successfully logged out.&quot;</span>
            <span class="p">]);</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">JWTException</span> <span class="nv">$e</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// something went wrong whilst attempting to encode the token</span>
            <span class="k">return</span> <span class="nx">response</span><span class="p">()</span><span class="o">-&gt;</span><span class="na">json</span><span class="p">([</span>
              <span class="s1">&#39;status&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;error&#39;</span><span class="p">,</span>
              <span class="s1">&#39;message&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;Failed to logout, please try again.&#39;</span>
            <span class="p">],</span> <span class="mi">500</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>参考资料：</p>
<p><a class="reference external" href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html">http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html</a></p>
<p><a class="reference external" href="https://segmentfault.com/a/1190000012606246">https://segmentfault.com/a/1190000012606246</a></p>
<p><a class="reference external" href="https://jwt.io/introduction/">https://jwt.io/introduction/</a></p>
<p><a class="reference external" href="https://jwt-auth.readthedocs.io/en/develop/quick-start/">https://jwt-auth.readthedocs.io/en/develop/quick-start/</a></p>
</div>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Laravel的API认证系统Passport.html" class="btn btn-neutral float-right" title="33. Laravel 的 API 认证系统 Passport" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="Laravel的用户认证系统.html" class="btn btn-neutral" title="31. Laravel 的用户认证系统" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, lzh.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.0',
            LANGUAGE:'zh',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  

<script type="text/javascript">
  
      $(document).ready(function(){
        var offset = sessionStorage.getItem("offsetTop");
        $('.wy-side-scroll').scrollTop(offset);
        sessionStorage.setItem("offsetTop", 0);


        $('.wy-menu > ul').click(function(){
            sessionStorage.setItem("offsetTop", $('.wy-side-scroll').scrollTop());
        });
      })

  </script> 

</body>
</html>