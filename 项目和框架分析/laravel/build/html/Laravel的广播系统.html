

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>36. 广播 &mdash; laravel 1.0 文档</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="索引"
              href="genindex.html"/>
        <link rel="search" title="搜索" href="search.html"/>
    <link rel="top" title="laravel 1.0 文档" href="index.html"/>
        <link rel="next" title="37. 广播系统原理分析" href="Laravel的广播系统原理分析.html"/>
        <link rel="prev" title="35. 命令行" href="Laravel的命令行.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> laravel
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">目录:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="请求到响应的生命周期-web.html">1. 请求到web响应的生命周期</a></li>
<li class="toctree-l1"><a class="reference internal" href="请求到响应的生命周期-console.html">2. 请求到console响应的生命周期</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的容器.html">3. 容器</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的Facades.html">4. Facades</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的Facades原理分析.html">5. Facade的原理</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的服务提供器.html">6. 服务提供器</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的路由.html">7. 路由</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的路由—路由的正则编译.html">8. 路由的正则编译</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的路由—路由的匹配与参数绑定.html">9. 路由的匹配与参数绑定</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的路由—路由中间件.html">10. 路由的中间件</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的中间件.html">11. 中间件</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的中间件-SubstituteBindings.html">12. 中间件SubstituteBindings</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的中间件-CSRF.html">13. 中间件CSRF</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的请求.html">14. 请求</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的控制器.html">15. 控制器</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的控制器—控制器方法的参数构建与运行.html">16. 控制器方法的参数构建与运行</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的响应.html">17. 响应</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的视图.html">18. 视图</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的生成URL.html">19. URL</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的Session.html">20. Session</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的Session原理分析.html">21. Session原理分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的表单验证机制详解.html">22. 表单验证机制详解</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的日志.html">23. 日志</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的异常和错误处理.html">24. 异常和错误处理</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的异常和错误处理原理分析.html">25. 异常和错误处理原理分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的Blade.html">26. Blade</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的blade原理分析.html">27. Blade原理分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的前端.html">28. 前端</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的Mix.html">29. Mix</a></li>
<li class="toctree-l1"><a class="reference internal" href="laravel-mix.html">30. mix使用手册</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的用户认证系统.html">31. Laravel 的用户认证系统</a></li>
<li class="toctree-l1"><a class="reference internal" href="用户认证JWT.html">32. 用户认证JWT</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的API认证系统Passport.html">33. Laravel 的 API 认证系统 Passport</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的用户授权系统.html">34. Laravel用户授权系统</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的命令行.html">35. 命令行</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">36. 广播</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id2">36.1. 简介</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id3">36.1.1. 配置</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">36.1.2. 对驱动器的要求</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id7">36.2. 概念综述</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id8">36.2.1. 使用示例程序</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id12">36.3. 定义广播事件</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id13">36.3.1. 广播名称</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id14">36.3.2. 广播数据</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id15">36.3.3. 广播队列</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id16">36.3.4. 广播条件</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id17">36.4. 频道授权</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id18">36.4.1. 定义授权路由</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id19">36.4.2. 定义授权回调</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id21">36.4.3. 定义频道类</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id22">36.5. 广播事件</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id23">36.5.1. 只广播给他人</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id24">36.5.2. 配置</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id25">36.6. 接收广播</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id26">36.6.1. 安装 Laravel Echo</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id27">36.6.2. 对事件进行监听</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id28">36.6.3. 退出频道</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id29">36.6.4. 命名空间</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#presence">36.7. Presence 频道</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id30">36.7.1. 授权 Presence 频道</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id31">36.7.2. 加入 Presence 频道</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id32">36.7.3. 广播到 Presence 频道</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id33">36.8. 客户端事件</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id34">36.9. 消息通知</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的广播系统原理分析.html">37. 广播系统原理分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的缓存系统.html">38. 缓存</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的集合Collection.html">39. 集合</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的事件系统.html">40. 事件</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的事件系统原理分析.html">41. 事件系统原理分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的文件存储.html">42. 文件存储</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的辅助函数-字符串操作.html">43. 辅助函数-字符串函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的辅助函数-数组和对象操作.html">44. 辅助函数-数组和对象函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的辅助函数-路径操作.html">45. 辅助函数-路径函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的辅助函数-tap分析.html">46. 辅助函数-Tap函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的辅助函数-其它.html">47. 辅助函数-其它杂项</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的邮件发送功能.html">48. 邮件</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的消息通知.html">49. 通知</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel Queue——消息队列任务与分发源码剖析.html">50. 消息队列任务与分发源码剖析</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的任务调度.html">51. 任务调度</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的数据库—原始方式.html">52. 数据库-原始操作</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的数据库—查询构造器.html">53. 数据库-查询构建器</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的数据分页.html">54. 数据分页</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的数据分页原理分析.html">55. 数据分页原理分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的数据库迁移.html">56. 数据库迁移</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的数据库填充.html">57. 数据库填充</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的Redis.html">58. Redis</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的Redis原理分析.html">59. Redis原理分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的数据库—Eloquent.html">60. Eloquent</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的数据库—Eloquent关联.html">61. Eloquent关联</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的数据库—Eloquent修改器.html">62. Eloquent修改器</a></li>
<li class="toctree-l1"><a class="reference internal" href="Laravel的验证规则.html">63. 验证规则</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">laravel</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>36. 广播</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            
        
        <a href="http://blog.liaozhonghao.cn" rel="nofollow"> 返回主页</a>
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>36. 广播<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<div class="section" id="id2">
<h2>36.1. 简介<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>在现代的 <code class="docutils literal"><span class="pre">web</span></code> 应用程序中， <code class="docutils literal"><span class="pre">WebSockets</span></code> 被用来实现需要实时、即时更新的接口。当服务器上的数据被更新后，更新信息将通过 <code class="docutils literal"><span class="pre">WebSocket</span></code> 连接发送到客户端等待处理。相比于不停地轮询应用程序， <code class="docutils literal"><span class="pre">WebSocket</span></code> 是一种更加可靠和高效的选择。</p>
<p>为了帮助你建立这类应用, Laravel 将通过 <code class="docutils literal"><span class="pre">WebSocket</span></code> 连接来使「广播」事件 变得更加轻松。广播事件允许你在服务端代码和客户端 <code class="docutils literal"><span class="pre">JavaScript</span></code> 应用之间共享相同的事件名。</p>
<div class="section" id="id3">
<h3>36.1.1. 配置<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<p>所有关于事件广播的配置都被保存在 <code class="docutils literal"><span class="pre">config/broadcasting.php</span></code> 文件中。 Laravel 自带了几个广播驱动器： <code class="docutils literal"><span class="pre">Pusher</span></code> 、 <code class="docutils literal"><span class="pre">Redis</span></code> ，和一个用于本地开发与调试的 <code class="docutils literal"><span class="pre">log</span></code> 驱动器。另外，还有一个 <code class="docutils literal"><span class="pre">null</span></code> 驱动器可以让你完全关闭广播功能。每一个驱动的示例配置都可以在 <code class="docutils literal"><span class="pre">config/broadcasting.php</span></code> 文件中被找到。</p>
<div class="section" id="id4">
<h4>36.1.1.1. 广播服务提供器<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>在对事件进行广播之前，你必须先注册 <code class="docutils literal"><span class="pre">App\Providers\BroadcastServiceProvider</span></code> 。对于一个全新安装的 Laravel 应用程序，你只需在 <code class="docutils literal"><span class="pre">config/app.php</span></code> 配置文件的 <code class="docutils literal"><span class="pre">providers</span></code> 数组中取消对该提供器的注释即可。该提供器将允许你注册广播授权路由和回调。</p>
</div>
<div class="section" id="csrf">
<h4>36.1.1.2. CSRF 令牌<a class="headerlink" href="#csrf" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal"><span class="pre">Laravel</span> <span class="pre">Echo</span></code> 需要访问当前会话的 <code class="docutils literal"><span class="pre">CSRF</span></code> 令牌。 你应该验证您的应用程序的头部 <code class="docutils literal"><span class="pre">HTML</span></code> 元素是否定义了包含 <code class="docutils literal"><span class="pre">CSRF</span></code> 标记的 <code class="docutils literal"><span class="pre">meta</span></code> 标签：</p>
<div class="highlight-html"><div class="highlight"><pre><span></span><span class="p">&lt;</span><span class="nt">meta</span> <span class="na">name</span><span class="o">=</span><span class="s">&quot;csrf-token&quot;</span> <span class="na">content</span><span class="o">=</span><span class="s">&quot;{{ csrf_token() }}&quot;</span><span class="p">&gt;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id5">
<h3>36.1.2. 对驱动器的要求<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<div class="section" id="pusher">
<h4>36.1.2.1. Pusher<a class="headerlink" href="#pusher" title="永久链接至标题">¶</a></h4>
<p>创pusher账号，到网站注册一个。</p>
<p>我们需要配置Laravel使用 <code class="docutils literal"><span class="pre">Pusher</span></code> 作为其广播驱动程序，</p>
<div class="highlight-ini"><div class="highlight"><pre><span></span><span class="na">PUSHER_APP_ID</span><span class="o">=</span><span class="s">322700</span>
<span class="na">BROADCAST_DRIVER</span><span class="o">=</span><span class="s">pusher</span>

<span class="na">// Get the credentials from your pusher dashboard</span>
<span class="na">PUSHER_APP_ID</span><span class="o">=</span><span class="s">XXXXX</span>
<span class="na">PUSHER_APP_KEY</span><span class="o">=</span><span class="s">XXXXXXX</span>
<span class="na">PUSHER_APP_SECRET</span><span class="o">=</span><span class="s">XXXXXXX</span>
</pre></div>
</div>
<p>如果你使用 <code class="docutils literal"><span class="pre">Pusher</span></code> 对事件进行广播，请用 <code class="docutils literal"><span class="pre">Composer</span></code> 包管理器来安装 <code class="docutils literal"><span class="pre">Pusher</span> <span class="pre">PHP</span> <span class="pre">SDK</span></code> ：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>composer require pusher/pusher-php-server <span class="s2">&quot;~3.0&quot;</span>
</pre></div>
</div>
<p>然后，你需要在 <code class="docutils literal"><span class="pre">config/broadcasting.php</span></code> 配置文件中填写你的 <code class="docutils literal"><span class="pre">Pusher</span></code> 证书。该文件中已经包含了一个 <code class="docutils literal"><span class="pre">Pusher</span></code> 示例配置，你只需指定 <code class="docutils literal"><span class="pre">Pusher</span> <span class="pre">key</span></code> 、 <code class="docutils literal"><span class="pre">secret</span></code> 和 <code class="docutils literal"><span class="pre">application</span> <span class="pre">ID</span></code> 即可。 <code class="docutils literal"><span class="pre">config/broadcasting.php</span></code> 中的 <code class="docutils literal"><span class="pre">pusher</span></code> 配置项同时也允许你指定 <code class="docutils literal"><span class="pre">Pusher</span></code> 支持的 <code class="docutils literal"><span class="pre">options</span></code> ，例如 <code class="docutils literal"><span class="pre">cluster</span></code> ：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="s1">&#39;options&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span>
    <span class="s1">&#39;cluster&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;eu&#39;</span><span class="p">,</span>
    <span class="s1">&#39;encrypted&#39;</span> <span class="o">=&gt;</span> <span class="k">true</span>
<span class="p">],</span>
</pre></div>
</div>
<p>当把 <code class="docutils literal"><span class="pre">Pusher</span></code> 和 <code class="docutils literal"><span class="pre">Laravel</span> <span class="pre">Echo</span></code> 一起使用时，你应该在 <code class="docutils literal"><span class="pre">resources/assets/js/bootstrap.js</span></code> 文件中实例化 <code class="docutils literal"><span class="pre">Echo</span></code> 对象时指定 <code class="docutils literal"><span class="pre">pusher</span></code> 作为所需要的 <code class="docutils literal"><span class="pre">broadcaster</span></code> :</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>npm install --save laravel-echo pusher-js
</pre></div>
</div>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nx">Echo</span> <span class="nx">from</span> <span class="s2">&quot;laravel-echo&quot;</span>

<span class="nb">window</span><span class="p">.</span><span class="nx">Pusher</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;pusher-js&#39;</span><span class="p">);</span>

<span class="nb">window</span><span class="p">.</span><span class="nx">Echo</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Echo</span><span class="p">({</span>
    <span class="nx">broadcaster</span><span class="o">:</span> <span class="s1">&#39;pusher&#39;</span><span class="p">,</span>
    <span class="nx">key</span><span class="o">:</span> <span class="s1">&#39;your-pusher-key&#39;</span>
<span class="p">});</span>
</pre></div>
</div>
</div>
<div class="section" id="redis">
<h4>36.1.2.2. Redis<a class="headerlink" href="#redis" title="永久链接至标题">¶</a></h4>
<p>如果你使用 <code class="docutils literal"><span class="pre">Redis</span></code> 广播器，请安装 <code class="docutils literal"><span class="pre">Predis</span></code> 库：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>composer require predis/predis
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">Redis</span></code> 广播器会使用 <code class="docutils literal"><span class="pre">Redis</span></code> 的「生产者/消费者」特性来广播消息；尽管如此，你仍需将它与 <code class="docutils literal"><span class="pre">WebSocket</span></code> 服务器一起使用。 <code class="docutils literal"><span class="pre">WebSocket</span></code> 服务器会从 <code class="docutils literal"><span class="pre">Redis</span></code> 接收消息，然后再将消息广播到你的 <code class="docutils literal"><span class="pre">WebSocket</span></code> 频道上去。</p>
<p>当 <code class="docutils literal"><span class="pre">Redis</span></code> 广播器发布一个事件时，该事件会被发布到它指定的频道上去，传输的数据是一个采用 <code class="docutils literal"><span class="pre">JSON</span></code> 编码的字符串。该字符串包含了事件名、 <code class="docutils literal"><span class="pre">data</span></code> 数据和生成该事件套接字 <code class="docutils literal"><span class="pre">ID</span></code> 的用户（如果可用的话）。</p>
<p>Socket.IO</p>
<p>如果你想把 <code class="docutils literal"><span class="pre">Redis</span></code> 广播器和 <code class="docutils literal"><span class="pre">Socket.IO</span></code> 服务器一起使用，你需要将 <code class="docutils literal"><span class="pre">Socket.IO</span> <span class="pre">JavaScript</span></code> 客户端库文件包含到应用程序的 <code class="docutils literal"><span class="pre">head</span> <span class="pre">HTML</span></code> 元素中。当 <code class="docutils literal"><span class="pre">Socket.IO</span></code> 服务启动的时候，它会自动把 <code class="docutils literal"><span class="pre">Socket.IO</span> <span class="pre">JavaScript</span></code> 客户端库暴露在一个标准的 <code class="docutils literal"><span class="pre">URL</span></code> 中。例如，如果你的应用和 <code class="docutils literal"><span class="pre">Socket.IO</span></code> 服务器运行在同域名下，你可以像下面这样来访问你的 <code class="docutils literal"><span class="pre">Socket.IO</span> <span class="pre">JavaScript</span></code> 客户端库：</p>
<p>安装 Laravel Echo</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>npm install --save laravel-echo
</pre></div>
</div>
<div class="highlight-html"><div class="highlight"><pre><span></span><span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">&quot;//{{ Request::getHost() }}:6001/socket.io/socket.io.js&quot;</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>接着，你需要在实例化 <code class="docutils literal"><span class="pre">Echo</span></code> 时指定 <code class="docutils literal"><span class="pre">socket.io</span></code> 连接器和 <code class="docutils literal"><span class="pre">host</span></code> 。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nx">Echo</span> <span class="nx">from</span> <span class="s2">&quot;laravel-echo&quot;</span>

<span class="nb">window</span><span class="p">.</span><span class="nx">Echo</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Echo</span><span class="p">({</span>
    <span class="nx">broadcaster</span><span class="o">:</span> <span class="s1">&#39;socket.io&#39;</span><span class="p">,</span>
    <span class="nx">host</span><span class="o">:</span> <span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">hostname</span> <span class="o">+</span> <span class="s1">&#39;:6001&#39;</span>
<span class="p">});</span>
</pre></div>
</div>
<p>这里还可以把 <code class="docutils literal"><span class="pre">socket.io-client</span></code> 集成到 <code class="docutils literal"><span class="pre">app.js</span></code> 文件中，这样就不用在客户端引用 <code class="docutils literal"><span class="pre">socket.io.js</span></code> 。</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>npm install --save socket.io-client
</pre></div>
</div>
<p>在 <code class="docutils literal"><span class="pre">bootstrap.js</span></code> 中注册 <code class="docutils literal"><span class="pre">Echo</span></code></p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nx">Echo</span> <span class="nx">from</span> <span class="s2">&quot;laravel-echo&quot;</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">io</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;socket.io-client&#39;</span><span class="p">);</span>
<span class="c1">// Have this in case you stop running your laravel echo server</span>
<span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">io</span> <span class="o">!==</span> <span class="s1">&#39;undefined&#39;</span><span class="p">)</span> <span class="p">{</span>
  <span class="nb">window</span><span class="p">.</span><span class="nx">Echo</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Echo</span><span class="p">({</span>
    <span class="nx">broadcaster</span><span class="o">:</span> <span class="s1">&#39;socket.io&#39;</span><span class="p">,</span>
    <span class="nx">host</span><span class="o">:</span> <span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">hostname</span> <span class="o">+</span> <span class="s1">&#39;:6001&#39;</span><span class="p">,</span>
  <span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
<p>最后，你需要运行一个与 Laravel 兼容的 <code class="docutils literal"><span class="pre">Socket.IO</span></code> 服务器。 Laravel 官方并没有实现 <code class="docutils literal"><span class="pre">Socket.IO</span></code> 服务器；不过，可以选择一个由社区驱动维护的项目 <a class="reference external" href="https://github.com/tlaverdure/laravel-echo-server">tlaverdure/laravel-echo-server</a>  ，目前托管在 GitHub 。</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>npm install -g laravel-echo-server
</pre></div>
</div>
<p>然后在根目录下生成 <code class="docutils literal"><span class="pre">laravel-echo-server.json</span></code> 文件。</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>laravel-echo-server init
</pre></div>
</div>
<p>生成如下文件：</p>
<div class="highlight-json"><div class="highlight"><pre><span></span>{
    &quot;authHost&quot;: &quot;http://local-website.app&quot;,
    &quot;authEndpoint&quot;: &quot;/broadcasting/auth&quot;,
    &quot;clients&quot;: [
        {
            &quot;appId&quot;: &quot;my-app-id&quot;,
            &quot;key&quot;: &quot;my-key-generated-with-init-command&quot;
        }
    ],
    &quot;database&quot;: &quot;redis&quot;,
    &quot;databaseConfig&quot;: {
        &quot;redis&quot;: {
            &quot;host&quot;: &quot;192.168.10.10&quot;,
            &quot;port&quot;: &quot;6379&quot;,
            &quot;password&quot;: &quot;foobared&quot;
        },
        &quot;sqlite&quot;: {
            &quot;databasePath&quot;: &quot;/database/laravel-echo-server.sqlite&quot;
        },
        &quot;port&quot;: &quot;6379&quot;, // 数据库的全局配置
        &quot;host&quot;: &quot;127.0.0.1&quot;
    },
    &quot;devMode&quot;: false,
    &quot;host&quot;: null,
    &quot;port&quot;: &quot;6001&quot;,
    &quot;protocol&quot;: &quot;http&quot;,
    &quot;socketio&quot;: { },
    &quot;sslCertPath&quot;: &quot;&quot;,
    &quot;sslKeyPath&quot;: &quot;&quot;,
    &quot;sslCertChainPath&quot;: &quot;&quot;,
    &quot;sslPassphrase&quot;: &quot;&quot;
}
</pre></div>
</div>
<p>运行 Laravel Echo Server 。</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>laravel-echo-server start
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h4>36.1.2.3. 对队列的要求<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h4>
<p>在开始广播事件之前，你还需要配置和运行 队列侦听器(为什么需要它？？) 。所有的事件广播都是通过队列任务来完成的，因此应用程序的响应时间不会受到明显影响。</p>
</div>
</div>
</div>
<div class="section" id="id7">
<h2>36.2. 概念综述<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h2>
<p>Laravel 的事件广播允许你使用基于驱动的 <code class="docutils literal"><span class="pre">WebSockets</span></code> 将服务端的 Larevel 事件广播到客户端的 JavaScript 应用程序。当前的 Laravel 自带了 <code class="docutils literal"><span class="pre">Pusher</span></code> 和 <code class="docutils literal"><span class="pre">Redis</span></code> 驱动。通过使用 <code class="docutils literal"><span class="pre">Laravel</span> <span class="pre">Echo</span></code> 的 Javascript 包，我们可以很方便地在客户端消费事件。</p>
<p>事件通过「频道」来广播，这些频道可以被指定为公开的或私有的。任何访客都可以订阅一个不需要认证和授权的公开频道；然而，如果想订阅一个私有频道，那么该用户必须通过认证，并获得该频道的授权。</p>
<div class="section" id="id8">
<h3>36.2.1. 使用示例程序<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h3>
<p>让我们先用一个电子商务网站作为例子来概览一下事件广播。我们不会讨论如何配置 <a class="reference external" href="https://pusher.com/">Pusher</a> 或者 <a class="reference external" href="https://laravel-china.org/docs/laravel/5.6/broadcasting/1386#installing-laravel-echo">Laravel Echo</a> 的细节，因为这些会在本文档的其他章节被详细介绍。</p>
<p>在我们的应用程序中，让我们假设有一个允许用户查看订单配送状态的页面。有一个 <code class="docutils literal"><span class="pre">ShippingStatusUpdated</span></code> 事件会在配送状态更新时被触发：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="nx">event</span><span class="p">(</span><span class="k">new</span> <span class="nx">ShippingStatusUpdated</span><span class="p">(</span><span class="nv">$update</span><span class="p">));</span>
</pre></div>
</div>
<div class="section" id="shouldbroadcast">
<h4>36.2.1.1. ShouldBroadcast 接口<a class="headerlink" href="#shouldbroadcast" title="永久链接至标题">¶</a></h4>
<p>当用户在查看自己的订单时，我们不希望他们必须通过刷新页面才能看到状态更新。我们希望一旦有更新时就主动将更新信息广播到客户端。所以，我们必须让 <code class="docutils literal"><span class="pre">ShippingStatusUpdated</span></code> 事件实现 <code class="docutils literal"><span class="pre">ShouldBroadcast</span></code> 接口。这会让 Laravel 在事件被触发时广播该事件：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">namespace</span> <span class="nx">App\Events</span><span class="p">;</span>

<span class="k">use</span> <span class="nx">Illuminate\Broadcasting\Channel</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Illuminate\Queue\SerializesModels</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Illuminate\Broadcasting\PrivateChannel</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Illuminate\Broadcasting\PresenceChannel</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Illuminate\Broadcasting\InteractsWithSockets</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Illuminate\Contracts\Broadcasting\ShouldBroadcast</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">ShippingStatusUpdated</span> <span class="k">implements</span> <span class="nx">ShouldBroadcast</span>
<span class="p">{</span>
    <span class="sd">/**</span>
<span class="sd">     * 有关传输状态更新的信息。</span>
<span class="sd">     *</span>
<span class="sd">     * @var string</span>
<span class="sd">     */</span>
    <span class="k">public</span> <span class="nv">$update</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">ShouldBroadcast</span></code> 接口要求事件实现 <code class="docutils literal"><span class="pre">broadcastOn</span></code> 方法。该方法负责指定事件被广播到哪些频道。在通过 <code class="docutils literal"><span class="pre">Artisan</span></code> 命令生成的事件类中，一个空的 <code class="docutils literal"><span class="pre">broadcastOn</span></code> 方法已经被预定义好了，所以我们要做的仅仅是指定频道。我们希望只有订单的创建者能够看到状态更新，所以我们要把该事件广播到与这个订单绑定的私有频道上去：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="sd">/**</span>
<span class="sd"> * 获取事件应播放的频道。</span>
<span class="sd"> *</span>
<span class="sd"> * @return array</span>
<span class="sd"> */</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">broadcastOn</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">PrivateChannel</span><span class="p">(</span><span class="s1">&#39;order.&#39;</span><span class="o">.</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">update</span><span class="o">-&gt;</span><span class="na">order_id</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id10">
<h4>36.2.1.2. 频道授权<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h4>
<p>记住，用户只有在被授权后才能监听私有频道。我们可以在 <code class="docutils literal"><span class="pre">routes/channels.php</span></code> 文件中定义频道的授权规则。在本例中，我们需要对试图监听私有 <code class="docutils literal"><span class="pre">order.1</span></code> 频道的所有用户进行验证，确保只有订单的创建者才能进行监听：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="nx">Broadcast</span><span class="o">::</span><span class="na">channel</span><span class="p">(</span><span class="s1">&#39;order.{orderId}&#39;</span><span class="p">,</span> <span class="k">function</span> <span class="p">(</span><span class="nv">$user</span><span class="p">,</span> <span class="nv">$orderId</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nv">$user</span><span class="o">-&gt;</span><span class="na">id</span> <span class="o">===</span> <span class="nx">Order</span><span class="o">::</span><span class="na">findOrNew</span><span class="p">(</span><span class="nv">$orderId</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">user_id</span><span class="p">;</span>
<span class="p">});</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">channel</span></code> 方法接收两个参数：频道名称和一个回调函数，该回调通过返回 <code class="docutils literal"><span class="pre">true</span></code> 或者 <code class="docutils literal"><span class="pre">false</span></code> 来表示用户是否被授权监听该频道。</p>
<p>所有的授权回调接收当前被认证的用户作为第一个参数，任何额外的通配符参数作为后续参数。在本例中，我们使用 <code class="docutils literal"><span class="pre">{orderId}</span></code> 占位符来表示频道名称的 <code class="docutils literal"><span class="pre">ID</span></code> 部分是通配符。</p>
</div>
<div class="section" id="id11">
<h4>36.2.1.3. 对事件广播进行监听<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h4>
<p>接下来，就只剩下在 JavaScript 应用程序中监听事件了。我们可以使用 <code class="docutils literal"><span class="pre">Laravel</span> <span class="pre">Echo</span></code> 来实现。首先，使用 <code class="docutils literal"><span class="pre">private</span></code> 方法来订阅私有频道。然后，使用 <code class="docutils literal"><span class="pre">listen</span></code> 方法来监听 <code class="docutils literal"><span class="pre">ShippingStatusUpdated</span></code> 事件。默认情况下，事件的所有公有属性会被包括在广播事件中：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">Echo</span><span class="p">.</span><span class="kr">private</span><span class="p">(</span><span class="sb">`order.</span><span class="si">${</span><span class="nx">orderId</span><span class="si">}</span><span class="sb">`</span><span class="p">)</span> <span class="c1">//模板字符串，会自动使用JavaScript变量替换里面的占位符</span>
    <span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="s1">&#39;ShippingStatusUpdated&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">update</span><span class="p">);</span>
    <span class="p">});</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id12">
<h2>36.3. 定义广播事件<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h2>
<p>要告知 Laravel 一个给定的事件是广播类型，只需在事件类中实现 <code class="docutils literal"><span class="pre">Illuminate\Contracts\Broadcasting\ShouldBroadcast</span></code> 接口即可。该接口已经被导入到所有由框架生成的事件类中，所以你可以很方便地将它添加到你自己的事件中。</p>
<p>可以通过命令自动生成：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>php artisan make:event ServerCreated
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">ShouldBroadcast</span></code> 接口要求你实现一个方法： <code class="docutils literal"><span class="pre">broadcastOn</span></code> 。 <code class="docutils literal"><span class="pre">broadcastOn</span></code> 方法返回一个频道或一个频道数组，事件会被广播到这些频道。频道必须是 <code class="docutils literal"><span class="pre">Channel</span></code> 、 <code class="docutils literal"><span class="pre">PrivateChannel</span></code> 或 <code class="docutils literal"><span class="pre">PresenceChannel</span></code> 的实例。 <code class="docutils literal"><span class="pre">Channel</span></code> 实例表示任何用户都可以订阅的公开频道，而 <code class="docutils literal"><span class="pre">PrivateChannels</span></code> 和 <code class="docutils literal"><span class="pre">PresenceChannels</span></code> 则表示需要 频道授权 的私有频道：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>

<span class="k">namespace</span> <span class="nx">App\Events</span><span class="p">;</span>

<span class="k">use</span> <span class="nx">Illuminate\Broadcasting\Channel</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Illuminate\Queue\SerializesModels</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Illuminate\Broadcasting\PrivateChannel</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Illuminate\Broadcasting\PresenceChannel</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Illuminate\Broadcasting\InteractsWithSockets</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Illuminate\Contracts\Broadcasting\ShouldBroadcast</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">ServerCreated</span> <span class="k">implements</span> <span class="nx">ShouldBroadcast</span>
<span class="p">{</span>
    <span class="k">use</span> <span class="nx">SerializesModels</span><span class="p">;</span>

    <span class="k">public</span> <span class="nv">$user</span><span class="p">;</span>

    <span class="sd">/**</span>
<span class="sd">     * 创建一个新的事件实例</span>
<span class="sd">     *</span>
<span class="sd">     * @return void</span>
<span class="sd">     */</span>
    <span class="k">public</span> <span class="k">function</span> <span class="fm">__construct</span><span class="p">(</span><span class="nx">User</span> <span class="nv">$user</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">user</span> <span class="o">=</span> <span class="nv">$user</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="sd">/**</span>
<span class="sd">     * 指定事件在哪些频道上进行广播</span>
<span class="sd">     *</span>
<span class="sd">     * @return Channel|array</span>
<span class="sd">     */</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">broadcastOn</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nx">PrivateChannel</span><span class="p">(</span><span class="s1">&#39;user.&#39;</span><span class="o">.</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">user</span><span class="o">-&gt;</span><span class="na">id</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>然后，你只需要像你平时那样 触发事件 。一旦事件被触发，一个 队列任务 会自动广播事件到你指定的广播驱动器上。</p>
<div class="section" id="id13">
<h3>36.3.1. 广播名称<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h3>
<p>Laravel 默认会使用事件的类名作为广播名称来广播事件。不过，你也可以在事件类中通过定义一个 <code class="docutils literal"><span class="pre">broadcastAs</span></code> 方法来自定义广播名称:</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="sd">/**</span>
<span class="sd"> * 事件的广播名称。</span>
<span class="sd"> *</span>
<span class="sd"> * @return string</span>
<span class="sd"> */</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">broadcastAs</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="s1">&#39;server.created&#39;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如果你使用 <code class="docutils literal"><span class="pre">broadcastAs</span></code> 方法自定义广播名称，你需要在你订阅事件的时候为事件类加上 <code class="docutils literal"><span class="pre">.</span></code> 前缀。这将指示 <code class="docutils literal"><span class="pre">Echo</span></code> 不要将应用程序的命名空间添加到事件中：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="s1">&#39;.server.created&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">....</span>
<span class="p">});</span>
</pre></div>
</div>
</div>
<div class="section" id="id14">
<h3>36.3.2. 广播数据<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h3>
<p>当一个事件被广播时，它所有的 <code class="docutils literal"><span class="pre">public</span></code> 属性会自动被序列化为广播数据，这允许你在你的 JavaScript 应用中访问事件的公有数据。因此，举个例子，如果你的事件有一个公有的 <code class="docutils literal"><span class="pre">$user</span></code> 属性，它包含了一个 <code class="docutils literal"><span class="pre">Elouqent</span></code> 模型，那么事件的广播数据会是：</p>
<div class="highlight-json"><div class="highlight"><pre><span></span>{
    &quot;user&quot;: {
        &quot;id&quot;: 1,
        &quot;name&quot;: &quot;Patrick Stewart&quot;
        ...
    }
}
</pre></div>
</div>
<p>然而，如果你想更细粒度地控制你的广播数据，你可以添加一个 <code class="docutils literal"><span class="pre">broadcastWith</span></code> 方法到你的事件中。这个方法应该返回一个数组，该数组中的数据会被添加到广播数据中：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="sd">/**</span>
<span class="sd"> * 指定广播数据。</span>
<span class="sd"> *</span>
<span class="sd"> * @return array</span>
<span class="sd"> */</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">broadcastWith</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;id&#39;</span> <span class="o">=&gt;</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">user</span><span class="o">-&gt;</span><span class="na">id</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id15">
<h3>36.3.3. 广播队列<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h3>
<p>默认情况下，每一个广播事件都被添加到默认的队列上，默认的队列连接在 <code class="docutils literal"><span class="pre">queue.php</span></code> 配置文件中指定。你可以通过在事件类中定义一个 <code class="docutils literal"><span class="pre">broadcastQueue</span></code> 属性来自定义广播器使用的队列。该属性用于指定广播使用的队列名称：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="sd">/**</span>
<span class="sd"> * 指定事件被放置在哪个队列上</span>
<span class="sd"> *</span>
<span class="sd"> * @var string</span>
<span class="sd"> */</span>
<span class="k">public</span> <span class="nv">$broadcastQueue</span> <span class="o">=</span> <span class="s1">&#39;your-queue-name&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>如果要使用 <code class="docutils literal"><span class="pre">sync</span></code> 队列而不是默认队列驱动程序广播你的事件，你可以实现 <code class="docutils literal"><span class="pre">ShouldBroadcastNow</span></code> 接口而不是 <code class="docutils literal"><span class="pre">ShouldBroadcast</span></code> ：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>

<span class="k">use</span> <span class="nx">Illuminate\Contracts\Broadcasting\ShouldBroadcastNow</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">ShippingStatusUpdated</span> <span class="k">implements</span> <span class="nx">ShouldBroadcastNow</span>
<span class="p">{</span>
    <span class="c1">//</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id16">
<h3>36.3.4. 广播条件<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h3>
<p>有时，你想在给定条件为 <code class="docutils literal"><span class="pre">true</span></code> ，才广播你的事件。你可以通过在事件类中添加一个 <code class="docutils literal"><span class="pre">broadcastWhen</span></code> 方法来定义这些条件：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="sd">/**</span>
<span class="sd"> * 确定是否应该播放此事件。</span>
<span class="sd"> *</span>
<span class="sd"> * @return bool</span>
<span class="sd"> */</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">broadcastWhen</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">value</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id17">
<h2>36.4. 频道授权<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h2>
<p>对于私有频道，用户只有被授权后才能监听。实现过程是用户向你的 Laravel 应用程序发起一个携带频道名称的 <code class="docutils literal"><span class="pre">HTTP</span></code> 请求，你的应用程序判断该用户是否能够监听该频道。在使用 <code class="docutils literal"><span class="pre">Laravel</span> <span class="pre">Echo</span></code> 时，上述 <code class="docutils literal"><span class="pre">HTTP</span></code> 请求会被自动发送；尽管如此，你仍然需要定义适当的路由来响应这些请求。</p>
<div class="section" id="id18">
<h3>36.4.1. 定义授权路由<a class="headerlink" href="#id18" title="永久链接至标题">¶</a></h3>
<p>幸运的是，我们可以在 Laravel 里很容易地定义路由来响应频道授权请求。在 <code class="docutils literal"><span class="pre">BroadcastServiceProvider</span></code> 中，你会看到一个对 <code class="docutils literal"><span class="pre">Broadcast::routes</span></code> 方法的调用。该方法会注册 <code class="docutils literal"><span class="pre">/broadcasting/auth</span></code> 路由来处理授权请求(通过 <code class="docutils literal"><span class="pre">http</span></code> 来访问该路径)：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="nx">Broadcast</span><span class="o">::</span><span class="na">routes</span><span class="p">();</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">Broadcast::routes</span></code> 方法会自动把 <code class="docutils literal"><span class="pre">/broadcasting/auth</span></code> 路由放进 <code class="docutils literal"><span class="pre">web</span></code> 中间件组中；另外，如果你想对一些属性自定义，可以向该方法传递一个包含路由属性的数组：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="nx">Broadcast</span><span class="o">::</span><span class="na">routes</span><span class="p">(</span><span class="nv">$attributes</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="id19">
<h3>36.4.2. 定义授权回调<a class="headerlink" href="#id19" title="永久链接至标题">¶</a></h3>
<p>接下来，我们需要定义真正用于处理频道授权的逻辑。这是在 <code class="docutils literal"><span class="pre">routes/channels.php</span></code> 文件中完成。在该文件中，你可以用 <code class="docutils literal"><span class="pre">Broadcast::channel</span></code> 方法来注册频道授权回调函数：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="nx">Broadcast</span><span class="o">::</span><span class="na">channel</span><span class="p">(</span><span class="s1">&#39;order.{orderId}&#39;</span><span class="p">,</span> <span class="k">function</span> <span class="p">(</span><span class="nv">$user</span><span class="p">,</span> <span class="nv">$orderId</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nv">$user</span><span class="o">-&gt;</span><span class="na">id</span> <span class="o">===</span> <span class="nx">Order</span><span class="o">::</span><span class="na">findOrNew</span><span class="p">(</span><span class="nv">$orderId</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">user_id</span><span class="p">;</span>
<span class="p">});</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">channel</span></code> 方法接收两个参数：频道名称和一个回调函数，该回调通过返回 <code class="docutils literal"><span class="pre">true</span></code> 或 <code class="docutils literal"><span class="pre">false</span></code> 来表示用户是否被授权监听该频道。</p>
<p>所有的授权回调接收当前被认证的用户作为第一个参数，任何额外的通配符参数作为后续参数。在本例中，我们使用 <code class="docutils literal"><span class="pre">{orderId}</span></code> 占位符来表示频道名称的 <code class="docutils literal"><span class="pre">ID</span></code> 部分是通配符。</p>
<div class="section" id="id20">
<h4>36.4.2.1. 授权回调模型绑定<a class="headerlink" href="#id20" title="永久链接至标题">¶</a></h4>
<p>就像 <code class="docutils literal"><span class="pre">HTTP</span></code> 路由一样，频道路由也可以利用显式或隐式 路由模型绑定。例如，相比于接收一个字符串或数字类型的 <code class="docutils literal"><span class="pre">order</span> <span class="pre">ID</span></code> ，你也可以请求一个真正的 <code class="docutils literal"><span class="pre">Order</span></code> 模型实例:</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="x">use App\Order;</span>

<span class="x">Broadcast::channel(&#39;order.{order}&#39;, function ($user, Order $order) {</span>
<span class="x">    return $user-&gt;id === $order-&gt;user_id;</span>
<span class="x">});</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id21">
<h3>36.4.3. 定义频道类<a class="headerlink" href="#id21" title="永久链接至标题">¶</a></h3>
<p>如果你的应用程序消耗了许多不同的频道，你的 <code class="docutils literal"><span class="pre">routes/channels.php</span></code> 文件可能会变得庞大。 因此，您可以使用频道类来代替使用闭包来授权频道。 要生成频道类，请使用 <code class="docutils literal"><span class="pre">make:channel</span> <span class="pre">Artisan</span></code> 命令。 该命令将在 <code class="docutils literal"><span class="pre">App/Broadcasting</span></code> 目录中放置一个新的频道类。</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>php artisan make:channel OrderChannel
</pre></div>
</div>
<p>接下来，在你的 <code class="docutils literal"><span class="pre">routes/channels.php</span></code> 文件中注册你的频道：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">use</span> <span class="nx">App\Broadcasting\OrderChannel</span><span class="p">;</span>

<span class="nx">Broadcast</span><span class="o">::</span><span class="na">channel</span><span class="p">(</span><span class="s1">&#39;order.{order}&#39;</span><span class="p">,</span> <span class="nx">OrderChannel</span><span class="o">::</span><span class="na">class</span><span class="p">);</span>
</pre></div>
</div>
<p>最后，您可以将您的频道的授权逻辑放入频道类 <code class="docutils literal"><span class="pre">join</span></code> 方法中。 这个 <code class="docutils literal"><span class="pre">join</span></code> 方法将保存您通常放置在您的频道授权 <code class="docutils literal"><span class="pre">Closure</span></code> 中的相同逻辑。 当然，您也可以利用通道模型绑定：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="k">namespace</span> <span class="nx">App\Broadcasting</span><span class="p">;</span>

<span class="k">use</span> <span class="nx">App\User</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">App\Order</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">OrderChannel</span>
<span class="p">{</span>
    <span class="sd">/**</span>
<span class="sd">     * 创建一个新的频道实例。</span>
<span class="sd">     *</span>
<span class="sd">     * @return void</span>
<span class="sd">     */</span>
    <span class="k">public</span> <span class="k">function</span> <span class="fm">__construct</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">//</span>
    <span class="p">}</span>

    <span class="sd">/**</span>
<span class="sd">     * 验证用户对频道的访问权限。</span>
<span class="sd">     *</span>
<span class="sd">     * @param  \App\User  $user</span>
<span class="sd">     * @param  \App\Order  $order</span>
<span class="sd">     * @return array|bool</span>
<span class="sd">     */</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">join</span><span class="p">(</span><span class="nx">User</span> <span class="nv">$user</span><span class="p">,</span> <span class="nx">Order</span> <span class="nv">$order</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nv">$user</span><span class="o">-&gt;</span><span class="na">id</span> <span class="o">===</span> <span class="nv">$order</span><span class="o">-&gt;</span><span class="na">user_id</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">像 Laravel 中的许多其他类一样，通道类将自动由 服务容器 解析。 因此，您可以在其构造函数中键入提示您的频道所需的任何依赖项。</p>
</div>
</div>
</div>
<div class="section" id="id22">
<h2>36.5. 广播事件<a class="headerlink" href="#id22" title="永久链接至标题">¶</a></h2>
<p>一旦你已经定义好了一个事件并实现了 <code class="docutils literal"><span class="pre">ShouldBroadcast</span></code> 接口，剩下的就是使用 <code class="docutils literal"><span class="pre">event</span></code> 函数来触发该事件。事件分发器会识别出实现了 <code class="docutils literal"><span class="pre">ShouldBroadcast</span></code> 接口的事件并将它们加入到队列进行广播：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="nx">event</span><span class="p">(</span><span class="k">new</span> <span class="nx">ShippingStatusUpdated</span><span class="p">(</span><span class="nv">$update</span><span class="p">));</span>
</pre></div>
</div>
<div class="section" id="id23">
<h3>36.5.1. 只广播给他人<a class="headerlink" href="#id23" title="永久链接至标题">¶</a></h3>
<p>当创建一个使用到事件广播的应用程序时，你可以用 <code class="docutils literal"><span class="pre">broadcast</span></code> 函数来替代 <code class="docutils literal"><span class="pre">event</span></code> 函数。和 <code class="docutils literal"><span class="pre">event</span></code> 函数一样， <code class="docutils literal"><span class="pre">broadcast</span></code> 函数将事件分发到服务端监听器(如 <code class="docutils literal"><span class="pre">socket.io</span></code> 的服务器)：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="nx">broadcast</span><span class="p">(</span><span class="k">new</span> <span class="nx">ShippingStatusUpdated</span><span class="p">(</span><span class="nv">$update</span><span class="p">));</span>
</pre></div>
</div>
<p>不同的是 <code class="docutils literal"><span class="pre">broadcast</span></code> 函数有一个 <code class="docutils literal"><span class="pre">toOthers</span></code> 方法允许你将当前用户从广播接收者中排除：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="nx">broadcast</span><span class="p">(</span><span class="k">new</span> <span class="nx">ShippingStatusUpdated</span><span class="p">(</span><span class="nv">$update</span><span class="p">))</span><span class="o">-&gt;</span><span class="na">toOthers</span><span class="p">();</span>
</pre></div>
</div>
<p>为了更好地理解什么时候使用 <code class="docutils literal"><span class="pre">toOthers</span></code> 方法，让我们假设有一个任务列表的应用程序，用户可以通过输入任务名称来新建任务。为了新建任务，你的应用程序需要发起一个请求到 <code class="docutils literal"><span class="pre">/task</span></code> 路由，该路由在接收到请求并成功创建新任务后会触发一个任务被新建的事件广播，并返回新任务的 <code class="docutils literal"><span class="pre">JSON</span></code> 响应。当你的 <code class="docutils literal"><span class="pre">JavaScript</span></code> 应用程序接收到来自该路由的响应时，它会直接将新任务插入到任务列表，就像这样：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">axios</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="s1">&#39;/task&#39;</span><span class="p">,</span> <span class="nx">task</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">response</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">tasks</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">response</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
    <span class="p">});</span>
</pre></div>
</div>
<p>但是，别忘了我们还将接收到一个事件广播。如果你的 JavaScript 应用程序同时监听该事件以便添加新任务到任务列表，你将会在你的列表中看到重复的任务：一份来自路由响应，另一份来自广播。你可以通过使用 <code class="docutils literal"><span class="pre">toOthers</span></code> 方法让广播器只广播事件到其他用户来解决该问题。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">你的事件必须使用 <code class="docutils literal"><span class="pre">Illuminate\Broadcasting\InteractsWithSockets</span></code> trait 来调用 <code class="docutils literal"><span class="pre">toOthers</span></code> 方法。</p>
</div>
</div>
<div class="section" id="id24">
<h3>36.5.2. 配置<a class="headerlink" href="#id24" title="永久链接至标题">¶</a></h3>
<p>当你实例化 <code class="docutils literal"><span class="pre">Laravel</span> <span class="pre">Echo</span></code> 实例时，一个 <code class="docutils literal"><span class="pre">Socket</span> <span class="pre">ID</span></code> 会被指定到该连接。如果你使用 <code class="docutils literal"><span class="pre">Vue</span></code> 和 <code class="docutils literal"><span class="pre">Axios</span></code> ， <code class="docutils literal"><span class="pre">Socket</span> <span class="pre">ID</span></code> 会自动被添加到每一个请求(应该是指 <code class="docutils literal"><span class="pre">http</span></code> 请求)的 <code class="docutils literal"><span class="pre">X-Socket-ID</span></code> 头中。然后，当你调用 <code class="docutils literal"><span class="pre">toOthers</span></code> 方法时，Laravel 会从头中提取出 <code class="docutils literal"><span class="pre">Socket</span> <span class="pre">ID</span></code> ，并告诉广播器不要广播任何消息到该 <code class="docutils literal"><span class="pre">Socket</span> <span class="pre">ID</span></code> 的连接上。</p>
<p>如果你没有使用 <code class="docutils literal"><span class="pre">Vue</span></code> 和 <code class="docutils literal"><span class="pre">Axios</span></code> ，则需要手动配置 JavaScript 应用程序来发送 <code class="docutils literal"><span class="pre">X-Socket-ID</span></code> 头。你可以用 <code class="docutils literal"><span class="pre">Echo.socketId()</span></code> 方法来获取 <code class="docutils literal"><span class="pre">Socket</span> <span class="pre">ID</span></code> ：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">socketId</span> <span class="o">=</span> <span class="nx">Echo</span><span class="p">.</span><span class="nx">socketId</span><span class="p">();</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id25">
<h2>36.6. 接收广播<a class="headerlink" href="#id25" title="永久链接至标题">¶</a></h2>
<div class="section" id="id26">
<h3>36.6.1. 安装 Laravel Echo<a class="headerlink" href="#id26" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal"><span class="pre">Laravel</span> <span class="pre">Echo</span></code> 是一个 JavaScript 库，它使得订阅频道和监听由 Laravel 广播的事件变得非常容易。你可以通过 <code class="docutils literal"><span class="pre">NPM</span></code> 包管理器来安装 <code class="docutils literal"><span class="pre">Echo</span></code> 。在本例中，因为我们将使用 <code class="docutils literal"><span class="pre">Pusher</span></code> 广播器，请安装 <code class="docutils literal"><span class="pre">pusher-js</span></code> 包：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>npm install --save laravel-echo pusher-js
</pre></div>
</div>
<p>一旦 <code class="docutils literal"><span class="pre">Echo</span></code> 被安装好，你就可以在你应用程序的 JavaScript 中创建一个全新的 <code class="docutils literal"><span class="pre">Echo</span></code> 实例。做这件事的一个理想地方是在 <code class="docutils literal"><span class="pre">resources/assets/js/bootstrap.js</span></code> 文件的底部，Laravel 框架自带了该文件：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nx">Echo</span> <span class="nx">from</span> <span class="s2">&quot;laravel-echo&quot;</span>

<span class="nb">window</span><span class="p">.</span><span class="nx">Echo</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Echo</span><span class="p">({</span>
    <span class="nx">broadcaster</span><span class="o">:</span> <span class="s1">&#39;pusher&#39;</span><span class="p">,</span>
    <span class="nx">key</span><span class="o">:</span> <span class="s1">&#39;your-pusher-key&#39;</span>
<span class="p">});</span>
</pre></div>
</div>
<p>当你使用 <code class="docutils literal"><span class="pre">pusher</span></code> 连接器来创建一个 <code class="docutils literal"><span class="pre">Echo</span></code> 实例的时候，你需要指定 <code class="docutils literal"><span class="pre">cluster</span></code> 以及指定连接是否需要加密：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nb">window</span><span class="p">.</span><span class="nx">Echo</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Echo</span><span class="p">({</span>
    <span class="nx">broadcaster</span><span class="o">:</span> <span class="s1">&#39;pusher&#39;</span><span class="p">,</span>
    <span class="nx">key</span><span class="o">:</span> <span class="s1">&#39;your-pusher-key&#39;</span><span class="p">,</span>
    <span class="nx">cluster</span><span class="o">:</span> <span class="s1">&#39;eu&#39;</span><span class="p">,</span>
    <span class="nx">encrypted</span><span class="o">:</span> <span class="kc">true</span>
<span class="p">});</span>
</pre></div>
</div>
</div>
<div class="section" id="id27">
<h3>36.6.2. 对事件进行监听<a class="headerlink" href="#id27" title="永久链接至标题">¶</a></h3>
<p>一旦你安装好并实例化了 <code class="docutils literal"><span class="pre">Echo</span></code> ，你就可以开始监听事件广播了。首先，使用 <code class="docutils literal"><span class="pre">channel</span></code> 方法来获取一个频道实例，然后调用 <code class="docutils literal"><span class="pre">listen</span></code> 方法来监听指定的事件：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">Echo</span><span class="p">.</span><span class="nx">channel</span><span class="p">(</span><span class="s1">&#39;orders&#39;</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="s1">&#39;OrderShipped&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">order</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
    <span class="p">});</span>
</pre></div>
</div>
<p>如果你想监听私有频道上的事件，请使用 <code class="docutils literal"><span class="pre">private</span></code> 方法。你可以通过链式调用 <code class="docutils literal"><span class="pre">listen</span></code> 方法来监听一个频道上的多个事件：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">Echo</span><span class="p">.</span><span class="kr">private</span><span class="p">(</span><span class="s1">&#39;orders&#39;</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">listen</span><span class="p">(...)</span>
    <span class="p">.</span><span class="nx">listen</span><span class="p">(...)</span>
    <span class="p">.</span><span class="nx">listen</span><span class="p">(...);</span>
</pre></div>
</div>
</div>
<div class="section" id="id28">
<h3>36.6.3. 退出频道<a class="headerlink" href="#id28" title="永久链接至标题">¶</a></h3>
<p>如果想退出频道，你需要在你的 <code class="docutils literal"><span class="pre">Echo</span></code> 实例上调用 <code class="docutils literal"><span class="pre">leave</span></code> 方法：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">Echo</span><span class="p">.</span><span class="nx">leave</span><span class="p">(</span><span class="s1">&#39;orders&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="id29">
<h3>36.6.4. 命名空间<a class="headerlink" href="#id29" title="永久链接至标题">¶</a></h3>
<p>你可能注意到了在上面的例子中我们没有为事件类指定完整的命名空间。这是因为 <code class="docutils literal"><span class="pre">Echo</span></code> 会自动认为事件在 <code class="docutils literal"><span class="pre">App\Events</span></code> 命名空间下。你可以在实例化 <code class="docutils literal"><span class="pre">Echo</span></code> 的时候传递一个 <code class="docutils literal"><span class="pre">namespace</span></code> 配置选项来指定根命名空间：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nb">window</span><span class="p">.</span><span class="nx">Echo</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Echo</span><span class="p">({</span>
    <span class="nx">broadcaster</span><span class="o">:</span> <span class="s1">&#39;pusher&#39;</span><span class="p">,</span>
    <span class="nx">key</span><span class="o">:</span> <span class="s1">&#39;your-pusher-key&#39;</span><span class="p">,</span>
    <span class="nx">namespace</span><span class="o">:</span> <span class="s1">&#39;App.Other.Namespace&#39;</span>
<span class="p">});</span>
</pre></div>
</div>
<p>另外，你也可以在使用 <code class="docutils literal"><span class="pre">Echo</span></code> 订阅事件的时候为事件类加上 <code class="docutils literal"><span class="pre">.</span></code> 前缀。这时需要填写完全限定名称的类名：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">Echo</span><span class="p">.</span><span class="nx">channel</span><span class="p">(</span><span class="s1">&#39;orders&#39;</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="s1">&#39;.Namespace.Event.Class&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="c1">//</span>
    <span class="p">});</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="presence">
<h2>36.7. Presence 频道<a class="headerlink" href="#presence" title="永久链接至标题">¶</a></h2>
<p><code class="docutils literal"><span class="pre">Presence</span></code> 频道是在私有频道的安全性基础上，额外暴露出有哪些人订阅了该频道。这使得它可以很容易地建立强大的、协同的应用，如当有一个用户在浏览页面时，通知其他正在浏览相同页面的用户。</p>
<div class="section" id="id30">
<h3>36.7.1. 授权 Presence 频道<a class="headerlink" href="#id30" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal"><span class="pre">Presence</span></code> 频道也是私有频道；因此，用户必须 获取授权 后才能访问他们。与私有频道不同的是，在给 <code class="docutils literal"><span class="pre">presence</span></code> 频道定义授权回调函数时，如果一个用户已经加入了该频道，那么不应该返回 <code class="docutils literal"><span class="pre">true</span></code> ，而应该返回一个关于该用户信息的数组。</p>
<p>由授权回调函数返回的数据能够在你的 JavaScript 应用程序中被 <code class="docutils literal"><span class="pre">presence</span></code> 频道事件侦听器所使用。如果用户没有获得加入该 <code class="docutils literal"><span class="pre">presence</span></code> 频道的授权，那么你应该返回 <code class="docutils literal"><span class="pre">false</span></code> 或 <code class="docutils literal"><span class="pre">null</span></code> ：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">Broadcast</span><span class="o">::</span><span class="nx">channel</span><span class="p">(</span><span class="s1">&#39;chat.{roomId}&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">$user</span><span class="p">,</span> <span class="nx">$roomId</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">$user</span><span class="o">-&gt;</span><span class="nx">canJoinRoom</span><span class="p">(</span><span class="nx">$roomId</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;id&#39;</span> <span class="p">=&gt;</span> <span class="nx">$user</span><span class="o">-&gt;</span><span class="nx">id</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span> <span class="p">=&gt;</span> <span class="nx">$user</span><span class="o">-&gt;</span><span class="nx">name</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">});</span>
</pre></div>
</div>
</div>
<div class="section" id="id31">
<h3>36.7.2. 加入 Presence 频道<a class="headerlink" href="#id31" title="永久链接至标题">¶</a></h3>
<p>你可以用 <code class="docutils literal"><span class="pre">Echo</span></code> 的 <code class="docutils literal"><span class="pre">join</span></code> 方法来加入 <code class="docutils literal"><span class="pre">Presence</span></code> 频道。 <code class="docutils literal"><span class="pre">join</span></code> 方法会返回一个实现了 <code class="docutils literal"><span class="pre">PresenceChannel</span></code> 的对象，它通过暴露 <code class="docutils literal"><span class="pre">listen</span></code> 方法，允许你订阅 <code class="docutils literal"><span class="pre">here</span></code> 、 <code class="docutils literal"><span class="pre">joining</span></code> 和 <code class="docutils literal"><span class="pre">leaving</span></code> 事件。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">Echo</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="sb">`chat.</span><span class="si">${</span><span class="nx">roomId</span><span class="si">}</span><span class="sb">`</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">here</span><span class="p">((</span><span class="nx">users</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="c1">//</span>
    <span class="p">})</span>
    <span class="p">.</span><span class="nx">joining</span><span class="p">((</span><span class="nx">user</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">user</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
    <span class="p">})</span>
    <span class="p">.</span><span class="nx">leaving</span><span class="p">((</span><span class="nx">user</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">user</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
    <span class="p">});</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">here</span></code> 回调函数会在你成功加入频道后被立即执行，它接收一个包含用户信息的数组，用来告知当前订阅在该频道上的其他用户。 <code class="docutils literal"><span class="pre">joining</span></code> 方法会在其他新用户加入到频道时被执行， <code class="docutils literal"><span class="pre">leaving</span></code> 会在其他用户退出频道时被执行。</p>
</div>
<div class="section" id="id32">
<h3>36.7.3. 广播到 Presence 频道<a class="headerlink" href="#id32" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal"><span class="pre">Presence</span></code> 频道可以像公开和私有频道一样接收事件。使用一个聊天室的例子，我们要把 <code class="docutils literal"><span class="pre">NewMessage</span></code> 事件广播到聊天室的 <code class="docutils literal"><span class="pre">presence</span></code> 频道。要实现它，我们将从事件的 <code class="docutils literal"><span class="pre">broadcastOn</span></code> 方法中返回一个 <code class="docutils literal"><span class="pre">PresenceChannel</span></code> 实例：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="sd">/**</span>
<span class="sd"> * 指定事件在哪些频道上进行广播</span>
<span class="sd"> *</span>
<span class="sd"> * @return Channel|array</span>
<span class="sd"> */</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">broadcastOn</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">PresenceChannel</span><span class="p">(</span><span class="s1">&#39;room.&#39;</span><span class="o">.</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">message</span><span class="o">-&gt;</span><span class="na">room_id</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>和公开或私有事件一样， <code class="docutils literal"><span class="pre">Presence</span></code> 频道事件也能使用 <code class="docutils literal"><span class="pre">broadcast</span></code> 函数来广播。同样的，你还能用 <code class="docutils literal"><span class="pre">toOthers</span></code> 方法将当前用户从广播接收者中排除：</p>
<div class="highlight-php"><div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="nx">broadcast</span><span class="p">(</span><span class="k">new</span> <span class="nx">NewMessage</span><span class="p">(</span><span class="nv">$message</span><span class="p">));</span>

<span class="nx">broadcast</span><span class="p">(</span><span class="k">new</span> <span class="nx">NewMessage</span><span class="p">(</span><span class="nv">$message</span><span class="p">))</span><span class="o">-&gt;</span><span class="na">toOthers</span><span class="p">();</span>
</pre></div>
</div>
<p>你可以通过 <code class="docutils literal"><span class="pre">Echo</span></code> 的 <code class="docutils literal"><span class="pre">listen</span></code> 方法来监听 <code class="docutils literal"><span class="pre">join</span></code> 事件：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">Echo</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="sb">`chat.</span><span class="si">${</span><span class="nx">roomId</span><span class="si">}</span><span class="sb">`</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">here</span><span class="p">(...)</span>
    <span class="p">.</span><span class="nx">joining</span><span class="p">(...)</span>
    <span class="p">.</span><span class="nx">leaving</span><span class="p">(...)</span>
    <span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="s1">&#39;NewMessage&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="c1">//</span>
    <span class="p">});</span>
</pre></div>
</div>
<p>这些方法不是很明白，需要研究？？？？</p>
</div>
</div>
<div class="section" id="id33">
<h2>36.8. 客户端事件<a class="headerlink" href="#id33" title="永久链接至标题">¶</a></h2>
<p>有时候你可能希望广播一个事件给其他已经连接的客户端，但并不需要通知你的 Laravel 程序。试想一下当你想提醒用户，另外一个用户正在输入中的时候，显而易见客服端事件对于「输入中」之类的通知就显得非常有用了。你可以使用 <code class="docutils literal"><span class="pre">Echo</span></code> 的 <code class="docutils literal"><span class="pre">whisper</span></code> 方法来广播客户端事件：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">Echo</span><span class="p">.</span><span class="kr">private</span><span class="p">(</span><span class="s1">&#39;chat&#39;</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">whisper</span><span class="p">(</span><span class="s1">&#39;typing&#39;</span><span class="p">,</span> <span class="p">{</span>
        <span class="nx">name</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">user</span><span class="p">.</span><span class="nx">name</span>
    <span class="p">});</span>
</pre></div>
</div>
<p>你可以使用 <code class="docutils literal"><span class="pre">listenForWhisper</span></code> 方法来监听客户端事件：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">Echo</span><span class="p">.</span><span class="kr">private</span><span class="p">(</span><span class="s1">&#39;chat&#39;</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">listenForWhisper</span><span class="p">(</span><span class="s1">&#39;typing&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
    <span class="p">});</span>
</pre></div>
</div>
</div>
<div class="section" id="id34">
<h2>36.9. 消息通知<a class="headerlink" href="#id34" title="永久链接至标题">¶</a></h2>
<p>将 消息通知 和事件广播一同使用，你的 JavaScript 应用程序可以在不刷新页面的情况下接收新的消息通知。首先，请先阅读关于如何使用 广播通知 的文档。</p>
<p>一旦你将一个消息通知配置为使用广播频道，你需要使用 <code class="docutils literal"><span class="pre">Echo</span></code> 的 <code class="docutils literal"><span class="pre">notification</span></code> 方法来监听广播事件。谨记，频道名称应该和接收消息通知的实体类名相匹配：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">Echo</span><span class="p">.</span><span class="kr">private</span><span class="p">(</span><span class="sb">`App.User.</span><span class="si">${</span><span class="nx">userId</span><span class="si">}</span><span class="sb">`</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">notification</span><span class="p">((</span><span class="nx">notification</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">notification</span><span class="p">.</span><span class="nx">type</span><span class="p">);</span>
    <span class="p">});</span>
</pre></div>
</div>
<p>在本例中，所有通过 <code class="docutils literal"><span class="pre">broadcast</span></code> 频道发送到 <code class="docutils literal"><span class="pre">App\User</span></code> 实例的消息通知都会被该回调接收到。一个针对 <code class="docutils literal"><span class="pre">App.User.{id}</span></code> 频道的授权回调函数已经被包含在 Laravel 的 <code class="docutils literal"><span class="pre">BroadcastServiceProvider</span></code> 中了。</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">queue:work</span></code> 默认只执行一次队列请求, 当请求执行完成后就终止；</li>
<li><code class="docutils literal"><span class="pre">queue:listen</span></code> 监听队列请求，只要运行着，就能一直接受请求，除非手动终止；</li>
<li><code class="docutils literal"><span class="pre">queue:work</span> <span class="pre">--daemon</span></code> 同 <code class="docutils literal"><span class="pre">listen</span></code> 一样，不同的是 work 不需要再次加载框架，直接运行任务，一般推荐使用这个来处理队列监听。</li>
</ul>
<p>注：使用 <code class="docutils literal"><span class="pre">queue:work</span> <span class="pre">--daemon</span></code> ，当更新代码的时候，需要停止，然后重新启动，这样才能把修改的代码应用上。</p>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Laravel的广播系统原理分析.html" class="btn btn-neutral float-right" title="37. 广播系统原理分析" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="Laravel的命令行.html" class="btn btn-neutral" title="35. 命令行" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, lzh.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.0',
            LANGUAGE:'zh',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  

<script type="text/javascript">
  
      $(document).ready(function(){
        var offset = sessionStorage.getItem("offsetTop");
        $('.wy-side-scroll').scrollTop(offset);
        sessionStorage.setItem("offsetTop", 0);


        $('.wy-menu > ul').click(function(){
            sessionStorage.setItem("offsetTop", $('.wy-side-scroll').scrollTop());
        });
      })

  </script> 

</body>
</html>