****
定义
****

模型定义
========
定义一个 ``User`` 模型类很简单：

.. code-block:: php

	<?php
	namespace app\index\model;

	use think\Model;

	class User extends Model
	{
	}

.. note:: 请确保你已经在数据库配置文件中配置了数据库连接信息，如不清楚请参考数据库一章

模型会自动对应数据表，模型类的命名规则是除去表前缀的数据表名称，采用驼峰法命名，并且首字母大写，例如：

+----------+-------------------------------------------------+
| 模型名   | 约定对应数据表（假设数据库的前缀定义是 think_） |
+==========+=================================================+
| User     | think_user                                      |
+----------+-------------------------------------------------+
| UserType | think_user_type                                 |
+----------+-------------------------------------------------+

如果你的规则和上面的系统约定不符合，那么需要设置 ``Model`` 类的数据表名称属性，以确保能够找到对应的数据表。

.. note:: 模型自动对应的数据表名称都是遵循小写+下划线规范，如果你的表名有大写的情况，必须通过设置模型的 ``table`` 属性。

如果担心模型的名称和PHP关键字冲突，可以启用类后缀功能，只需要在应用配置文件 ``app.php`` 中设置：

.. code-block:: php

    // 开启应用类库后缀
    'class_suffix'           => true,

.. note:: 开启后，所有的应用类库定义的时候都需要加上对应后缀，包括控制器类。

这样 ``app\index\model\User`` 类定义就要改成

.. code-block:: php

	<?php
	namespace app\index\model;

	use think\Model;

	class UserModel extends Model
	{
	}

并且文件名也要改为 ``UserModel.php`` 。

.. note:: 大多数情况下，不同模块的模型是不需要独立的，因此可以统一在 ``common`` 模块下面定义模型。


模型设置
========

默认主键为 ``id`` ，如果你没有使用 ``id`` 作为主键名，需要在模型中设置属性：

.. code-block:: php

	<?php
	namespace app\index\model;

	use think\Model;

	class User extends Model
	{
	    protected $pk = 'uid';
	}

.. note:: ``5.1`` 中模型不会自动获取主键名称，必须设置 ``pk`` 属性。

如果你想指定数据表甚至数据库连接的话，可以使用：

.. code-block:: php

	<?php
	namespace app\index\model;

	use think\Model;

	class User extends Model
	{
	    // 设置当前模型对应的完整数据表名称
	    protected $table = 'think_user';
	    
	    // 设置当前模型的数据库连接
	    protected $connection = 'db_config';
	}

``connection`` 属性的建议用配置参数名（需要在 ``database.php`` 中添加）而不是具体的连接信息，从而避免把数据库连接固化在代码里面。

常用的模型设置属性包括（以下属性都不是必须设置）：

+------------+----------------------------------------+
| 属性       | 描述                                   |
+============+========================================+
| name       | 模型名（默认为当前不含后缀的模型类名） |
+------------+----------------------------------------+
| table      | 数据表名（默认自动获取）               |
+------------+----------------------------------------+
| pk         | 主键名（默认为id）                     |
+------------+----------------------------------------+
| connection | 数据库连接（默认读取数据库配置）       |
+------------+----------------------------------------+
| query      | 模型使用的查询类名称                   |
+------------+----------------------------------------+
| field      | 模型对应数据表的字段列表（数组）       |
+------------+----------------------------------------+


模型初始化
==========
模型同样支持初始化，与控制器的初始化不同的是，模型的初始化是定义 ``Model`` 的 ``init`` 方法，具体如下

.. code-block:: php

	<?php
	namespace app\index\model;

	use think\Model;

	class User extends Model
	{

	    // 模型初始化
	    protected static function init()
	    {
	        //TODO:初始化内容
	    }
	}

模型初始化方法通常用于注册模型的事件操作。

.. note:: ``init`` 必须是静态方法，并且只在第一次实例化的时候执行



模型操作
========

.. note:: 在模型中除了可以调用数据库类(Db)的方法之外（换句话说，数据库的所有查询方法模型中都可以支持），可以定义自己的方法，所以也可以把模型看成是数据库的增强版。

模型的查询方法无需和数据库查询一样调用 ``table`` 或者 ``name`` 方法，因为模型会按照规则自动匹配对应的数据表，例如：

.. code-block:: php

    Db::name('user')->where('id','>',10)->select();

改成模型操作的话就变成

.. code-block:: php

    User::where('id','>',10)->select();

虽然看起来是相同的查询条件，但一个最明显的区别是 **查询结果的类型** 不同。第一种方式的查询结果是一个（二维）数组，而第二种方式的查询结果是包含了模型（集合）的数据集。不过，在大多数情况下，这二种返回类型的使用方式并无明显区别。

**模型操作和数据库操作的另外一个显著区别是模型支持包括获取器、修改器、自动完成在内的一系列自动化操作和事件，简化了数据的存取操作** ，但随之而来的是性能有所下降（其实并没下降，而是自动帮你处理了一些原本需要手动处理的操作），后面会逐步领略到模型的这些特色功能。









































