

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>8. 预缓存其它文件夹和文件来加速导航 &mdash; Vue示例 1.0 文档</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="索引"
              href="genindex.html"/>
        <link rel="search" title="搜索" href="search.html"/>
    <link rel="top" title="Vue示例 1.0 文档" href="index.html"/>
        <link rel="next" title="9. 介绍Vue-Router并加载基于URL的组件" href="介绍Vue-Router并加载基于URL的组件.html"/>
        <link rel="prev" title="7. 使用Vuex缓存当前文件夹结构" href="使用Vuex缓存当前文件夹结构.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Vue示例
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="前言.html">1. 前言</a></li>
<li class="toctree-l1"><a class="reference internal" href="Vue入门.html">2. Vue入门</a></li>
<li class="toctree-l1"><a class="reference internal" href="显示、循环、查询和过滤数据.html">3. 显示、循环、查询和过滤数据</a></li>
<li class="toctree-l1"><a class="reference internal" href="优化你的App和使用组件显示数据.html">4. 优化你的App和使用组件显示数据</a></li>
<li class="toctree-l1"><a class="reference internal" href="使用Dropbox_API获取文件列表.html">5. 使用Dropbox API获取文件列表</a></li>
<li class="toctree-l1"><a class="reference internal" href="浏览文件树和通过URL加载文件夹.html">6. 浏览文件树和通过URL加载文件夹</a></li>
<li class="toctree-l1"><a class="reference internal" href="使用Vuex缓存当前文件夹结构.html">7. 使用Vuex缓存当前文件夹结构</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">8. 预缓存其它文件夹和文件来加速导航</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id2">8.1. 缓存子文件夹</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">8.2. 规划应用方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="#getfolderstructure">8.3. 创建getFolderStructure方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="#displayfolderstructure">8.4. 用displayFolderStructure方法显示数据</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#true">8.4.1. 将加载状态设置为true并创建一个空的结构对象</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">8.4.2. 加载getFolderStructure方法的内容</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">8.4.3. 循环遍历结果并将每个项目添加到文件夹或文件数组中</a></li>
<li class="toctree-l3"><a class="reference internal" href="#structure">8.4.4. 更新全局 structure 对象并修改加载状态</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id6">8.5. 调用该方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id7">8.6. 缓存子文件夹</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id8">8.7. 修改缓存方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id9">8.8. 缓存父文件夹</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id10">8.9. 缓存父文件夹一次</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id11">8.10. 缓存文件下载链接</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id12">8.11. 完整的代码 - 添加了文档</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id13">8.12. 总结</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="介绍Vue-Router并加载基于URL的组件.html">9. 介绍Vue-Router并加载基于URL的组件</a></li>
<li class="toctree-l1"><a class="reference internal" href="使用Vue-Router动态路由加载数据.html">10. 使用Vue-Router动态路由加载数据</a></li>
<li class="toctree-l1"><a class="reference internal" href="建立电子商务商店-浏览产品.html">11. 建立电子商务商店-浏览产品</a></li>
<li class="toctree-l1"><a class="reference internal" href="建立电子商务商店-添加结帐.html">12. 建立电子商务商店-添加结帐</a></li>
<li class="toctree-l1"><a class="reference internal" href="使用Vue开发工具并测试您的SPA.html">13. 使用Vue开发工具并测试您的SPA</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Vue示例</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>8. 预缓存其它文件夹和文件来加速导航</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/预缓存其它文件夹和文件来加速导航.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>8. 预缓存其它文件夹和文件来加速导航<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<p>在本章的最后一节中，我们将通过向应用程序引入更多缓存来进一步加快我们的 <code class="docutils literal"><span class="pre">Dropbox</span></code> 文件浏览的速度。到目前为止，我们已经构建了一个可以查询 <code class="docutils literal"><span class="pre">Dropbox</span> <span class="pre">API</span></code> 的应用程序，并返回文件和文件夹。从那里，我们添加了文件夹导航，包括更新共享的 <code class="docutils literal"><span class="pre">URL</span></code> 链接并能够使用后退和前进按钮。在第6章中，使用 <code class="docutils literal"><span class="pre">Vuex</span></code> 缓存当前文件夹结构后，我们引入 <code class="docutils literal"><span class="pre">Vuex</span></code> 用于存储当前文件夹路径和我们访问过的文件夹的内容。</p>
<p>本章将着眼于：</p>
<ul class="simple">
<li>预先缓存用户当前所在的文件夹，还包括子文件夹。这将通过循环显示当前显示的文件夹并检查它们是否已被缓存来完成。如果不是，我们可以从 <code class="docutils literal"><span class="pre">API</span></code> 收集数据。</li>
<li>如果用户通过直接URL输入，则存储父文件夹的内容。这将通过利用面包屑路径向上遍历树来完成。</li>
<li>缓存文件的下载链接。无论文件夹是否被我们的代码缓存，每个文件都应该具有下载链接。</li>
</ul>
<p>通过这些改进，我们可以确保应用程序仅为每个项目联系一次 <code class="docutils literal"><span class="pre">API</span></code> ，而不是原来的无数次。</p>
<div class="section" id="id2">
<h2>8.1. 缓存子文件夹<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>通过子文件夹和父文件夹缓存，我们不一定会编写新代码，而是将现有代码重组并重新调整为更加模块化的系统，以便可以分别调用每个部分。</p>
<p>以下流程图应该帮助您可视化缓存当前文件夹和子文件夹所需的步骤：</p>
<img alt="_images/流程图.png" src="_images/流程图.png" />
<p>在查看流程图时，您可以立即看到应用程序所需的一些重复事件。在两个地方，应用程序需要确定缓存中是否存在文件夹，如果不存在，查询 <code class="docutils literal"><span class="pre">API</span></code> 以获取数据并存储结果。虽然它在流程图上只出现两次，但此功能需要多次，对于当前位置中的每个文件夹都需要一次。</p>
<p>我们还需要将我们的显示逻辑从查询和存储逻辑中分离出来，因为我们可能需要从API和存储中加载，而不更新视图。</p>
</div>
<div class="section" id="id3">
<h2>8.2. 规划应用方法<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>考虑到上一节，我们可以借此机会修改和重构我们的 <code class="docutils literal"><span class="pre">dropbox-viewer</span></code> 应用程序的方法，确保每个操作都有自己的方法。这将允许我们在需要时调用每个动作。 在我们进入代码之前，让我们根据前面的流程图规划出需要创建的方法。</p>
<p>首先要注意的是，每次查询 <code class="docutils literal"><span class="pre">API</span></code> 时，我们都需要将结果存储在缓存中。由于我们不需要在缓存中存储任何内容，除非调用 <code class="docutils literal"><span class="pre">API</span></code> ，我们可以用相同的方法组合这两个操作。 我们还经常需要检查缓存中是否有特定路径的内容，或者从缓存加载或从API中检索它。 我们可以将其添加到自己的返回数据的方法中。</p>
<p>让我们绘制出我们需要创建的方法：</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">getFolderStructure</span></code> : 此方法将接受单个路径参数并返回文件夹条目的一个对象。 这将负责检查数据是否在缓存中，如果没有，则查询 <code class="docutils literal"><span class="pre">Dropbox</span> <span class="pre">API</span></code> 。</li>
<li><code class="docutils literal"><span class="pre">displayFolderStructure</span></code> : 此方法将触发前面的函数并使用数据更新组件上的 <code class="docutils literal"><span class="pre">structure</span></code> 对象以显示 <code class="docutils literal"><span class="pre">View</span></code> 中的文件和文件夹。</li>
<li><code class="docutils literal"><span class="pre">cacheFolderStructure</span></code> : 这个方法将包含 <code class="docutils literal"><span class="pre">getFolderStructure</span></code> 方法来缓存每个子文件夹 - 我们将探索一些可以触发的方法。</li>
</ul>
<p>我们可能需要创建比这更多的方法，但这三个将成为组件的中枢。 我们将保留 <code class="docutils literal"><span class="pre">path</span></code> 和 <code class="docutils literal"><span class="pre">slug</span></code> 计算属性以及 <code class="docutils literal"><span class="pre">dropbox()</span></code> 方法。 删除其余的对象，方法和函数，以便您的 <code class="docutils literal"><span class="pre">Dropbox-viewer</span></code> 恢复基本功能：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">Vue</span><span class="p">.</span><span class="nx">component</span><span class="p">(</span><span class="s1">&#39;dropbox-viewer&#39;</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">template</span><span class="o">:</span> <span class="s1">&#39;#dropbox-viewer-template&#39;</span><span class="p">,</span>
    <span class="nx">data</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="nx">accessToken</span><span class="o">:</span> <span class="s1">&#39;XXXX&#39;</span><span class="p">,</span>
            <span class="nx">structure</span><span class="o">:</span> <span class="p">{},</span>
            <span class="nx">isLoading</span><span class="o">:</span> <span class="kc">true</span>
        <span class="p">}</span>
    <span class="p">},</span>
    <span class="nx">computed</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">path</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">$store</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">path</span>
        <span class="p">},</span>
        <span class="nx">slug</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">path</span><span class="p">.</span><span class="nx">toLowerCase</span><span class="p">()</span>
                <span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/^\/|\/$/g</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/ /g</span><span class="p">,</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
                <span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/\//g</span><span class="p">,</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
                <span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/[-]+/g</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">)</span>
                <span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/[^\w-]+/g</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">},</span>
    <span class="nx">methods</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">dropbox</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nx">Dropbox</span><span class="p">({</span>
                <span class="nx">accessToken</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">accessToken</span>
            <span class="p">});</span>
        <span class="p">},</span>
    <span class="p">}</span>
<span class="p">});</span>
</pre></div>
</div>
</div>
<div class="section" id="getfolderstructure">
<h2>8.3. 创建getFolderStructure方法<a class="headerlink" href="#getfolderstructure" title="永久链接至标题">¶</a></h2>
<p>在组件上创建一个名为 <code class="docutils literal"><span class="pre">getFolderStructure</span></code> 的新方法。 如前所述，此方法需要接受单个路径参数。这样我们可以使用当前路径和子路径：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">getFolderStructure</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span> <span class="p">{}</span>
</pre></div>
</div>
<p>此方法需要检查缓存并返回数据。在方法内部创建一个名为 <code class="docutils literal"><span class="pre">output</span></code> 的新变量并将其返回：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">getFolderStructure</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">output</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">output</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在第6章中缓存数据时，使用 <code class="docutils literal"><span class="pre">Vuex</span></code> 缓存当前文件夹结构，我们使用 <code class="docutils literal"><span class="pre">slug</span></code> 作为存储中的关键字。 <code class="docutils literal"><span class="pre">slug</span></code> 是通过使用当前路径生成的; 但是，我们不能在新方法中使用它，因为它固定在当前位置。这里需要根据传入的路径生成动态结果。</p>
<p>创建一个名为 <code class="docutils literal"><span class="pre">generateSlug</span></code> 的新方法。 这将接受一个参数(路径)，并使用 <code class="docutils literal"><span class="pre">slug</span></code> 计算函数的替换返回转换的字符串：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">generateSlug</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">path</span><span class="p">.</span><span class="nx">toLowerCase</span><span class="p">()</span>
        <span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/^\/|\/$/g</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/ /g</span><span class="p">,</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
        <span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/\//g</span><span class="p">,</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
        <span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/[-]+/g</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">)</span>
        <span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/[^\w-]+/g</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>现在我们可以删除 <code class="docutils literal"><span class="pre">slug</span></code> 计算函数，以便我们没有任何重复的代码。</p>
<p>回到我们的 <code class="docutils literal"><span class="pre">getFolderStructure</span></code> 方法，创建一个存储路径别名的新变量。 为此，我们将使用 <code class="docutils literal"><span class="pre">const</span></code> 创建一个无法更改的变量：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">getFolderStructure</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">output</span><span class="p">;</span>
    <span class="kr">const</span> <span class="nx">slug</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">generateSlug</span><span class="p">(</span><span class="nx">path</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">output</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>我们将创建的最后一个变量是数据路径，就像我们在第8章介绍 <code class="docutils literal"><span class="pre">VueRouter</span></code> 和加载基于 <code class="docutils literal"><span class="pre">URL</span></code> 的组件中所做的那样。这将使用我们刚刚创建的新 <code class="docutils literal"><span class="pre">slug</span></code> 变量：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">getFolderStructure</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">output</span><span class="p">;</span>
    <span class="kr">const</span> <span class="nx">slug</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">generateSlug</span><span class="p">(</span><span class="nx">path</span><span class="p">),</span>
        <span class="nx">data</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">$store</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">structure</span><span class="p">[</span><span class="nx">slug</span><span class="p">];</span>
    <span class="k">return</span> <span class="nx">output</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>我们现在可以使用前面的代码中的 <code class="docutils literal"><span class="pre">data</span></code>  通过if语句判断是否存在缓存。如果存储在缓存中，我们可以将 <code class="docutils literal"><span class="pre">data</span></code> 直接分配给 <code class="docutils literal"><span class="pre">output</span></code> ：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">getFolderStructure</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">output</span><span class="p">;</span>
    <span class="kr">const</span> <span class="nx">slug</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">generateSlug</span><span class="p">(</span><span class="nx">path</span><span class="p">),</span>
        <span class="nx">data</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">$store</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">structure</span><span class="p">[</span><span class="nx">slug</span><span class="p">];</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">output</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">output</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>但是，通过 <code class="docutils literal"><span class="pre">Dropbox</span> <span class="pre">API</span></code> 调用，我们可以调整它以适应这个新代码。 以前，它从 <code class="docutils literal"><span class="pre">API</span></code> 中检索数据，然后触发一个方法，然后保存并显示结构。 由于我们需要将检索到的数据存储到 <code class="docutils literal"><span class="pre">output</span></code> 变量中，因此我们将更改数据流。 我们首先将响应存储在缓存中，然后将数据返回到 <code class="docutils literal"><span class="pre">output</span></code> 变量，而不是触发方法。</p>
<p>由于我们只使用 <code class="docutils literal"><span class="pre">API</span></code> 调用中的条目，因此我们也将更新 <code class="docutils literal"><span class="pre">store</span></code> 以缓存这部分响应。 这将减少应用程序的代码和复杂性：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">getFolderStructure</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">output</span><span class="p">;</span>
    <span class="kr">const</span> <span class="nx">slug</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">generateSlug</span><span class="p">(</span><span class="nx">path</span><span class="p">),</span>
        <span class="nx">data</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">$store</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">structure</span><span class="p">[</span><span class="nx">slug</span><span class="p">];</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">output</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">output</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">dropbox</span><span class="p">().</span><span class="nx">filesListFolder</span><span class="p">({</span>
            <span class="nx">path</span><span class="o">:</span> <span class="nx">path</span><span class="p">,</span>
            <span class="nx">include_media_info</span><span class="o">:</span> <span class="kc">true</span>
        <span class="p">})</span>
            <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">response</span> <span class="p">=&gt;</span> <span class="p">{</span>
                <span class="kd">let</span> <span class="nx">entries</span> <span class="o">=</span> <span class="nx">response</span><span class="p">.</span><span class="nx">entries</span><span class="p">;</span>
                <span class="k">this</span><span class="p">.</span><span class="nx">$store</span><span class="p">.</span><span class="nx">commit</span><span class="p">(</span><span class="s1">&#39;structure&#39;</span><span class="p">,</span> <span class="p">{</span>
                    <span class="nx">path</span><span class="o">:</span> <span class="nx">slug</span><span class="p">,</span>
                    <span class="nx">data</span><span class="o">:</span> <span class="nx">entries</span>
                <span class="p">});</span>
                <span class="k">return</span> <span class="nx">entries</span><span class="p">;</span>
            <span class="p">})</span>
            <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">error</span> <span class="p">=&gt;</span> <span class="p">{</span>
                <span class="k">this</span><span class="p">.</span><span class="nx">isLoading</span> <span class="o">=</span> <span class="s1">&#39;error&#39;</span><span class="p">;</span>
                <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
            <span class="p">});</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">output</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">Dropbox</span> <span class="pre">filesListFolder</span></code> 方法使用传入的路径变量，而不是它以前使用的全局路径变量。然后将响应中的条目存储在变量中，然后使用相同的 <code class="docutils literal"><span class="pre">mutation</span></code> 缓存到 <code class="docutils literal"><span class="pre">Vuex</span></code> 存储中。然后从 <code class="docutils literal"><span class="pre">promise</span></code> 中返回 <code class="docutils literal"><span class="pre">entries</span></code> 变量，将结果存储在 <code class="docutils literal"><span class="pre">output</span></code> 中。 <code class="docutils literal"><span class="pre">catch()</span></code> 函数与以前相同。</p>
<p>通过从缓存或 <code class="docutils literal"><span class="pre">API</span></code> 返回数据，我们可以在创建组件和更新路径时触发并处理这些数据。然而，在我们这样做之前，我们需要混合处理数据类型。</p>
<p>从 <code class="docutils literal"><span class="pre">API</span></code> 返回时，数据仍然是需要解决的 <code class="docutils literal"><span class="pre">promise</span></code> ；将它分配给一个变量只是传递了稍后解决的 <code class="docutils literal"><span class="pre">promise</span></code> 。然而，来自 <code class="docutils literal"><span class="pre">store</span></code> 的数据是一个普通数组。为了给我们一个单一的数据类型来处理，我们将把存储数组 <code class="docutils literal"><span class="pre">resolve</span></code> 为一个 <code class="docutils literal"><span class="pre">promise</span></code> ，这意味着不管数据从哪里加载 <code class="docutils literal"><span class="pre">getFolderStructure</span></code> 返回一个 <code class="docutils literal"><span class="pre">promise</span></code> ：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">getFolderStructure</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">output</span><span class="p">;</span>
    <span class="kr">const</span> <span class="nx">slug</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">generateSlug</span><span class="p">(</span><span class="nx">path</span><span class="p">),</span>
        <span class="nx">data</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">$store</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">structure</span><span class="p">[</span><span class="nx">slug</span><span class="p">];</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">output</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span> <span class="c1">// 转换为Promise</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">output</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">dropbox</span><span class="p">().</span><span class="nx">filesListFolder</span><span class="p">({</span>
            <span class="nx">path</span><span class="o">:</span> <span class="nx">path</span><span class="p">,</span>
            <span class="nx">include_media_info</span><span class="o">:</span> <span class="kc">true</span>
        <span class="p">})</span>
            <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">response</span> <span class="p">=&gt;</span> <span class="p">{</span>
                <span class="kd">let</span> <span class="nx">entries</span> <span class="o">=</span> <span class="nx">response</span><span class="p">.</span><span class="nx">entries</span><span class="p">;</span>
                <span class="k">this</span><span class="p">.</span><span class="nx">$store</span><span class="p">.</span><span class="nx">commit</span><span class="p">(</span><span class="s1">&#39;structure&#39;</span><span class="p">,</span> <span class="p">{</span>
                    <span class="nx">path</span><span class="o">:</span> <span class="nx">slug</span><span class="p">,</span>
                    <span class="nx">data</span><span class="o">:</span> <span class="nx">entries</span>
                <span class="p">});</span>
                <span class="k">return</span> <span class="nx">entries</span><span class="p">;</span>
            <span class="p">})</span>
            <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">error</span> <span class="p">=&gt;</span> <span class="p">{</span>
                <span class="k">this</span><span class="p">.</span><span class="nx">isLoading</span> <span class="o">=</span> <span class="s1">&#39;error&#39;</span><span class="p">;</span>
                <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
            <span class="p">});</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">output</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>通过这个 <code class="docutils literal"><span class="pre">getFolderStructure</span></code> 方法，我们现在可以从 <code class="docutils literal"><span class="pre">API</span></code> 加载一些数据，并将结果存储在全局缓存中，而无需更新视图。 然而，该函数会返回我们希望用 <code class="docutils literal"><span class="pre">JavaScript</span> <span class="pre">promise</span></code> 进一步处理它的信息。</p>
<p>我们现在可以继续创建我们的下一个方法 <code class="docutils literal"><span class="pre">displayFolderStructure</span></code> ，它将采用我们刚刚创建的方法的结果并更新 <code class="docutils literal"><span class="pre">View</span></code> ，以便应用程序再次可以导航。</p>
</div>
<div class="section" id="displayfolderstructure">
<h2>8.4. 用displayFolderStructure方法显示数据<a class="headerlink" href="#displayfolderstructure" title="永久链接至标题">¶</a></h2>
<p>随着我们的数据现在可以从 <code class="docutils literal"><span class="pre">store</span></code> 中缓存并提供，我们可以继续使用我们的新方法实际显示数据。 在 <code class="docutils literal"><span class="pre">dropbox-viewer</span></code> 组件中创建一个名为 <code class="docutils literal"><span class="pre">displayFolderStructure</span></code> 新方法：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">displayFolderStructure</span><span class="p">()</span> <span class="p">{}</span>
</pre></div>
</div>
<p>这种方法将借用该组件以前版本中的很多代码。请记住，此方法纯粹用于显示文件夹，与缓存内容无关。</p>
<p>该方法的过程将是：</p>
<ol class="arabic simple">
<li>在应用程序中将加载状态设置为 <code class="docutils literal"><span class="pre">active</span></code> 状态。这让用户知道发生了一些事情。</li>
<li>创建一个空的 <code class="docutils literal"><span class="pre">structure</span></code> 对象。</li>
<li>加载 <code class="docutils literal"><span class="pre">getFolderStructure</span></code> 方法的内容。</li>
<li>遍历结果并将每个项目添加到 <code class="docutils literal"><span class="pre">folders</span></code> 或 <code class="docutils literal"><span class="pre">files</span></code> 数组中。</li>
<li>将全局 <code class="docutils literal"><span class="pre">structure</span></code> 对象设置为新创建的对象。</li>
<li>将加载状态设置为 <code class="docutils literal"><span class="pre">false</span></code> ，以便显示内容。</li>
</ol>
<div class="section" id="true">
<h3>8.4.1. 将加载状态设置为true并创建一个空的结构对象<a class="headerlink" href="#true" title="永久链接至标题">¶</a></h3>
<p>此方法的第一步是隐藏结构树并显示加载消息。这可以像以前一样完成，方法是将 <code class="docutils literal"><span class="pre">isLoading</span></code> 变量设置为 <code class="docutils literal"><span class="pre">true</span></code> 。我们也可以在这里创建我们的空 <code class="docutils literal"><span class="pre">structure</span></code> 对象，随时可以填充数据：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">displayFolderStructure</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">isLoading</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="kr">const</span> <span class="nx">structure</span> <span class="o">=</span> <span class="p">{</span>
        <span class="nx">folders</span><span class="o">:</span> <span class="p">[],</span>
        <span class="nx">files</span><span class="o">:</span> <span class="p">[]</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h3>8.4.2. 加载getFolderStructure方法的内容<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<p>由于 <code class="docutils literal"><span class="pre">getFolderStructure</span></code> 方法返回一个 <code class="docutils literal"><span class="pre">promise</span></code> ，我们需要在继续操作之前解析结果。这是通过 <code class="docutils literal"><span class="pre">.then()</span></code> 函数完成的； 我们已经在 <code class="docutils literal"><span class="pre">Dropbox</span></code> 类中使用了它。调用该方法，然后将结果分配给一个变量：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">displayFolderStructure</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">isLoading</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="kr">const</span> <span class="nx">structure</span> <span class="o">=</span> <span class="p">{</span>
        <span class="nx">folders</span><span class="o">:</span> <span class="p">[],</span>
        <span class="nx">files</span><span class="o">:</span> <span class="p">[]</span>
    <span class="p">}</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">getFolderStructure</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">path</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">data</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
<p>此代码将组件的 <code class="docutils literal"><span class="pre">path</span></code> 对象传递给方法。此路径是用户正尝试查看的当前路径。 一旦数据返回，我们可以将其分配给 data 变量，然后可以在函数内部使用。</p>
</div>
<div class="section" id="id5">
<h3>8.4.3. 循环遍历结果并将每个项目添加到文件夹或文件数组中<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<p>我们已经熟悉遍历条目并检查每个条目的 <code class="docutils literal"><span class="pre">.tag</span></code> 属性的代码。如果结果是一个文件夹，它将被添加到 <code class="docutils literal"><span class="pre">structure.folders</span></code> 数组中，否则它将被追加到 <code class="docutils literal"><span class="pre">structure.files</span></code> 中。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">displayFolderStructure</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">isLoading</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="kr">const</span> <span class="nx">structure</span> <span class="o">=</span> <span class="p">{</span>
        <span class="nx">folders</span><span class="o">:</span> <span class="p">[],</span>
        <span class="nx">files</span><span class="o">:</span> <span class="p">[]</span>
    <span class="p">}</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">getFolderStructure</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">path</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">data</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">entry</span> <span class="k">of</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Check &quot;.tag&quot; prop for type</span>
            <span class="k">if</span><span class="p">(</span><span class="nx">entry</span><span class="p">[</span><span class="s1">&#39;.tag&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;folder&#39;</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">structure</span><span class="p">.</span><span class="nx">folders</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">entry</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nx">structure</span><span class="p">.</span><span class="nx">files</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">entry</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="structure">
<h3>8.4.4. 更新全局 structure 对象并修改加载状态<a class="headerlink" href="#structure" title="永久链接至标题">¶</a></h3>
<p>此方法的最后一项任务是更新全局 <code class="docutils literal"><span class="pre">structure</span></code> 并修改加载状态。此代码与之前没有任何变化：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">displayFolderStructure</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">isLoading</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="kr">const</span> <span class="nx">structure</span> <span class="o">=</span> <span class="p">{</span>
        <span class="nx">folders</span><span class="o">:</span> <span class="p">[],</span>
        <span class="nx">files</span><span class="o">:</span> <span class="p">[]</span>
    <span class="p">};</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">getFolderStructure</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">path</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">data</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">entry</span> <span class="k">of</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Check &quot;.tag&quot; prop for type</span>
            <span class="k">if</span><span class="p">(</span><span class="nx">entry</span><span class="p">[</span><span class="s1">&#39;.tag&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;folder&#39;</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">structure</span><span class="p">.</span><span class="nx">folders</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">entry</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nx">structure</span><span class="p">.</span><span class="nx">files</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">entry</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">structure</span> <span class="o">=</span> <span class="nx">structure</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">isLoading</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
<p>我们现在有一个方法可以显示我们的数据检索结果。</p>
</div>
</div>
<div class="section" id="id6">
<h2>8.5. 调用该方法<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h2>
<p>现在可以在创建 <code class="docutils literal"><span class="pre">dropbox-viewer</span></code> 组件时调用此方法。该路径已经被填充，这要归功于全局 <code class="docutils literal"><span class="pre">Vue</span></code> 中的 <code class="docutils literal"><span class="pre">created</span></code> 函数，它将 <code class="docutils literal"><span class="pre">URL</span></code> 散列提交给 <code class="docutils literal"><span class="pre">store</span></code> ，从而创建路径变量。 因此，我们不需要传递任何东西给函数。将 <code class="docutils literal"><span class="pre">created</span></code> 的函数添加到组件中，并在里面调用新方法：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">Vue</span><span class="p">.</span><span class="nx">component</span><span class="p">(</span><span class="s1">&#39;dropbox-viewer&#39;</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">template</span><span class="o">:</span> <span class="s1">&#39;#dropbox-viewer-template&#39;</span><span class="p">,</span>
    <span class="nx">data</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="nx">accessToken</span><span class="o">:</span> <span class="s1">&#39;XXXX&#39;</span><span class="p">,</span>
            <span class="nx">structure</span><span class="o">:</span> <span class="p">{},</span>
            <span class="nx">isLoading</span><span class="o">:</span> <span class="kc">true</span>
        <span class="p">}</span>
    <span class="p">},</span>
    <span class="nx">computed</span><span class="o">:</span> <span class="p">{</span>
        <span class="p">...</span>
    <span class="p">},</span>
    <span class="nx">methods</span><span class="o">:</span> <span class="p">{</span>
        <span class="p">...</span>
    <span class="p">},</span>
    <span class="nx">created</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">displayFolderStructure</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">});</span>
</pre></div>
</div>
<p>刷新应用程序现在将加载您的文件夹内容。 更新 <code class="docutils literal"><span class="pre">URL</span></code> 哈希并重新加载页面也会显示该文件夹的内容；但是，单击任何文件夹链接将更新面包屑，但不会更新数据结构。 这可以通过观察 <code class="docutils literal"><span class="pre">computed</span></code> 路径变量来解决。 当哈希更新并因此可以触发 <code class="docutils literal"><span class="pre">watch</span></code> 对象中的函数时，这将会更新。 添加一个函数，用于监视 <code class="docutils literal"><span class="pre">path</span></code> 变量的更新，并在具有以下内容时触发新方法：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">created</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">displayFolderStructure</span><span class="p">();</span>
<span class="p">},</span>
<span class="nx">watch</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">path</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">displayFolderStructure</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>有了这个，我们创建了一个应用程序，再次缓存您访问过的任何文件夹。第一次点击结构看起来非常慢，但是一旦你重新导入树并重新进入子文件夹，你几乎看不到加载屏幕。尽管应用程序具有与本章开始时相同的功能，但我们重构了代码以分离检索和缓存以及显示数据。 我们继续通过预缓存所选路径的子文件夹来进一步增强我们的应用程序。</p>
</div>
<div class="section" id="id7">
<h2>8.6. 缓存子文件夹<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h2>
<p>现在我们可以在不更新 <code class="docutils literal"><span class="pre">Vue</span></code> 的情况下缓存文件夹，我们可以使用我们的 <code class="docutils literal"><span class="pre">structure</span></code> 对象来获取子文件夹的内容。使用结构对象中的 <code class="docutils literal"><span class="pre">folders</span></code> 数组，我们可以遍历它并依次缓存每个文件夹。</p>
<p>我们必须确保我们不会妨碍应用程序的性能；缓存必须异步完成，所以用户不知道这个过程。我们还需要确保我们不会运行不必要地缓存。</p>
<p>为了达到这个目的，我们可以 <code class="docutils literal"><span class="pre">watch</span> <span class="pre">structure</span></code> 对象。只有从缓存或 <code class="docutils literal"><span class="pre">API</span></code> 中加载数据并更新 <code class="docutils literal"><span class="pre">Vue</span></code> 后，才会进行更新。用户查看文件夹的内容后，我们可以循环遍历文件夹以存储其内容。</p>
<p>但是，有一个小问题。如果我们监听 <code class="docutils literal"><span class="pre">structure</span></code> 变量，那么我们的代码将永远不会运行，因为对象的直接内容不会更新，尽管我们每次都用新的结构对象替换它。不同的文件夹，结构对象总是有两个键，即文件和文件夹，它们都是数组。就 <code class="docutils literal"><span class="pre">Vue</span></code> 和 <code class="docutils literal"><span class="pre">JavaScript</span></code> 而言，结构对象从不改变。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">由于 <code class="docutils literal"><span class="pre">Vue</span></code> 会在初始化实例时对属性执行 <code class="docutils literal"><span class="pre">getter/setter</span></code> 转化过程，所以属性必须在 <code class="docutils literal"><span class="pre">data</span></code> 对象上存在才能让 <code class="docutils literal"><span class="pre">Vue</span></code> 转换它，这样才能让它是响应的。</p>
</div>
<p>但是， <code class="docutils literal"><span class="pre">Vue</span></code> 可以检测 <code class="docutils literal"><span class="pre">deep</span></code> 变量的嵌套更改。这可以在每个变量的基础上启用。与组件上的道具类似，为了在监视属性上启用更多选项，可以将其传递给对象而不是直接函数。</p>
<p>为结构创建一个新的观察键，该键是具有两个值的对象， <code class="docutils literal"><span class="pre">deep</span></code> 和 <code class="docutils literal"><span class="pre">handler</span></code> 。 <code class="docutils literal"><span class="pre">deep</span></code> 键将被设置为 <code class="docutils literal"><span class="pre">true</span></code> ，而 <code class="docutils literal"><span class="pre">handler</span></code> 将是变量被更改时触发的函数：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">watch</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">path</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">displayFolderStructure</span><span class="p">();</span>
    <span class="p">},</span>
    <span class="nx">structure</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">deep</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
            <span class="nx">handler</span><span class="p">()</span> <span class="p">{</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在这个 <code class="docutils literal"><span class="pre">handler</span></code> 中，我们现在可以遍历每个文件夹并为每个文件夹运行 <code class="docutils literal"><span class="pre">getFolderStructure</span></code> 方法，并使用每个文件夹的 <code class="docutils literal"><span class="pre">path_lower</span></code> 属性作为函数参数：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">structure</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">deep</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="nx">handler</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">folder</span> <span class="k">of</span> <span class="k">this</span><span class="p">.</span><span class="nx">structure</span><span class="p">.</span><span class="nx">folders</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">getFolderStructure</span><span class="p">(</span><span class="nx">folder</span><span class="p">.</span><span class="nx">path_lower</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>通过这段简单的代码，我们的应用似乎加速了十倍。您导航到的每个子文件夹都会立即加载（除非您有特别长的文件夹列表，并且很快导航到最后一个文件夹）。 为了让您了解缓存的速度和时间，请在 <code class="docutils literal"><span class="pre">getFolderStructure</span></code> 方法中添加一个 <code class="docutils literal"><span class="pre">console.log()</span></code> 来记录这些信息：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="k">if</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">output</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`API query for </span><span class="si">${</span><span class="nx">path</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
    <span class="nx">output</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">dropbox</span><span class="p">().</span><span class="nx">filesListFolder</span><span class="p">({</span>
        <span class="nx">path</span><span class="o">:</span> <span class="nx">path</span><span class="p">,</span>
        <span class="nx">include_media_info</span><span class="o">:</span> <span class="kc">true</span>
    <span class="p">})</span>
        <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">response</span> <span class="p">=&gt;</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`Response for </span><span class="si">${</span><span class="nx">path</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
        <span class="p">...</span>
</pre></div>
</div>
<p>这使您可以看到所有的 <code class="docutils literal"><span class="pre">API</span></code> 调用都是异步完成的 - 应用程序不会等待前一个文件夹被加载并缓存，然后再转到下一个文件夹。 这具有允许缓存较小的文件夹而无需等待从 <code class="docutils literal"><span class="pre">API</span></code> 返回更大的文件夹的优点。</p>
</div>
<div class="section" id="id8">
<h2>8.7. 修改缓存方法<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h2>
<p>与所有事情一样，在制作应用程序时，有很多方法可以实现相同的结果。 这种方法的缺点是即使你的文件夹只包含文件，这个函数也会触发 - 尽管没有任何事情要做。</p>
<p>另一种方法是再次使用我们的 <code class="docutils literal"><span class="pre">created</span></code> 函数，这次是在 <code class="docutils literal"><span class="pre">folder</span></code> 组件本身上，以路径作为参数触发父方法。</p>
<p>一种做法是使用 <code class="docutils literal"><span class="pre">$parent</span></code> 属性。在 <code class="docutils literal"><span class="pre">folder</span></code> 组件中，使用 <code class="docutils literal"><span class="pre">this.$parent</span></code> 将允许访问 <code class="docutils literal"><span class="pre">dropbox-viewer</span></code> 组件上的变量，方法和计算值。</p>
<p>将 <code class="docutils literal"><span class="pre">created</span></code> 函数添加到 <code class="docutils literal"><span class="pre">folder</span></code> 组件，并从 <code class="docutils literal"><span class="pre">Dropbox</span></code> 组件中删除 <code class="docutils literal"><span class="pre">structure</span> <span class="pre">watch</span></code> 属性。 从那里，调用父 <code class="docutils literal"><span class="pre">getFolderStructure</span></code> 方法：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">Vue</span><span class="p">.</span><span class="nx">component</span><span class="p">(</span><span class="s1">&#39;folder&#39;</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">template</span><span class="o">:</span> <span class="s1">&#39;&lt;li&gt;&lt;strong&gt;&lt;a :href=&quot;\&#39;#\&#39; + f.path_lower&quot;&gt;{{ f.name }}&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;&#39;</span><span class="p">,</span>
    <span class="nx">props</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">f</span><span class="o">:</span> <span class="nb">Object</span>
    <span class="p">},</span>
    <span class="nx">created</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">$parent</span><span class="p">.</span><span class="nx">getFolderStructure</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">f</span><span class="p">.</span><span class="nx">path_lower</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">});</span>
</pre></div>
</div>
<p>预览应用程序证明了此方法的有效性。只有在结构中存在文件夹时才会触发，这种更清楚的技术将文件夹缓存与文件夹本身绑定在一起，而不是混入 <code class="docutils literal"><span class="pre">Dropbox</span></code> 代码中。</p>
<p>但是，除非必要，否则应该避免使用 <code class="docutils literal"><span class="pre">this.$parent</span></code> ，并且只能用于边缘情况。 由于我们有机会使用 <code class="docutils literal"><span class="pre">props</span></code> ，我们应该这样做。 它还使我们有机会在文件夹上下文中为该功能提供更有意义的名称。</p>
<p>导航到您的 <code class="docutils literal"><span class="pre">HTML</span></code> 视图并更新 <code class="docutils literal"><span class="pre">folder</span></code> 组件以接受新的 <code class="docutils literal"><span class="pre">prop</span></code> 。我们将使用 <code class="docutils literal"><span class="pre">cache</span> <span class="pre">prop</span></code> 并将该函数作为值传递。由于该属性是动态的，因此不要忘记添加前面的冒号：</p>
<div class="highlight-html"><div class="highlight"><pre><span></span><span class="p">&lt;</span><span class="nt">folder</span> <span class="na">:f</span><span class="o">=</span><span class="s">&quot;entry&quot;</span> <span class="na">:cache</span><span class="o">=</span><span class="s">&quot;getFolderStructure&quot;</span><span class="p">&gt;&lt;/</span><span class="nt">folder</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>将 <code class="docutils literal"><span class="pre">cache</span></code> 键添加到 <code class="docutils literal"><span class="pre">JavaScript</span> <span class="pre">folder</span></code> 组件中的 <code class="docutils literal"><span class="pre">props</span></code> 项。 告诉 <code class="docutils literal"><span class="pre">Vue</span></code> ，输入将是一个函数：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">Vue</span><span class="p">.</span><span class="nx">component</span><span class="p">(</span><span class="s1">&#39;folder&#39;</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">template</span><span class="o">:</span> <span class="s1">&#39;&lt;li&gt;&lt;strong&gt;&lt;a :href=&quot;\&#39;#\&#39; + f.path_lower&quot;&gt;{{ f.name }}&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;&#39;</span><span class="p">,</span>
    <span class="nx">props</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">f</span><span class="o">:</span> <span class="nb">Object</span><span class="p">,</span>
        <span class="nx">cache</span><span class="o">:</span> <span class="nb">Function</span>
    <span class="p">}</span>
<span class="p">});</span>
</pre></div>
</div>
<p>最后，我们可以在 <code class="docutils literal"><span class="pre">created</span></code> 函数中调用我们的新的 <code class="docutils literal"><span class="pre">cache()</span></code> 方法：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">Vue</span><span class="p">.</span><span class="nx">component</span><span class="p">(</span><span class="s1">&#39;folder&#39;</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">template</span><span class="o">:</span> <span class="s1">&#39;&lt;li&gt;&lt;strong&gt;&lt;a :href=&quot;\&#39;#\&#39; + f.path_lower&quot;&gt;{{ f.name }}&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;&#39;</span><span class="p">,</span>
    <span class="nx">props</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">f</span><span class="o">:</span> <span class="nb">Object</span><span class="p">,</span>
        <span class="nx">cache</span><span class="o">:</span> <span class="nb">Function</span>
    <span class="p">},</span>
    <span class="nx">created</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">cache</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">f</span><span class="p">.</span><span class="nx">path_lower</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">});</span>
</pre></div>
</div>
<p>可以像以前一样使用控制台日志再次验证高速缓存。 这会创建更简洁的代码，使您和其他开发人员更容易阅读。</p>
<p>随着我们的 <code class="docutils literal"><span class="pre">Dropbox</span></code> 应用程序的进步，我们可以继续缓存父文件夹，如果您在 <code class="docutils literal"><span class="pre">URL</span></code> 中使用散列输入子文件夹。</p>
</div>
<div class="section" id="id9">
<h2>8.8. 缓存父文件夹<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h2>
<p>缓存父结构是我们能够帮助加速我们的应用程序的下一个先发制人的事情。假设我们已经浏览了我们的图片目录 <code class="docutils literal"><span class="pre">/images/holiday/summer</span></code> ，并希望与朋友或同事分享。我们会在 <code class="docutils literal"><span class="pre">URL</span></code> 哈希中将这个 <code class="docutils literal"><span class="pre">URL</span></code> 发送给他们，并且在页面加载时，他们会看到内容。例如，如果他们使用面包屑导航到 <code class="docutils literal"><span class="pre">/images/holiday</span></code> 节点，那么他们需要等待应用程序检索内容。</p>
<p>使用 <code class="docutils literal"><span class="pre">breadcrumb</span></code> 组件，我们可以缓存父目录，因此，在导航到 <code class="docutils literal"><span class="pre">holiday</span></code> 文件夹时，用户将立即显示其内容。当用户浏览该文件夹时，其所有子文件夹都将使用先前的方法一起缓存。</p>
<p>为了缓存父文件夹，我们已经有一个组件显示路径，可以访问我们循环遍历的所有父文件夹的别名 - 面包屑。</p>
<p>在开始缓存过程之前，我们需要更新组件内的 <code class="docutils literal"><span class="pre">folders</span></code> 计算函数。这是因为目前我们存储的路径带有散列前置，这会为 <code class="docutils literal"><span class="pre">Dropbox</span> <span class="pre">API</span></code> 创建无效路径。从被推送到 <code class="docutils literal"><span class="pre">output</span></code> 数组的对象中移除哈希，并以类似于 <code class="docutils literal"><span class="pre">folder</span></code> 组件的方式将其添加到模板中：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">Vue</span><span class="p">.</span><span class="nx">component</span><span class="p">(</span><span class="s1">&#39;breadcrumb&#39;</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">template</span><span class="o">:</span> <span class="s1">&#39;&lt;div&gt;&#39;</span> <span class="o">+</span>
        <span class="s1">&#39;&lt;span v-for=&quot;(f, i) in folders&quot;&gt;&#39;</span> <span class="o">+</span>
            <span class="s1">&#39;&lt;a :href=&quot;\&#39;#\&#39; + f.path&quot;&gt;{{ f.name || &#39;</span><span class="nx">Home</span><span class="s1">&#39; }}&lt;/a&gt;&#39;</span> <span class="o">+</span>
            <span class="s1">&#39;&lt;i v-if=&quot;i !== (folders.length - 1)&quot;&gt; &amp;raquo; &lt;/i&gt;&#39;</span> <span class="o">+</span>
        <span class="s1">&#39;&lt;/span&gt;&#39;</span> <span class="o">+</span>
    <span class="s1">&#39;&lt;/div&gt;&#39;</span><span class="p">,</span>
    <span class="nx">computed</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">folders</span><span class="p">()</span> <span class="p">{</span>
            <span class="kd">let</span> <span class="nx">output</span> <span class="o">=</span> <span class="p">[],</span>
                <span class="nx">slug</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
                <span class="nx">parts</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">$store</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">path</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">);</span>
            <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">item</span> <span class="k">of</span> <span class="nx">parts</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">slug</span> <span class="o">+=</span> <span class="nx">item</span><span class="p">;</span>
                <span class="nx">output</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="o">:</span> <span class="nx">item</span> <span class="o">||</span> <span class="s1">&#39;home&#39;</span><span class="p">,</span> <span class="s1">&#39;path&#39;</span><span class="o">:</span> <span class="nx">slug</span><span class="p">});</span>
                <span class="nx">slug</span> <span class="o">+=</span> <span class="s1">&#39;/&#39;</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="nx">output</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">});</span>
</pre></div>
</div>
<p>我们现在可以使用输出来显示面包屑和缓存父结构。</p>
<p>第一步是允许 <code class="docutils literal"><span class="pre">breadcrumb</span></code> 组件访问缓存函数。与 <code class="docutils literal"><span class="pre">folder</span></code> 组件类似的方式，将该函数作为 <code class="docutils literal"><span class="pre">prop</span></code> 添加到视图中的 <code class="docutils literal"><span class="pre">breadcrumb</span></code> 组件：</p>
<div class="highlight-html"><div class="highlight"><pre><span></span><span class="p">&lt;</span><span class="nt">breadcrumb</span> <span class="na">:cache</span><span class="o">=</span><span class="s">&quot;getFolderStructure&quot;</span><span class="p">&gt;&lt;/</span><span class="nt">breadcrumb</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>将 <code class="docutils literal"><span class="pre">props</span></code> 对象添加到 <code class="docutils literal"><span class="pre">JavaScript</span></code> 代码中的组件中。 声明 <code class="docutils literal"><span class="pre">cache</span></code> 道具作为一个函数，所以 <code class="docutils literal"><span class="pre">Vue</span></code> 知道会发生什么：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">Vue</span><span class="p">.</span><span class="nx">component</span><span class="p">(</span><span class="s1">&#39;breadcrumb&#39;</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">template</span><span class="o">:</span> <span class="s1">&#39;...&#39;</span><span class="p">,</span>
    <span class="nx">props</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">cache</span><span class="o">:</span> <span class="nb">Function</span>
    <span class="p">},</span>
    <span class="nx">computed</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">folders</span><span class="p">()</span> <span class="p">{</span>
        <span class="p">...</span>
        <span class="p">}</span>
<span class="p">});</span>
</pre></div>
</div>
<p><strong>父级数据结构</strong> 将在创建 <code class="docutils literal"><span class="pre">breadcrumb</span></code> 组件时生成。 但是，由于这会阻止加载过程，因此我们将在组件 <code class="docutils literal"><span class="pre">mounted</span></code> 而不是 <code class="docutils literal"><span class="pre">created</span></code> 时触发它。</p>
<p>向您的组件添加一个 <code class="docutils literal"><span class="pre">mounted</span></code> 函数，并将文件夹的计算值分配给一个变量：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">Vue</span><span class="p">.</span><span class="nx">component</span><span class="p">(</span><span class="s1">&#39;breadcrumb&#39;</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">template</span><span class="o">:</span> <span class="s1">&#39;...&#39;</span><span class="p">,</span>
    <span class="nx">props</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">cache</span><span class="o">:</span> <span class="nb">Function</span>
    <span class="p">},</span>
    <span class="nx">computed</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">folders</span><span class="p">()</span> <span class="p">{</span>
        <span class="p">...</span>
        <span class="p">}</span>
    <span class="p">},</span>
    <span class="nx">mounted</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">parents</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">folders</span><span class="p">;</span> <span class="c1">// 生成父数据结构</span>
    <span class="p">}</span>
<span class="p">});</span>
</pre></div>
</div>
<p>我们现在需要开始缓存文件夹；但是，我们可以明智的决定缓存文件夹的顺序。我们可以假设用户通常会回到文件夹树，所以我们理想的情况下应该缓存直接父节点，然后再移动到其父节点上，等等。由于我们的文件夹的变量从上到下，我们需要将其反转。</p>
<p>我们可以做的另一件事是提高性能，即删除当前文件夹; 因为我们已经在其中，应用程序已经缓存了它。 在您的组件中，反转该数组并删除第一个项目：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">mounted</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">parents</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">folders</span><span class="p">;</span>
    <span class="nx">parents</span><span class="p">.</span><span class="nx">reverse</span><span class="p">().</span><span class="nx">shift</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如果我们将``parents`` 变量添加到控制台日志函数中 ，我们可以看到它包含我们现在想要缓存的文件夹。 我们现在可以遍历这个数组，为数组中的每个元素调用缓存函数：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">mounted</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">parents</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">folders</span><span class="p">;</span>
    <span class="nx">parents</span><span class="p">.</span><span class="nx">reverse</span><span class="p">().</span><span class="nx">shift</span><span class="p">();</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">parent</span> <span class="k">of</span> <span class="nx">parents</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">cache</span><span class="p">(</span><span class="nx">parent</span><span class="p">.</span><span class="nx">path</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>有了这个，我们的父母和孩子文件夹被应用程序缓存，导致树上下之间快速导航。 但是，在挂载的函数内部运行 <code class="docutils literal"><span class="pre">console.log()</span></code> 会显示每次导航文件夹时重新安装面包屑。 这是因为 <code class="docutils literal"><span class="pre">View</span></code> 中的 <code class="docutils literal"><span class="pre">v-if</span></code> 语句，每次删除和添加 <code class="docutils literal"><span class="pre">HTML</span></code> 。</p>
<p>由于我们只需要在初始应用程序加载时缓存父文件夹一次，让我们看看更改触发的位置。 我们只需要第一次运行这个函数； 一旦用户开始在树上上下导航，所有访问的文件夹将一路缓存。</p>
</div>
<div class="section" id="id10">
<h2>8.9. 缓存父文件夹一次<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h2>
<p>为确保我们使用的资源最少，我们可以将用于 <code class="docutils literal"><span class="pre">breadcrumb</span></code> 的文件夹数组保留在 <code class="docutils literal"><span class="pre">store</span></code> 中。 这意味着 <code class="docutils literal"><span class="pre">breadcrumb</span></code> 组件和我们的父缓存函数都可以访问同一个数组。</p>
<p>将 <code class="docutils literal"><span class="pre">breadcrumb</span></code> 键添加到 <code class="docutils literal"><span class="pre">store</span> <span class="pre">state</span></code> - 这是我们将存储数组的位置：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">store</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vuex</span><span class="p">.</span><span class="nx">Store</span><span class="p">({</span>
    <span class="nx">state</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">path</span><span class="o">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
        <span class="nx">structure</span><span class="o">:</span> <span class="p">{},</span>
        <span class="nx">breadcrumb</span><span class="o">:</span> <span class="p">[]</span>
    <span class="p">},</span>
    <span class="nx">mutations</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">updateHash</span><span class="p">(</span><span class="nx">state</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">let</span> <span class="nx">hash</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">hash</span><span class="p">.</span><span class="nx">substring</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
            <span class="nx">state</span><span class="p">.</span><span class="nx">path</span> <span class="o">=</span> <span class="p">(</span><span class="nx">hash</span> <span class="o">||</span> <span class="s1">&#39;&#39;</span><span class="p">);</span>
        <span class="p">},</span>
        <span class="nx">structure</span><span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">payload</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">state</span><span class="p">.</span><span class="nx">structure</span><span class="p">[</span><span class="nx">payload</span><span class="p">.</span><span class="nx">path</span><span class="p">]</span> <span class="o">=</span> <span class="nx">payload</span><span class="p">.</span><span class="nx">data</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">});</span>
</pre></div>
</div>
<p>接下来，将代码从面包屑组件移动到 <code class="docutils literal"><span class="pre">updateHash</span></code> mutation 中，以便我们可以更新 <code class="docutils literal"><span class="pre">path</span></code> 和 <code class="docutils literal"><span class="pre">breadcrumb</span></code> 变量：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">updateHash</span><span class="p">(</span><span class="nx">state</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">hash</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">hash</span><span class="p">.</span><span class="nx">substring</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="nx">state</span><span class="p">.</span><span class="nx">path</span> <span class="o">=</span> <span class="p">(</span><span class="nx">hash</span> <span class="o">||</span> <span class="s1">&#39;&#39;</span><span class="p">);</span>
    <span class="kd">let</span> <span class="nx">output</span> <span class="o">=</span> <span class="p">[],</span>
        <span class="nx">slug</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
        <span class="nx">parts</span> <span class="o">=</span> <span class="nx">state</span><span class="p">.</span><span class="nx">path</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">item</span> <span class="k">of</span> <span class="nx">parts</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">slug</span> <span class="o">+=</span> <span class="nx">item</span><span class="p">;</span>
        <span class="nx">output</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="o">:</span> <span class="nx">item</span> <span class="o">||</span> <span class="s1">&#39;home&#39;</span><span class="p">,</span> <span class="s1">&#39;path&#39;</span><span class="o">:</span> <span class="nx">slug</span><span class="p">});</span>
        <span class="nx">slug</span> <span class="o">+=</span> <span class="s1">&#39;/&#39;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">state</span><span class="p">.</span><span class="nx">breadcrumb</span> <span class="o">=</span> <span class="nx">output</span><span class="p">;</span>
<span class="p">},</span>
</pre></div>
</div>
<p>请注意，它不是返回 <code class="docutils literal"><span class="pre">output</span></code> 数组，而是存储在 <code class="docutils literal"><span class="pre">state</span></code> 对象中。我们现在可以在 <code class="docutils literal"><span class="pre">breadcrumb</span></code> 组件上更新 <code class="docutils literal"><span class="pre">folders</span></code> 计算函数以返回 <code class="docutils literal"><span class="pre">store</span></code> 数据：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">computed</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">folders</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">$store</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">breadcrumb</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>现在全局都可以使用这些数据，我们可以在 <code class="docutils literal"><span class="pre">dropboxviewer</span></code> 组件上创建一个新方法，即 <code class="docutils literal"><span class="pre">cacheParentFolders</span></code> ，它会触发我们为 <code class="docutils literal"><span class="pre">breadcrumb</span></code> 组件编写的代码。</p>
<p>在 <code class="docutils literal"><span class="pre">Dropbox</span></code> 组件上创建一个新方法并将代码移动到它。 更新父的位置并确保您发射的路径正确：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">cacheParentFolders</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">parents</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">$store</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">breadcrumb</span><span class="p">;</span>
    <span class="nx">parents</span><span class="p">.</span><span class="nx">reverse</span><span class="p">().</span><span class="nx">shift</span><span class="p">();</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">parent</span> <span class="k">of</span> <span class="nx">parents</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">getFolderStructure</span><span class="p">(</span><span class="nx">parent</span><span class="p">.</span><span class="nx">path</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>我们现在可以在创建 <code class="docutils literal"><span class="pre">Dropbox</span></code> 组件时触发该方法一次。 在 <code class="docutils literal"><span class="pre">created</span></code> 函数中的现有方法调用之后添加它：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">created</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">displayFolderStructure</span><span class="p">();</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">cacheParentFolders</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>现在我们可以做一些家务管理，并从 <code class="docutils literal"><span class="pre">breadcrumb</span></code> 组件中删除 <code class="docutils literal"><span class="pre">mounted</span></code> 的方法，以及视图中的 <code class="docutils literal"><span class="pre">props</span></code> 对象和 <code class="docutils literal"><span class="pre">:cache</span> <span class="pre">prop</span></code> 。 这意味着我们的 <code class="docutils literal"><span class="pre">breadcrumb</span></code> 组件现在比以前更简单：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">Vue</span><span class="p">.</span><span class="nx">component</span><span class="p">(</span><span class="s1">&#39;breadcrumb&#39;</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">template</span><span class="o">:</span> <span class="s1">&#39;&lt;div&gt;&#39;</span> <span class="o">+</span>
        <span class="s1">&#39;&lt;span v-for=&quot;(f, i) in folders&quot;&gt;&#39;</span> <span class="o">+</span>
            <span class="s1">&#39;&lt;a :href=&quot;\&#39;#\&#39; + f.path&quot;&gt;{{ f.name || &#39;</span><span class="nx">Home</span><span class="s1">&#39; }}&lt;/a&gt;&#39;</span> <span class="o">+</span>
            <span class="s1">&#39;&lt;i v-if=&quot;i !== (folders.length - 1)&quot;&gt; &amp;raquo; &lt;/i&gt;&#39;</span> <span class="o">+</span>
        <span class="s1">&#39;&lt;/span&gt;&#39;</span> <span class="o">+</span>
    <span class="s1">&#39;&lt;/div&gt;&#39;</span><span class="p">,</span>
    <span class="nx">computed</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">folders</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">$store</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">breadcrumb</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">});</span>
</pre></div>
</div>
<p>HTML样子如下所示：</p>
<div class="highlight-html"><div class="highlight"><pre><span></span><span class="p">&lt;</span><span class="nt">breadcrumb</span><span class="p">&gt;&lt;/</span><span class="nt">breadcrumb</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>我们还可以整理商店中的 <code class="docutils literal"><span class="pre">updateHash</span></code>  <code class="docutils literal"><span class="pre">mutation</span></code> ，使其更易于理解：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">updateHash</span><span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">path</span> <span class="o">=</span> <span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">hash</span><span class="p">.</span><span class="nx">substring</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="s1">&#39;&#39;</span><span class="p">),</span>
        <span class="nx">breadcrumb</span> <span class="o">=</span> <span class="p">[],</span>
        <span class="nx">slug</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
        <span class="nx">parts</span> <span class="o">=</span> <span class="nx">path</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">item</span> <span class="k">of</span> <span class="nx">parts</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">slug</span> <span class="o">+=</span> <span class="nx">item</span><span class="p">;</span>
        <span class="nx">breadcrumb</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="o">:</span> <span class="nx">item</span> <span class="o">||</span> <span class="s1">&#39;home&#39;</span><span class="p">,</span> <span class="s1">&#39;path&#39;</span><span class="o">:</span> <span class="nx">slug</span><span class="p">});</span>
        <span class="nx">slug</span> <span class="o">+=</span> <span class="s1">&#39;/&#39;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">state</span><span class="p">.</span><span class="nx">path</span> <span class="o">=</span> <span class="nx">path</span>
    <span class="nx">state</span><span class="p">.</span><span class="nx">breadcrumb</span> <span class="o">=</span> <span class="nx">breadcrumb</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>所有变量现在都在顶部声明， <code class="docutils literal"><span class="pre">state</span></code> 在底部更新。 变数的数量也有所减少。</p>
<p>现在查看应用程序，它似乎正常工作；但是，经过仔细检查， <code class="docutils literal"><span class="pre">breadcrumb</span></code> 似乎在初始页面加载时会受到文件夹结构的影响。一旦一个文件夹被导航到，它会迎头赶上，但在第一次加载时，它似乎只有一个项目，并且根本没有查看 <code class="docutils literal"><span class="pre">Dropbox</span></code> 的根目录。</p>
<p>这是因为在我们提交 <code class="docutils literal"><span class="pre">updateHash</span></code> <code class="docutils literal"><span class="pre">mutation</span></code> 之前， <code class="docutils literal"><span class="pre">store</span></code> 还没有完全初始化。 如果我们回想起 <code class="docutils literal"><span class="pre">Vue</span></code> 实例生命周期，请参阅第4章使用 <code class="docutils literal"><span class="pre">Dropbox</span> <span class="pre">API</span></code> 获取文件列表，我们可以看到 <code class="docutils literal"><span class="pre">created</span></code> 函数很早就被触发了。 更新主 <code class="docutils literal"><span class="pre">Vue</span></code> 实例以在 <code class="docutils literal"><span class="pre">mounted</span></code> 时触发 <code class="docutils literal"><span class="pre">mutation</span></code> 来解决问题：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">app</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vue</span><span class="p">({</span>
    <span class="nx">el</span><span class="o">:</span> <span class="s1">&#39;#app&#39;</span><span class="p">,</span>
    <span class="nx">store</span><span class="p">,</span>
    <span class="nx">mounted</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">store</span><span class="p">.</span><span class="nx">commit</span><span class="p">(</span><span class="s1">&#39;updateHash&#39;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">});</span>
</pre></div>
</div>
<p>在所有文件夹都被缓存的情况下，我们可以通过存储每个文件的下载链接来缓存更多的 <code class="docutils literal"><span class="pre">API</span></code> 调用。</p>
<p>我们也可以查看缓存子文件夹的子文件夹，遍历每个缓存文件夹的内容以最终缓存整个树。 我们不会深究这一点，但你随时可以尝试下。</p>
</div>
<div class="section" id="id11">
<h2>8.10. 缓存文件下载链接<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h2>
<p>当用户在文档树周围导航时， <code class="docutils literal"><span class="pre">Dropbox</span> <span class="pre">API</span></code> 仍然被查询的次数超过了必要量。 这是因为每次显示文件时，我们都会查询 <code class="docutils literal"><span class="pre">API</span></code> 以检索下载链接。 通过将下载链接响应存储在缓存中当重新导航到该文件夹时重新显示，可以取消额外的 <code class="docutils literal"><span class="pre">API</span></code> 查询。</p>
<p>每次显示文件时，都会使用 <code class="docutils literal"><span class="pre">store</span></code> 中的数据初始化新组件。 我们可以将其用于我们的优势，因为这意味着我们只需更新组件实例，然后将结果缓存起来。</p>
<p>在您的 <code class="docutils literal"><span class="pre">file</span></code> 组件中，更新 <code class="docutils literal"><span class="pre">API</span></code> 响应，以便不仅将结果保存在数据属性的 <code class="docutils literal"><span class="pre">link</span></code> 属性上，而且还保存在文件实例 <code class="docutils literal"><span class="pre">f</span></code> 上。 这将作为 <code class="docutils literal"><span class="pre">f</span></code> 新键 <code class="docutils literal"><span class="pre">download_link</span></code> 存储。</p>
<p>当存储数据时，我们可以将它们连接赋值：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">Vue</span><span class="p">.</span><span class="nx">component</span><span class="p">(</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">template</span><span class="o">:</span> <span class="s1">&#39;&lt;li&gt;&lt;strong&gt;{{ f.name }}&lt;/strong&gt;&lt;span v-if=&quot;f.size&quot;&gt; - {{ bytesToSize(f.size) }}&lt;/span&gt; - &lt;a v-if=&quot;link&quot; :href=&quot;link&quot;&gt;Download&lt;/a&gt;&lt;/li&gt;&#39;</span><span class="p">,</span>
    <span class="nx">props</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">f</span><span class="o">:</span> <span class="nb">Object</span><span class="p">,</span>
        <span class="nx">d</span><span class="o">:</span> <span class="nb">Object</span>
    <span class="p">},</span>
    <span class="nx">data</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="nx">byteSizes</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;Bytes&#39;</span><span class="p">,</span> <span class="s1">&#39;KB&#39;</span><span class="p">,</span> <span class="s1">&#39;MB&#39;</span><span class="p">,</span> <span class="s1">&#39;GB&#39;</span><span class="p">,</span> <span class="s1">&#39;TB&#39;</span><span class="p">],</span>
            <span class="nx">link</span><span class="o">:</span> <span class="kc">false</span>
        <span class="p">}</span>
    <span class="p">},</span>
    <span class="nx">methods</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">bytesToSize</span><span class="p">(</span><span class="nx">bytes</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Set a default</span>
            <span class="kd">let</span> <span class="nx">output</span> <span class="o">=</span> <span class="s1">&#39;0 Byte&#39;</span><span class="p">;</span>
            <span class="c1">// If the bytes are bigger than 0</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">bytes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// Divide by 1024 and make an int</span>
                <span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nb">parseInt</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">bytes</span><span class="p">)</span> <span class="o">/</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1024</span><span class="p">)));</span>
                <span class="c1">// Round to 2 decimal places and select the appropriate unit from the array</span>
                <span class="nx">output</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">round</span><span class="p">(</span><span class="nx">bytes</span> <span class="o">/</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">pow</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="nx">i</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">byteSizes</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="nx">output</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">},</span>
    <span class="nx">created</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">d</span><span class="p">.</span><span class="nx">filesGetTemporaryLink</span><span class="p">({</span><span class="nx">path</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">f</span><span class="p">.</span><span class="nx">path_lower</span><span class="p">})</span>
            <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">data</span> <span class="p">=&gt;</span> <span class="p">{</span>
                <span class="k">this</span><span class="p">.</span><span class="nx">f</span><span class="p">.</span><span class="nx">download_link</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">link</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">link</span><span class="p">;</span>
            <span class="p">});</span>
    <span class="p">}</span>
<span class="p">});</span>
</pre></div>
</div>
<p>这基本上意味着 <code class="docutils literal"><span class="pre">this.f.download_link</span></code> 等于 <code class="docutils literal"><span class="pre">this.link</span></code> ，它也等于 <code class="docutils literal"><span class="pre">data.link</span></code> ，它是来自 <code class="docutils literal"><span class="pre">API</span></code> 的下载链接。当文件夹被导航到时使用该存储并显示，我们可以添加 <code class="docutils literal"><span class="pre">if</span></code> 语句来查看数据是否存在，如果不存在，则查询 <code class="docutils literal"><span class="pre">API</span></code> 以获取它。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">created</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">f</span><span class="p">.</span><span class="nx">download_link</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">link</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">f</span><span class="p">.</span><span class="nx">download_link</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">d</span><span class="p">.</span><span class="nx">filesGetTemporaryLink</span><span class="p">({</span><span class="nx">path</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">f</span><span class="p">.</span><span class="nx">path_lower</span><span class="p">})</span>
            <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">data</span> <span class="p">=&gt;</span> <span class="p">{</span>
                <span class="k">this</span><span class="p">.</span><span class="nx">f</span><span class="p">.</span><span class="nx">download_link</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">link</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">link</span><span class="p">;</span>
            <span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在文件创建时执行此操作会不必要地保存正被查询的 <code class="docutils literal"><span class="pre">API</span></code> 。 如果我们在缓存文件夹时获得这些信息，我们可能会放慢应用程序并存储非必要的信息。 想象一个包含数百张照片的文件夹 - 我们不希望在用户可能进入该文件夹的时候查询每一个的 <code class="docutils literal"><span class="pre">API</span></code> 。</p>
<p>这意味着我们的应用程序中的所有内容只需要查询 <code class="docutils literal"><span class="pre">API</span></code> 一次即可获取信息。 用户可以根据需要多次上下浏览文件夹结构，而应用程序只会越来越快。</p>
</div>
<div class="section" id="id12">
<h2>8.11. 完整的代码 - 添加了文档<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h2>
<p>随着我们的应用程序完成，我们现在可以添加一些急需的文档。文档化代码总是很好，因为这给出了推理和解释。良好的文档不应该仅仅说明代码的功能，而是为什么它会这样做，什么是允许的，什么是不允许的。</p>
<p>文档的流行方法是 <code class="docutils literal"><span class="pre">JavaScript</span> <span class="pre">DocBlock</span></code> 标准。 这套约定为您在编写代码时遵循样式指南规则。 <code class="docutils literal"><span class="pre">DocBlock</span></code> 格式化为注释块，功能键以 <code class="docutils literal"><span class="pre">&#64;</span></code> 开头，例如 <code class="docutils literal"><span class="pre">&#64;author</span></code> ， <code class="docutils literal"><span class="pre">&#64;example</span></code> ，或用 <code class="docutils literal"><span class="pre">&#64;param</span></code> 关键字列出函数可以接受的参数。 一个例子是：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * Displays a folder with a link and cache its contents</span>
<span class="cm"> * @example &lt;folder :f=&quot;entry&quot; :cache=&quot;getFolderStructure&quot;&gt;&lt;/folder&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * @param {object} f The folder entry from the tree</span>
<span class="cm"> * @param {function} cache The getFolderStructure method from the dropbox-viewer component</span>
<span class="cm"> */</span>
</pre></div>
</div>
<p>从描述开始， <code class="docutils literal"><span class="pre">DocBlock</span></code> 有几个关键字来帮助布置文档。 我们将通过完成的 <code class="docutils literal"><span class="pre">Dropbox</span></code> 应用程序添加文档。</p>
<p>让我们先看看 <code class="docutils literal"><span class="pre">breadcrumb</span></code> 组件：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * Displays the folder tree breadcrumb</span>
<span class="cm"> * @example &lt;breadcrumb&gt;&lt;/breadcrumb&gt;</span>
<span class="cm"> */</span>
<span class="nx">Vue</span><span class="p">.</span><span class="nx">component</span><span class="p">(</span><span class="s1">&#39;breadcrumb&#39;</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">template</span><span class="o">:</span> <span class="s1">&#39;&lt;div&gt;&#39;</span> <span class="o">+</span>
        <span class="s1">&#39;&lt;span v-for=&quot;(f, i) in folders&quot;&gt;&#39;</span> <span class="o">+</span>
            <span class="s1">&#39;&lt;a :href=&quot;\&#39;#\&#39; + f.path&quot;&gt;{{ f.name || &#39;</span><span class="nx">Home</span><span class="s1">&#39; }}&lt;/a&gt;&#39;</span> <span class="o">+</span>
            <span class="s1">&#39;&lt;i v-if=&quot;i !== (folders.length - 1)&quot;&gt; &amp;raquo; &lt;/i&gt;&#39;</span> <span class="o">+</span>
        <span class="s1">&#39;&lt;/span&gt;&#39;</span> <span class="o">+</span>
    <span class="s1">&#39;&lt;/div&gt;&#39;</span><span class="p">,</span>
    <span class="nx">computed</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">folders</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">$store</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">breadcrumb</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">});</span>
</pre></div>
</div>
<p>转到 <code class="docutils literal"><span class="pre">folder</span></code> 组件：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * Displays a folder with a link and cache its contents</span>
<span class="cm"> * @example &lt;folder :f=&quot;entry&quot; :cache=&quot;getFolderStructure&quot;&gt;&lt;/folder&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * @param {object} f The folder entry from the tree</span>
<span class="cm"> * @param {function} cache The getFolderStructure method from the dropbox-viewer component</span>
<span class="cm"> */</span>
<span class="nx">Vue</span><span class="p">.</span><span class="nx">component</span><span class="p">(</span><span class="s1">&#39;folder&#39;</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">template</span><span class="o">:</span> <span class="s1">&#39;&lt;li&gt;&lt;strong&gt;&lt;a :href=&quot;\&#39;#\&#39; + f.path_lower&quot;&gt;{{ f.name }}&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;&#39;</span><span class="p">,</span>
    <span class="nx">props</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">f</span><span class="o">:</span> <span class="nb">Object</span><span class="p">,</span>
        <span class="nx">cache</span><span class="o">:</span> <span class="nb">Function</span>
    <span class="p">},</span>
    <span class="nx">created</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// Cache the contents of the folder</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">cache</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">f</span><span class="p">.</span><span class="nx">path_lower</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">});</span>
</pre></div>
</div>
<p>接下来，我们看到 <code class="docutils literal"><span class="pre">file</span></code> 组件：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * File component display size of file and download link</span>
<span class="cm"> * @example &lt;file :d=&quot;dropbox()&quot; :f=&quot;entry&quot;&gt;&lt;/file&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  @param {object} f The file entry from the tree</span>
<span class="cm"> * @param {object} d The dropbox instance from the parent component</span>
<span class="cm"> */</span>
<span class="nx">Vue</span><span class="p">.</span><span class="nx">component</span><span class="p">(</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">template</span><span class="o">:</span> <span class="s1">&#39;&lt;li&gt;&lt;strong&gt;{{ f.name }}&lt;/strong&gt;&lt;span v-if=&quot;f.size&quot;&gt; - {{ bytesToSize(f.size) }}&lt;/span&gt; - &lt;a v-if=&quot;link&quot; :href=&quot;link&quot;&gt;Download&lt;/a&gt;&lt;/li&gt;&#39;</span><span class="p">,</span>
    <span class="nx">props</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">f</span><span class="o">:</span> <span class="nb">Object</span><span class="p">,</span>
        <span class="nx">d</span><span class="o">:</span> <span class="nb">Object</span>
    <span class="p">},</span>
    <span class="nx">data</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="c1">// List of file size</span>
            <span class="nx">byteSizes</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;Bytes&#39;</span><span class="p">,</span> <span class="s1">&#39;KB&#39;</span><span class="p">,</span> <span class="s1">&#39;MB&#39;</span><span class="p">,</span> <span class="s1">&#39;GB&#39;</span><span class="p">,</span> <span class="s1">&#39;TB&#39;</span><span class="p">],</span>
            <span class="c1">// The download link</span>
            <span class="nx">link</span><span class="o">:</span> <span class="kc">false</span>
        <span class="p">}</span>
    <span class="p">},</span>
    <span class="nx">methods</span><span class="o">:</span> <span class="p">{</span>
        <span class="cm">/**</span>
<span class="cm">         * Convert an integer to a human readable file size</span>
<span class="cm">         * @param {integer} bytes</span>
<span class="cm">         * @return {string}</span>
<span class="cm">         */</span>
        <span class="nx">bytesToSize</span><span class="p">(</span><span class="nx">bytes</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Set a default</span>
            <span class="kd">let</span> <span class="nx">output</span> <span class="o">=</span> <span class="s1">&#39;0 Byte&#39;</span><span class="p">;</span>
            <span class="c1">// If the bytes are bigger than 0</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">bytes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// Divide by 1024 and make an int</span>
                <span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nb">parseInt</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">bytes</span><span class="p">)</span> <span class="o">/</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1024</span><span class="p">)));</span>
                <span class="c1">// Round to 2 decimal places and select the appropriate unit from the array</span>
                <span class="nx">output</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">round</span><span class="p">(</span><span class="nx">bytes</span> <span class="o">/</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">pow</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="nx">i</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">byteSizes</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="nx">output</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">},</span>
    <span class="nx">created</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// If the download link has be retrieved from the API, use it</span>
        <span class="c1">// if not, aquery the API</span>
        <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">f</span><span class="p">.</span><span class="nx">download_link</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">link</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">f</span><span class="p">.</span><span class="nx">download_link</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">d</span><span class="p">.</span><span class="nx">filesGetTemporaryLink</span><span class="p">({</span><span class="nx">path</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">f</span><span class="p">.</span><span class="nx">path_lower</span><span class="p">})</span>
                <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">data</span> <span class="p">=&gt;</span> <span class="p">{</span>
                    <span class="k">this</span><span class="p">.</span><span class="nx">f</span><span class="p">.</span><span class="nx">download_link</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">link</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">link</span><span class="p">;</span>
                <span class="p">});</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">});</span>
</pre></div>
</div>
<p>现在我们来看看 <code class="docutils literal"><span class="pre">dropbox-viewer</span></code> 组件：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span>/**
 * The dropbox component
 * @example &lt;dropbox-viewer&gt;&lt;/dropbox-viewer&gt;
 */
Vue.component(&#39;dropbox-viewer&#39;, {
    template: &#39;#dropbox-viewer-template&#39;,
    data() {
        return {
            // Dropbox API token
            accessToken: &#39;XXXX&#39;,
            // Current folder structure
            structure: {},
            isLoading: true
        }
    },
    computed: {
        // The current folder path
        path() {
            return this.$store.state.path
        }
    },
    methods: {
        /**
         * Dropbox API instance
         * @return {object}
         */
        dropbox() {
            return new Dropbox({
                accessToken: this.accessToken
            });
        },
        /**
         * @param {string} path The path to a folder
         * @return {string} A cache-friendly URL without punctuation/symbals
         */
        generateSlug(path) {
            return path.toLowerCase()
                .replace(/^\/|\/$/g, &#39;&#39;)
                .replace(/ /g,&#39;-&#39;)
                .replace(/\//g,&#39;-&#39;)
                .replace(/[-]+/g, &#39;-&#39;)
                .replace(/[^\w-]+/g,&#39;&#39;);
        },
        /**
         * Retrieve the folder structure form the cache or Dropbox API
         * @param {string} path The folder path
         * @return {Promise} A promise containing the folder data
         */
        getFolderStructure(path) {
            let output;
            const slug = this.generateSlug(path),
                data = this.$store.state.structure[slug];
            if(data) {
                output = Promise.resolve(data);
            } else {
                output = this.dropbox().filesListFolder({
                    path: path,
                    include_media_info: true
                })
                    .then(response =&gt; {
                        let entries = response.entries;
                        this.$store.commit(&#39;structure&#39;, {
                            path: slug,
                            data: entries
                        });
                        return entries;
                    })
                    .catch(error =&gt; {
                        this.isLoading = &#39;error&#39;;
                        console.log(error);
                    });
            }
            return output;
        },
        /**
         * Display the contents of getFolderStructure
         * Updates the output to display the folders and folders
         */
        displayFolderStructure() {
            // Set the app to loading
            this.isLoading = true;
            // Create an empty object
            const structure = {
                    folders: [],
                    files: []
                } /
                / Get the structure
            this.getFolderStructure(this.path).then(data =&gt; {
                for (let entry of data) {
                    // Check &quot;.tag&quot; prop for type
                    if(entry[&#39;.tag&#39;] == &#39;folder&#39;) {
                        structure.folders.push(entry);
                    } else {
                        structure.files.push(entry);
                    }
                }
                // Update the data object
                this.structure = structure;
                this.isLoading = false;
            });
        },
        /**
         * Loop through the breadcrumb and cache parent folders
         */
        cacheParentFolders() {
            let parents = this.$store.state.breadcrumb;
            parents.reverse().shift();
            for(let parent of parents) {
                this.getFolderStructure(parent.path);
            }
        }
    },
    created() {
        // Display the current path &amp; cache parent folders
        this.displayFolderStructure();
        this.cacheParentFolders();
    },
    watch: {
        // Update the view when the path gets updated
        path() {
            this.displayFolderStructure();
        }
    }
});
</pre></div>
</div>
<p>让我们来看看 <code class="docutils literal"><span class="pre">Vuex</span></code> <code class="docutils literal"><span class="pre">store</span></code> ：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * The Vuex Store</span>
<span class="cm"> */</span>
<span class="kr">const</span> <span class="nx">store</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vuex</span><span class="p">.</span><span class="nx">Store</span><span class="p">({</span>
    <span class="nx">state</span><span class="o">:</span> <span class="p">{</span>
        <span class="c1">// Current folder path</span>
        <span class="nx">path</span><span class="o">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
        <span class="c1">// The current breadcrumb</span>
        <span class="nx">breadcrumb</span><span class="o">:</span> <span class="p">[],</span>
        <span class="c1">// The cached folder contents</span>
        <span class="nx">structure</span><span class="o">:</span> <span class="p">{},</span>
    <span class="p">},</span>
    <span class="nx">mutations</span><span class="o">:</span> <span class="p">{</span>
        <span class="cm">/**</span>
<span class="cm">         * Update the path &amp; breadcrumb components</span>
<span class="cm">         * @param {object} state The state object of the store</span>
<span class="cm">         */</span>
        <span class="nx">updateHash</span><span class="p">(</span><span class="nx">state</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">let</span> <span class="nx">path</span> <span class="o">=</span> <span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">hash</span><span class="p">.</span><span class="nx">substring</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="s1">&#39;&#39;</span><span class="p">),</span>
                <span class="nx">breadcrumb</span> <span class="o">=</span> <span class="p">[],</span>
                <span class="nx">slug</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
                <span class="nx">parts</span> <span class="o">=</span> <span class="nx">path</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">);</span>
            <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">item</span> <span class="k">of</span> <span class="nx">parts</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">slug</span> <span class="o">+=</span> <span class="nx">item</span><span class="p">;</span>
                <span class="nx">breadcrumb</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="o">:</span> <span class="nx">item</span> <span class="o">||</span> <span class="s1">&#39;home&#39;</span><span class="p">,</span> <span class="s1">&#39;path&#39;</span><span class="o">:</span> <span class="nx">slug</span><span class="p">});</span>
                <span class="nx">slug</span> <span class="o">+=</span> <span class="s1">&#39;/&#39;</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="nx">state</span><span class="p">.</span><span class="nx">path</span> <span class="o">=</span> <span class="nx">path</span>
            <span class="nx">state</span><span class="p">.</span><span class="nx">breadcrumb</span> <span class="o">=</span> <span class="nx">breadcrumb</span><span class="p">;</span>
        <span class="p">},</span>
        <span class="cm">/**</span>
<span class="cm">         * Cache a folder structure</span>
<span class="cm">         * @param {object} state The state objet of the store</span>
<span class="cm">         * @param {object} payload An object containing the slug and data to store</span>
<span class="cm">         */</span>
        <span class="nx">structure</span><span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">payload</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">state</span><span class="p">.</span><span class="nx">structure</span><span class="p">[</span><span class="nx">payload</span><span class="p">.</span><span class="nx">path</span><span class="p">]</span> <span class="o">=</span> <span class="nx">payload</span><span class="p">.</span><span class="nx">data</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">});</span>
</pre></div>
</div>
<p>我们进一步转向 <code class="docutils literal"><span class="pre">Vue</span></code> 应用程序：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * The Vue app</span>
<span class="cm"> */</span>
<span class="kr">const</span> <span class="nx">app</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vue</span><span class="p">({</span>
    <span class="nx">el</span><span class="o">:</span> <span class="s1">&#39;#app&#39;</span><span class="p">,</span>
    <span class="c1">// Initialize the store</span>
    <span class="nx">store</span><span class="p">,</span>
    <span class="c1">// Update the current path on page load</span>
    <span class="nx">mounted</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">store</span><span class="p">.</span><span class="nx">commit</span><span class="p">(</span><span class="s1">&#39;updateHash&#39;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">});</span>
</pre></div>
</div>
<p>最后，我们浏览 <code class="docutils literal"><span class="pre">window.onhashchange</span></code> 函数：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * Update the path &amp; store when the URL hash changes</span>
<span class="cm"> */</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">onhashchange</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">app</span><span class="p">.</span><span class="nx">$store</span><span class="p">.</span><span class="nx">commit</span><span class="p">(</span><span class="s1">&#39;updateHash&#39;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>最后，视图中的 <code class="docutils literal"><span class="pre">HTML</span></code> 如下所示：</p>
<div class="highlight-js"><div class="highlight"><pre><span></span>&lt;div id=&quot;app&quot;&gt;
    &lt;dropbox-viewer&gt;&lt;/dropbox-viewer&gt;
&lt;/div&gt;
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">Dropbox-viewer</span></code> 的模板如下所示：</p>
<div class="highlight-html"><div class="highlight"><pre><span></span>&lt;script type=&quot;text/x-template&quot; id=&quot;dropbox-viewer-template&quot;&gt;
    &lt;div&gt;
        &lt;h1&gt;Dropbox&lt;/h1&gt;
        &lt;transition name=&quot;fade&quot;&gt;
            &lt;div v-if=&quot;isLoading&quot;&gt;
                &lt;div v-if=&quot;isLoading == &#39;error&#39;&quot;&gt;
                    &lt;p&gt;There seems to be an issue with the URL entered.&lt;/p&gt;
                    &lt;p&gt;&lt;a href=&quot;&quot;&gt;Go home&lt;/a&gt;&lt;/p&gt;
                &lt;/div&gt;
                &lt;div v-else&gt;
                    Loading...
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/transition&gt;
        &lt;transition name=&quot;fade&quot;&gt;
            &lt;div v-if=&quot;!isLoading&quot;&gt;
                &lt;breadcrumb&gt;&lt;/breadcrumb&gt;
                &lt;ul&gt;
                    &lt;template v-for=&quot;entry in structure.folders&quot;&gt;
                        &lt;folder :f=&quot;entry&quot; :cache=&quot;getFolderStructure&quot;&gt;&lt;/folder&gt;
                    &lt;/template&gt;
                    &lt;template v-for=&quot;entry in structure.files&quot;&gt;
                        &lt;file :d=&quot;dropbox()&quot; :f=&quot;entry&quot;&gt;&lt;/file&gt;
                    &lt;/template&gt;
                &lt;/ul&gt;
            &lt;/div&gt;
        &lt;/transition&gt;
    &lt;/div&gt;
&lt;/script&gt;
</pre></div>
</div>
<p>你会注意到并非所有事情都被记录在案。一个简单的函数或变量赋值不需要重新解释它的作用，但是主要变量的记录将帮助任何人在将来查看它。</p>
</div>
<div class="section" id="id13">
<h2>8.12. 总结<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h2>
<p>在本书的这一部分，我们已经涵盖了很多！ 我们从查询 <code class="docutils literal"><span class="pre">Dropbox</span> <span class="pre">API</span></code> 开始获取文件和文件夹列表。然后，我们继续添加导航，允许用户点击文件夹并下载文件。然后，我们将 <code class="docutils literal"><span class="pre">Vuex</span></code> 和 <code class="docutils literal"><span class="pre">store</span></code> 引入到我们的应用程序中，这意味着我们可以集中路径，面包屑，最重要的是缓存文件夹内容。最后，我们研究了缓存子文件夹和文件下载链接。</p>
<p>在本书的下一部分，我们将着眼于制作一家商店。这将包括使用称为 <code class="docutils literal"><span class="pre">Vue</span></code> 路由器的新 <code class="docutils literal"><span class="pre">Vue</span></code> 插件浏览分类和产品页面中的产品。我们还会考虑将产品添加到购物车并将产品列表和个人偏爱存储在 <code class="docutils literal"><span class="pre">Vuex</span> <span class="pre">store</span></code> 中。</p>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="介绍Vue-Router并加载基于URL的组件.html" class="btn btn-neutral float-right" title="9. 介绍Vue-Router并加载基于URL的组件" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="使用Vuex缓存当前文件夹结构.html" class="btn btn-neutral" title="7. 使用Vuex缓存当前文件夹结构" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, lzh.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.0',
            LANGUAGE:'zh_CN',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="_static/translations.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>