*************
建立电子商务商店-浏览产品
*************
在第9章，使用 Vue-router 动态路由加载数据，我们将我们的产品数据加载到 ``Vuex store`` 中，并创建了产品详细信息页面，供用户查看产品及其变体。在查看产品详细信息页面时，用户可以从下拉菜单中更改变体，价格和其他详细信息将会更新。

在本章中，我们将要：

- 使用特定产品创建主页列表页面；
- 使用可重用组件创建一个类别页面；
- 创建一个订购机制；
- 动态创建过滤器并允许用户过滤产品；

产品列表
========
在我们创建任何过滤，策划列表，订购组件和功能之前，我们需要创建一个基本产品列表 - 首先显示所有产品，然后创建一个分页组件，然后我们可以在整个应用程序中重用。

添加一条新路由
==============
让我们添加一个新的路由到我们的 ``routes`` 数组。 现在，我们将处理 ``HomePage`` 组件，该组件将具有 ``/`` 路由。请确保将其添加到 ``routes`` 数组的顶部，以免被其他任何组件覆盖：

.. code-block:: js

    const router = new VueRouter({
        routes: [
            {
                path: '/',
                name: 'Home',
                component: HomePage
            },
            {
                path: '/product/:slug',
                component: ProductPage
            },
            {
                path: '/404',
                alias: '*',
                component: PageNotFound
            }
        ]
    });

在 ``HomePage`` 组件中，创建一个新的 ``computed`` 属性并收集 ``store`` 中的所有产品。 在模板中显示任何内容之前，确保产品已加载。使用以下代码填充 ``HomePage`` 组件：

.. code-block:: js

    const HomePage = {
        name: 'HomePage',
        template: `<div v-if="products"></div>`,
        computed: {
            products() {
                return this.$store.state.products;
            }
        }
    };

循环遍历产品
============
在查看任何商店的类别列表时，显示的数据往往具有反复出现的主题。 它通常由图像，标题，价格和制造商组成。

为您的模板添加一个有序列表 - 由于产品将向他们发布订单，因此将其置于有序列表中会使其具有语义意义。在 ``<ol>`` 中，为产品添加一个 ``v-for`` 循环，并为每个产品显示一个标题，如下所示。在继续显示产品变量之前，确保 ``product`` 变量存在也是一个很好的做法：

.. code-block:: html

    template: `<div v-if="products">
        <ol>
            <li v-for="product in products" v-if="product">
                <h3>{{ product.title }}</h3>
            </li>
        </ol>
    </div>`,

在浏览器中查看页面时，您可能会注意到产品列表非常长。为这些产品中的每一种产品加载图像都会对用户的计算机造成巨大的负担，同时让用户无法看到展示的产品。在向我们的模板添加更多信息（例如价格和图片）之前，我们会查看产品分页，允许以更易于管理的方式访问数据。

创建分页
========
最初创建分页似乎很简单 - 因为您只需要返回固定数量的产品。但是，如果我们希望使分页能够与产品列表互动和反应，则需要更高级一些。我们需要建立我们的分页，在我们的产品清单已被过滤为更少的产品的情况下能够处理不同长度的产品。

计算值
------
创建分页组件并显示正确产品的算法依赖于四个主要变量：

- 每页项目：通常由用户设置；但是，我们将使用固定数量 12 ；
- 总项目数：这是要显示的产品总数项目数；
- 页码：这可以通过将产品数除以每页项目数来计算；
- 当前页码：这与其他人结合，将使我们能够准确地返回我们需要的产品；

从这些数字中，我们可以计算出我们分页所需的一切。这包括显示哪些产品，是否显示下一个/上一个链接，以及如果需要的话，跳到不同链接的组件。

在我们继续之前，我们将把我们的 ``products`` 对象转换成一个数组。这使我们可以在其上使用 ``split`` (拆分)方法，这将允许我们返回特定的产品列表。这也意味着我们可以很容易地统计项目的总数。

更新您的 ``products`` 计算函数以返回一个数组而不是一个对象。这是通过使用 ``map()`` 函数完成的，该函数是 ``ES2015`` 取代简单 ``for`` 循环的函数。这个函数现在返回一个包含产品对象的数组：

.. code-block:: js

    products() {
        let products = this.$store.state.products;
        return Object.keys(products).map(key => products[key]);
    },

在计算对象中创建一个标题为 ``pagination`` 的新函数。此函数将返回一个包含有关我们分页的各种数字的对象，例如总页数。这将允许我们创建产品列表并更新导航组件。如果我们的 ``products`` 变量有数据，我们只需要返回对象。该函数显示在以下代码片段中：

.. code-block:: js

    computed: {
        products() {
            let products = this.$store.state.products;
            return Object.keys(products).map(key => products[key]);
        },
        pagination() {
            if(this.products) {
                return {
                }
            }
        }
    },

现在我们需要跟踪两个变量 - ``perPage`` 和 ``currentPage`` 。 在 ``HomePage`` 组件上创建一个 ``data`` 函数并存储这两个变量。我们会让用户稍后具有更新 ``perPage`` 变量的能力。高亮的代码部分显示了我们的 ``data`` 函数：

.. code-block:: js

    const HomePage = {
        name: 'HomePage',
        template: `...`,
        data() {
            return {
                perPage: 12,
                currentPage: 1
            }
        },
        computed: {
            ...
        }
    };

.. tip:: 您可能想知道何时在组件上使用本地数据以及何时将信息存储在 ``Vuex store`` 中。这一切都取决于你将要使用数据的地方以及如何操纵它。作为一般规则，如果只有一个组件使用数据并对其进行处理，则使用本地 ``data()`` 函数。但是，如果多个组件将与该变量进行交互，请将其保存在集中存储中。

回到 ``pagination()`` 计算函数，存储数组长度到一个变量。以此作为变量，我们现在可以计算总页数。为此，我们将执行以下等式： **产品总数/每页项目数** 一旦得到此结果，我们需要将它四舍五入到最接近的整数。这是因为如果有任何余数，我们需要为它创建一个新页面。

例如，如果您每页显示 12 个项目并且您有 14 个产品，则会产生 1.1666 页的结果 - 这不是有效的页码。四舍五入可确保我们有两页来显示我们的产品。为此，请使用 ``Math.ceil()`` JavaScript 函数。我们还可以将产品总数添加到我们的输出中。检查使用 ``Math.ceil()`` 函数的以下代码：

.. code-block:: js

    pagination() {
        if(this.products) {
            let totalProducts = this.products.length;
            return {
                totalProducts: totalProducts,
                totalPages: Math.ceil(totalProducts / this.perPage)
            }
        }
    }

我们需要做的下一个计算是确定当前页面的当前产品范围。这有点复杂，因为我们不仅需要从页码中计算出我们需要的内容，而且数组切片基于项目索引 - 这意味着第一个项目为 0 。要计算出我们需要的切片位置，我们可以使用以下计算： **（当前页码 \* 每页项目） - 每页项数** 最后的减法可能看起来很奇怪，但它意味着在第 1 页上，结果为 0 。我们需要对 ``products`` 数组进行切片。

再例如，如果我们在第三页，结果将是 24 ，这是第三页开始的地方。切片的结尾是这个结果加上每页的项目数。这意味着我们可以更新每页的项目，我们所有的计算都会更新。

使用这两个结果在 ``pagination`` 结果中创建一个对象 - 这将允许我们稍后轻松访问它们：

.. code-block:: js

    pagination() {
        if(this.products) {
            let totalProducts = this.products.length,
                pageFrom = (this.currentPage * this.perPage) - this.perPage;
            return {
                totalProducts: totalProducts,
                totalPages: Math.ceil(totalProducts / this.perPage),
                range: {
                    from: pageFrom,
                    to: pageFrom + this.perPage
                }
            }
        }
    }

显示分页列表
------------
通过计算我们的分页属性，我们现在可以使用开始点和结束点来操作我们的 ``products`` 数组。我们将使用一种方法来截断产品列表，而不是使用硬编码值或使用其他计算函数。这具有能够传递任何产品列表的优点，同时也意味着 ``Vue`` 不会缓存结果。

在组件中方法对象中创建一个新的 ``paginate`` 方法。这应该接受一个参数，这个参数将成为我们分割的 ``products`` 数组。在函数中，我们可以使用我们之前计算的两个变量来返回正确的产品数量：

.. code-block:: js

    methods: {
        paginate(list) {
            return list.slice(
                this.pagination.range.from,
                this.pagination.range.to
            );
        }
    }

循环浏览产品时使用此方法更新模板：

.. code-block:: html

    template: `<div v-if="products">
        <ol>
            <li v-for="product in paginate(products)" v-if="product">
                <h3>{{ product.title }}</h3>
            </li>
        </ol>
    </div>`,

我们现在可以在浏览器中查看它，并注意它会返回我们对象的前 12 个产品。将 ``data`` 对象中的 ``currentPage`` 变量更新为 2 或者 3 将显示不同的产品列表，具体取决于编号。

要继续我们的语义方法来列出我们的产品，我们不在第一页时应该更新我们有序列表的开始位置。这可以使用 ``HTML`` 属性 ``start`` 来完成 - 这允许您指定应该以哪个数字开始一个有序列表。

使用 ``pagination.range.from`` 变量来设置我们有序列表的起始点 - 记住要加 1 ，它将是 0 ：

.. code-block:: html

    template: `<div v-if="products">
        <ol :start="pagination.range.from + 1">
            <li v-for="product in paginate(products)" v-if="product">
                <h3>{{ product.title }}</h3>
            </li>
        </ol>
    </div>`

当在代码中递增页码时，您会注意到有序列表从每个页面的适当位置开始。

创建分页按钮
------------
通过代码更新页码不是用户友好的 - 所以我们应该添加一些页面来递增和递减页码变量。为此，我们将创建一个更改 ``currentPage`` 变量的函数。这使我们可以将它用于“下一页”和“上一页”按钮，并根据需要加上编号的页面列表。

首先在 ``pagination`` 容器中创建两个按钮。如果我们处于导航的末端，我们希望禁用这些按钮 - 例如，您不希望在返回时能够低于 1 ，并且在前进时超过最大页数。我们可以通过在按钮上设置 ``disabled`` 属性来做到这一点 - 就像我们在产品详细信息页面上做的那样，并将当前页面与这些限制进行比较。添加一个禁用的属性，并在上一页，该按钮检查当前页面是否为一个。在下一页按钮上，将其与我们的分页方法的 ``totalPages`` 值进行比较。这里显示了实现前面提到的属性的代码：

.. code-block:: html

    <button :disabled="currentPage == 1">Previous page</button>
    <button :disabled="currentPage == pagination.totalPages">Next page</button>

将 currentPage 变量重新设置为1并在浏览器中加载主页。您应该注意到前一页按钮被禁用。如果您更改当前页面变量，您会注意到按钮会根据需要变为活动和非活动状态。我们现在需要为按钮创建一个点击方法来更新当前页面。创建一个名为 ``toPage()`` 的新函数。这应该接受一个变量 - 这将直接更新 ``currentPage`` 变量：

.. code-block:: js

    methods: {
        toPage(page) {
            this.currentPage = page;
        },
        paginate(list) {
            return list.slice(this.pagination.range.from, this.pagination.range.to);
        }
    }

点击处理程序添加到按钮，通过 ``currentPage + 1`` 为下一页按钮， ``currentPage - 1`` 为前一页按钮：

.. code-block:: html

    template: `<div v-if="products">
        <button @click="toPage(currentPage - 1)" :disabled="currentPage == 1">Previous page</button>
        <button @click="toPage(currentPage + 1)" :disabled="currentPage == pagination.totalPages">Next page</button>
        <ol :start="pagination.range.from + 1">
            <li v-for="product in paginate(products)" v-if="product">
                <h3>{{ product.title }}</h3>
            </li>
        </ol>
    </div>`

我们现在可以在产品中来回导航。作为用户界面的一个很好的补充，我们可以使用我们提供的变量来指示页码和剩余页数：

.. code-block:: html

    template: `<div v-if="products">
        <p>
            Page {{ currentPage }} out of {{ pagination.totalPages }}
        </p>
        <button @click="toPage(currentPage - 1)" :disabled="currentPage == 1">Previous page</button>
        <button @click="toPage(currentPage + 1)" :disabled="currentPage == pagination.totalPages">Next page</button>
        <ol :start="pagination.range.from + 1">
            <li v-for="product in paginate(products)" v-if="product">
                <h3>{{ product.title }}</h3>
            </li>
        </ol>
    </div>`

在导航上更新URL
---------------
用户体验的另一个改进是更新页面导航上的 ``URL`` - 这将允许用户共享 ``URL`` ，将其加入书签并稍后返回。分页时，页面是临时状态，不应该是 ``URL`` 的主要端点。相反，我们可以利用 ``Vue`` 路由器的查询参数。

更新 ``toPage`` 方法以将参数添加到页面更改中的 ``URL`` 。这可以使用 ``$router.push`` 来实现，但是，我们需要小心，不要删除将来可能用于过滤的任何现有参数。这可以通过将路由中的当前查询对象与包含页面变量的新对象组合来实现：

.. code-block:: js

    toPage(page) {
        this.$router.push({
            query: Object.assign({}, this.$route.query, {
                page
            })
        });
        this.currentPage = page; // 为什么这里更新当前页，下面还需要更新？？
    },

在页面之间导航时，您会注意到 ``URL`` 获取了 ``?page=`` 等于当前页面名称的新参数。但是，按刷新不会产生正确的页面结果，还是第一页。这是因为我们需要将当前页面查询参数传递给我们的 ``HomePage`` 组件中的 ``currentPage`` 变量。

这可以使用 ``created()`` 函数完成 - 更新变量 - 确保我们已经检查了它的存在。 ``created()`` 函数是 ``Vue`` 生命周期的一部分，并在第4章使用 ``Dropbox API`` 获取文件列表中进行了介绍：

.. code-block:: js

    created() {
        if(this.$route.query.page) {
            this.currentPage = parseInt(this.$route.query.page);
        }
    }

我们需要确保 ``currentPage`` 变量是一个整数，以帮助我们处理稍后需要做的任何算术运算。

创建分页链接
------------
查看分页产品时，最好有一个截断的页码列表，允许用户跳转多个页面。我们已经有了在页面之间导航的机制 - 这可以扩展它。

作为一个简单的入口点，我们可以通过循环创建到每个页面的链接，直到达到 ``totalPages`` 值。 ``Vue`` 允许我们在没有任何 JavaScript 的情况下做到这一点。在组件底部创建一个 ``nav`` 元素，并在其中添加一个列表。 使用 ``v-for`` ，并为 ``totalPages`` 变量中的每个项创建一个 ``page`` 变量：

.. code-block:: html

    <nav>
        <ol>
            <li v-for="page in pagination.totalPages">
                <button @click="toPage(page)">{{ page }}</button>
            </li>
        </ol>
    </nav>

这将为每个页面创建一个按钮 - 例如，如果总共有 24 个页面，则会创建 24 个链接。这不是我们想要的效果，因为我们希望在当前页面的前后几页。例如，如果当前页面为 15 ，则页面链接应该是 12,13,14,15,16,17 和 18 。这意味着链接较少，并且对用户而言令人满意。

首先，在数据对象中创建一个新变量，该变量将记录显示选定页面两侧的页面数量 - 开始的值为 3 ：

.. code-block:: js

    data() {
        return {
            perPage: 12,
            currentPage: 1,
            pageLinksCount: 3
        }
    },

接下来，创建一个名为 ``pageLinks`` 的新计算函数。 此功能需要获取当前页面，并确定哪些页面数量少于 3 个。从那里，我们需要检查下限不小于 1 ，上限不超过页面总数。在继续之前检查产品数组是否有项目：

.. code-block:: js

    pageLinks() {
        if(this.products.length) {
            let negativePoint = parseInt(this.currentPage) - this.pageLinksCount,
                positivePoint = parseInt(this.currentPage) + this.pageLinksCount;
            if(negativePoint < 1) {
                negativePoint = 1;
            }
            if(positivePoint > this.pagination.totalPages) {
                positivePoint = this.pagination.totalPages;
            }
            return pages;
        }
    }

最后一步是创建一个数组和一个 ``for`` 循环，从较低范围循环到较高范围。这将创建一个最多包含 7 个页面范围的数字的数组：

.. code-block:: js

    pageLinks() {
        if(this.products.length) {
            let negativePoint = parseInt(this.currentPage) - this.pageLinksCount,
                positivePoint = parseInt(this.currentPage) + this.pageLinksCount,
                pages = [];
            if(negativePoint < 1) {
                negativePoint = 1;
            }
            if(positivePoint > this.pagination.totalPages) {
                positivePoint = this.pagination.totalPages;
            }
            for (var i = negativePoint; i <= positivePoint; i++) {
                pages.push(i)
            }
            return pages;
        }
    }

现在我们可以用新的 ``pageLinks`` 变量替换导航组件中的 ``pagination.totalPages`` 变量，并创建正确的链接数量，如下所示：

.. code-block:: html

    <nav>
        <ul>
            <li v-for="page in pageLinks">
                <button @click="toPage(page)">{{ page }}</button>
            </li>
        </ul>
    </nav>

然而，在浏览器中查看它会导致一些奇怪的行为 虽然会生成正确数量的链接，但单击它们或使用下一个/上一个按钮将导致按钮保持不变 - 即使您跳出按钮的范围。 **这是因为计算的值被缓存。**  我们可以通过两种方式解决这个问题 - 将函数移入 ``method`` 对象，或者添加一个 ``watch`` 函数来观察并更路由新当前页面。

选择第二个选项意味着我们可以确保没有其他结果和输出被缓存并相应地更新。将 ``watch`` 对象添加到组件，并将 ``currentPage`` 变量更新为页面查询变量的值。确保它存在，否则默认为一个。 ``watch`` 方法如下所示：

.. code-block:: js

    watch: {
        '$route'(to) {
            this.currentPage = parseInt(to.query.page) || 1;
        }
    }

这可确保在导航到不同页面时更新所有计算的变量。打开您的 ``HomePage`` 组件并确保所有分页组件都相应地工作并更新列表。

更新每页的项目
--------------
我们需要创建的最后一个用户界面还允许用户更新每页产品的数量。要初始设置它，我们可以创建一个具有直接更新值的 ``v-model`` 属性的 ``<select>`` 框。这按预期工作，并相应地更新产品列表，如图所示：

.. code-block:: html

    template: `<div v-if="products">
        <p>
            Page {{ currentPage }} out of {{ pagination.totalPages }}
        </p>
        Products per page:
        <select v-model="perPage">
            <option>12</option>
            <option>24</option>
            <option>48</option>
            <option>60</option>
        </select>
        <button @click="toPage(currentPage - 1)" :disabled="currentPage == 1">Previous page</button>
        <button @click="toPage(currentPage + 1)" :disabled="currentPage == pagination.totalPages">Next page</button>
        <ol :start="pagination.range.from + 1">
            <li v-for="product in paginate(products)" v-if="product">
                <h3>{{ product.title }}</h3>
            </li>
        </ol>
        <nav>
            <ul>
                <li v-for="page in pageLinks">
                    <button @click="toPage(page)">{{ page }}</button>
                </li>
            </ul>
        </nav>
    </div>

与此相关的问题是，如果值发生变化，用户所在页面的值高于可能值。 例如，如果有 30 个产品每页有 12 个产品，则会创建三个页面。如果用户导航到第 3 页，然后每页选择 24 个产品，则只需要两页，而第 3 页将是空的。

这可以通过 ``watch`` 功能再一次解决。当 ``perPage`` 变量更新时，我们可以检查当前页面是否高于 ``totalPages`` 变量。如果是这样，我们可以将其重定向到最后一页：

.. code-block:: js

    watch: {
        '$route'(to) {
            this.currentPage = parseInt(to.query.page);
        },
        perPage() {
            if(this.currentPage > this.pagination.totalPages) {
                this.$router.push({
                    query: Object.assign({}, this.$route.query, {
                        page: this.pagination.totalPages
                    })
                })
            }
        }
    }

创建ListProducts组件
====================
在我们开始创建过滤和排序之前，我们需要提取我们的产品列表逻辑并将其模板化到我们的组件中 - 这使我们可以轻松地重用它。该组件应该接受应该能够列出和分页的 ``products`` prop 。

打开 ``ListProducts.js`` 文件并将 ``HomePage.js`` 文件中的代码复制到组件中。移动数据对象并复制 ``pagination`` 和 ``pageLinks`` 计算的函数。将 ``watch`` 和 ``methods`` 对象以及 ``created()`` 函数从 ``HomePage`` 移动到 ``ListProducts`` 文件。

更新 ``HomePage`` 模板中 ``<list-products>`` 组件与 ``products`` 道具一起使用，并传递 ``products`` 计算值。相比之下， ``HomePage`` 组件现在应该明显更小：

.. code-block:: js

    const HomePage = {
        name: 'HomePage',
        template: `<div>
            <list-products :products="products"></list-products>
        </div>`,
        computed: {
            products() {
                let products = this.$store.state.products;
                return Object.keys(products).map(key => products[key]);
            }
        }
    };

在 ``ListProducts`` 组件中，我们需要添加一个道具对象，让组件知道应该期待什么。 这个组件现在很重要。我们需要添加更多的东西来使这个组件更具多功能性。他们包括：

- 如果有多个页面，则显示下一个/上一个链接；
- 如果有超过 12 种产品，则显示“每页产品”组件；
- 如果比我们的 ``pageLinksCount`` 变量多，则只显示 ``pageLinks`` 组件；

所有这些添加项都已添加到以下组件代码中，如下所示。我们还删除了不必要的 ``products`` 计算值：

.. code-block:: js

    Vue.component('list-products', {
        template: `<div v-if="products">
        <p v-if="pagination.totalPages > 1">
            Page {{ currentPage }} out of {{ pagination.totalPages }}
        </p>
        <div v-if="pagination.totalProducts > 12">
            Products per page:
            <select v-model="perPage">
                <option>12</option>
                <option>24</option>
                <option v-if="pagination.totalProducts > 24">48</option>
                <option v-if="pagination.totalProducts > 48">60</option>
            </select>
        </div>
        <button
                @click="toPage(currentPage - 1)"
                :disabled="currentPage == 1"
                v-if="pagination.totalPages > 1"
        >
            Previous page
        </button>
        <button
                @click="toPage(currentPage + 1)"
                :disabled="currentPage == pagination.totalPages"
                v-if="pagination.totalPages > 1"
        >
            Next page
        </button>
        <ol :start="pagination.range.from + 1">
            <li v-for="product in paginate(products)" v-if="product">
                <h3>{{ product.title }}</h3>
            </li>
        </ol>
        <nav v-if="pagination.totalPages > pageLinksCount">
            <ul>
                <li v-for="page in pageLinks">
                    <button @click="toPage(page)">{{ page }}</button>
                </li>
            </ul>
        </nav>
    </div>`,
        props: {
            products: Array
        },
        data() {
            return {
                perPage: 12,
                currentPage: 1,
                pageLinksCount: 3
            }
        },
        computed: {
            pagination() {
                if(this.products) {
                    let totalProducts = this.products.length,
                        pageFrom = (this.currentPage * this.perPage) - this.perPage,
                        totalPages = Math.ceil(totalProducts / this.perPage);
                    return {
                        totalProducts: totalProducts,
                        totalPages: Math.ceil(totalProducts / this.perPage),
                        range: {
                            from: pageFrom,
                            to: pageFrom + this.perPage
                        }
                    }
                }
            },
            pageLinks() {
                if(this.products.length) {
                    let negativePoint = this.currentPage - this.pageLinksCount,
                        positivePoint = this.currentPage + this.pageLinksCount,
                        pages = [];
                    if(negativePoint < 1) {
                        negativePoint = 1;
                    }
                    if(positivePoint > this.pagination.totalPages) {
                        positivePoint = this.pagination.totalPages;
                    }
                    for (var i = negativePoint; i <= positivePoint; i++) {
                        pages.push(i)
                    }
                    return pages;
                }
            }
        },
        watch: {
            '$route'(to) {
                this.currentPage = parseInt(to.query.page);
            },
            perPage() {
                if(this.currentPage > this.pagination.totalPages) {
                    this.$router.push({
                        query: Object.assign({}, this.$route.query, {
                            page: this.pagination.totalPages
                        })
                    })
                }
            }
        },
        created() {
            if(this.$route.query.page) {
                this.currentPage = parseInt(this.$route.query.page);
            }
        },
        methods: {
            toPage(page) {
                this.$router.push({
                    query: Object.assign({}, this.$route.query, {
                        page
                    })
                });
                this.currentPage = page;
            },
            paginate(list) {
                return list.slice(this.pagination.range.from, this.pagination.range.to)
            }
        }
    });

您可以在主页模板中通过临时截断产品数组来验证您的条件渲染标签正在工作 - 一旦完成，请不要忘记将其删除：

.. code-block:: js

    products() {
        let products = this.$store.state.products;
        return Object.keys(products).map(key => products[key]).slice(1, 10);
    }

为主页创建一个策划清单
======================
使用我们的产品列表组件，我们可以继续为我们的主页制作产品列表，并在产品列表中添加更多信息。

在这个例子中，我们将硬编码我们想要显示的主页组件上的一系列产品句柄。如果这是在开发中，你会期望这个列表通过内容管理系统或类似的东西来控制。

在 ``HomePage`` 组件上创建一个 ``data`` 函数，该函数包含一个名为 ``selectedProducts`` 的数组：

.. code-block:: js

    data() {
        return {
            selectedProducts: []
        }
    },

用产品列表中的几个句柄填充数组。尝试并获得 6 个，但如果你超过 12，记住它将在我们的组件中分页。 将所选句柄添加到 ``selectedProducts`` 数组中：

.. code-block:: js

    data() {
        return {
            selectedProducts: [
                'adjustable-stem',
                'colorful-fixie-lima',
                'fizik-saddle-pak',
                'kenda-tube',
                'oury-grip-set',
                'pure-fix-pedals-with-cages'
            ]
        }
    },

通过选择的句柄，我们现在可以过滤产品列表，仅包含我们的 ``selectedProducts`` 数组中包含的产品列表。最初的想法可能是在 ``products`` 数组上使用 ``includes()`` 和 ``filter()`` 函数：

.. code-block:: js

    products() {
        let products = this.$store.state.products;
        products = Object.keys(products).map(key => products[key]);
        products = products.filter(product => this.selectedProducts.includes(product.handle));
        return products;
    }

与此相关的问题是，虽然它似乎能够运行，但并不考虑所选产品的排序。过滤器功能只是删除不匹配的任何项目，并按照其加载顺序保留剩余的产品。

幸运的是，我们的产品以手柄为键保存在一个键/值对中。使用这个，我们可以利用产品对象并使用 ``for`` 循环返回一个数组。

在计算的函数中创建一个空数组( ``output`` )。循环遍历 ``selectedProducts`` 数组，找到每个需要的产品并添加到 ``output`` 数组中：

.. code-block:: js

    products() {
        let products = this.$store.state.products,
            output = [];
        if(Object.keys(products).length) {
            for(let featured of this.selectedProducts) {
                output.push(products[featured]);
            }
            return output;
        }
    }

这会创建相同的产品列表，但这次按正确的顺序。尝试重新排序，添加和删除项目以确保您的列表做出相应反应。

显示更多信息
============
现在我们可以在 ``ListProduct`` 组件中显示更多产品信息。正如在本章开头附近提到的，我们应该显示：

- Image
- Title
- Price
- Manufacturer(生产厂家)

我们已经显示标题，图像，制造商可以很容易地从产品信息中提取出来。不要忘记总是从 ``images`` 数组中检索第一个图像。打开 ``ListProducts.js`` 文件并更新产品以显示此信息 - 确保在显示图像之前检查图像是否存在。制造商标题列在产品数据中的 ``vendor`` 对象下：

.. code-block:: html

    <ol :start="pagination.range.from + 1">
        <li v-for="product in paginate(products)" v-if="product">
            <img v-if="product.images[0]" :src="product.images[0].source" :alt="product.title" width="120">
            <h3>{{ product.title }}</h3>
            <p>Made by: {{ product.vendor.title }}</p>
        </li>
    </ol>

价格将会变得复杂一点。这是因为产品上的每种变化都可能有不同的价格，但是，这些变化往往是相同的。 如果有不同的价格，我们应该显示最便宜的一个带有 ``from`` 前置的价格。

我们需要创建一个函数，循环变体并计算出最便宜的价格，如果有价格范围，请添加 ``from`` 单词。 为了实现这一点，我们将循环变体并建立不重复的价格数组。 一旦完成，我们可以检查长度 - 如果有多个价格，我们可以添加前缀，如果不是，则意味着所有变化都是相同的价格。

在 ``ListProducts`` 组件上创建一个名为 ``productPrice`` 的新方法。这接受一个参数，这将是变体。 在里面，创建一个空数组， ``prices`` ：

.. code-block:: js

    productPrice(variations) {
        let prices = [];
    }

循环浏览变体，如果它不存在的话，则将价格追加到 ``prices`` 数组中。创建一个 ``for`` 循环，使用 ``includes()`` 函数检查数组中是否存在价格：

.. code-block:: js

    productPrice(variations) {
        let prices = [];
        for(let variation of variations) {
            if(!prices.includes(variation.price)) {
                prices.push(variation.price);
            }
        }
    }

用我们的价格数组，我们现在可以提取最低的数字，并检查是否有多个项。

为了从数组中提取最小数字，我们可以使用 JavaScript ``Math.min()`` 函数。使用 ``.length`` 属性检查数组的长度。最后，返回 ``price`` 变量：

.. code-block:: js

    productPrice(variations) {
        let prices = [];
        for(let variation of variations) {
            if(!prices.includes(variation.price)) {
                prices.push(variation.price);
            }
        }
        let price = '$' + Math.min(...prices);
        if(prices.length > 1) {
            price = 'From: ' + price;
        }
        return price;
    }

将您的 ``productPrice`` 方法添加到您的模板中，记住将 ``product.variationProducts`` 传递给它。 我们需要添加到模板中的最后一件事是指向产品的链接：

.. code-block:: html

    <ol :start="pagination.range.from + 1">
        <li v-for="product in paginate(products)" v-if="product">
            <router-link :to="'/product/' + product.handle">
                <img v-if="product.images[0]" :src="product.images[0].source" :alt="product.title" width="120">
            </router-link>
            <h3>
                <router-link :to="'/product/' + product.handle">
                    {{ product.title }}
                </router-link>
            </h3>
            <p>Made by: {{ product.vendor.title }}</p>
            <p>Price {{ productPrice(product.variationProducts) }}</p>
        </li>
    </ol>

理想情况下，产品链接应该使用命名路由，而不是硬编码链接，以防路由改变。为产品路由添加名称，并更新 to 属性以改为使用名称：

.. code-block:: json

    {
      path: '/product/:slug',
      name: 'Product',
      component: ProductPage
    }

使用 ``params`` 对象更新模板为现在使用的路由名称：

.. code-block:: html

    <ol :start="pagination.range.from + 1">
        <li v-for="product in paginate(products)" v-if="product">
            <router-link :to="{name: 'Product', params: {slug: product.handle}}">
                <img v-if="product.images[0]" :src="product.images[0].source" :alt="product.title" width="120">
            </router-link>
            <h3>
                <router-link :to="{name: 'Product', params: {slug: product.handle}}">
                    {{ product.title }}
                </router-link>
            </h3>
            <p>Made by: {{ product.vendor.title }}</p>
            <p>Price {{ productPrice(product.variationProducts) }}</p>
        </li>
    </ol>

创建类别
========
如果商店没有可导航的类别，那么它并不是一个真正可用的商店。幸运的是，我们的每个产品都有一个类型键，指明了要显示的类别。我们现在可以创建一个列出该特定类别产品的类别页面。

创建一个类别列表
----------------
在我们能够在特定类别中展示产品之前，我们首先需要生成可用类别的列表。为了帮助我们的应用程序的性能，我们还会在每个类别中存储产品的句柄。类别结构如下所示：

.. code-block:: js

    categories = {
        tools: {
            name: 'Tools',
            handle: 'tools',
            products: ['product-handle', 'product-handle'...]
        },
        freewheels: {
            name: 'Freewheels',
            handle: 'freewheels',
            products: ['another-product-handle', 'product'...]
        }
    };

像这样创建类别列表意味着我们可以轻松获得类别内的产品列表，同时能够遍历类别并输出标题和句柄以创建类别链接列表。由于我们已经有了这些信息，我们将在检索产品列表后创建分类列表。

打开 ``app.js`` 并导航到 ``Vue`` 实例上的 ``created()`` 方法。除了在 ``products`` 存储方法下创建第二个 ``$store.commit`` 外，我们将使用 ``Vuex`` 的不同功能 - ``actions`` (操作)。

``actions`` 允许您在 ``store`` 本身中创建函数。 ``actions`` 不能直接改变状态但它可以让你将几个突变组合在一起，在本示例情况下，它完美地适合我们。如果要在变更状态之前运行异步操作，则 ``actions`` 也很完美 - 例如，使用 ``setTimeout`` JavaScript函数。

导航到您的 ``Vuex.Store`` 实例，并在 ``mutations`` 后添加一个新的 ``actions`` 对象。在里面，创建一个名为 ``initializeShop`` 的新函数：

.. code-block:: js

    const store = new Vuex.Store({
        state: {
            products: {}
        },
        mutations: {
            products(state, payload) {
                state.products = payload;
            }
        },
        actions: {
            initializeShop() {
            }
        }
    });

通过动作参数，第一个参数是 ``store`` 本身，我们需要使用它来利用突变。 有两种方法可以做到这一点，第一种方法是使用单个变量并在函数内访问它的属性。 例如：

.. code-block:: js

    actions: {
        initializeShop(store) {
            store.commit('products');
        }
    }

但是，通过 ``ES2015`` ，我们可以使用参数解构并利用我们所需的属性。 对于这个动作，我们只需要 ``commit`` 函数，如下所示：

.. code-block:: js

    actions: {
        initializeShop({commit}) {
            commit('products');
        }
    }

如果我们也想要来自 ``store`` 的 ``state`` ，我们可以将它添加到大括号中：

.. code-block:: js

    actions: {
        initializeShop({state, commit}) {
            commit('products');
            // state.products
        }
    }

使用这种访问属性的“分解”方法可以使我们的代码更加清晰，重复性更低。删除 ``state`` 属性并在大括号标记产品后添加第二个参数。这将是我们已经格式化的产品数据。 直接将该变量传递给产品的提交功能：

.. code-block:: js

    initializeShop({commit}, products) {
        commit('products', products);
    }

使用操作与使用突变一样简单，除了不使用 ``$store.commit`` 之外，您使用 ``$store.dispatch`` 。更新您 ``created`` 方法 - 不要忘记更改函数名称，并检查您的应用程序是否仍然有效：

.. code-block:: js

    created() {
        CSV.fetch({url: './data/csv-files/bicycles.csv'}).then(data => {
            this.$store.dispatch('initializeShop', this.$formatProducts(data));
        });
    }

下一步是为我们的类别创建一个 ``mutation`` 。因为我们可能希望独立于我们的产品更新我们的类别 - 我们应该在 ``mutations`` 中创建第二个功能。它也应该是这个函数循环遍历产品并创建类别列表。

首先，在状态对象中创建一个标题为 ``categories`` 的新属性。这默认应该是一个对象：

.. code-block:: js

    state: {
        products: {},
        categories: {}
    }

接下来，创建一个名为 ``categories`` 的新 ``mutation`` 。除了 ``state`` ，这应该接收第二个参数。 为了保持一致，将其称为有效载荷( ``payload`` ) - 因为这是引用 ``Vuex`` 的称谓：

.. code-block:: js

    mutations: {
        products(state, payload) {
            state.products = payload;
        },
        categories(state, payload) {
        }
    },

这种突变需要循环遍历产品。对于每种产品，都需要根据类型分组。 一旦它有标题和 ``slug`` ，它需要检查是否存在与该 ``slug`` 的一个条目；如果是这样，则将产品句柄附加到 ``products`` 数组中，如果不是的话 - 它需要创建一个新的数组和详情。

创建一个空的 ``categories`` 对象并循环遍历有效负载，为产品和类型分别设置一个变量：

.. code-block:: js

    categories(state, payload) {
        let categories = {};
        Object.keys(payload).forEach(key => {
            let product = payload[key],
                type = product.type;
        });
    }

我们现在需要检查当前 ``type.handle`` 是否存在条目。如果没有，我们需要用它创建一个新条目。 该条目需要具有标题，句柄和空产品数组：

.. code-block:: js

    categories(state, payload) {
        let categories = {};
        Object.keys(payload).forEach(key => {
            let product = payload[key],
                type = product.type;
            if(!categories.hasOwnProperty(type.handle)) {
                categories[type.handle] = {
                    title: type.title,
                    handle: type.handle,
                    products: []
                }
            }
        });
    }

最后，我们需要将当前产品句柄附加到条目的产品数组上：

.. code-block:: js

    categories(state, payload) {
        let categories = {};
        Object.keys(payload).forEach(key => {
            let product = payload[key],
                type = product.type;
            if(!categories.hasOwnProperty(type.handle)) {
                categories[type.handle] = {
                    title: type.title,
                    handle: type.handle,
                    products: []
                }
            }
            categories[type.handle].products.push(product.handle);
        });
    }

您可以通过将 ``console.log`` 添加到该函数的结尾来查看 ``categories`` 输出：

.. code-block:: js

    categories(state, payload) {
        let categories = {};
        Object.keys(payload).forEach(key => {
        ...
        });
        console.log(categories);
    }

将该突变添加到 ``initializeShop`` 操作中：

.. code-block:: js

    initializeShop({commit}, products) {
        commit('products', products);
        commit('categories', products);
    }

在浏览器中查看应用程序，您将面临 JavaScript 错误。 这是因为有些产品不包含 ``type`` 供我们用来对它们进行分类。即使解决了 JavaScript 错误，仍然有很多类别被列出。

为了帮助确定类别数量，并对未分类的产品进行分组，我们应该制定一个“其它”类别。 这将整理所有类别与两个或更少的产品，并将产品分组到该组。

创建一个“其它”类别
------------------
我们需要注意的一个问题是无名分类。当循环浏览我们的产品时，如果找不到类型，我们应该插入一个类别，因此所有内容都被分类。

在 ``categories`` 方法中创建一个新对象，该对象包含新类别的标题和句柄。对于句柄和变量叫它 ``other`` 。 通过将标题称为 ``Miscellaneous`` 更友好一些。

.. code-block:: js

    let categories = {},
        other = {
            title: 'Miscellaneous',
            handle: 'other'
        };

在循环产品时，我们可以检查 ``type`` 键是否存在，如果不存在，则创建 ``other`` 类并附加到该类：

.. code-block:: js

    Object.keys(payload).forEach(key => {
        let product = payload[key],
            type = product.hasOwnProperty('type') ? product.type : other;
        if(!categories.hasOwnProperty(type.handle)) {
            categories[type.handle] = {
                title: type.title,
                handle: type.handle,
                products: []
            }
        }
        categories[type.handle].products.push(product.handle);
    });

现在查看应用程序将在 JavaScript 控制台中显示的所有类别 - 可以查看其中有多少类别的大小。

让我们将任何具有两个或更少产品的类别合并到“其他”类别 - 不要忘记随后删除那些类别。在产品循环之后，遍历类别，检查可用产品的数量。 如果少于三个，则将它们添加到“其他”类别中：

.. code-block:: js

    Object.keys(categories).forEach(key => {
        let category = categories[key];
        if(category.products.length < 3) {
            categories.other.products = categories.other.products.concat(category.products);
        }
    });

然后，我们可以删除我们刚刚合并的产品类别：

.. code-block:: js

    Object.keys(categories).forEach(key => {
        let category = categories[key];
        if(category.products.length < 3) {
            categories.other.products = categories.other.products.concat(category.products);
            delete categories[key];
        }
    });

因此，我们有一个更容易管理的类别列表。 我们可以做的更多改进是确保类别按字母顺序排列。这有助于用户更快地找到所需的类别。在JavaScript中，数组可以比对象更容易排序，所以我们再一次需要循环访问对象键的数组并对它们进行排序。创建一个新对象并添加分类。之后，将其存储在 ``state`` 对象中，以便我们可用这些类别：

.. code-block:: js

    categories(state, payload) {
        let categories = {},
            other = {
                title: 'Miscellaneous',
                handle: 'other'
            };
        Object.keys(payload).forEach(key => {
            let product = payload[key],
                type = product.hasOwnProperty('type') ? product.type : other;
            if(!categories.hasOwnProperty(type.handle)) {
                categories[type.handle] = {
                    title: type.title,
                    handle: type.handle,
                    products: []
                }
            }
            categories[type.handle].products.push(product.handle);
        });
        Object.keys(categories).forEach(key => {
            let category = categories[key];
            if(category.products.length < 3) {
                categories.other.products = categories.other.products.concat(category.products);
                delete categories[key];
            }
        });
        let categoriesSorted = {};
        Object.keys(categories).sort().forEach(key => {
            categoriesSorted[key] = categories[key]
        });
        state.categories = categoriesSorted;
    }

有了这个，我们现在可以添加一个类别列表到我们的 ``HomePage`` 模板。为此，我们将创建命名的 ``router-view`` 组件 - 允许我们在选定页面上的商店侧边栏中放置东西。

显示类别
--------
随着我们的类别存储，我们现在可以继续创建我们的 ``ListCategories`` 组件。我们希望在主页上的侧边栏中以及在商店类别页面上显示我们的类别导航。因为我们想在几个地方展示它，所以我们有几个选项来展示它。

我们可以像使用 ``<list-products>`` 组件一样在模板中使用该组件。 与此相关的问题是，如果我们想要在侧边栏中显示我们的列表，并且我们的边栏需要在整个网站上保持一致，那么我们必须在视图之间复制和粘贴大量 ``HTML`` 。

更好的方法是使用命名路由并在我们的 ``index.html`` 中设置模板一次。更新应用模板以包含 ``<main>`` 和 ``<aside>`` 元素。 在这些内部，创建一个 ``router-view`` ，在 ``main`` 块内放置一个未命名路由视图，同时向 ``aside`` 块中提供一个命名为 ``sidebar`` 的路由视图：

.. code-block:: html

    <div id="app">
        <main>
            <router-view></router-view>
        </main>
        <aside>
            <router-view name="sidebar"></router-view>
        </aside>
    </div>

在我们的路由对象中，我们现在可以为不同的命名视图添加不同的组件。 在 ``Home`` 路由中，将 ``component`` 键更改为 ``components`` ，并添加一个对象 - 指定每个组件及其视图：

.. code-block:: js

    {
        path: '/',
        name: 'Home',
        components: {
            default: HomePage,
            sidebar: ListCategories
        }
    }

默认值表示组件将进入未命名的 ``router-view`` 。这使得我们仍然可以在需要时使用单数 ``component`` 键。 为了将组件正确加载到侧栏视图中，我们需要更改 ``ListCategories`` 组件的初始化方式。 而不是使用 ``Vue.component`` ，像视图组件一样初始化它：

.. code-block:: js

    const ListCategories = {
        name: 'ListCategories'
    };

我们现在可以继续为类别列表制作模板。由于我们的类别已保存在 ``store`` 中，因此加载并显示它们应该很熟悉。 建议您将状态中的类别加载到计算函数中 - 以便更清晰的模板代码，并且如果需要以任何方式操作它，则更容易进行调整。

在我们创建模板之前，我们需要为类别创建一个路由。回顾我们在第9章使用 ``Vue-Router`` 动态路由加载数据的计划，我们可以看到路由将是 ``/category/:slug`` - 添加一个带有名称并启用道具的路由，因为我们会利用它 ``slug`` 。确保您已创建 CategoryPage 文件并初始化组件。

.. code-block:: js

    const router = new VueRouter({
        routes: [
            {
                path: '/',
                name: 'Home',
                components: {
                    default: HomePage,
                    sidebar: ListCategories
                }
            },
            {
                path: '/category/:slug',
                name: 'Category',
                component: CategoryPage,
                props: true
            },
            {
                path: '/product/:slug',
                name: 'Product',
                component: ProductPage
            },
            {
                path: '/404',
                alias: '*',
                component: PageNotFound
            }
        ]
    });

回到我们的 ``ListCategories`` 组件; 循环存储的类别并为每个类别创建一个链接。在每个名称后括号中显示产品数量：

.. code-block:: js

    const ListCategories = {
        name: 'ListCategories',
        template: `<div v-if="categories">
        <ul>
            <li v-for="category in categories">
                <router-link :to="{name: 'Category', params: {slug: category.handle}}">
                    {{ category.title }} ({{ category.products.length }})
                </router-link>
            </li>
        </ul>
    </div>`,
        computed: {
            categories() {
                return this.$store.state.categories;
            }
        }
    };

通过现在主页上显示的我们类别的链接，我们可以开始创建类别页面。

在类别中显示产品
----------------
点击其中一个分类链接（即 ``/＃/category/grips`` ）将导航到一个空白页面 - 感谢我们的路由。 我们需要创建一个模板并设置分类页面来显示产品。作为一个起点，创建类似于产品页面的 ``CategoryPage`` 组件。

用一个空容器和内置 ``PageNotFound`` 组件创建一个模板。 创建一个名为 ``categoryNotFound`` 的数据变量，如果设置为 ``true`` 则 ``PageNotFound`` 组件显示。 创建一个道具对象，它允许传递 ``slug`` 属性，最后创建一个 ``category`` 计算函数。

``CategoryPage`` 组件应如下所示：

.. code-block:: js

    const CategoryPage = {
        name: 'CategoryPage',
        template: `<div>
            <div v-if="category"></div>
            <page-not-found v-if="categoryNotFound"></page-not-found>
        </div>`,
        components: {
            PageNotFound
        },
        props: {
            slug: String
        },
        data() {
            return {
                categoryNotFound: false,
            }
        },
        computed: {
            category() {
            }
        }
    };

在计算函数 ``category`` 内部，根据 ``slug`` 从 ``store`` 中加载正确的类别。 如果它不在列表中，请将 ``categoryNotFound`` 变量标记为 ``true`` - 与我们在 ``ProductPage`` 组件中执行的操作类似：

.. code-block:: js

    computed: {
        category() {
            let category;
            if(Object.keys(this.$store.state.categories).length) {
                category = this.$store.state.categories[this.slug];
                if(!category) {
                    this.categoryNotFound = true;
                }
            }
            return category;
        }
    }

加载我们的类别后，我们可以在模板中输出标题：

.. code-block:: html

    template: `<div>
        <div v-if="category">
            <h1>{{ category.title }}</h1>
        </div>
        <page-not-found v-if="categoryNotFound"></page-not-found>
    </div>`,

我们现在可以继续在我们的分类页面上显示产品。 为此，我们可以使用 ``HomePage`` 组件中的代码，因为我们有完全相同的场景 - 一组产品句柄。 创建一个新的计算函数，它接受当前类别产品并按照我们在主页上所做的那样处理它们：

.. code-block:: js

    computed: {
        category() {
        ...
        },
        products() {
            if(this.category) { // 当前选择分类
                let products = this.$store.state.products,
                    output = [];
                for(let featured of this.category.products) {
                    output.push(products[featured]);
                }
                return output;
            }
        }
    }

此函数中我们不需要检查产品是否存在，因为我们正在检查该类别是否存在，并且只有在数据已加载时才会返回 ``true`` 。将组件添加到 ``HTML`` 并传递 ``products`` 变量：

.. code-block:: html

    template: `<div>
        <div v-if="category">
            <h1>{{ category.title }}</h1>
            <list-products :products="products"></list-products>
        </div>
        <page-not-found v-if="categoryNotFound"></page-not-found>
    </div>`

因此，我们为每个类别列出了我们的类别产品。

代码优化
========
通过完成我们的 ``CategoryPage`` 组件，我们可以看到它和主页之间的很多相似之处 - 唯一的区别是主页有一个固定的产品数组。为了节省重复，我们可以将这两个组件结合起来 - 这意味着如果需要的话，我们只需要更新一个组件。

当我们确定我们在主页上时，我们可以通过显示它来解决固定阵列问题。这样做的方法是检查 ``slug prop`` 是否有值。如果没有，我们可以假设我们在主页上。

首先，将 ``Home`` 路由更新为指向 ``CategoryPage`` 组件并启用道具。当使用命名视图时，必须为每个视图启用道具。将道具值更新为每个命名视图的对象：

.. code-block:: json

    {
      path: '/',
      name: 'Home',
      components: {
        default: CategoryPage,
        sidebar: ListCategories
      },
      props: {
        default: true,
        sidebar: true
      }
    }

接下来，在 ``CategoryPage`` 的数据函数中创建一个名为 ``categoryHome`` 的新变量。 这将成为一个与类别对象具有相同结构的对象，其中包含 ``products`` 数组，标题和句柄。 尽管句柄不会被使用，但遵循约定是一种好习惯：

.. code-block:: js

    data() {
        return {
            categoryNotFound: false,
            categoryHome: {
                title: 'Welcome to the Shop',
                handle: 'home',
                products: [
                    'adjustable-stem',
                    'fizik-saddle-pak',
                    'kenda-tube',
                    'colorful-fixie-lima',
                    'oury-grip-set',
                    'pure-fix-pedals-with-cages'
                ]
            }
        }
    }

我们需要做的最后一件事是检查 ``slug`` 是否存在。如果不是，则在计算函数中将我们的新对象分配给的类别变量：

.. code-block:: js

    category() {
        let category;
        if(Object.keys(this.$store.state.categories).length) {
            if(this.slug) {
                category = this.$store.state.categories[this.slug];
            } else {
                category = this.categoryHome;
            }
            if(!category) {
                this.categoryNotFound = true;
            }
        }
        return category;
    }

转到主页并确认您的新组件正在工作。如果是这样，你可以删除 ``HomePage.js`` 并从 ``index.html`` 中删除它。 将类别路由更新为包含侧边栏中的类别列表并使用 ``props`` 对象：

.. code-block:: json

    {
      path: '/category/:slug',
      name: 'Category',
      components: {
        default: CategoryPage,
        sidebar: ListCategories
      },
      props: { //  对于包含命名视图的路由，你必须分别为每个命名视图添加porps选项
        default: true,
        sidebar: true
      }
    },

在类别中排序产品
==============
通过我们的类别页面显示正确的产品，现在可以在我们的ListProducts组件中添加一些排序选项。在网上查看商店时，您通常可以通过以下方式排序产品：

- Title升序(A-Z)；
- Title降序(Z-A)；
- Price升序($1-$999)；
- Price降序($999-$1)；

但是，一旦我们有了这个机制，您就可以添加您想要的任何排序标准。

首先在 ListProducts 组件中使用前面的每个值创建一个选择框。

.. code-block:: html

    <div class="ordering">
        <select>
            <option>Order products</option>
            <option>Title - ascending (A - Z)</option>
            <option>Title - descending (Z - A)</option>
            <option>Price - ascending ($1 - $999)</option>
            <option>Price - descending ($999 - $1)</option>
        </select>
    </div>

现在我们需要为选择框在数据函数中创建一个变量来进行更新。添加一个标题为 ``ordering`` 的新键并为每个选项添加一个值，以便解释该值更容易。使用字段和顺序构造该值，并用连字符分隔。例如， ``Title - ascending(A - Z)`` 将成为 ``title-asc`` ：

.. code-block:: html

    <div class="ordering">
        <select v-model="ordering">
            <option value="">Order products</option>
            <option value="title-asc">Title - ascending (A - Z)</option>
            <option value="title-desc">Title - descending (Z - A)</option>
            <option value="price-asc">Price - ascending ($1 - $999)</option>
            <option value="price-desc">Price - descending ($999 - $1)</option>
        </select>
    </div>

更新后的数据函数变为：

.. code-block:: js

    data() {
        return {
            perPage: 12,
            currentPage: 1,
            pageLinksCount: 3,
            ordering: ''
        }
    }

要更新产品的订单，我们现在需要操作产品列表。这需要在列表分页之前完成 - 因为用户期望整个列表被排序，而不仅仅是当前页面。

存储产品价格
------------
在我们开始之前，我们需要解决一个问题。 要按价格排序，价格需要理想地在产品本身上提供，而不用特别的计算。为了解决这个问题，我们将在产品加入 ``store`` 之前计算价格。这意味着它将作为产品本身的属性提供，而不是动态创建。

我们需要知道的细节是最便宜的价格以及产品在其变体中是否有很多价格。后者意味着我们知道在列出产品时是否需要显示 ``From:`` 。我们将为每个产品创建两个新属性： ``price`` 和 ``hasManyPrices`` 。

导航到 ``store`` 中的 ``products`` 突变，并创建一个新对象和产品的一个循环：

.. code-block:: js

    products(state, payload) {
        let products = {};
        Object.keys(payload).forEach(key => {
            let product = payload[key];
            products[key] = product;
        });
        state.products = payload;
    }

将 ``ListProducts`` 组件上 ``ProductPrice`` 方法中的代码复制，并将其放置在循环中。更新第二个 ``for`` 循环，以便循环访问 ``product.variationProducts`` 。 一旦这个 ``for`` 循环完成，我们可以将新属性添加到产品中。最后，用新产品对象更新状态：

.. code-block:: js

    products(state, payload) {
        let products = {};
        Object.keys(payload).forEach(key => {
            let product = payload[key];
            let prices = [];
            for(let variation of product.variationProducts) {
                if(!prices.includes(variation.price)) {
                    prices.push(variation.price);
                }
            }
            product.price = Math.min(...prices);
            product.hasManyPrices = prices.length > 1;
            products[key] = product;
        });
        state.products = products;
    }

我们现在可以更新 ``ListProducts`` 组件上的 ``productPrice`` 方法。更新该函数，以便接受 ``product`` ，而不是变体。从函数中除去 ``for`` 循环，并更新变量，以便它们使用产品的 ``price`` 和 ``hasManyPrices`` 属性：

.. code-block:: js

    productPrice(product) {
        let price = '$' + product.price;
        if(product.hasManyPrices) {
            price = 'From: ' + price;
        }
        return price;
    }

更新模板，以便将 ``product`` 传递给该函数：

.. code-block:: html

    <p>Price {{ productPrice(product) }}</p>

实现排序
--------
随着我们的价格随时可用，我们可以继续实现排序。创建一个名为 ``orderProducts`` 的新计算函数，并返回 ``this.products`` 。我们希望确保我们始终从源头进行排序，而不是排序之前已经排序的东西。从 ``paginate`` 函数中调用这个新函数，并从该方法和模板中删除参数：

.. code-block:: js

    computed: {
    ...
        orderProducts() {
            return this.products;
        },
    },
    methods: {
        paginate() {
            return this.orderProducts.slice(
                this.pagination.range.from,
                this.pagination.range.to
            );
        },
    }

为了确定我们需要如何排序产品，我们可以使用 ``this.ordering`` 值。如果存在，我们可以在连字符上拆分字符串，这意味着我们有一个包含字段和订单类型的数组。如果它不存在，我们只需要返回现有的产品数组：

.. code-block:: js

    orderProducts() {
        let output;
        if(this.ordering.length) {
            let orders = this.ordering.split('-');
        } else {
            output = this.products;
        }
        return output;
    }

根据排序数组的第一个项目的值对产品数组进行排序。如果它是一个字符串，我们将使用 ``localCompare`` ，比较时会忽略大小写情况。否则，我们只需从另一个中减去一个值 - 这就是排序函数所期望的：

.. code-block:: js

    orderProducts() {
        let output;
        if(this.ordering.length) {
            let orders = this.ordering.split('-');
            output = this.products.sort(function(a, b) {
                if(typeof a[orders[0]] == 'string') {
                    return a[orders[0]].localeCompare(b[orders[0]]);
                } else {
                    return a[orders[0]] - b[orders[0]];
                }
            });
        } else {
            output = this.products;
        }
        return output;
    }

最后，我们需要检查 ``orders`` 数组中的第二项是 ``asc`` 还是 ``desc`` 。默认情况下，当前的排序函数将返回按升序排序的项目，所以如果值是 ``desc`` ，我们可以反转数组：

.. code-block:: js

    orderProducts() {
        let output;
        if(this.ordering.length) {
            let orders = this.ordering.split('-');
            output = this.products.sort(function(a, b) {
                if(typeof a[orders[0]] == 'string') {
                    return a[orders[0]].localeCompare(b[orders[0]]);
                } else {
                    return a[orders[0]] - b[orders[0]];
                }
            });
            if(orders[1] == 'desc') {
                output.reverse();
            }
        } else {
            output = this.products;
        }
        return output;
    }

前往您的浏览器并查看排序产品信息！

创建Vuex getters
=================
使我们的类别页面像任何其他商店一样的最后一步是引入过滤。通过筛选，您可以查找具有特定尺寸，颜色，标签或制造商的产品。我们的过滤选项将从网页上的产品构建。例如，如果没有任何产品具有 XL 尺寸或蓝色，则没有意义将其作为过滤器。

为了实现这一点，我们需要将当前类别的产品传递给过滤组件。但是，产品在 CategoryPage 组件上得到处理。我们可以将功能移至 ``Vuex store getter`` ，而不是重复此处理。 ``Getters`` 允许您从 ``store`` 中检索数据并像在组件上的函数中那样操作它。但是，由于它是一个中心位置，这意味着有几个组件可以从处理中受益。

``Getters`` 是计算函数在 ``Vuex`` 中等价物。它们被声明为函数，但被称为变量。然而，他们可以通过返回一个函数来接受参数。我们将把类别和产品功能从 ``CategoryPage`` 组件移到 ``getter`` 中。然后 ``getter`` 函数将返回一个包含类别和产品的对象。

在 ``store`` 名为 ``getters`` 中创建一个新对象。在里面，创建一个名为 ``categoryProducts`` 的新函数：

.. code-block:: js

    getters: {
        categoryProducts: () => {
        }
    }

``Getters`` 自己获得两个参数，第一个是状态( ``state`` )，第二个是其它( ``getters`` )。要将参数传递给 ``getter`` ，必须在 ``getter`` 中返回一个接收参数的函数。幸运的是，在 ES2015 中，这可以通过双箭头 ``(=>)`` 语法来实现。由于我们不打算在此函数中使用任何其他 getter ，因此我们不需要调用第二个参数。

当我们抽取所有逻辑时，传入 ``slug`` 变量作为第二个函数的参数：

.. code-block:: js

    categoryProducts: (state) => (slug) => {} // 函数的函数

随着我们将选择和检索类别和产品的逻辑转移到 ``store`` 中，将 ``HomePage`` 类别内容存储在 ``state`` 本身中是有意义的：

.. code-block:: js

    state: {
        products: {},
        categories: {},
        categoryHome: {
            title: 'Welcome to the Shop',
                handle: 'home',
                products: [
                'adjustable-stem',
                'fizik-saddle-pak',
                'kenda-tube',
                'colorful-fixie-lima',
                'oury-grip-set',
                'pure-fix-pedals-with-cages'
            ]
        }
    }

将类别选择逻辑从 ``CategoryPage`` 组件中的 ``category`` 计算函数移动到 ``getter`` 中。更新 ``slug`` 和 ``categoryHome`` 变量以使用相关位置的内容：

.. code-block:: js

    categoryProducts: (state) => (slug) => {
        if(Object.keys(state.categories).length) {
            let category = false;
            if(slug) {
                category = this.$store.state.categories[this.slug];
            } else {
                category = state.categoryHome;
            }
        }
    }

在分配类别后，我们现在可以根据存储在类别中的句柄加载产品。将 ``products`` 计算函数中的代码移到 ``getter`` 中。 因为我们有 ``state`` 可用，所以将变量赋值组合在一起并删除 ``store`` 产品检索变量。确保检查该类别是否存在的代码仍然存在：

.. code-block:: js

    categoryProducts: (state) => (slug) => {
        if(Object.keys(state.categories).length) {
            let category = false,
                products = [];
            if(slug) {
                category = this.$store.state.categories[this.slug];
            } else {
                category = state.categoryHome;
            }
            if(category) {
                for(let featured of category.products) {
                    products.push(state.products[featured]);
                }
            }
        }
    }

最后，我们可以在 ``category`` 中添加一个新的 ``productDetails`` 数组属性。在函数结尾处返回 ``category`` 。 如果输入的 ``slug`` 变量作为一个类别存在，我们将返回所有数据。如果没有，它将返回 ``false`` - 我们可以从中显示我们的 ``PageNotFound`` 组件：

.. code-block:: js

    categoryProducts: (state) => (slug) => {
        if(Object.keys(state.categories).length) {
            let category = false,
                products = [];
            if(slug) {
                category = state.categories[slug];
            } else {
                category = state.categoryHome;
            }
            if(category) {
                for(let featured of category.products) {
                    products.push(state.products[featured]);
                }
                category.productDetails = products;
            }
            return category;
        }
    }

在我们的 ``CategoryPage`` 组件中，我们可以移除 ``products()`` 计算的函数并更新 ``category()`` 函数。 要调用 ``getter`` 函数，请引用 ``this.$store.getters`` ：

.. code-block:: js

    computed: {
        category() {
            if(Object.keys(this.$store.state.categories).length) {
                let category = this.$store.getters.categoryProducts(this.slug);
                if(!category) {
                    this.categoryNotFound = true;
                }
                return category;
            }
        }
    }

不幸的是，在继续之前，我们仍然需要检查类别是否存在。这是因为我们可以看出，没有该名称的类别，而不是未加载的类别。

为了使这个更清洁，我们可以将这个检查抽取到另一个 ``getter`` 中，并将其用于我们的其他 ``getter`` 和组件。

创建一个名为 ``categoriesExist`` 的新 ``getter`` ，并返回 ``if`` 语句的内容：

.. code-block:: js

    categoriesExist: (state) => {
        return Object.keys(state.categories).length;
    },

更新 ``categoryProducts getter`` 以在第一个函数的参数中接受 ``getter`` 并使用此新的 ``getter`` ：

.. code-block:: js

    categoryProducts: (state, getters) => (slug) => {
        if(getters.categoriesExist) {
        ...
        }
    }

在我们的 ``CategoryPage`` 组件中，我们现在可以用 ``this.$store.getters.categoriesExist()`` 来调用新的 ``getter`` 。 为了节省这个 ``this.$store.getters`` 在这个函数中重复了两次，我们可以映射 ``getters`` 在本地访问。这使我们可以调用 ``this.categoriesExist()`` 作为更具可读性的函数名称。

在计算对象的开始处，添加一个名为 ``...Vuex.mapGetters()`` 的新函数。 该函数接受一个数组或一个对象作为参数，开头的三个点确保内容被扩展后与计算对象合并。

传入包含两个 ``getters`` 名称的数组：

.. code-block:: js

    computed: {
        ...Vuex.mapGetters([
            'categoryProducts',
            'categoriesExist'
        ]),
        category() {
        ...
        }
    }

这意味着我们有 ``this.categoriesExist`` 和 ``this.categoryProducts`` 在任我们处置。 更新类别函数以使用这些新函数：

.. code-block:: js

    computed: {
        ...Vuex.mapGetters([
            'categoriesExist',
            'categoryProducts'
        ]),
         category() {
            if(this.categoriesExist) {
                let category = this.categoryProducts(this.slug);
                if(!category) {
                    this.categoryNotFound = true;
                }
                return category;
            }
        }
    }

更新模板以反映计算数据中的更改：

.. code-block:: html

    template: `<div>
        <div v-if="category">
            <h1>{{ category.title }}</h1>
            <list-products :products="category.productDetails"></list-products>
        </div>
        <page-not-found v-if="categoryNotFound"></page-not-found>
    </div>`,

基于产品构建过滤组件
====================
如前所述，我们所有的过滤器都将由当前类别的产品创建。这意味着如果没有 ``IceToolz`` 制作的产品，它将不会显示一个可用的过滤器。

首先，打开 ``ProductFiltering.js`` 组件文件。我们的产品过滤将进入侧边栏，因此将组件定义从 ``Vue.component`` 更改为对象。我们仍希望在过滤后显示我们的类别，因此将 ``ListCategories`` 组件添加为 ``ProductFiltering`` 中的声明组件。添加模板键并包含 ``<list-categories>`` 组件：

.. code-block:: js

    const ProductFiltering = {
        name: 'ProductFiltering',
        template: `<div>
        <list-categories />
        </div>`,
        components: {
            ListCategories
        }
    }

更新类别路由以在侧边栏中包含 ``ProductFiltering`` 组件，而不是 ``ListCategories`` ：

.. code-block:: js

    {
      path: '/category/:slug',
      name: 'Category',
      components: {
        default: CategoryPage,
        sidebar: ProductFiltering
      },
      props: {
        default: true,
        sidebar: true
      }
    }

现在您应该拥有包含 ``CategoryPage`` 和 ``ListCategories`` 组件的 ``Home`` 路由，以及包含 ``ProductFiltering`` 组件的 ``Category`` 路由。

从 ``CategoryPage`` 组件中，复制道具和计算对象 - 因为我们将要利用很多现有的代码。将 ``category`` 计算函数重命名为 ``filters`` 。 除去 ``return`` 和 ``componentNotFound if`` 语句。您的组件现在应该如下所示：

.. code-block:: js

    const ProductFiltering = {
        name: 'ProductFiltering',
        template: `<div>
        <list-categories />
        </div>`,
        components: {
            ListCategories
        },
        props: {
            slug: String
        },
        computed: {
            ...Vuex.mapGetters([
                'categoriesExist',
                'categoryProducts'
            ]),
            filters() {
                if(this.categoriesExist) {
                    let category = this.categoryProducts(this.slug);
                }
            }
        }
    }

我们现在需要根据类别中的产品构建我们的过滤器。我们将通过循环遍历产品，从预选值收集信息并显示它们来做到这一点。

创建一个包含 ``topics`` 键的数据对象。这将是一个包含子对象的对象，该对象具有现在熟悉的'handle'模式：{}，用于我们要过滤的每个属性。

每个子对象都将包含一个句柄，该句柄是要过滤的产品（例如供应商）的值， ``title`` （该用户友好的键版本）以及将填充的值数组。

我们将从两个 ``vendor`` 和 ``tags`` 开始；但是，当我们处理产品时，会动态添加更多内容：

.. code-block:: js

    data() {
        return {
            topics: {
                vendor: {
                    title: 'Manufacturer',
                    handle: 'vendor',
                    values: {}
                },
                tags: {
                    title: 'Tags',
                    handle: 'tags',
                    values: {}
                }
            }
        }
    },

我们现在将开始循环遍历产品。随着值的变化，我们将跟踪有多少产品具有相同的值，使我们能够向用户显示多少产品。

在过滤器方法中循环遍历该类别的产品，并首先找到每个产品的 ``vendor`` 。 对于遇到的每一个，检查它是否存在于 ``values`` 数组中。

如果没有，则添加一个新的对象，其中包含 ``name`` ， ``handle`` 和 ``count`` ，这是一组产品句柄。 我们存储一系列句柄，以便我们可以验证产品是否已被看到。如果我们保持原始的数字计数，我们可能会遇到过滤器被触发两次的情况，使计数加倍。通过检查产品手柄是否已经存在，我们可以检查它只被看过一次。

如果过滤名称确实存在，则在检查该句柄不存在后将该句柄添加到该数组中：

.. code-block:: js

    filters() {
        if(this.categoriesExist) {
            let category = this.categoryProducts(this.slug),
                vendors = this.topics.vendor;
            for(let product of category.productDetails) {
                if(product.hasOwnProperty('vendor')) {
                    let vendor = product.vendor;
                    if(vendor.handle) {
                        if(!vendor.handle.count.includes(product.handle)) {
                            category.values[item.handle].count.push(product.handle);
                        }
                    } else {
                        vendors.values[vendor.handle] = {
                            ...vendor,
                            count: [product.handle]
                        }
                    }
                }
            }
        }
    }

这利用了以前使用的对象扩展省略号（...），这使我们不必写：

.. code-block:: js

    vendors.values[product.vendor.handle] = {
        title: vendor.title,
        handle: vendor.handle,
        count: [product.handle]
    }

尽管如果你对此更加适应，可以随意使用它。

复制代码以使 tags 工作，但由于 tags 本身就是一个数组，我们需要遍历每个标签并相应添加：

.. code-block:: js

    for(let product of category.productDetails) {
        if(product.hasOwnProperty('vendor')) {
            let vendor = product.vendor;
            if(vendor.handle) {
                if(!vendor.handle.count.includes(product.handle)) {
                    category.values[item.handle].count.push(product.handle);
                }
            } else {
                vendors.values[vendor.handle] = {
                    ...vendor,
                    count: [product.handle]
                }
            }
        }
        if(product.hasOwnProperty('tags')) {
            for(let tag of product.tags) {
                if(tag.handle) {
                    if(topicTags.values[tag.handle]) {
                        if(!topicTags.values[tag.handle].count.includes(product.handle)) {
                            topicTags.values[tag.handle].count.push(product.handle);
                        }
                    } else {
                        topicTags.values[tag.handle] = {
                            ...tag,
                            count: [product.handle]
                        }
                    }
                }
            }
        }
    }

我们的代码已经变得重复和复杂，我们通过创建一个处理重复代码的方法来简化它。

在methods对象中创建一个 ``addTopic`` 函数。 这将需要两个参数：要追加的对象和单数项。例如，它的用法是：

.. code-block:: js

    if(product.hasOwnProperty('vendor')) {
        this.addTopic(this.topics.vendor, product.vendor, product.handle);
    }

创建函数并从 ``if`` 语句 ``hasOwnProperty`` 中抽象出逻辑。命名两个参数 ``category`` 和 ``item`` ，并相应地更新代码：

.. code-block:: js

    methods: {
        addTopic(category, item, handle) {
            if(item.handle) {
                if(category.values[item.handle]) {
                    if(!category.values[item.handle].count.includes(handle)) {
                        category.values[item.handle].count.push(handle);
                    }
                } else {
                    category.values[item.handle] = {
                        ...item,
                        count: [handle]
                    }
                }
            }
        }
    }

更新 ``filters`` 计算的函数以使用新的 ``addTopic`` 方法。删除函数顶部的变量声明，因为它们被直接传递给方法：

.. code-block:: js

    filters() {
        if(this.categoriesExist) {
            let category = this.categoryProducts(this.slug);
            for(let product of category.productDetails) {
                if(product.hasOwnProperty('vendor')) {
                    this.addTopic(this.topics.vendor, product.vendor, product.handle);
                }
                if(product.hasOwnProperty('tags')) {
                    for(let tag of product.tags) {
                        this.addTopic(this.topics.tags, tag, product.handle);
                    }
                }
            }
        }
    }

P382

动态创建过滤器
==============


重置过滤器
==========


更新复选框过滤器上的URL更改
============================


在页面加载时预先选择过滤器
==========================

过滤产品
========


总结
====


