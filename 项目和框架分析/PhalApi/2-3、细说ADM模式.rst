*******
细说ADM模式
*******
前面我们已经学习了接口请求与接口响应，若把接口服务视为一个黑盒子，我们相当于已经了解这个黑盒子的输入与输出。但作为专业的软件开发工程师，我们还应洞悉这个黑盒子其中的构造、原理和细则。在全方位掌握整个接口服务流程的构建后，才能更清楚该如何编排代码的层级，同时通过关注点分离对每个层级的职责有个统一的共识，从而便于产生灵活、规范、高质量、容易维护的代码。

何为Api-Domain-Model模式？
=========================
在传统 Web 框架中，惯用 MVC 模式。可以说， MVC 模式是使用最为广泛的模式，但同时也可能是误解最多的模式。然而，接口服务这一领域，与传统的 Web 应用所面向的领域和需要解决的问题不同，最为明显的是接口服务领域中没有 View 视图。如果把 MVC 模式生搬硬套到接口服务领域，不但会产生更多对 MVC 模式的误解，还不利于实际接口服务项目的开发和交付。

仔细深入地再思考一番，接口服务除了需要处理输入和输出，以及从持久化的存储媒介中提取、保存、删除、更新数据外，还有一个相当重要且不容忽视的任务——处理特定领域的业务规则。而这些规则的处理几乎都是逻辑层面上对数据信息的加工、转换、处理等操作，以满足特定场景的业务需求。对于这些看不见，摸不着，听不到的领域规则处理，却具备着交付有价值的业务功能的使命，与此同时也是最为容易出现问题，产生线上故障，引发损失的危险区。所以，在接口服务过程中，我们应该把这些领域业务规则的处理，把这些受市场变化而频繁变动的热区，单独封装成一层，并配套完备的自动化测试体系，保证核心业务的稳定性。

基于以上考虑，在 ``MVC`` 模式的基础上，我们去掉了 ``View`` 视图层，添加了 ``Domain`` 领域业务层。从而涌现了 ``Api-Domain-Model`` 模式，简称 ``ADM`` 模式。

简单来说，

- ``Api层`` 称为接口服务层，负责对客户端的请求进行响应，处理接收客户端传递的参数，进行高层决策并对领域业务层进行调度，最后将处理结果返回给客户端。
- ``Domain层`` 称为领域业务层，负责对领域业务的规则处理，重点关注对数据的逻辑处理、转换和加工，封装并体现特定领域业务的规则。
- ``Model层`` 称为数据模型层，负责技术层面上对数据信息的提取、存储、更新和删除等操作，数据可来自内存，也可以来自持久化存储媒介，甚至可以是来自外部第三方系统。

下面再分别展开说明。

会讲故事的Api接口层
==================
在2015年大会上，我所敬仰的偶像Martin Fowler，通过下面这张Slice再次分享了何为微服务。

.. image:: ./images/ch-2-micro-service.jpg

图2-2 Martin Fowler对微服务的定义

这里提到的微服务概念，对应 ``PhalApi`` 框架中的接口服务，主要体现在 ``Api`` 接口服务层。微服务与接口服务有些微妙的区别，但不管何种说法，我们都应该关注微服务里所提及到的这几点重要特质：

- 小，且专注于做一件事情
- 独立的进程中
- 轻量级的通信机制
- 松耦合、独立部署

``Api`` 接口服务层，主要是负责响应客户端的请求，在抽象层面进行决策并对领域层进行调度，最后返回相应的结果。

接口服务的定义
-------------
在实际项目开发过程中，绝大部分我们编写的接口服务都是提供给别的开发工程师使用的，包括但不限于客户端开发人员，前端开发人员和其它后端系统开发人员。为了提高并行开发的速度，我们不能等到接口服务开发完成后才提供相应接口文档，而应尽早提供具体描述了接口服务定义的接口文档。

所以，使用接口服务的开发人员时常会问：什么时候可以提供接口文档？

我们提倡“接口先行”，即接口服务应该在使用方使用前就完成开发并通过自测，但往往在多任务、多项目并行的情况下很难百分百做到这一点，毕竟多变的需求促发多变的情境。此时，我们可以快速提供接口服务的定义。

接口服务的定义，是指声明接口服务的函数签名，并对接口服务的功能、接口参数和返回结果进行相应说明。在设计模式中，其中一个很重要的原则是：“针对接口编程，而不是针对实现编程”。我们在这里定义的接口服务，也正是很好体现了这一点。一开始通过关注客户端业务场景需要的视角，在规约层面定义好接口服务的功能，以及相关的签名、参数和返回结果，而不过多对实现的细节作深入地展开。

在 ``PhalApi`` 中定义一个接口服务，具体过程为：

1. 创建接口服务类并添加成员函数
2. 描述接口服务功能
3. 配置接口参数规则
4. 添加成员函数返回结果的注释

下面以在 ``Shop`` 商城项目中添加获取商品快照信息服务为例，进行讲解。

1. 创建接口服务类并添加成员函数

假设此获取商品快照信息服务名称为： ``Goods.Snapshot`` ，则先在 ``Shop`` 项目的 ``Api`` 层创建一个新的类文件并添加一个继承自 ``PhalApi_Api`` 的接口服务类 ``Api_Goods`` ，然后添加一个成员函数 ``Api_Goods::snapshot()`` 。

.. code-block:: php

	//$ vim ./Shop/Api/Goods.php
	<?php
	class Api_Goods extends PhalApi_Api {

	    public function snapshot() {
	    }
	}

2. 描述接口服务功能

接口服务的功能，可以在成员函数的标准文档注释中进行说明，并且可使用 ``@desc`` 注解进行详细说明。如下：

.. code-block:: php

 	/**
     * 获取商品快照信息
     * @desc 获取商品基本和常用的信息
     */
    public function snapshot() {
    }

3. 配置接口参数规则

参数规则的配置，则是前面所说的接口参数规则配置，需要在 ``Api_Goods::getRules()`` 成员函数中进行配置，假设这里只需要一个商品 ``ID`` 的参数。

.. code-block:: php

	public function getRules() {
        return array(
            'snapshot' => array(
                'id' => array('name' => 'id', 'require' => true, 'type' => 'int', 'min' => 1, 'desc' => '商品ID'),
            ),
        );
    }

4. 添加成员函数返回结果的注释

最后，需要对接口返回的结果结构及字段进行说明，这部分也是在成员函数的标准文档注释中进行说明，并遵循 ``@return`` 注解的格式。假设此快照服务返回的结构格式和字段如下：

.. code-block:: php

	/**
     * 获取商品快照信息
     * @return int      goods_id    商品ID
     * @return string   goods_name  商品名称
     * @return int      goods_price 商品价格
     * @return string   goods_image 商品图片
     */
    public function snapshot() {
    }

至此，我们便完成了获取商品快照信息服务的雏形，即完成了对此接口服务的定义。简单尝试请求一下：

.. code-block:: shell

	$ curl "http://api.phalapi.net/shop/?service=Goods.Snapshot&id=1"
	{"ret":200,"data":null,"msg":""}

可以看到上面定义的接口服务已经可以访问。因为还没具体实现，所以暂时没有业务数据返回。

那我们是要把这个接口服务链接提供给使用方吗？是，但不全面。我们最终要提供给使用方的是在线接口服务说明文档。请注意，在完成上面这4个步骤后，我们将会看到一份很酷、很实用、并且是自动实时生成的在线接口服务说明文档。

请在浏览器，打开以下链接并访问。

.. code-block:: shell

    http://api.phalapi.net/shop/checkApiParams.php?service=Goods.Snapshot

可以看到类似这样的截图效果。

.. image:: ./images/ch-2-goods-snapshot-docs.png

图2-3 接口服务Goods.Snapshot的在线说明文档

由前面创建的类和编写的代码、配置的规则以及文档注释，最终生成了这份接口文档。即使在未完成接口服务的开发情况下，通过此在线文档，使用方也能明确接口服务的功能，以及需要传递的参数和返回结果的说明，从而不影响他们的开发进度。

.. note:: 这里省略了公共参数中的签名参数和版本参数。关于在线文档的使用，后续会再进行详细说明。

在TDD下讲故事
------------
在完成了接口服务定义后，可以说，我们为讲述故事铺垫好了背景，部署好了场景上下文。接下来，我们推荐遵循测试驱动开发的理念，在意图导向编程的引导下继续完成故事的讲述。主要的方向是，为了验证业务场景的正确性，应该先编写不断引导我们前往正确目的地的单元测试，再开始编写具体的代码。

继续上面的获取商品快照信息接口服务，我们可以使用 ``PhalApi`` 提供的脚本命令快速生成测试骨架。其用法如下：

.. code-block:: shell

	$ cd ./Shop/Tests
	$ php ../../PhalApi/phalapi-buildtest ../Api/Goods.php Api_Goods ./test_env.php > ./Api/Goods_Test.php

上面主要是生成了 ``Goods.Snapshot`` 接口服务对应的测试骨架代码，并保存在文件 ``./Api/Goods_Test.php`` 里。然后，稍微修改完善生成的测试代码。

.. code-block:: php

	// $ vim ./Shop/Tests/Api/Goods_Test.php
	require_once dirname(__FILE__) . '/../test_env.php'; // 调整测试环境文件的加载

	... ...

	    public function testSnapshot()
	    {
	        // Step 1. 构建请求URL
	        $url = 'service=Goods.Snapshot';
	        $params = array(
	            'id' => 1,
	        );

	        // Step 2. 执行请求
	        $rs = PhalApi_Helper_TestRunner::go($url, $params);
	        //var_dump($rs);

	        //Step 3. 验证
	        $this->assertNotEmpty($rs);
	        $this->assertArrayHasKey('goods_id', $rs);
	        $this->assertArrayHasKey('goods_name', $rs);
	        $this->assertArrayHasKey('goods_price', $rs);
	        $this->assertArrayHasKey('goods_image', $rs);
	    }

上面的单元测试，根据构建-执行-验证模式，对商品 ``ID`` 为 ``1`` 的信息进行验证，主要是验证是否包含 ``goods_id`` 、 ``goods_name`` 、 ``goods_price`` 、 ``goods_image`` 这四个字段。

试执行一下此单元测试，明显是失败的。

到这里，我们讲述了一个失败的故事，因为这个故事讲不下去了。但我们知道错在哪里。要想让这个故事讲得通，我们可以先简单模拟一些数据，即先讲一个假故事。

修改 ``Goods.Snapshot`` 接口服务的源代码，返回以下模拟的商品数据。

.. code-block:: php

	// $ vim ./Shop/Api/Goods.php
    public function snapshot() {
        return array(
            'goods_id' => 1,
            'goods_name' => 'iPhone 7 Plus',
            'goods_price' => 6680,
            'goods_image' => '/images/iphone_7_plus.jpg',
        );
    }

此时，再运行单元测试，是可以通过的了。到这一步，虽然我们最终尚未实现接口服务的开发，但已经是非常 接近了。因为我们已经提供了在线接口说明文档给使用方，现在又可以有一份模拟的接口返回数据，虽然是假的。而这些文档和模拟数据，都已经可以帮忙客户端完成主流程的业务功能开发。

接下来，让我们再进一步，把这个故事讲得更真实，更动听，更丰满一点。

还记得我们 ``Api`` 层的职责吗？ ``Api`` 层主要负责请求响应、进行决策和高层的调度。下面是 ``Goods`` 接口层调整后的代码实现：

.. code-block:: php

	// $ vim ./Shop/Api/Goods.php
    public function snapshot() {
        $domain = new Domain_Goods();
        $info = $domain->snapshot($this->id);
        return $info;
    }

即根据客户端传递的商品 ``ID`` ，把具体的快照信息提取委托给领域业务层 ``Domain_Goods`` 进行，最后返回结果给客户端。

那么什么是领域业务层呢？

专注领域的Domain业务层
=====================
很多框架关心性能，而不关心人文；很多项目关心技术，而不关注业务。

就这造成了复杂的领域业务在项目中得不到很好地体现和描述，也没有统一的规则，更没有释意的接口。最终导致了在“纯面向对象”框架里面凌乱的代码编写，为后期的维护扩展、升级优化带来很大的阻碍。这就变成了，框架只关注性能，项目只关心技术，而项目却可怜地失去了演进的权利，慢慢地步履维艰，最终陷入牵一发而动全身的困境。

很多人都不知道该如何真正应对和处理领域的业务 ，尽管领域业务和单元测试都是如此重要并被广泛推崇。正如同表面上我们都知道单元测试却没有具体真实地接触过，并且一旦到真正需要编写一行单元测试的代码时就更迷惑了。

在一个项目架构里面，有三个主要模型：设计模型、领域模型和代码模型。设计模型在选择 ``PhalApi`` 时已大体确定，领域模式则需要项目干系人员消化、理解并表达出来。对于开发人员，代码模型则是他们表达的媒介。 所以 ``Domain`` 这一层，主要关注的是领域业务规则的处理。让我们暂且抛开外界客户端接口调用的签名验证、参数获取、安全性等问题，也不考虑数据从何而来、存放于何处，而是着重关注对领域业务数据的处理。

有趣的开发体验
-------------
曾经我在进行一个接口项目开发时，与 ``iOS`` 资深开发同学 ``@Aevit`` 有过一段有趣的编程体验。当时我们正在为 F 项目共同开发第三方联登的接口服务。由于 Aevit 是首次接触 PHP 开发，也是首次接触 PhalApi 开发，他在参考我编写的微信登录后，很快就交付了微博和QQ登录这两个接口服务。

但令我为之惊讶和兴奋的不是他的速度，而是他所编写的代码是如此的优雅美丽，犹如出自资深 ``PHP`` 开发人员之手。这让我再一次相信，使用在 ``TDD`` 下讲述故事的方式来开发接口服务，专注于领域业务规则，不仅能让代码更易于传送业务逻辑，也能为更多的同学乃至新手接受并更高效率地产出高质量的代码。

下面，我们将走进 ``Domain`` 领域业务层的内部，深入探索其中的奥秘，为讲真实、动听、丰满的故事做好准备。

表达规则
--------

释意接口
^^^^^^^^
领域的逻辑是对现实业务场景的再解释。现实的因素充满变数并且由人为指定，所以不能简单的在计算机中“推导”出领域逻辑。在项目开发过程中，要特别对这些领域逻辑理解透彻，以便后面接手的同学可以更容易理解和明白这些流程、限制和规则。其中一个有力的指导就是释意接口。

对接口签名甚至是对变量命名的仔细推敲都是很有益处的，因为名字能正名份，不至于混淆或者含糊不清。释意接口的作用和成效很大，它可以让后来维护项目的同学在端详一个接口时，无须深入内部实现即可明白它的用意和产生的影响。如一个 getter 系列的操作，我们可以推断出它是无副作用的。但如果当时的开发者不遵守约定，在里面作了一些“手脚”，则会导致产生“望文生义”的推断。

简单来说，释意接口会将“命令-查询”分离、会将多个操作分解成更小粒度的操作而保持同一层面的处理。根据《领域驱动设计》一书的说法：
“类型名、方法名和参数名一起构成了一个释意接口（Intention-Revealing Interface），以解释设计意图，避免开发人员需要考虑内部如何实现，或者猜测。”

在我曾经任职的一个游戏公司里面，我常根据接口的命名来推断它的作用，但往往会倍受伤害。因为以前的开发人员没有遵守这些约定，当时的 Team Leader 还责怪我不能太相信这些接口的命名。然而我想，如果连自己团队的其他成员都不能相信，我们还能相信谁呢？我们是否应该反思，是否应该考虑遵守约定编程所带来的好处？任何一个问题，都不是个人的问题，而是一个团队的问题。如果我们经常不断地发生一生项目的问题而要去指责某个人时，我们又为何不从一开始就遵守约定而去避免呢？

如下面在 F 项目中的家庭组成员领域业务类：

.. code-block:: php

	<?php
	class Domain_Group_Member {

	    public function joinGroup($userId, $groupId) {
	        //TODO
	    }

	    public function hasJoined($userId, $groupId) {
	        //TODO
	    }

	}

我们可以知道， ``Domain_Group_Member::joinGroup()`` 用于加入家庭组，会产生副作用，是一个命令操作； ``Domain_Group_Member::hasJoined()`` 则用于检测用户是否已加入家庭组，无副作用，则是一个查询操作。

业务规则的描述
^^^^^^^^^^^^^
“规则出现且仅出现一次。”

领域之所以复杂，在于规则众多。如果不能很好地把控这些规则，当规则发生变化时，就会出现很大的问题。在开发过程中，要注意对规则进行提炼并且放置在一个指定的位置。如对游戏玩家的经验计算等级时，这样一个规则就要统一好。不要到处都有类型相同的计算接口。当代码出现重复时，我们都知道会面临维护的高成本。而当规则多次出现时，我们更知道当规则发生变化时所带来的各种严重的问题，这也正是为什么总有一些这样那样的 BUG 的原因。系统出现问题，大多数上都是业务的问题。而业务的问题在于我们不能把规则收敛起来，汇集于一处。

在以往的开发中，我都很注意对业务规则统一提取、归纳，并在必要时进行重构。这使得我可以非常相信我所提供业务的稳定性，以及在给别人讲解时的信心。例如有一次，在一个大型的系统中，需要对某个页面跳转链接的生成规则进行调整。我跟另一位新来的同事说，这个需求只需修改一处时，他仍然很惊讶地问我：“怎么可能？！”因为他看到是这么多场景，如此多的页面，怕会有所遗漏。然而，事实证明，最终确实只需要改动一处就可以了。

类似这样的 ``URL`` 拼接规则，我们可以这样表示：

.. code-block:: php

	<?php
	class Domain_Page_Helper {

	    public static function createUrl($userId) {
	        return DI()->config->get('app.web.host') . '/u/' . $userId;
	    }
	}

规则出现且仅出现一次，可以说是一个知易行难的做法，因为我们总会有不经意间重复实现规则。有时会忽略已有的规则，有时会出于当前紧张的开发进度而暂且容忍，有时可能多了几步就懒得去统一。但把规则的实现统一起来再重复调用，而非重生实现，会让你在今后的项目开发中长期收益。没错，真的会长期收益。

而这些业务规则，都应该封装 ``Domain`` 领域业务层，并统一进行维护管理。

代码保持在同一高度
^^^^^^^^^^^^^^^^^
**领域层关注的是流程、规则** ，所以当你进行用户个性化分流和排序时，不应该把底层网络接口请求的细节也放到这里流程里面。把底层技术实现的细节和业务规则的处理分开是很有好处的，这样便于更清晰领域逻辑的表达，也助于单元测试时的测试桩模拟。

不可变值与无状态操作
-------------------

不可变值
^^^^^^^^
通常，我们在程序中处理的变量可以分为：值和实体。简单来说，值是一些基本的类型，如整数、布尔值、字符串；实体则是类对象，有自己内部的状态。当一个实体表示一个值的概念时（如坐标、金额、日期等），我们可以称之为值对象。明显地，系统的复杂性不在于对值的处理，而在于对一系列实体以及与其关联的另一系列实体间的处理。

如同其他语言一样，如果也在 PHP 遵循不可变值与无状态这两个用法，我们的接口系统乃至业务方都可以从中获益。

不可变值是指一个实体在创建后，其内部的状态是不可变更的，这样就能在系统内放心地流通使用，而无须担心有副作用。

举个简单的例子，在我们国际交易系统中有一个金额为100 RMB的对象，表示用户此次转账的金额。如果此对象是不可变值，那么我们在系统内，无论是计算手费、日志记录，还是转账事务或其他，我们都能信任此对象放心使用，不用担心哪里作了篡改而导致一个隐藏的致使BUG。

也就说，当你需要修改此类对象时，你需要复制一个再改之。有人会担心 ``new`` 所带来的内存消耗，但实际上， ``new`` 一个只有一些属性的对象消耗很少很少。

要明白为什么在修改前需要再创建新的对象，也是很容易理解的。首先，我们保持了和基本类型一致的处理方式；其次，我们保持了概念的一致性，如坐标 ``A(1, 2)`` 和坐标 ``B(1, 3)`` 是两个不同的坐标。当坐标 ``A`` 发生改变，坐标 ``A`` 就不再是原来的坐标 ``A`` ，而是一个新的坐标。从哲学角度上看，这是两个不同的概念。

在 ``PhalApi`` 中，我们可以看到不可变值在 ``Query`` 对象中的应用：

.. code-block:: php

	$query1 = new PhalApi_ModelQuery();
	$query1->id = 1;

	$query2 = new PhalApi_ModelQuery($query1->toArray());
	$query2->id = 2;

这样以后，我们就不再需要小心翼翼维护“漂洋过海”的值对象了，而是可以轻松地逐层传递，这有点像网络协议的逐层组装。

这又让我想起了《领域驱动设计》一书中较为中肯的说法：
把值对象看成是不可变的。不要给它任何标识，这样可以避免实体的维护工作，降低设计的复杂性。

无状态操作
^^^^^^^^^^
``PHP`` 的运行机制，不同于长时间运行的语言或系统， ``PHP`` 很少会在不同的 ``php-fpm`` 进程之间共享实体，最多也只是在同一次请求里共享。

这样，当我们在一次请求中需要处理两个或两个以上的用户实体时，可以怎么应对呢？
关于对实体的追踪和识别，可以使用 ``ORM`` 进行实体与关系数据库映射，但 ``PhalApi`` 弱化了这种映射，取而代之的是更明朗的处理方式，即：无状态操作。

因为 ``PhalApi`` 都是通过“空洞”的实体来获得数据，即实体无内部属性，对数据库的处理采用了 **表数据入口模式**  。当我们需要获取两个用户的信息时，可以这样：

.. code-block:: php

	$model = new Model_User();
	$user1 = $model->get(1);  //$user1是一个数组
	$user2 = $model->get(2);

	// 而不是
	$user1 = new Model_User(1);  //$user1是一个对象
	$user2 = new Model_User(2);

	// 或者可以这样批量获取
	$users = $model->multiGet(array(1, 2));  //$users是一个二维数组，下标是用户的ID

这样做，没有绝对的对错，可以根据你的项目应用场景作出调整。但我觉得无状态在 ``PhalApi`` 应用，可以更简单便捷地处理各种数据以及规则的统一，以实现操作的无状态。因为：

1. 可以按需取得不同的字段，多个获取时可以使用批量获取
2. 在单次请求处理中，简化对实体的追踪和维护
3. 换种方式来获得不可变值性的好处，因为既然没有内部状态，就没有改变了

引申到Domain层
--------------
``Domain`` 层作为 ``Api-Domain-Model`` 分层模式中的桥梁，主要负责处理业务规则。将值对象与无状态操作引申到 ``Domain`` 层，同样有处于简化我们对数据和业务规则的处理。

我们可以根据上述的家庭组成员领域类来完成类似下面功能场景的业务需求：

.. code-block:: php

	$domain = new Domain_Group_Member();

	if (!$domain->hasJoined(1, 100)) {
	    $domain->joinGroup(1, 100);
	}
	if (!$domain->hasJoined(2, 100)) {
	    $domain->joinGroup(2, 100);
	}
	if (!$domain->hasJoined(3, 100)) {
	    $domain->joinGroup(3, 100);
	}

即：如果用户1还没加入过组100，那么就允许他加入。用户2、用户3也以此类推。

当我们在领域业务层把业务规则划分为更细的维度时，就能更轻松上组装不同的业务功能，满足不同的业务场景，讲述不同的故事。

对于前面的示例，对于商品快照信息的获取，假设不能返回价格为0或负数的商品信息。则可以添加对价格有效性判断的业务规则处理：

.. code-block:: php

	// $ vim ./Shop/Domain/Goods.php
	<?php
	class Domain_Goods {

	    public function snapshot($goodsId) {
	        $model = new Model_Goods();
	        $info = $model->getSnapshot($goodsId);

	        if (empty($info) || $info['goods_price'] <= 0) {
	            return array();
	        }

	        return $info;
	    }
	}

休息一下，接下来，继续探讨 ``Model`` 数据层。

广义的Model数据层
=================
领域层固然重要，但如果没有数据源层，领域层就是一个空中楼阁。

这里的 ``Model`` 层，不限于传统框架的 ``Model`` 层，即不应将 ``Model`` 层与数据库习惯性地绑定在一起。数据的来源可以是广泛的，可能来自数据库，或者来自简单的文件，可能来自第三方平台接口，也可能存放于内存。所以， ``PhalApi`` 这里的 ``Model`` 层，则是广义上的数据源层，用于获取原始的业务数据，而不管来自何方，何种存储媒介。

我曾经在一家游戏公司任职时，就看到他们使用了文件来存放。相信，你也看到过。其次，在现在多客户端多系统的交互背景下，很多系统都需要进行数据共享和通信，为了提高服务器的性能也会使用到缓存。这些场景下，会导致数据是通过接口来获取，或者来源于缓存。可以看出，如果把数据源就看作是 MySql ，是非常局限的。

我们在 ``PhalApi`` 中继续使用了 ``Model`` 层，受 ``MVC`` 模式的影响，大家都对 ``Model`` 层非常熟悉，但可能会在潜意识中存在误解。再强调一次， ``PhalApi`` 为 ``Model`` 层赋予了新的诠释和活力，其数据来源不局限于数据库，可以是通过开放平台接口获取的数据，也可以是不落地直接存放于缓存的数据，还可以是存储在其他媒介的数据。

更富表现力的Model层
------------------
``Model`` 层主要是关注技术层面的实现细节，以及需要考虑系统性能和海量数据存储等。如果数据来源于数据库，我们则需要考虑到数据库服务器的感受，保证不会有过载的请求而导致它“罢工”。对此，我们可以结合缓存来进行性能优化。

如，一般地：

.. code-block:: php

	// 版本1：简单的获取
	$model = new Model_User();
	$rs = $model->getByUserId($userId);

这种是没有缓存的情况，当发现有性能问题并且需要通过添加缓存来解决时，可以这样调整：

.. code-block:: php

	// 版本2：使用缓存
	$key = 'userbaseinfo_' . $userId;
	$rs = DI()->cache->get($key);
	if ($rs === NULL) {
	    $rs = $model->getByUserId($userId);
	    DI()->cache->set($key, $rs, 600);
	}

但不建议在领域 ``Domain`` 层中引入缓存，因为会导致混淆 ``Domain`` 层的关注点，并且不便进行测试。更好是将技术层面的缓存机制处理移至 ``Model`` 层，保持数据获取的透明性：

.. code-block:: php

	<?php
	class Model_User extends PhalApi_Model_NotORM {

	    public function getByUserIdWithCache($userId) {
	        $key = 'userbaseinfo_' . $userId;
	        $rs = DI()->cache->get($key);
	        if ($rs === NULL) {
	            $rs = $this->getByUserId($userId);
	            DI()->cache->set($key, $rs, 600);
	        }
	        return $rs;
	    }

对应地，在 ``Domain`` 层的调用改为：

.. code-block:: php

	// 版本3：使用缓存 (缓存机制封装在Model层)
	$model = new Model_User();
	$rs = $model->getByUserIdWithCache($userId);

至此， ``Model`` 层对于上层如 ``Domain`` 来说，负责获取源数据，而不管此数据来自于数据库，还是远程接口，抑或是缓存包装下的数据。这正是我们使用数组在 ``Model`` 层和 ``Domain`` 层通讯的原因，因为数组更加通用，不需要额外添加实体。但如果项目有需要，也可以添加 ``DTO`` 这样的层级。

重量级数据获取的应对方案
----------------------
纵使更富表现力的 ``Model`` 很好地封装了源数据的获取，但是仍然会遇到一些尴尬的问题。特别地，当我们大量地进行缓存读取判断时，会出现很多重复的代码，这样既不雅观也难以管理，甚至会出现一些简单的人为编写错误而导致的BUG。另外，当我们需要进行预览、调试或测试时，我们是不希望看到缓存的，即希望能够手工指定是否需要缓存。

这里再稍微简单回顾总结一下现在所面临的问题：我们希望通过缓存策略来优化 ``Model`` 层的源数据获取，特别当源数据获取的成本非常大时。但我们又希望我们可以轻易控制何时需要缓存，何时不需要，并且希望原有的代码能在 OCP 的原则下不需要修改，但又能很好地传递源数据获取的复杂参数。归纳一下，则可分为三点：缓存的控制、源数据的获取、复杂参数的传递。

缓存的控制
^^^^^^^^^^
不管是单点缓存，还是多级缓存，都希望使用原有已经注册的 ``cache`` 组件服务。所以，应该使用委托。委托的另一个好处在于使用外部依赖注入可以获得更好的测试性。

源数据的获取
^^^^^^^^^^^
源数据的获取，作为源数据获取的主要过程和主要实现，需要进行缓存的控制（可细分为：是否允许读缓存、是否允许写缓存）、获取缓存的 ``key`` 值和有效时间，以及最终原始数据的获取。明显，这里应该使用模板方法，然后提供钩子函数给具体子类。

这里，我们提供了 ``Model`` 代理抽象类 ``PhalApi_ModelProxy`` 。之所以使用代理模式，是因为实际上并不一定会真正调用到最终源数据的获取，因为往往源数据的获取成本非常高，故而我们希望通过缓存来拦截数据的获取。

由于 ``Model`` 代理被上层的 ``Domain`` 领域层调用，但又依赖于下层 ``Model`` 层获得原始数据，所以处于 ``Domain`` 和 ``Model`` 之间。为了保持良好的项目代码层级，如果需要创建 ``PhalApi_ModelProxy`` 子类，建议新建一个 ``ModelProxy`` 目录。

如对用户基本信息的获取，我们添加了一个代理：

.. code-block:: php

	<?php
	class ModelProxy_UserBaseInfo extends PhalApi_ModelProxy {

	    protected function doGetData($query) {
	        $model = new Model_User();

	        return $model->getByUserId($query->id);
	    }

	    protected function getKey($query) {
	        return 'userbaseinfo_' . $query->id;
	    }

	    protected function getExpire($query) {
	        return 600;
	    }
	}

其中， ``doGetData($query)`` 方法由具体子类实现，委托给 ``Model_User`` 的实例进行源数据获取。另外，实现钩子函数以返回缓存唯一key，和缓存的有效时间。

这里只是作为简单的示例，更好的建议是应该将缓存的时间纳入配置中管理，如配置四个缓存级别：低(5 min)、中(10 min)、高(30 min)、超(1 h) ，然后根据不同的业务数据使用不同的缓存级别。这样，即便于团队交流，也便于缓存时间的统一调整。


复杂参数的传递
^^^^^^^^^^^^^
敏锐的读者会发现，上面有一个 ``$query`` 查询对象，这就是我们即将谈到的复杂参数的传递。

``$query`` 是查询对象 ``PhalApi_ModelQuery`` 的实例。我们强烈建议此类实例应当被作为值对象对待。虽然我们出于便利将此类对象设计成了结构化的使用。但你可以轻松通过 ``new PhalApi_ModelQuery($query->toArray());`` 来拷贝一个新的查询对象。

此查询对象，目前包括了四个成员变量：是否读缓存、是否写缓存、主键id、时间戳。很多时候，这四个基本的变量是满足不了各项目的实际需求的，因此你可以定义你的查询子类， 以支持丰富的数据获取。如调用优酷平台接口获取用户最近上传发布的视频时，需要用户昵称、获取的数量、排序种类等。

在完成了上面的工作后，让我们看下最终呈现的效果：

.. code-block:: php

	// 版本4：缓存 + 代理
	$query = new PhalApi_ModelQuery();
	$query->id = $userId;
	$modelProxy = new ModelProxy_UserBaseInfo();
	$rs = $modelProxy->getData($query);

在领域层中，我们切换到了 ``Model`` 代理获取数据，而不再是原来的 ``Model`` 直接获取。其中新增的是代理具体类 ``ModelProxy_UserBaseInfo`` ，和可选的查询类。

至此，我们很好地在源数据的获取基础上，统一结合缓存策略。你会发现： **缓存节点可变、具体的源数据可变、复杂的查询亦可变** 。

.. image:: ./images/ch-2-model-proxy-full.jpg

图2-4 代理模式下的UML静态结构

将此静态结构简化一下，可得到：

.. image:: ./images/ch-2-model-proxy-lite.jpg

图2-5 简化后代理模式下的UML静态结构

这样的设计是合理的，因为缓存节点我们希望能在项目内共享，而不管是哪块的业务数据；对于具体的源数据获取明显也是不尽相同，所以也需要各自实现，同时对于同一类业务数据（如用户基本信息）则使用一样的缓存有效时间和指定格式的缓存key（通常结合不同的id组成唯一key）；最后在前面的缓存共享和同类数据的基础上，还需要支持不同数据的具体获取，因此需要查询对象。也就是说，你可以在不同的层级不同的范畴内进行自由的控制和定制。

如果退回到最初的版本，我们可以对比发现， ``Model_Proxy`` 就是 ``Domain`` 和 ``Model`` 间的桥梁，即：中间层。因为每次直接通过 ``Model`` 获取源数据的成本较大，我们可以通过 ``Model_Proxy`` 模型代理来缓存获取的数据来减轻服务器的压力。

细粒度和可测试性
---------------
细粒度的划分，对于支撑复杂的领域业务有着非常重要的作用。一来是更清楚明了的层次结构划分，二来是可测试性。

正如前面提及到的，我们在预览、调试、单元测试或者后台计划任务时，不希望有缓存的干扰。在细粒度划分的基础上，可轻松用以下方法实现而不必担心会破坏代码的简洁性。

取消缓存的方法1：外部注入模拟缓存
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
在构造 ``Model`` 代理时，默认情况下使用了 ``DI()->cache`` 作为缓存，当需要进行单元测试时，我们可以两种途径在外部注入模拟的缓存而达到测试的目的：替换全局的 ``DI()->cache`` ，或单次构造注入。对于计划任务则可以在统一的后台任务启动文件将 ``DI()->cache`` 设置成空对象。

取消缓存的方法2：查询中的缓存控制
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
在项目层次，我们可以统一构造自己的查询基类，以实现对缓存的控制。

如：

.. code-block:: php

	<?php
	class Common_ModelQuery extends PhalApi_ModelQuery {

	    public function __construct($queryArr = array()) {
	        parent::__construct($queryArr);

	        if (DI()->debug) {
	            $this->readCache = FALSE;
	            $this->writeCache = FALSE;
	        }
	    }
	}

这样便可以获得了接口预览和调试的能力。

最后，让我们继续来完成前面的商品快照信息获取的实现。为简单起见，假设我们的商品数据不存在数据库，而是固定编码在代码中，并其数据和实现如下：

.. code-block:: php

	//$ vim ./Shop/Model/Goods.php
	<?php
	class Model_Goods {

	    public function getSnapshot($goodsId) {
	        $allGoods = array(
	            1 => array(
	                'goods_id' => 1,
	                'goods_name' => 'iPhone 7 Plus',
	                'goods_price' => 6680,
	                'goods_image' => '/images/iphone_7_plus.jpg',
	            ),
	            2 => array(
	                'goods_id' => 2,
	                'goods_name' => 'iPhone 6 Plus',
	                'goods_price' => 4588,
	                'goods_image' => '/images/iphone_6_plus.jpg',
	            ),
	        );

	        return isset($allGoods[$goodsId]) ? $allGoods[$goodsId] : array();
	    }
	}

这里硬编码了两个商品： ``iPhone 7 Plus`` 和 ``iPhone 6 Plus`` 。然后执行一下最初的单元测试，发现已经可以通过测试了。

.. code-block:: shell

	$ phpunit ./Api/Goods_Test.php
	... ...
	OK (2 tests, 5 assertions)

ADM职责划分与调用关系
====================
传统的接口开发，由于没有很好的分层结构，而且热衷于在一个文件里面完成绝大部分事情，最终导致了臃肿漫长的代码，也就是通常所说的意大利面条式的代码。

在 ``PhalApi`` 中，我们针对接口领域开发，提供了新的分层思想： ``Api-Domain-Model`` 模式。即便这样，如果项目在实际开发中，仍然使用原来的做法，纵使再好的接口开发框架，也还是会退化到原来的局面。

为了能让大家更为明确 ``Api`` 接口层的职责所在，我们建议：

``Api`` 接口服务层应该做：

应该：对用户登录态进行必要的检测
应该：控制业务场景的主流程，创建领域业务实例，并进行调用
应该：进行必要的日记纪录
应该：返回接口结果
应该：调度领域业务层

``Api`` 接口服务层不应该做：

不应该：进行业务规则的处理或者计算
不应该：关心数据是否使用缓存，或进行缓存相关的直接操作
不应该：直接操作数据库
不应该：将多个接口合并在一起

``Domain`` 领域业务层应该做：

应该：体现特定领域的业务规则
应该：对数据进行逻辑上的处理
应该：调度数据模型层或其他领域业务层

``Domain`` 领域业务层不应该做：

不应该：直接实现数据的操作，如添加并实现缓存机制

``Model`` 数据模型层应该：

应该：进行数据库的操作
应该：实现缓存机制

在明确了上面应该做的和不应该做的，并且也完成了接口的定义，还有验收测序驱动开发的场景准备后，相信这时，即使是新手也可以编写出高质量的接口代码。因为他会受到约束，他知道他需要做什么，主要他按照限定的开发流程和约定稍加努力即可。

如果真的这样，相信我们也就慢慢能体会到精益开发的乐趣。

至于调用关系，整体上讲，应根据从 ``Api`` 接口层、 ``Domain`` 领域层再到 ``Model`` 数据源层的顺序进行开发。

在开发过程中，需要注意不能越层调用也不能逆向调用，即不能 ``Api`` 调用 ``Model`` 。而应该是上层调用下层，或者同层级调用，也就是说，我们应该：

- ``Api`` 层调用 ``Domain`` 层
- ``Domain`` 层调用 ``Domain`` 层
- ``Domain`` 层调用 ``Model`` 层
- ``Model`` 层调用 ``Model`` 层

如果用一张图来表示，则是：

.. image:: ./images/ch-2-api-domain-model-call.png

图2-6 ADM调用关系

为了更明确调用的关系，以下调用是错误的：

- 错误的做法1： ``Api`` 层直接调用 ``Model`` 层
- 错误的做法2:  ``Domain`` 层调用 ``Api`` 层，也不应用将 ``Api`` 层对象传递给 ``Domain`` 层
- 错误的做法3:  ``Model`` 层调用 ``Domain`` 层

这样的约定，便于我们形成统一的开发规范，降低学习维护成本。比如需要添加缓存，我们知道应该定位到 ``Model`` 层数据源进行扩展；若发现业务规则处理不当，则应该进入 ``Domain`` 层探其究竟；如果需要对接口的参数进行调整，即使是新手也知道应该找到对应的 ``Api`` 文件进行改动。

扩展你的项目
===========
假设，我们的 ``Shop`` 商城项目中，有三种缓存机制，分别是：

- 实时数据，无缓存
- 轻量级缓存，只使用本地服务器缓存，特点是快但不可共享
- 重量级缓存，同时使用本地和集群服务器的高效缓存，特点是可共享但有网络 ``I/O`` 消耗

则可以创建三个对应的模型代理目录，如下：

.. code-block:: shell

	$ tree ./Shop/ModelProxy/
	./Shop/ModelProxy/
	├── Heavy      # 重量级缓存
	├── Light      # 轻量级缓存
	└── Realtime   # 实时数据

并且，假设我们有四份这样的数据：

- 来自数据库的商品信息
- 来自第三方接口系统的推荐商品
- 来自配置文件的全局站点配置

经过分析数据的稳定性和来源，可以得到以下这样的缓存策略分配。

表2-10 业务数据的缓存策略示例

+----------+------------+------------------------------------------------+
| 业务数据 | 缓存策略   | 考虑点                                         |
+==========+============+================================================+
| 商品信息 | 重量级缓存 | 商品信息可共享缓存，并且访问量大，需避免DB穿透 |
+----------+------------+------------------------------------------------+
| 推荐商品 | 实时数据   | 每个用户所看到的推荐商品不一样，需要千人千面   |
+----------+------------+------------------------------------------------+
| 站点配置 | 轻量级缓存 | 适合使用单机缓存，且允许回源到文件             |
+----------+------------+------------------------------------------------+

当缓存失效时，容易出现高并发的查询DB，导致DB压力骤然上升，这种现象我们称之为缓存穿透。

https://blog.csdn.net/a417930422/article/details/18222973

在 ``Model`` 层的目录里，默认情况下，数据来源于数据库。如果有其他来源的数据，可在 ``Model`` 目录里面添加子目录，以示区分。如添加以下目录：

.. code-block:: shell

	$ tree ./Shop/Model/
	./Shop/Model/
	├── Connector # 连接器，与外部接口进行通信
	├── File      # 文件数据

然后，在 ``Model`` 相应的子目录里实现对应业务数据的原始操作。假设最终的实现文件列表如下：

.. code-block:: shell

	./Shop/Model/Connector/Recommend.php # 推荐商品
	./Shop/Model/File/SiteConfig.php     # 站点配置
	./Shop/Model/Goods.php               # 商品信息

接着，在 ``ModelProxy`` 层，各自添加相应的缓存策略，如下：

.. code-block:: shell

	./Shop/ModelProxy/Heavy/Goods.php        # 重量级的商品信息
	./Shop/ModelProxy/Light/SiteConfig.php   # 轻量级的站点配置
	./Shop/ModelProxy/Realtime/Recommend.php # 实时的推荐商品

至此，我们便得到了一个清晰的数据划分。对于每个业务数据，我们都能一种更细粒度上的管理和分布视角。同时对于何种业务数据使用何种缓存策略也一目了解。当然，这里只是作为一个示例，实际项目中，还应实现完善各种缓存策略的基类，以及添加类似下面这样的查询类。

.. code-block:: shell

	./Shop/ModelProxy/Query/Goods.php      # 商品信息查询参数类
	./Shop/ModelProxy/Query/Recommond.php  # 推荐商品查询参数类
	./Shop/ModelProxy/Query/SiteConfig.php # 站点配置查询参数类

虽然这种方案，可以提供更清晰、更可视化的数据管理，但与此同时也引入了一定的复杂性，建议在大型项目中优先考虑采用，在小型项目中可以先快速迭代再逐渐演进考虑。

