*******
非阻塞式服务器
*******

即使你知道 Java NIO 非阻塞的工作特性（如 ``Selector`` ， ``Channel`` ， ``Buffer`` 等组件），但是想要设计一个非阻塞的服务器仍然是一件很困难的事。非阻塞式服务器相较于阻塞式来说要多上许多挑战。本文将会讨论非阻塞式服务器的主要几个难题，并针对这些难题给出一些可能的解决方案。

查找关于非阻塞式服务器设计方面的资料实在不太容易，所以本文提供的解决方案都是基于本人工作和想法上的。如果各位有其他的替代方案或者更好的想法，我会很乐意听取这些方案和想法！你可以在文章下方留下你的评论，或者发邮件给我（邮箱为：info@jenkov.com ）。

本文的设计思路想法都是基于 Java NIO 的。但是我相信如果某些语言中也有像 ``Selector`` 之类的组件的话，文中的想法也能用于该语言。据我所知，类似的组件底层操作系统会提供，所以对你来说也可以根据其中的思想运用在其他语言上。

非阻塞式服务器– GitHub 仓库
==========================
我已经创建了一些简单的这些思想的概念验证呈现在这篇教程中，并且为了让你可以看到，我把源码放到了 ``github`` 资源库上了。这里是 ``GitHub`` 资源库地址:

https://github.com/jjenkov/java-nio-server

非阻塞式IO管道(Pipelines)
=========================
一个非阻塞式 IO 管道是由各个处理非阻塞式 IO 组件组成的链。其中包括读/写 IO 。下图就是一个简单的非阻塞式 IO 管道组成：

.. image:: ../images/non-blocking-server-1.png

一个组件使用 ``Selector`` 监控 ``Channel`` 什么时候有可读数据。然后这个组件读取输入并且根据输入生成相应的输出。最后输出将会再次写入到一个 ``Channel`` 中。

一个非阻塞式 ``IO`` 管道不需要将读数据和写数据都包含，有一些管道可能只会读数据，另一些可能只会写数据。

上图仅显示了一个单一的组件。一个非阻塞式 ``IO`` 管道可能拥有超过一个以上的组件去处理输入数据。一个非阻塞式管道的长度是由他的所要完成的任务决定。

一个非阻塞 ``IO`` 管道可能同时读取多个 ``Channel`` 里的数据。举个例子：从多个 ``SocketChannel`` 管道读取数据。

其实上图的控制流程还是太简单了。这里是组件从 ``Selector`` 开始从 ``Channel`` 中读取数据，而不是 ``Channel`` 将数据推送给 ``Selector`` 进入组件中，即便上图画的就是这样。

非阻塞式vs. 阻塞式管道
=====================
非阻塞和阻塞 ``IO`` 管道两者之间最大的区别在于他们如何从底层 ``Channel`` ( ``Socket`` 或者 ``file`` )读取数据。

``IO`` 管道通常从流中读取数据（来自 ``socket`` 或者 ``file`` ）并且将这些数据拆分为一系列连贯的消息。这和使用 ``tokenizer`` （这里估计是解析器之类的意思）将数据流解析为 ``token`` （这里应该是数据包的意思）类似。相反你只是将数据流分解为更大的消息体。我将拆分数据流成消息这一组件称为“消息读取器”（Message Reader）下面是 Message Reader 拆分流为消息的示意图：

.. image:: ../images/non-blocking-server-2.png





基础非阻塞式IO管道设计
====================
http://ifeve.com/non-blocking-server/


服务器线程模型
=============
GitHub 资源库里面的非阻塞式服务器实现使用了两个线程的线程模式。第一个线程用来接收来自 ``ServerSocketChannel`` 的传入连接。第二个线程处理接受的连接，意思是读取消息，处理消息并将响应写回连接。这两个线程模型的图解如下：

.. image:: ../images/non-blocking-server-10.png

上一节中说到的服务器循环处理是由处理线程（Processor Thread）执行。









