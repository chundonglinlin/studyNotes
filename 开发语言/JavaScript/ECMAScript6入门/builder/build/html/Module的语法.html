

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>23. Module 的语法 &mdash; ECMAScript6入门 1.0 文档</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="索引"
              href="genindex.html"/>
        <link rel="search" title="搜索" href="search.html"/>
    <link rel="top" title="ECMAScript6入门 1.0 文档" href="index.html"/>
        <link rel="next" title="24. Module 的加载实现" href="Module的加载实现.html"/>
        <link rel="prev" title="22. 修饰器" href="Decorator.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> ECMAScript6入门
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="前言.html">1. 前言</a></li>
<li class="toctree-l1"><a class="reference internal" href="ECMAScript6简介.html">2. ECMAScript6简介</a></li>
<li class="toctree-l1"><a class="reference internal" href="let和const命令.html">3. let 和 const 命令</a></li>
<li class="toctree-l1"><a class="reference internal" href="变量的解构赋值.html">4. 变量的解构赋值</a></li>
<li class="toctree-l1"><a class="reference internal" href="字符串的扩展.html">5. 字符串的扩展</a></li>
<li class="toctree-l1"><a class="reference internal" href="正则的扩展.html">6. 正则的扩展</a></li>
<li class="toctree-l1"><a class="reference internal" href="数值的扩展.html">7. 数值的扩展</a></li>
<li class="toctree-l1"><a class="reference internal" href="函数的扩展.html">8. 函数的扩展</a></li>
<li class="toctree-l1"><a class="reference internal" href="数组的扩展.html">9. 数组的扩展</a></li>
<li class="toctree-l1"><a class="reference internal" href="对象的扩展.html">10. 对象的扩展</a></li>
<li class="toctree-l1"><a class="reference internal" href="Symbol.html">11. Symbol</a></li>
<li class="toctree-l1"><a class="reference internal" href="Set和Map数据结构.html">12. Set和Map数据结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="Proxy.html">13. Proxy</a></li>
<li class="toctree-l1"><a class="reference internal" href="Reflect.html">14. Reflect</a></li>
<li class="toctree-l1"><a class="reference internal" href="Promise对象.html">15. Promise对象</a></li>
<li class="toctree-l1"><a class="reference internal" href="Iterator和for...of循环.html">16. Iterator 和 for…of 循环</a></li>
<li class="toctree-l1"><a class="reference internal" href="Generator函数的语法.html">17. Generator函数的语法</a></li>
<li class="toctree-l1"><a class="reference internal" href="Generator函数的异步应用.html">18. Generator 函数的异步应用</a></li>
<li class="toctree-l1"><a class="reference internal" href="async函数.html">19. asyn函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="Class的基本语法.html">20. Class 的基本语法</a></li>
<li class="toctree-l1"><a class="reference internal" href="Class的继承.html">21. Class的继承</a></li>
<li class="toctree-l1"><a class="reference internal" href="Decorator.html">22. 修饰器</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">23. Module 的语法</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1">23.1. 概述</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id2">23.2. 严格模式</a></li>
<li class="toctree-l2"><a class="reference internal" href="#export">23.3. export 命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#import">23.4. import 命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">23.5. 模块的整体加载</a></li>
<li class="toctree-l2"><a class="reference internal" href="#export-default">23.6. export default 命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#export-import">23.7. export 与 import 的复合写法</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id5">23.8. 模块的继承</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id6">23.9. 跨模块常量</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id7">23.10. import()</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id8">23.10.1. 简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id10">23.10.2. 适用场合</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id11">23.10.3. 注意点</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Module的加载实现.html">24. Module 的加载实现</a></li>
<li class="toctree-l1"><a class="reference internal" href="编程风格.html">25. 编程风格</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">ECMAScript6入门</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>23. Module 的语法</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module">
<h1>23. Module 的语法<a class="headerlink" href="#module" title="永久链接至标题">¶</a></h1>
<div class="section" id="id1">
<h2>23.1. 概述<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>历史上，JavaScript 一直没有模块（ <code class="docutils literal"><span class="pre">module</span></code> ）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 <code class="docutils literal"><span class="pre">Ruby</span></code> 的 <code class="docutils literal"><span class="pre">require</span></code> 、 <code class="docutils literal"><span class="pre">Python</span></code> 的 <code class="docutils literal"><span class="pre">import</span></code> ，甚至就连 <code class="docutils literal"><span class="pre">CSS</span></code> 都有 <code class="docutils literal"><span class="pre">&#64;import</span></code> ，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p>
<p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 <code class="docutils literal"><span class="pre">CommonJS</span></code> 和 <code class="docutils literal"><span class="pre">AMD</span></code> 两种。前者用于服务器，后者用于浏览器。 ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 <code class="docutils literal"><span class="pre">CommonJS</span></code> 和 <code class="docutils literal"><span class="pre">AMD</span></code> 规范，成为浏览器和服务器通用的模块解决方案。</p>
<p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。 <code class="docutils literal"><span class="pre">CommonJS</span></code> 和 <code class="docutils literal"><span class="pre">AMD</span></code> 模块，都只能在运行时确定这些东西。比如， <code class="docutils literal"><span class="pre">CommonJS</span></code> 模块就是对象，输入时必须查找对象属性。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// CommonJS模块</span>
<span class="kd">let</span> <span class="p">{</span> <span class="nx">stat</span><span class="p">,</span> <span class="nx">exists</span><span class="p">,</span> <span class="nx">readFile</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;fs&#39;</span><span class="p">);</span>

<span class="c1">// 等同于</span>
<span class="kd">let</span> <span class="nx">_fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;fs&#39;</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">stat</span> <span class="o">=</span> <span class="nx">_fs</span><span class="p">.</span><span class="nx">stat</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">exists</span> <span class="o">=</span> <span class="nx">_fs</span><span class="p">.</span><span class="nx">exists</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">readfile</span> <span class="o">=</span> <span class="nx">_fs</span><span class="p">.</span><span class="nx">readfile</span><span class="p">;</span>
</pre></div>
</div>
<p>上面代码的实质是整体加载 <code class="docutils literal"><span class="pre">fs</span></code> 模块（即加载 <code class="docutils literal"><span class="pre">fs</span></code> 的所有方法），生成一个对象（ <code class="docutils literal"><span class="pre">_fs</span></code> ），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。</p>
<p>ES6 模块不是对象，而是通过 <code class="docutils literal"><span class="pre">export</span></code> 命令显式指定输出的代码，再通过 <code class="docutils literal"><span class="pre">import</span></code> 命令输入。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// ES6模块</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">stat</span><span class="p">,</span> <span class="nx">exists</span><span class="p">,</span> <span class="nx">readFile</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;fs&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>上面代码的实质是从 <code class="docutils literal"><span class="pre">fs</span></code> 模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 <code class="docutils literal"><span class="pre">CommonJS</span></code> 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。</p>
<p>由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（ <code class="docutils literal"><span class="pre">macro</span></code> ）和类型检验（ <code class="docutils literal"><span class="pre">type</span> <span class="pre">system</span></code> ）这些只能靠静态分析实现的功能。</p>
<p>除了静态加载带来的各种好处，ES6 模块还有以下好处。</p>
<ul class="simple">
<li>不再需要 <code class="docutils literal"><span class="pre">UMD</span></code> 模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。</li>
<li>将来浏览器的新 <code class="docutils literal"><span class="pre">API</span></code> 就能用模块格式提供，不再必须做成全局变量或者 <code class="docutils literal"><span class="pre">navigator</span></code> 对象的属性。</li>
<li>不再需要对象作为命名空间（比如 <code class="docutils literal"><span class="pre">Math</span></code> 对象），未来这些功能可以通过模块提供。</li>
</ul>
<p>本章介绍 ES6 模块的语法，下一章介绍如何在浏览器和 <code class="docutils literal"><span class="pre">Node</span></code> 之中，加载 ES6 模块。</p>
</div>
<div class="section" id="id2">
<h2>23.2. 严格模式<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>ES6 的模块自动采用严格模式，不管你有没有在模块头部加上 <code class="docutils literal"><span class="pre">&quot;use</span> <span class="pre">strict&quot;;</span></code> 。</p>
<p>严格模式主要有以下限制。</p>
<ul class="simple">
<li>变量必须声明后再使用；</li>
<li>函数的参数不能有同名属性，否则报错；</li>
<li>不能使用 <code class="docutils literal"><span class="pre">with</span></code> 语句；</li>
<li>不能对只读属性赋值，否则报错；</li>
<li>不能使用前缀 0 表示八进制数，否则报错；</li>
<li>不能删除不可删除的属性，否则报错；</li>
<li>不能删除变量 <code class="docutils literal"><span class="pre">delete</span> <span class="pre">prop</span></code> ，会报错，只能删除属性 <code class="docutils literal"><span class="pre">delete</span> <span class="pre">global[prop]</span></code> ；</li>
<li><code class="docutils literal"><span class="pre">eval</span></code> 不会在它的外层作用域引入变量；</li>
<li><code class="docutils literal"><span class="pre">eval</span></code> 和 <code class="docutils literal"><span class="pre">arguments</span></code> 不能被重新赋值；</li>
<li><code class="docutils literal"><span class="pre">arguments</span></code> 不会自动反映函数参数的变化；</li>
<li>不能使用 <code class="docutils literal"><span class="pre">arguments.callee</span></code> ；</li>
<li>不能使用 <code class="docutils literal"><span class="pre">arguments.caller</span></code> ；</li>
<li>禁止 <code class="docutils literal"><span class="pre">this</span></code> 指向全局对象；</li>
<li>不能使用 <code class="docutils literal"><span class="pre">fn.caller</span></code> 和 <code class="docutils literal"><span class="pre">fn.arguments</span></code> 获取函数调用的堆栈；</li>
<li>增加了保留字（比如 <code class="docutils literal"><span class="pre">protected</span></code> 、 <code class="docutils literal"><span class="pre">static</span></code> 和 <code class="docutils literal"><span class="pre">interface</span></code> ）；</li>
</ul>
<p>上面这些限制，模块都必须遵守。由于严格模式是 ES5 引入的，不属于 ES6，所以请参阅相关 ES5 书籍，本书不再详细介绍了。</p>
<p>其中，尤其需要注意 <code class="docutils literal"><span class="pre">this</span></code> 的限制。 ES6 模块之中，顶层的 <code class="docutils literal"><span class="pre">this</span></code> 指向 <code class="docutils literal"><span class="pre">undefined</span></code> ，即不应该在顶层代码使用 <code class="docutils literal"><span class="pre">this</span></code> 。</p>
</div>
<div class="section" id="export">
<h2>23.3. export 命令<a class="headerlink" href="#export" title="永久链接至标题">¶</a></h2>
<p>模块功能主要由两个命令构成： <code class="docutils literal"><span class="pre">export</span></code> 和 <code class="docutils literal"><span class="pre">import</span></code> 。 <code class="docutils literal"><span class="pre">export</span></code> 命令用于规定模块的对外接口， <code class="docutils literal"><span class="pre">import</span></code> 命令用于输入其他模块提供的功能。</p>
<p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用 <code class="docutils literal"><span class="pre">export</span></code> 关键字输出该变量。下面是一个 <code class="docutils literal"><span class="pre">JS</span></code> 文件，里面使用 <code class="docutils literal"><span class="pre">export</span></code> 命令输出变量。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// profile.js</span>
<span class="kr">export</span> <span class="kd">var</span> <span class="nx">firstName</span> <span class="o">=</span> <span class="s1">&#39;Michael&#39;</span><span class="p">;</span>
<span class="kr">export</span> <span class="kd">var</span> <span class="nx">lastName</span> <span class="o">=</span> <span class="s1">&#39;Jackson&#39;</span><span class="p">;</span>
<span class="kr">export</span> <span class="kd">var</span> <span class="nx">year</span> <span class="o">=</span> <span class="mi">1958</span><span class="p">;</span>
</pre></div>
</div>
<p>上面代码是 <code class="docutils literal"><span class="pre">profile.js</span></code> 文件，保存了用户信息。 ES6 将其视为一个模块，里面用 <code class="docutils literal"><span class="pre">export</span></code> 命令对外部输出了三个变量。</p>
<p><code class="docutils literal"><span class="pre">export</span></code> 的写法，除了像上面这样，还有另外一种。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// profile.js</span>
<span class="kd">var</span> <span class="nx">firstName</span> <span class="o">=</span> <span class="s1">&#39;Michael&#39;</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">lastName</span> <span class="o">=</span> <span class="s1">&#39;Jackson&#39;</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">year</span> <span class="o">=</span> <span class="mi">1958</span><span class="p">;</span>

<span class="kr">export</span> <span class="p">{</span><span class="nx">firstName</span><span class="p">,</span> <span class="nx">lastName</span><span class="p">,</span> <span class="nx">year</span><span class="p">};</span>
</pre></div>
</div>
<p>上面代码在 <code class="docutils literal"><span class="pre">export</span></code> 命令后面，使用大括号指定所要输出的一组变量。它与前一种写法（直接放置在 <code class="docutils literal"><span class="pre">var</span></code> 语句前）是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。</p>
<p><code class="docutils literal"><span class="pre">export</span></code> 命令除了输出变量，还可以输出函数或类（ <code class="docutils literal"><span class="pre">class</span></code> ）。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">export</span> <span class="kd">function</span> <span class="nx">multiply</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>上面代码对外输出一个函数 <code class="docutils literal"><span class="pre">multiply</span></code> 。</p>
<p>通常情况下， <code class="docutils literal"><span class="pre">export</span></code> 输出的变量就是本来的名字，但是可以使用 <code class="docutils literal"><span class="pre">as</span></code> 关键字重命名。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">v1</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="kd">function</span> <span class="nx">v2</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>

<span class="kr">export</span> <span class="p">{</span>
  <span class="nx">v1</span> <span class="nx">as</span> <span class="nx">streamV1</span><span class="p">,</span>
  <span class="nx">v2</span> <span class="nx">as</span> <span class="nx">streamV2</span><span class="p">,</span>
  <span class="nx">v2</span> <span class="nx">as</span> <span class="nx">streamLatestVersion</span>
<span class="p">};</span>
</pre></div>
</div>
<p>上面代码使用 <code class="docutils literal"><span class="pre">as</span></code> 关键字，重命名了函数 <code class="docutils literal"><span class="pre">v1</span></code> 和 <code class="docutils literal"><span class="pre">v2</span></code> 的对外接口。重命名后， <code class="docutils literal"><span class="pre">v2</span></code> 可以用不同的名字输出两次。</p>
<p>需要特别注意的是， <code class="docutils literal"><span class="pre">export</span></code> 命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// 报错</span>
<span class="kr">export</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">// 报错</span>
<span class="kd">var</span> <span class="nx">m</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kr">export</span> <span class="nx">m</span><span class="p">;</span>
</pre></div>
</div>
<p>上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出 1，第二种写法通过变量 <code class="docutils literal"><span class="pre">m</span></code> ，还是直接输出 1 。 1 只是一个值，不是接口。正确的写法是下面这样。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// 写法一</span>
<span class="kr">export</span> <span class="kd">var</span> <span class="nx">m</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">// 写法二</span>
<span class="kd">var</span> <span class="nx">m</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kr">export</span> <span class="p">{</span><span class="nx">m</span><span class="p">};</span>

<span class="c1">// 写法三</span>
<span class="kd">var</span> <span class="nx">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kr">export</span> <span class="p">{</span><span class="nx">n</span> <span class="nx">as</span> <span class="nx">m</span><span class="p">};</span>
</pre></div>
</div>
<p>上面三种写法都是正确的，规定了对外的接口 <code class="docutils literal"><span class="pre">m</span></code> 。其他脚本可以通过这个接口，取到值 1 。它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系。</p>
<p>同样的， <code class="docutils literal"><span class="pre">function</span></code> 和 <code class="docutils literal"><span class="pre">class</span></code> 的输出，也必须遵守这样的写法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// 报错</span>
<span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{}</span>
<span class="kr">export</span> <span class="nx">f</span><span class="p">;</span>

<span class="c1">// 正确</span>
<span class="kr">export</span> <span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{};</span>

<span class="c1">// 正确</span>
<span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{}</span>
<span class="kr">export</span> <span class="p">{</span><span class="nx">f</span><span class="p">};</span>
</pre></div>
</div>
<p>另外， <code class="docutils literal"><span class="pre">export</span></code> 语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">export</span> <span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="s1">&#39;bar&#39;</span><span class="p">;</span>
<span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">foo</span> <span class="o">=</span> <span class="s1">&#39;baz&#39;</span><span class="p">,</span> <span class="mi">500</span><span class="p">);</span>
</pre></div>
</div>
<p>上面代码输出变量 <code class="docutils literal"><span class="pre">foo</span></code> ，值为 <code class="docutils literal"><span class="pre">bar</span></code> ， <code class="docutils literal"><span class="pre">500</span></code> 毫秒之后变成 <code class="docutils literal"><span class="pre">baz</span></code> 。</p>
<p>这一点与 <code class="docutils literal"><span class="pre">CommonJS</span></code> 规范完全不同。 <code class="docutils literal"><span class="pre">CommonJS</span></code> 模块输出的是值的缓存，不存在动态更新，详见下文《Module 的加载实现》一节。</p>
<p>最后， <code class="docutils literal"><span class="pre">export</span></code> 命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的 <code class="docutils literal"><span class="pre">import</span></code> 命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">export</span> <span class="k">default</span> <span class="s1">&#39;bar&#39;</span> <span class="c1">// SyntaxError</span>
<span class="p">}</span>
<span class="nx">foo</span><span class="p">()</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">export</span></code> 语句放在函数之中，结果报错。</p>
</div>
<div class="section" id="import">
<h2>23.4. import 命令<a class="headerlink" href="#import" title="永久链接至标题">¶</a></h2>
<p>使用 <code class="docutils literal"><span class="pre">export</span></code> 命令定义了模块的对外接口以后，其他 <code class="docutils literal"><span class="pre">JS</span></code> 文件就可以通过 <code class="docutils literal"><span class="pre">import</span></code> 命令加载这个模块。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// main.js</span>
<span class="kr">import</span> <span class="p">{</span><span class="nx">firstName</span><span class="p">,</span> <span class="nx">lastName</span><span class="p">,</span> <span class="nx">year</span><span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;./profile.js&#39;</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">setName</span><span class="p">(</span><span class="nx">element</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">element</span><span class="p">.</span><span class="nx">textContent</span> <span class="o">=</span> <span class="nx">firstName</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="nx">lastName</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码的 <code class="docutils literal"><span class="pre">import</span></code> 命令，用于加载 <code class="docutils literal"><span class="pre">profile.js</span></code> 文件，并从中输入变量。 <code class="docutils literal"><span class="pre">import</span></code> 命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（ <code class="docutils literal"><span class="pre">profile.js</span></code> ）对外接口的名称相同。</p>
<p>如果想为输入的变量重新取一个名字， <code class="docutils literal"><span class="pre">import</span></code> 命令要使用 <code class="docutils literal"><span class="pre">as</span></code> 关键字，将输入的变量重命名。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="p">{</span> <span class="nx">lastName</span> <span class="nx">as</span> <span class="nx">surname</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;./profile.js&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">import</span></code> 命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="p">{</span><span class="nx">a</span><span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;./xxx.js&#39;</span>

<span class="nx">a</span> <span class="o">=</span> <span class="p">{};</span> <span class="c1">// Syntax Error : &#39;a&#39; is read-only;</span>
</pre></div>
</div>
<p>上面代码中，脚本加载了变量 <code class="docutils literal"><span class="pre">a</span></code> ，对其重新赋值就会报错，因为 <code class="docutils literal"><span class="pre">a</span></code> 是一个只读的接口。但是，如果 <code class="docutils literal"><span class="pre">a</span></code> 是一个对象，改写 <code class="docutils literal"><span class="pre">a</span></code> 的属性是允许的。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="p">{</span><span class="nx">a</span><span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;./xxx.js&#39;</span>

<span class="nx">a</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="s1">&#39;hello&#39;</span><span class="p">;</span> <span class="c1">// 合法操作</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">a</span></code> 的属性可以成功改写，并且其他模块也可以读到改写后的值。不过，这种写法很难查错，建议凡是输入的变量，都当作完全只读，轻易不要改变它的属性。</p>
<p><code class="docutils literal"><span class="pre">import</span></code> 后面的 <code class="docutils literal"><span class="pre">from</span></code> 指定模块文件的位置，可以是相对路径，也可以是绝对路径， <code class="docutils literal"><span class="pre">.js</span></code> 后缀可以省略。如果只是模块名，不带有路径，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="p">{</span><span class="nx">myMethod</span><span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;util&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">util</span></code> 是模块文件名，由于不带有路径，必须通过配置，告诉引擎怎么取到这个模块。</p>
<p>注意， <code class="docutils literal"><span class="pre">import</span></code> 命令具有提升效果，会提升到整个模块的头部，首先执行。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">foo</span><span class="p">();</span>

<span class="kr">import</span> <span class="p">{</span> <span class="nx">foo</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;my_module&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>上面的代码不会报错，因为 <code class="docutils literal"><span class="pre">import</span></code> 的执行早于 <code class="docutils literal"><span class="pre">foo</span></code> 的调用。这种行为的本质是， <code class="docutils literal"><span class="pre">import</span></code> 命令是编译阶段执行的，在代码运行之前。</p>
<p>由于 <code class="docutils literal"><span class="pre">import</span></code> 是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// 报错</span>
<span class="kr">import</span> <span class="p">{</span> <span class="s1">&#39;f&#39;</span> <span class="o">+</span> <span class="s1">&#39;oo&#39;</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;my_module&#39;</span><span class="p">;</span>

<span class="c1">// 报错</span>
<span class="kd">let</span> <span class="nx">module</span> <span class="o">=</span> <span class="s1">&#39;my_module&#39;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">foo</span> <span class="p">}</span> <span class="nx">from</span> <span class="nx">module</span><span class="p">;</span>

<span class="c1">// 报错</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">import</span> <span class="p">{</span> <span class="nx">foo</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;module1&#39;</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="kr">import</span> <span class="p">{</span> <span class="nx">foo</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;module2&#39;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面三种写法都会报错，因为它们用到了表达式、变量和 <code class="docutils literal"><span class="pre">if</span></code> 结构。在静态分析阶段，这些语法都是没法得到值的。</p>
<p>最后， <code class="docutils literal"><span class="pre">import</span></code> 语句会执行所加载的模块，因此可以有下面的写法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="s1">&#39;lodash&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>上面代码仅仅执行 <code class="docutils literal"><span class="pre">lodash</span></code> 模块，但是不输入任何值。</p>
<p>如果多次重复执行同一句 <code class="docutils literal"><span class="pre">import</span></code> 语句，那么只会执行一次，而不会执行多次。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="s1">&#39;lodash&#39;</span><span class="p">;</span>
<span class="kr">import</span> <span class="s1">&#39;lodash&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>上面代码加载了两次 <code class="docutils literal"><span class="pre">lodash</span></code> ，但是只会执行一次。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="p">{</span> <span class="nx">foo</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;my_module&#39;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">bar</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;my_module&#39;</span><span class="p">;</span>

<span class="c1">// 等同于</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">foo</span><span class="p">,</span> <span class="nx">bar</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;my_module&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>上面代码中，虽然 <code class="docutils literal"><span class="pre">foo</span></code> 和 <code class="docutils literal"><span class="pre">bar</span></code> 在两个语句中加载，但是它们对应的是同一个 <code class="docutils literal"><span class="pre">my_module</span></code> 实例。也就是说， <code class="docutils literal"><span class="pre">import</span></code> 语句是 <code class="docutils literal"><span class="pre">Singleton</span></code> 模式。</p>
<p>目前阶段，通过 <code class="docutils literal"><span class="pre">Babel</span></code> 转码， <code class="docutils literal"><span class="pre">CommonJS</span></code> 模块的 <code class="docutils literal"><span class="pre">require</span></code> 命令和 ES6 模块的 <code class="docutils literal"><span class="pre">import</span></code> 命令，可以写在同一个模块里面，但是最好不要这样做。因为 <code class="docutils literal"><span class="pre">import</span></code> 在静态解析阶段执行，所以它是一个模块之中最早执行的。下面的代码可能不会得到预期结果。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">require</span><span class="p">(</span><span class="s1">&#39;core-js/modules/es6.symbol&#39;</span><span class="p">);</span>
<span class="nx">require</span><span class="p">(</span><span class="s1">&#39;core-js/modules/es6.promise&#39;</span><span class="p">);</span>
<span class="kr">import</span> <span class="nx">React</span> <span class="nx">from</span> <span class="s1">&#39;React&#39;</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h2>23.5. 模块的整体加载<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>除了指定加载某个输出值，还可以使用整体加载，即用星号（ * ）指定一个对象，所有输出值都加载在这个对象上面。</p>
<p>下面是一个 <code class="docutils literal"><span class="pre">circle.js</span></code> 文件，它输出两个方法 <code class="docutils literal"><span class="pre">area</span></code> 和 <code class="docutils literal"><span class="pre">circumference</span></code> 。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// circle.js</span>

<span class="kr">export</span> <span class="kd">function</span> <span class="nx">area</span><span class="p">(</span><span class="nx">radius</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span> <span class="o">*</span> <span class="nx">radius</span> <span class="o">*</span> <span class="nx">radius</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="kd">function</span> <span class="nx">circumference</span><span class="p">(</span><span class="nx">radius</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span> <span class="o">*</span> <span class="nx">radius</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>现在，加载这个模块。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// main.js</span>

<span class="kr">import</span> <span class="p">{</span> <span class="nx">area</span><span class="p">,</span> <span class="nx">circumference</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;./circle&#39;</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;圆面积：&#39;</span> <span class="o">+</span> <span class="nx">area</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;圆周长：&#39;</span> <span class="o">+</span> <span class="nx">circumference</span><span class="p">(</span><span class="mi">14</span><span class="p">));</span>
</pre></div>
</div>
<p>上面写法是逐一指定要加载的方法，整体加载的写法如下。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="o">*</span> <span class="nx">as</span> <span class="nx">circle</span> <span class="nx">from</span> <span class="s1">&#39;./circle&#39;</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;圆面积：&#39;</span> <span class="o">+</span> <span class="nx">circle</span><span class="p">.</span><span class="nx">area</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;圆周长：&#39;</span> <span class="o">+</span> <span class="nx">circle</span><span class="p">.</span><span class="nx">circumference</span><span class="p">(</span><span class="mi">14</span><span class="p">));</span>
</pre></div>
</div>
<p>注意，模块整体加载所在的那个对象（上例是 <code class="docutils literal"><span class="pre">circle</span></code> ），应该是可以静态分析的，所以不允许运行时改变。下面的写法都是不允许的。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="o">*</span> <span class="nx">as</span> <span class="nx">circle</span> <span class="nx">from</span> <span class="s1">&#39;./circle&#39;</span><span class="p">;</span>

<span class="c1">// 下面两行都是不允许的</span>
<span class="nx">circle</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="s1">&#39;hello&#39;</span><span class="p">;</span>
<span class="nx">circle</span><span class="p">.</span><span class="nx">area</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{};</span>
</pre></div>
</div>
</div>
<div class="section" id="export-default">
<h2>23.6. export default 命令<a class="headerlink" href="#export-default" title="永久链接至标题">¶</a></h2>
<p>从前面的例子可以看出，使用 <code class="docutils literal"><span class="pre">import</span></code> 命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。</p>
<p>为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到 <code class="docutils literal"><span class="pre">export</span> <span class="pre">default</span></code> 命令，为模块指定默认输出。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// export-default.js</span>
<span class="kr">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码是一个模块文件 <code class="docutils literal"><span class="pre">export-default.js</span></code> ，它的默认输出是一个函数。</p>
<p>其他模块加载该模块时， <code class="docutils literal"><span class="pre">import</span></code> 命令可以为该匿名函数指定任意名字。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// import-default.js</span>
<span class="kr">import</span> <span class="nx">customName</span> <span class="nx">from</span> <span class="s1">&#39;./export-default&#39;</span><span class="p">;</span>
<span class="nx">customName</span><span class="p">();</span> <span class="c1">// &#39;foo&#39;</span>
</pre></div>
</div>
<p>上面代码的 <code class="docutils literal"><span class="pre">import</span></code> 命令，可以用任意名称指向 <code class="docutils literal"><span class="pre">export-default.js</span></code> 输出的方法，这时就不需要知道原模块输出的函数名。需要注意的是，这时 <code class="docutils literal"><span class="pre">import</span></code> 命令后面，不使用大括号。</p>
<p><code class="docutils literal"><span class="pre">export</span> <span class="pre">default</span></code> 命令用在非匿名函数前，也是可以的。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// export-default.js</span>
<span class="kr">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 或者写成</span>

<span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">foo</span><span class="p">;</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">foo</span></code> 函数的函数名 <code class="docutils literal"><span class="pre">foo</span></code> ，在模块外部是无效的。加载的时候，视同匿名函数加载。</p>
<p>下面比较一下默认输出和正常输出。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// 第一组</span>
<span class="kr">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">crc32</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// 输出</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kr">import</span> <span class="nx">crc32</span> <span class="nx">from</span> <span class="s1">&#39;crc32&#39;</span><span class="p">;</span> <span class="c1">// 输入</span>

<span class="c1">// 第二组</span>
<span class="kr">export</span> <span class="kd">function</span> <span class="nx">crc32</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// 输出</span>
  <span class="c1">// ...</span>
<span class="p">};</span>

<span class="kr">import</span> <span class="p">{</span><span class="nx">crc32</span><span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;crc32&#39;</span><span class="p">;</span> <span class="c1">// 输入</span>
</pre></div>
</div>
<p>上面代码的两组写法，第一组是使用 <code class="docutils literal"><span class="pre">export</span> <span class="pre">default</span></code> 时，对应的 <code class="docutils literal"><span class="pre">import</span></code> 语句不需要使用大括号；第二组是不使用 <code class="docutils literal"><span class="pre">export</span> <span class="pre">default</span></code> 时，对应的 <code class="docutils literal"><span class="pre">import</span></code> 语句需要使用大括号。</p>
<p><code class="docutils literal"><span class="pre">export</span> <span class="pre">default</span></code> 命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此 <code class="docutils literal"><span class="pre">export</span> <span class="pre">default</span></code> 命令只能使用一次。所以， <code class="docutils literal"><span class="pre">import</span></code> 命令后面才不用加大括号，因为只可能唯一对应 <code class="docutils literal"><span class="pre">export</span> <span class="pre">default</span></code> 命令。</p>
<p>本质上， <code class="docutils literal"><span class="pre">export</span> <span class="pre">default</span></code> 就是输出一个叫做 <code class="docutils literal"><span class="pre">default</span></code> 的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// modules.js</span>
<span class="kd">function</span> <span class="nx">add</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">}</span>
<span class="kr">export</span> <span class="p">{</span><span class="nx">add</span> <span class="nx">as</span> <span class="k">default</span><span class="p">};</span>
<span class="c1">// 等同于</span>
<span class="c1">// export default add;</span>

<span class="c1">// app.js</span>
<span class="kr">import</span> <span class="p">{</span> <span class="k">default</span> <span class="nx">as</span> <span class="nx">foo</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;modules&#39;</span><span class="p">;</span>
<span class="c1">// 等同于</span>
<span class="c1">// import foo from &#39;modules&#39;;</span>
</pre></div>
</div>
<p>正是因为 <code class="docutils literal"><span class="pre">export</span> <span class="pre">default</span></code> 命令其实只是输出一个叫做 <code class="docutils literal"><span class="pre">default</span></code> 的变量，所以它后面不能跟变量声明语句。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// 正确</span>
<span class="kr">export</span> <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">// 正确</span>
<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kr">export</span> <span class="k">default</span> <span class="nx">a</span><span class="p">;</span>

<span class="c1">// 错误</span>
<span class="kr">export</span> <span class="k">default</span> <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">export</span> <span class="pre">default</span> <span class="pre">a</span></code> 的含义是将变量 <code class="docutils literal"><span class="pre">a</span></code> 的值赋给变量 <code class="docutils literal"><span class="pre">default</span></code> 。所以，最后一种写法会报错。</p>
<p>同样地，因为 <code class="docutils literal"><span class="pre">export</span> <span class="pre">default</span></code> 命令的本质是将后面的值，赋给 <code class="docutils literal"><span class="pre">default</span></code> 变量，所以可以直接将一个值写在 <code class="docutils literal"><span class="pre">export</span> <span class="pre">default</span></code> 之后。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// 正确</span>
<span class="kr">export</span> <span class="k">default</span> <span class="mi">42</span><span class="p">;</span>

<span class="c1">// 报错</span>
<span class="kr">export</span> <span class="mi">42</span><span class="p">;</span>
</pre></div>
</div>
<p>上面代码中，后一句报错是因为没有指定对外的接口，而前一句指定外对接口为 <code class="docutils literal"><span class="pre">default</span></code> 。</p>
<p>有了 <code class="docutils literal"><span class="pre">export</span> <span class="pre">default</span></code> 命令，输入模块时就非常直观了，以输入 <code class="docutils literal"><span class="pre">lodash</span></code> 模块为例。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nx">_</span> <span class="nx">from</span> <span class="s1">&#39;lodash&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>如果想在一条 <code class="docutils literal"><span class="pre">import</span></code> 语句中，同时输入默认方法和其他接口，可以写成下面这样。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nx">_</span><span class="p">,</span> <span class="p">{</span> <span class="nx">each</span><span class="p">,</span> <span class="nx">each</span> <span class="nx">as</span> <span class="nx">forEach</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;lodash&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>对应上面代码的 <code class="docutils literal"><span class="pre">export</span></code> 语句如下。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ···</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="kd">function</span> <span class="nx">each</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">iterator</span><span class="p">,</span> <span class="nx">context</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ···</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="p">{</span> <span class="nx">each</span> <span class="nx">as</span> <span class="nx">forEach</span> <span class="p">};</span>
</pre></div>
</div>
<p>上面代码的最后一行的意思是，暴露出 <code class="docutils literal"><span class="pre">forEach</span></code> 接口，默认指向 <code class="docutils literal"><span class="pre">each</span></code> 接口，即 <code class="docutils literal"><span class="pre">forEach</span></code> 和 <code class="docutils literal"><span class="pre">each</span></code> 指向同一个方法。</p>
<p><code class="docutils literal"><span class="pre">export</span> <span class="pre">default</span></code> 也可以用来输出类。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// MyClass.js</span>
<span class="kr">export</span> <span class="k">default</span> <span class="kr">class</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>

<span class="c1">// main.js</span>
<span class="kr">import</span> <span class="nx">MyClass</span> <span class="nx">from</span> <span class="s1">&#39;MyClass&#39;</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">o</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyClass</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="export-import">
<h2>23.7. export 与 import 的复合写法<a class="headerlink" href="#export-import" title="永久链接至标题">¶</a></h2>
<p>如果在一个模块之中，先输入后输出同一个模块， <code class="docutils literal"><span class="pre">import</span></code> 语句可以与 <code class="docutils literal"><span class="pre">export</span></code> 语句写在一起。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">export</span> <span class="p">{</span> <span class="nx">foo</span><span class="p">,</span> <span class="nx">bar</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;my_module&#39;</span><span class="p">;</span>

<span class="c1">// 可以简单理解为</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">foo</span><span class="p">,</span> <span class="nx">bar</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;my_module&#39;</span><span class="p">;</span>
<span class="kr">export</span> <span class="p">{</span> <span class="nx">foo</span><span class="p">,</span> <span class="nx">bar</span> <span class="p">};</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">export</span></code> 和 <code class="docutils literal"><span class="pre">import</span></code> 语句可以结合在一起，写成一行。但需要注意的是，写成一行以后， <code class="docutils literal"><span class="pre">foo</span></code> 和 <code class="docutils literal"><span class="pre">bar</span></code> 实际上并没有被导入当前模块，只是相当于对外转发了这两个接口，导致当前模块不能直接使用 <code class="docutils literal"><span class="pre">foo</span></code> 和 <code class="docutils literal"><span class="pre">bar</span></code> 。</p>
<p>模块的接口改名和整体输出，也可以采用这种写法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// 接口改名</span>
<span class="kr">export</span> <span class="p">{</span> <span class="nx">foo</span> <span class="nx">as</span> <span class="nx">myFoo</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;my_module&#39;</span><span class="p">;</span>

<span class="c1">// 整体输出</span>
<span class="kr">export</span> <span class="o">*</span> <span class="nx">from</span> <span class="s1">&#39;my_module&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>默认接口的写法如下。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">export</span> <span class="p">{</span> <span class="k">default</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;foo&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>具名接口改为默认接口的写法如下。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">export</span> <span class="p">{</span> <span class="nx">es6</span> <span class="nx">as</span> <span class="k">default</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;./someModule&#39;</span><span class="p">;</span>

<span class="c1">// 等同于</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">es6</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;./someModule&#39;</span><span class="p">;</span>
<span class="kr">export</span> <span class="k">default</span> <span class="nx">es6</span><span class="p">;</span>
</pre></div>
</div>
<p>同样地，默认接口也可以改名为具名接口。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">export</span> <span class="p">{</span> <span class="k">default</span> <span class="nx">as</span> <span class="nx">es6</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;./someModule&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>下面三种 <code class="docutils literal"><span class="pre">import</span></code> 语句，没有对应的复合写法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="o">*</span> <span class="nx">as</span> <span class="nx">someIdentifier</span> <span class="nx">from</span> <span class="s2">&quot;someModule&quot;</span><span class="p">;</span>
<span class="kr">import</span> <span class="nx">someIdentifier</span> <span class="nx">from</span> <span class="s2">&quot;someModule&quot;</span><span class="p">;</span>
<span class="kr">import</span> <span class="nx">someIdentifier</span><span class="p">,</span> <span class="p">{</span> <span class="nx">namedIdentifier</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;someModule&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>为了做到形式的对称，现在有 <a class="reference external" href="https://github.com/leebyron/ecmascript-export-default-from">提案</a> ，提出补上这三种复合写法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">export</span> <span class="o">*</span> <span class="nx">as</span> <span class="nx">someIdentifier</span> <span class="nx">from</span> <span class="s2">&quot;someModule&quot;</span><span class="p">;</span>
<span class="kr">export</span> <span class="nx">someIdentifier</span> <span class="nx">from</span> <span class="s2">&quot;someModule&quot;</span><span class="p">;</span>
<span class="kr">export</span> <span class="nx">someIdentifier</span><span class="p">,</span> <span class="p">{</span> <span class="nx">namedIdentifier</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;someModule&quot;</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h2>23.8. 模块的继承<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<p>模块之间也可以继承。</p>
<p>假设有一个 <code class="docutils literal"><span class="pre">circleplus</span></code> 模块，继承了 <code class="docutils literal"><span class="pre">circle</span></code> 模块。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// circleplus.js</span>

<span class="kr">export</span> <span class="o">*</span> <span class="nx">from</span> <span class="s1">&#39;circle&#39;</span><span class="p">;</span>
<span class="kr">export</span> <span class="kd">var</span> <span class="nx">e</span> <span class="o">=</span> <span class="mf">2.71828182846</span><span class="p">;</span>
<span class="kr">export</span> <span class="k">default</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">exp</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码中的 <code class="docutils literal"><span class="pre">export</span> <span class="pre">*</span></code> ，表示再输出 <code class="docutils literal"><span class="pre">circle</span></code> 模块的所有属性和方法。注意， <code class="docutils literal"><span class="pre">export</span> <span class="pre">*</span></code> 命令会忽略 <code class="docutils literal"><span class="pre">circle</span></code> 模块的 <code class="docutils literal"><span class="pre">default</span></code> 方法。然后，上面代码又输出了自定义的 <code class="docutils literal"><span class="pre">e</span></code> 变量和默认方法。</p>
<p>这时，也可以将 <code class="docutils literal"><span class="pre">circle</span></code> 的属性或方法，改名后再输出。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// circleplus.js</span>

<span class="kr">export</span> <span class="p">{</span> <span class="nx">area</span> <span class="nx">as</span> <span class="nx">circleArea</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;circle&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>上面代码表示，只输出 <code class="docutils literal"><span class="pre">circle</span></code> 模块的 <code class="docutils literal"><span class="pre">area</span></code> 方法，且将其改名为 <code class="docutils literal"><span class="pre">circleArea</span></code> 。</p>
<p>加载上面模块的写法如下。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// main.js</span>

<span class="kr">import</span> <span class="o">*</span> <span class="nx">as</span> <span class="nx">math</span> <span class="nx">from</span> <span class="s1">&#39;circleplus&#39;</span><span class="p">;</span>
<span class="kr">import</span> <span class="nx">exp</span> <span class="nx">from</span> <span class="s1">&#39;circleplus&#39;</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">exp</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nx">e</span><span class="p">));</span>
</pre></div>
</div>
<p>上面代码中的 <code class="docutils literal"><span class="pre">import</span> <span class="pre">exp</span></code> 表示，将 <code class="docutils literal"><span class="pre">circleplus</span></code> 模块的默认方法加载为 <code class="docutils literal"><span class="pre">exp</span></code> 方法。</p>
</div>
<div class="section" id="id6">
<h2>23.9. 跨模块常量<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h2>
<p>本书介绍 <code class="docutils literal"><span class="pre">const</span></code> 命令的时候说过， <code class="docutils literal"><span class="pre">const</span></code> 声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），或者说一个值要被多个模块共享，可以采用下面的写法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// constants.js 模块</span>
<span class="kr">export</span> <span class="kr">const</span> <span class="nx">A</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kr">export</span> <span class="kr">const</span> <span class="nx">B</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="kr">export</span> <span class="kr">const</span> <span class="nx">C</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

<span class="c1">// test1.js 模块</span>
<span class="kr">import</span> <span class="o">*</span> <span class="nx">as</span> <span class="nx">constants</span> <span class="nx">from</span> <span class="s1">&#39;./constants&#39;</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">constants</span><span class="p">.</span><span class="nx">A</span><span class="p">);</span> <span class="c1">// 1</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">constants</span><span class="p">.</span><span class="nx">B</span><span class="p">);</span> <span class="c1">// 3</span>

<span class="c1">// test2.js 模块</span>
<span class="kr">import</span> <span class="p">{</span><span class="nx">A</span><span class="p">,</span> <span class="nx">B</span><span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;./constants&#39;</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">A</span><span class="p">);</span> <span class="c1">// 1</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">B</span><span class="p">);</span> <span class="c1">// 3</span>
</pre></div>
</div>
<p>如果要使用的常量非常多，可以建一个专门的 <code class="docutils literal"><span class="pre">constants</span></code> 目录，将各种常量写在不同的文件里面，保存在该目录下。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// constants/db.js</span>
<span class="kr">export</span> <span class="kr">const</span> <span class="nx">db</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">url</span><span class="o">:</span> <span class="s1">&#39;http://my.couchdbserver.local:5984&#39;</span><span class="p">,</span>
  <span class="nx">admin_username</span><span class="o">:</span> <span class="s1">&#39;admin&#39;</span><span class="p">,</span>
  <span class="nx">admin_password</span><span class="o">:</span> <span class="s1">&#39;admin password&#39;</span>
<span class="p">};</span>

<span class="c1">// constants/user.js</span>
<span class="kr">export</span> <span class="kr">const</span> <span class="nx">users</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;root&#39;</span><span class="p">,</span> <span class="s1">&#39;admin&#39;</span><span class="p">,</span> <span class="s1">&#39;staff&#39;</span><span class="p">,</span> <span class="s1">&#39;ceo&#39;</span><span class="p">,</span> <span class="s1">&#39;chief&#39;</span><span class="p">,</span> <span class="s1">&#39;moderator&#39;</span><span class="p">];</span>
</pre></div>
</div>
<p>然后，将这些文件输出的常量，合并在 <code class="docutils literal"><span class="pre">index.js</span></code> 里面。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// constants/index.js</span>
<span class="kr">export</span> <span class="p">{</span><span class="nx">db</span><span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;./db&#39;</span><span class="p">;</span>
<span class="kr">export</span> <span class="p">{</span><span class="nx">users</span><span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;./users&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>使用的时候，直接加载 <code class="docutils literal"><span class="pre">index.js</span></code> 就可以了。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// script.js</span>
<span class="kr">import</span> <span class="p">{</span><span class="nx">db</span><span class="p">,</span> <span class="nx">users</span><span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;./index&#39;</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h2>23.10. import()<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h2>
<div class="section" id="id8">
<h3>23.10.1. 简介<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h3>
<p>前面介绍过， <code class="docutils literal"><span class="pre">import</span></code> 命令会被 JavaScript 引擎静态分析，先于模块内的其他语句执行（import命令叫做“连接” binding 其实更合适）。所以，下面的代码会报错。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// 报错</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">===</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">import</span> <span class="nx">MyModual</span> <span class="nx">from</span> <span class="s1">&#39;./myModual&#39;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码中，引擎处理 <code class="docutils literal"><span class="pre">import</span></code> 语句是在编译时，这时不会去分析或执行 <code class="docutils literal"><span class="pre">if</span></code> 语句，所以 <code class="docutils literal"><span class="pre">import</span></code> 语句放在 <code class="docutils literal"><span class="pre">if</span></code> 代码块之中毫无意义，因此会报句法错误，而不是执行时错误。也就是说， <code class="docutils literal"><span class="pre">import</span></code> 和 <code class="docutils literal"><span class="pre">export</span></code> 命令只能在模块的顶层，不能在代码块之中（比如，在 <code class="docutils literal"><span class="pre">if</span></code> 代码块之中，或在函数之中）。</p>
<p>这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。如果 <code class="docutils literal"><span class="pre">import</span></code> 命令要取代 <code class="docutils literal"><span class="pre">Node</span></code> 的 <code class="docutils literal"><span class="pre">require</span></code> 方法，这就形成了一个障碍。因为 <code class="docutils literal"><span class="pre">require</span></code> 是运行时加载模块， <code class="docutils literal"><span class="pre">import</span></code> 命令无法取代 <code class="docutils literal"><span class="pre">require</span></code> 的动态加载功能。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">path</span> <span class="o">=</span> <span class="s1">&#39;./&#39;</span> <span class="o">+</span> <span class="nx">fileName</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">myModual</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="nx">path</span><span class="p">);</span>
</pre></div>
</div>
<p>上面的语句就是动态加载， <code class="docutils literal"><span class="pre">require</span></code> 到底加载哪一个模块，只有运行时才知道。 <code class="docutils literal"><span class="pre">import</span></code> 命令做不到这一点。</p>
<p>因此，有一个 <a class="reference external" href="https://github.com/tc39/proposal-dynamic-import">提案</a> ，建议引入 <code class="docutils literal"><span class="pre">import()</span></code> 函数，完成动态加载。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">import</span><span class="p">(</span><span class="nx">specifier</span><span class="p">)</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">import</span></code> 函数的参数 <code class="docutils literal"><span class="pre">specifier</span></code> ，指定所要加载的模块的位置。 <code class="docutils literal"><span class="pre">import</span></code> 命令能够接受什么参数， <code class="docutils literal"><span class="pre">import()</span></code> 函数就能接受什么参数，两者区别主要是后者为动态加载。</p>
<p><code class="docutils literal"><span class="pre">import()</span></code> 返回一个 <code class="docutils literal"><span class="pre">Promise</span></code> 对象。下面是一个例子。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">main</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;main&#39;</span><span class="p">);</span>

<span class="kr">import</span><span class="p">(</span><span class="sb">`./section-modules/</span><span class="si">${</span><span class="nx">someVariable</span><span class="si">}</span><span class="sb">.js`</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">module</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">module</span><span class="p">.</span><span class="nx">loadPageInto</span><span class="p">(</span><span class="nx">main</span><span class="p">);</span>
  <span class="p">})</span>
  <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">err</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">main</span><span class="p">.</span><span class="nx">textContent</span> <span class="o">=</span> <span class="nx">err</span><span class="p">.</span><span class="nx">message</span><span class="p">;</span>
  <span class="p">});</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">import()</span></code> 函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块。另外， <code class="docutils literal"><span class="pre">import()</span></code> 函数与所加载的模块没有静态连接关系，这点也是与 <code class="docutils literal"><span class="pre">import</span></code> 语句不相同。 <code class="docutils literal"><span class="pre">import()</span></code> 类似于 <code class="docutils literal"><span class="pre">Node</span></code> 的 <code class="docutils literal"><span class="pre">require</span></code> 方法，区别主要是前者是异步加载，后者是同步加载。</p>
</div>
<div class="section" id="id10">
<h3>23.10.2. 适用场合<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h3>
<p>下面是 <code class="docutils literal"><span class="pre">import()</span></code> 的一些适用场合。</p>
<ol class="arabic simple">
<li>按需加载。</li>
</ol>
<p><code class="docutils literal"><span class="pre">import()</span></code> 可以在需要的时候，再加载某个模块。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">button</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;click&#39;</span><span class="p">,</span> <span class="nx">event</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="kr">import</span><span class="p">(</span><span class="s1">&#39;./dialogBox.js&#39;</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">dialogBox</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">dialogBox</span><span class="p">.</span><span class="nx">open</span><span class="p">();</span>
  <span class="p">})</span>
  <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">error</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="cm">/* Error handling */</span>
  <span class="p">})</span>
<span class="p">});</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">import()</span></code> 方法放在 <code class="docutils literal"><span class="pre">click</span></code> 事件的监听函数之中，只有用户点击了按钮，才会加载这个模块。</p>
<ol class="arabic simple" start="2">
<li>条件加载</li>
</ol>
<p><code class="docutils literal"><span class="pre">import()</span></code> 可以放在 <code class="docutils literal"><span class="pre">if</span></code> 代码块，根据不同的情况，加载不同的模块。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="nx">condition</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">import</span><span class="p">(</span><span class="s1">&#39;moduleA&#39;</span><span class="p">).</span><span class="nx">then</span><span class="p">(...);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="kr">import</span><span class="p">(</span><span class="s1">&#39;moduleB&#39;</span><span class="p">).</span><span class="nx">then</span><span class="p">(...);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码中，如果满足条件，就加载模块 <code class="docutils literal"><span class="pre">A</span></code> ，否则加载模块 <code class="docutils literal"><span class="pre">B</span></code> 。</p>
<ol class="arabic simple" start="3">
<li>动态的模块路径</li>
</ol>
<p><code class="docutils literal"><span class="pre">import()</span></code> 允许模块路径动态生成。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">import</span><span class="p">(</span><span class="nx">f</span><span class="p">()).</span><span class="nx">then</span><span class="p">(...);</span>
</pre></div>
</div>
<p>上面代码中，根据函数 <code class="docutils literal"><span class="pre">f</span></code> 的返回结果，加载不同的模块。</p>
</div>
<div class="section" id="id11">
<h3>23.10.3. 注意点<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal"><span class="pre">import()</span></code> 加载模块成功以后，这个模块会作为一个对象，当作 <code class="docutils literal"><span class="pre">then</span></code> 方法的参数。因此，可以使用对象解构赋值的语法，获取输出接口。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">import</span><span class="p">(</span><span class="s1">&#39;./myModule.js&#39;</span><span class="p">)</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(({</span><span class="nx">export1</span><span class="p">,</span> <span class="nx">export2</span><span class="p">})</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="c1">// ...·</span>
<span class="p">});</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">export1</span></code> 和 <code class="docutils literal"><span class="pre">export2</span></code> 都是 <code class="docutils literal"><span class="pre">myModule.js</span></code> 的输出接口，可以解构获得。</p>
<p>如果模块有 <code class="docutils literal"><span class="pre">default</span></code> 输出接口，可以用参数直接获得。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">import</span><span class="p">(</span><span class="s1">&#39;./myModule.js&#39;</span><span class="p">)</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">myModule</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">myModule</span><span class="p">.</span><span class="k">default</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>
</div>
<p>上面的代码也可以使用具名输入的形式。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">import</span><span class="p">(</span><span class="s1">&#39;./myModule.js&#39;</span><span class="p">)</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(({</span><span class="k">default</span><span class="o">:</span> <span class="nx">theDefault</span><span class="p">})</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">theDefault</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>
</div>
<p>如果想同时加载多个模块，可以采用下面的写法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span>Promise.all([
  import(&#39;./module1.js&#39;),
  import(&#39;./module2.js&#39;),
  import(&#39;./module3.js&#39;),
])
.then(([module1, module2, module3]) =&gt; {
   ···
});
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">import()</span></code> 也可以用在 <code class="docutils literal"><span class="pre">async</span></code> 函数之中。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">async</span> <span class="kd">function</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">myModule</span> <span class="o">=</span> <span class="nx">await</span> <span class="kr">import</span><span class="p">(</span><span class="s1">&#39;./myModule.js&#39;</span><span class="p">);</span>
  <span class="kr">const</span> <span class="p">{</span><span class="nx">export1</span><span class="p">,</span> <span class="nx">export2</span><span class="p">}</span> <span class="o">=</span> <span class="nx">await</span> <span class="kr">import</span><span class="p">(</span><span class="s1">&#39;./myModule.js&#39;</span><span class="p">);</span>
  <span class="kr">const</span> <span class="p">[</span><span class="nx">module1</span><span class="p">,</span> <span class="nx">module2</span><span class="p">,</span> <span class="nx">module3</span><span class="p">]</span> <span class="o">=</span>
    <span class="nx">await</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span>
      <span class="kr">import</span><span class="p">(</span><span class="s1">&#39;./module1.js&#39;</span><span class="p">),</span>
      <span class="kr">import</span><span class="p">(</span><span class="s1">&#39;./module2.js&#39;</span><span class="p">),</span>
      <span class="kr">import</span><span class="p">(</span><span class="s1">&#39;./module3.js&#39;</span><span class="p">),</span>
    <span class="p">]);</span>
<span class="p">}</span>
<span class="nx">main</span><span class="p">();</span>
</pre></div>
</div>
</div>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Module的加载实现.html" class="btn btn-neutral float-right" title="24. Module 的加载实现" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="Decorator.html" class="btn btn-neutral" title="22. 修饰器" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, lzh.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.0',
            LANGUAGE:'zh_CN',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="_static/translations.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();

      });


      $(document).ready(function(){
        var offset = sessionStorage.getItem("offsetTop");
        $('.wy-side-scroll').scrollTop(offset);
        sessionStorage.setItem("offsetTop", 0);


        $('.wy-menu > ul').click(function(){
            sessionStorage.setItem("offsetTop", $('.wy-side-scroll').scrollTop());
        });
      })

  </script>
   

</body>
</html>