

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>17. Generator函数的语法 &mdash; ECMAScript6入门 1.0 文档</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="索引"
              href="genindex.html"/>
        <link rel="search" title="搜索" href="search.html"/>
    <link rel="top" title="ECMAScript6入门 1.0 文档" href="index.html"/>
        <link rel="next" title="18. Generator 函数的异步应用" href="Generator函数的异步应用.html"/>
        <link rel="prev" title="16. Iterator 和 for…of 循环" href="Iterator和for...of循环.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> ECMAScript6入门
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="前言.html">1. 前言</a></li>
<li class="toctree-l1"><a class="reference internal" href="ECMAScript6简介.html">2. ECMAScript6简介</a></li>
<li class="toctree-l1"><a class="reference internal" href="let和const命令.html">3. let 和 const 命令</a></li>
<li class="toctree-l1"><a class="reference internal" href="变量的解构赋值.html">4. 变量的解构赋值</a></li>
<li class="toctree-l1"><a class="reference internal" href="字符串的扩展.html">5. 字符串的扩展</a></li>
<li class="toctree-l1"><a class="reference internal" href="正则的扩展.html">6. 正则的扩展</a></li>
<li class="toctree-l1"><a class="reference internal" href="数值的扩展.html">7. 数值的扩展</a></li>
<li class="toctree-l1"><a class="reference internal" href="函数的扩展.html">8. 函数的扩展</a></li>
<li class="toctree-l1"><a class="reference internal" href="数组的扩展.html">9. 数组的扩展</a></li>
<li class="toctree-l1"><a class="reference internal" href="对象的扩展.html">10. 对象的扩展</a></li>
<li class="toctree-l1"><a class="reference internal" href="Symbol.html">11. Symbol</a></li>
<li class="toctree-l1"><a class="reference internal" href="Set和Map数据结构.html">12. Set和Map数据结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="Proxy.html">13. Proxy</a></li>
<li class="toctree-l1"><a class="reference internal" href="Reflect.html">14. Reflect</a></li>
<li class="toctree-l1"><a class="reference internal" href="Promise对象.html">15. Promise对象</a></li>
<li class="toctree-l1"><a class="reference internal" href="Iterator和for...of循环.html">16. Iterator 和 for…of 循环</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">17. Generator函数的语法</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1">17.1. 简介</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">17.1.1. 基本概念</a></li>
<li class="toctree-l3"><a class="reference internal" href="#yield">17.1.2. yield 表达式</a></li>
<li class="toctree-l3"><a class="reference internal" href="#iterator">17.1.3. 与 Iterator 接口的关系</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#next">17.2. next 方法的参数</a></li>
<li class="toctree-l2"><a class="reference internal" href="#for-of">17.3. for…of 循环</a></li>
<li class="toctree-l2"><a class="reference internal" href="#generator-prototype-throw">17.4. Generator.prototype.throw()</a></li>
<li class="toctree-l2"><a class="reference internal" href="#generator-prototype-return">17.5. Generator.prototype.return()</a></li>
<li class="toctree-l2"><a class="reference internal" href="#next-throw-return">17.6. next()、throw()、return() 的共同点</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">17.7. yield* 表达式</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id4">17.8. 作为对象属性的 Generator 函数</a></li>
<li class="toctree-l2"><a class="reference internal" href="#generator-this">17.9. Generator 函数的this</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id5">17.10. 含义</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id6">17.10.1. Generator 与协程</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id7">17.10.2. Generator 与上下文</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id8">17.11. 应用</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Generator函数的异步应用.html">18. Generator 函数的异步应用</a></li>
<li class="toctree-l1"><a class="reference internal" href="async函数.html">19. asyn函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="Class的基本语法.html">20. Class 的基本语法</a></li>
<li class="toctree-l1"><a class="reference internal" href="Class的继承.html">21. Class的继承</a></li>
<li class="toctree-l1"><a class="reference internal" href="Decorator.html">22. 修饰器</a></li>
<li class="toctree-l1"><a class="reference internal" href="Module的语法.html">23. Module 的语法</a></li>
<li class="toctree-l1"><a class="reference internal" href="Module的加载实现.html">24. Module 的加载实现</a></li>
<li class="toctree-l1"><a class="reference internal" href="编程风格.html">25. 编程风格</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">ECMAScript6入门</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>17. Generator函数的语法</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="generator">
<h1>17. Generator函数的语法<a class="headerlink" href="#generator" title="永久链接至标题">¶</a></h1>
<div class="section" id="id1">
<h2>17.1. 简介<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<div class="section" id="id2">
<h3>17.1.1. 基本概念<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal"><span class="pre">Generator</span></code> <strong>函数是 ES6 提供的一种异步编程解决方案</strong> ，语法行为与传统函数完全不同。本章详细介绍 <code class="docutils literal"><span class="pre">Generator</span></code> 函数的语法和 <code class="docutils literal"><span class="pre">API</span></code> ，它的异步编程应用请看《 <code class="docutils literal"><span class="pre">Generator</span></code> 函数的异步应用》一章。</p>
<p><code class="docutils literal"><span class="pre">Generator</span></code> 函数有多种理解角度。语法上，首先可以把它理解成， <code class="docutils literal"><span class="pre">Generator</span></code> 函数是一个状态机，封装了多个内部状态。</p>
<p>执行 <code class="docutils literal"><span class="pre">Generator</span></code> 函数会返回一个遍历器对象，也就是说， <code class="docutils literal"><span class="pre">Generator</span></code> 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 <code class="docutils literal"><span class="pre">Generator</span></code> 函数内部的每一个状态。</p>
<p>形式上， <code class="docutils literal"><span class="pre">Generator</span></code> 函数是一个普通函数，但是有两个特征。一是， <code class="docutils literal"><span class="pre">function</span></code> 关键字与函数名之间有一个星号；二是，函数体内部使用 <code class="docutils literal"><span class="pre">yield</span></code> 表达式，定义不同的内部状态（ <code class="docutils literal"><span class="pre">yield</span></code> 在英语里的意思就是“产出”）。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">helloWorldGenerator</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="s1">&#39;hello&#39;</span><span class="p">;</span>
  <span class="k">yield</span> <span class="s1">&#39;world&#39;</span><span class="p">;</span>
  <span class="k">return</span> <span class="s1">&#39;ending&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">hw</span> <span class="o">=</span> <span class="nx">helloWorldGenerator</span><span class="p">();</span>
</pre></div>
</div>
<p>上面代码定义了一个 <code class="docutils literal"><span class="pre">Generator</span></code> 函数 <code class="docutils literal"><span class="pre">helloWorldGenerator</span></code> ，它内部有两个 <code class="docutils literal"><span class="pre">yield</span></code> 表达式（ <code class="docutils literal"><span class="pre">hello</span></code> 和 <code class="docutils literal"><span class="pre">world</span></code> ），即该函数有三个状态： <code class="docutils literal"><span class="pre">hello</span></code> ， <code class="docutils literal"><span class="pre">world</span></code> 和 <code class="docutils literal"><span class="pre">return</span></code> 语句（结束执行）。</p>
<p>然后， <code class="docutils literal"><span class="pre">Generator</span></code> 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 <code class="docutils literal"><span class="pre">Generator</span></code> 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（ <code class="docutils literal"><span class="pre">Iterator</span> <span class="pre">Object</span></code> ）。</p>
<p>下一步，必须调用遍历器对象的 <code class="docutils literal"><span class="pre">next</span></code> 方法，使得指针移向下一个状态。也就是说，每次调用 <code class="docutils literal"><span class="pre">next</span></code> 方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个 <code class="docutils literal"><span class="pre">yield</span></code> 表达式（或 <code class="docutils literal"><span class="pre">return</span></code> 语句）为止。换言之， <code class="docutils literal"><span class="pre">Generator</span></code> 函数是分段执行的， <code class="docutils literal"><span class="pre">yield</span></code> 表达式是暂停执行的标记，而 <code class="docutils literal"><span class="pre">next</span></code> 方法可以恢复执行。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">hw</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>
<span class="c1">// { value: &#39;hello&#39;, done: false }</span>

<span class="nx">hw</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>
<span class="c1">// { value: &#39;world&#39;, done: false }</span>

<span class="nx">hw</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>
<span class="c1">// { value: &#39;ending&#39;, done: true }</span>

<span class="nx">hw</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>
<span class="c1">// { value: undefined, done: true }</span>
</pre></div>
</div>
<p>上面代码一共调用了四次 <code class="docutils literal"><span class="pre">next</span></code> 方法。</p>
<p>第一次调用， <code class="docutils literal"><span class="pre">Generator</span></code> 函数开始执行，直到遇到第一个 <code class="docutils literal"><span class="pre">yield</span></code> 表达式为止。 <code class="docutils literal"><span class="pre">next</span></code> 方法返回一个对象，它的 <code class="docutils literal"><span class="pre">value</span></code> 属性就是当前 <code class="docutils literal"><span class="pre">yield</span></code> 表达式的值 <code class="docutils literal"><span class="pre">hello</span></code> ， <code class="docutils literal"><span class="pre">done</span></code> 属性的值 <code class="docutils literal"><span class="pre">false</span></code> ，表示遍历还没有结束。</p>
<p>第二次调用， <code class="docutils literal"><span class="pre">Generator</span></code> 函数从上次 <code class="docutils literal"><span class="pre">yield</span></code> 表达式停下的地方，一直执行到下一个 <code class="docutils literal"><span class="pre">yield</span></code> 表达式。 <code class="docutils literal"><span class="pre">next</span></code> 方法返回的对象的 <code class="docutils literal"><span class="pre">value</span></code> 属性就是当前 <code class="docutils literal"><span class="pre">yield</span></code> 表达式的值 <code class="docutils literal"><span class="pre">world</span></code> ， <code class="docutils literal"><span class="pre">done</span></code> 属性的值 <code class="docutils literal"><span class="pre">false</span></code> ，表示遍历还没有结束。</p>
<p>第三次调用， <code class="docutils literal"><span class="pre">Generator</span></code> 函数从上次 <code class="docutils literal"><span class="pre">yield</span></code> 表达式停下的地方，一直执行到 <code class="docutils literal"><span class="pre">return</span></code> 语句（如果没有 <code class="docutils literal"><span class="pre">return</span></code> 语句，就执行到函数结束）。 <code class="docutils literal"><span class="pre">next</span></code> 方法返回的对象的 <code class="docutils literal"><span class="pre">value</span></code> 属性，就是紧跟在 <code class="docutils literal"><span class="pre">return</span></code> 语句后面的表达式的值（如果没有 <code class="docutils literal"><span class="pre">return</span></code> 语句，则 <code class="docutils literal"><span class="pre">value</span></code> 属性的值为 <code class="docutils literal"><span class="pre">undefined</span></code> ）， <code class="docutils literal"><span class="pre">done</span></code> 属性的值 <code class="docutils literal"><span class="pre">true</span></code> ，表示遍历已经结束。</p>
<p>第四次调用，此时 <code class="docutils literal"><span class="pre">Generator</span></code> 函数已经运行完毕， <code class="docutils literal"><span class="pre">next</span></code> 方法返回对象的 <code class="docutils literal"><span class="pre">value</span></code> 属性为 <code class="docutils literal"><span class="pre">undefined</span></code> ， <code class="docutils literal"><span class="pre">done</span></code> 属性为 <code class="docutils literal"><span class="pre">true</span></code> 。以后再调用 <code class="docutils literal"><span class="pre">next</span></code> 方法，返回的都是这个值。</p>
<p>总结一下，调用 <code class="docutils literal"><span class="pre">Generator</span></code> 函数，返回一个遍历器对象，代表 <code class="docutils literal"><span class="pre">Generator</span></code> 函数的内部指针。以后，每次调用遍历器对象的 <code class="docutils literal"><span class="pre">next</span></code> 方法，就会返回一个有着 <code class="docutils literal"><span class="pre">value</span></code> 和 <code class="docutils literal"><span class="pre">done</span></code> 两个属性的对象。 <code class="docutils literal"><span class="pre">value</span></code> 属性表示当前的内部状态的值，是 <code class="docutils literal"><span class="pre">yield</span></code> 表达式后面那个表达式的值； <code class="docutils literal"><span class="pre">done</span></code> 属性是一个布尔值，表示是否遍历结束。</p>
<p>ES6 没有规定， <code class="docutils literal"><span class="pre">function</span></code> 关键字与函数名之间的星号，写在哪个位置。这导致下面的写法都能通过。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span>function * foo(x, y) { ··· }
function *foo(x, y) { ··· }
function* foo(x, y) { ··· }
function*foo(x, y) { ··· }
</pre></div>
</div>
<p>由于 <code class="docutils literal"><span class="pre">Generator</span></code> 函数仍然是普通函数，所以一般的写法是上面的第三种，即星号紧跟在 <code class="docutils literal"><span class="pre">function</span></code> 关键字后面。本书也采用这种写法。</p>
</div>
<div class="section" id="yield">
<h3>17.1.2. yield 表达式<a class="headerlink" href="#yield" title="永久链接至标题">¶</a></h3>
<p>由于 <code class="docutils literal"><span class="pre">Generator</span></code> 函数返回的遍历器对象，只有调用 <code class="docutils literal"><span class="pre">next</span></code> 方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。 <code class="docutils literal"><span class="pre">yield</span></code> 表达式就是暂停标志。</p>
<p>遍历器对象的 <code class="docutils literal"><span class="pre">next</span></code> 方法的运行逻辑如下。</p>
<ol class="arabic simple">
<li>遇到 <code class="docutils literal"><span class="pre">yield</span></code> 表达式，就暂停执行后面的操作，并将紧跟在 <code class="docutils literal"><span class="pre">yield</span></code> 后面的那个表达式的值，作为返回的对象的 <code class="docutils literal"><span class="pre">value</span></code> 属性值。</li>
<li>下一次调用 <code class="docutils literal"><span class="pre">next</span></code> 方法时，再继续往下执行，直到遇到下一个 <code class="docutils literal"><span class="pre">yield</span></code> 表达式。</li>
<li>如果没有再遇到新的 <code class="docutils literal"><span class="pre">yield</span></code> 表达式，就一直运行到函数结束，直到 <code class="docutils literal"><span class="pre">return</span></code> 语句为止，并将 <code class="docutils literal"><span class="pre">return</span></code> 语句后面的表达式的值，作为返回的对象的 <code class="docutils literal"><span class="pre">value</span></code> 属性值。</li>
<li>如果该函数没有 <code class="docutils literal"><span class="pre">return</span></code> 语句，则返回的对象的 <code class="docutils literal"><span class="pre">value</span></code> 属性值为 <code class="docutils literal"><span class="pre">undefined</span></code> 。</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last"><code class="docutils literal"><span class="pre">yield</span></code> 表达式后面的表达式，只有当调用 <code class="docutils literal"><span class="pre">next</span></code> 方法、内部指针指向该语句时才会执行，因此等于为 <code class="docutils literal"><span class="pre">JavaScript</span></code> 提供了手动的“惰性求值”（ Lazy Evaluation ）的语法功能。</p>
</div>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">gen</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span>  <span class="mi">123</span> <span class="o">+</span> <span class="mi">456</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">yield</span></code> 后面的表达式 <code class="docutils literal"><span class="pre">123</span> <span class="pre">+</span> <span class="pre">456</span></code> ，不会立即求值，只会在 <code class="docutils literal"><span class="pre">next</span></code> 方法将指针移到这一句时，才会求值。</p>
<p><code class="docutils literal"><span class="pre">yield</span></code> 表达式与 <code class="docutils literal"><span class="pre">return</span></code> 语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到 <code class="docutils literal"><span class="pre">yield</span></code> ，函数暂停执行，下一次再从该位置继续向后执行，而 <code class="docutils literal"><span class="pre">return</span></code> 语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个） <code class="docutils literal"><span class="pre">return</span></code> 语句，但是可以执行多次（或者说多个） <code class="docutils literal"><span class="pre">yield</span></code> 表达式。正常函数只能返回一个值，因为只能执行一次 <code class="docutils literal"><span class="pre">return</span></code> ； <code class="docutils literal"><span class="pre">Generator</span></code> 函数可以返回一系列的值，因为可以有任意多个 <code class="docutils literal"><span class="pre">yield</span></code> 。从另一个角度看，也可以说 <code class="docutils literal"><span class="pre">Generator</span></code> 生成了一系列的值，这也就是它的名称的来历（英语中， <code class="docutils literal"><span class="pre">generator</span></code> 这个词是“生成器”的意思）。</p>
<p><code class="docutils literal"><span class="pre">Generator</span></code> 函数可以不用 <code class="docutils literal"><span class="pre">yield</span></code> 表达式，这时就变成了一个单纯的暂缓执行函数。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;执行了！&#39;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">generator</span> <span class="o">=</span> <span class="nx">f</span><span class="p">();</span>

<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">generator</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>
<span class="p">},</span> <span class="mi">2000</span><span class="p">);</span>
</pre></div>
</div>
<p>上面代码中，函数 <code class="docutils literal"><span class="pre">f</span></code> 如果是普通函数，在为变量 <code class="docutils literal"><span class="pre">generator</span></code> 赋值时就会执行。但是，函数 <code class="docutils literal"><span class="pre">f</span></code> 是一个 <code class="docutils literal"><span class="pre">Generator</span></code> 函数，就变成只有调用 <code class="docutils literal"><span class="pre">next</span></code> 方法时，函数 <code class="docutils literal"><span class="pre">f</span></code> 才会执行。</p>
<p>另外需要注意， <code class="docutils literal"><span class="pre">yield</span></code> 表达式只能用在 <code class="docutils literal"><span class="pre">Generator</span></code> 函数里面，用在其他地方都会报错。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="p">(</span><span class="kd">function</span> <span class="p">(){</span>
  <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">})()</span>
<span class="c1">// SyntaxError: Unexpected number</span>
</pre></div>
</div>
<p>上面代码在一个普通函数中使用 <code class="docutils literal"><span class="pre">yield</span></code> 表达式，结果产生一个句法错误。</p>
<p>下面是另外一个例子。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]];</span>

<span class="kd">var</span> <span class="nx">flat</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">a</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">item</span> <span class="o">!==</span> <span class="s1">&#39;number&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">yield</span><span class="o">*</span> <span class="nx">flat</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">yield</span> <span class="nx">item</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">});</span>
<span class="p">};</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">f</span> <span class="k">of</span> <span class="nx">flat</span><span class="p">(</span><span class="nx">arr</span><span class="p">)){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">f</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码也会产生句法错误，因为 <code class="docutils literal"><span class="pre">forEach</span></code> 方法的参数是一个普通函数，但是在里面使用了 <code class="docutils literal"><span class="pre">yield</span></code> 表达式（这个函数里面还使用了 <code class="docutils literal"><span class="pre">yield*</span></code> 表达式，详细介绍见后文）。一种修改方法是改用 <code class="docutils literal"><span class="pre">for</span></code> 循环。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]];</span>

<span class="kd">var</span> <span class="nx">flat</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">length</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">item</span> <span class="o">=</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">item</span> <span class="o">!==</span> <span class="s1">&#39;number&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">yield</span><span class="o">*</span> <span class="nx">flat</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">yield</span> <span class="nx">item</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">f</span> <span class="k">of</span> <span class="nx">flat</span><span class="p">(</span><span class="nx">arr</span><span class="p">))</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">f</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 1, 2, 3, 4, 5, 6</span>
</pre></div>
</div>
<p>另外， <code class="docutils literal"><span class="pre">yield</span></code> 表达式如果用在另一个表达式之中，必须放在圆括号里面。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">demo</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Hello&#39;</span> <span class="o">+</span> <span class="k">yield</span><span class="p">);</span> <span class="c1">// SyntaxError</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Hello&#39;</span> <span class="o">+</span> <span class="k">yield</span> <span class="mi">123</span><span class="p">);</span> <span class="c1">// SyntaxError</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Hello&#39;</span> <span class="o">+</span> <span class="p">(</span><span class="k">yield</span><span class="p">));</span> <span class="c1">// OK</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Hello&#39;</span> <span class="o">+</span> <span class="p">(</span><span class="k">yield</span> <span class="mi">123</span><span class="p">));</span> <span class="c1">// OK</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">yield</span></code> 表达式用作函数参数或放在赋值表达式的右边，可以不加括号。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">demo</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">foo</span><span class="p">(</span><span class="k">yield</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="k">yield</span> <span class="s1">&#39;b&#39;</span><span class="p">);</span> <span class="c1">// OK</span>
  <span class="kd">let</span> <span class="nx">input</span> <span class="o">=</span> <span class="k">yield</span><span class="p">;</span> <span class="c1">// OK</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="iterator">
<h3>17.1.3. 与 Iterator 接口的关系<a class="headerlink" href="#iterator" title="永久链接至标题">¶</a></h3>
<p>上一章说过，任意一个对象的 <code class="docutils literal"><span class="pre">Symbol.iterator</span></code> 方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。</p>
<p>由于 <code class="docutils literal"><span class="pre">Generator</span></code> 函数就是遍历器生成函数，因此可以把 <code class="docutils literal"><span class="pre">Generator</span></code> 赋值给对象的 <code class="docutils literal"><span class="pre">Symbol.iterator</span></code> 属性，从而使得该对象具有 <code class="docutils literal"><span class="pre">Iterator</span></code> 接口。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">myIterable</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nx">myIterable</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">[...</span><span class="nx">myIterable</span><span class="p">]</span> <span class="c1">// [1, 2, 3]</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">Generator</span></code> 函数赋值给 <code class="docutils literal"><span class="pre">Symbol.iterator</span></code> 属性，从而使得 <code class="docutils literal"><span class="pre">myIterable</span></code> 对象具有了 <code class="docutils literal"><span class="pre">Iterator</span></code> 接口，可以被 <code class="docutils literal"><span class="pre">...</span></code> 运算符遍历了。</p>
<p><code class="docutils literal"><span class="pre">Generator</span></code> 函数执行后，返回一个遍历器对象。该对象本身也具有 <code class="docutils literal"><span class="pre">Symbol.iterator</span></code> 属性，执行后返回自身。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">gen</span><span class="p">(){</span>
  <span class="c1">// some code</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">();</span>

<span class="nx">g</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]()</span> <span class="o">===</span> <span class="nx">g</span>
<span class="c1">// true</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">gen</span></code> 是一个 <code class="docutils literal"><span class="pre">Generator</span></code> 函数，调用它会生成一个遍历器对象 <code class="docutils literal"><span class="pre">g</span></code> 。它的 <code class="docutils literal"><span class="pre">Symbol.iterator</span></code> 属性，也是一个遍历器对象生成函数，执行后返回它自己。</p>
</div>
</div>
<div class="section" id="next">
<h2>17.2. next 方法的参数<a class="headerlink" href="#next" title="永久链接至标题">¶</a></h2>
<p><code class="docutils literal"><span class="pre">yield</span></code> <strong>表达式本身没有返回值</strong> ，或者说总是返回 <code class="docutils literal"><span class="pre">undefined</span></code> 。 <code class="docutils literal"><span class="pre">next</span></code> 方法可以带一个参数，该参数就会被当作上一个 <code class="docutils literal"><span class="pre">yield</span></code> 表达式的返回值。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="kc">true</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">reset</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">i</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">reset</span><span class="p">)</span> <span class="p">{</span> <span class="nx">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">f</span><span class="p">();</span>

<span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// { value: 0, done: false }</span>
<span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// { value: 1, done: false }</span>
<span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="c1">// { value: 0, done: false }</span>
</pre></div>
</div>
<p>上面代码先定义了一个可以无限运行的 <code class="docutils literal"><span class="pre">Generator</span></code> 函数 <code class="docutils literal"><span class="pre">f</span></code> ，如果 <code class="docutils literal"><span class="pre">next</span></code> 方法没有参数，每次运行到 <code class="docutils literal"><span class="pre">yield</span></code> 表达式，变量 <code class="docutils literal"><span class="pre">reset</span></code> 的值总是 <code class="docutils literal"><span class="pre">undefined</span></code> 。当 <code class="docutils literal"><span class="pre">next</span></code> 方法带一个参数 <code class="docutils literal"><span class="pre">true</span></code> 时，变量 <code class="docutils literal"><span class="pre">reset</span></code> 就被重置为这个参数（即 <code class="docutils literal"><span class="pre">true</span></code> ），因此 <code class="docutils literal"><span class="pre">i</span></code> 会等于 -1 ，下一轮循环就会从 -1 开始递增。</p>
<p>这个功能有很重要的语法意义。 <code class="docutils literal"><span class="pre">Generator</span></code> 函数从暂停状态到恢复运行，它的上下文状态（ <code class="docutils literal"><span class="pre">context</span></code> ）是不变的。通过 <code class="docutils literal"><span class="pre">next</span></code> 方法的参数，就有办法在 <code class="docutils literal"><span class="pre">Generator</span></code> 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 <code class="docutils literal"><span class="pre">Generator</span></code> 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。</p>
<p>再看一个例子。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="k">yield</span> <span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
  <span class="kd">var</span> <span class="nx">z</span> <span class="o">=</span> <span class="k">yield</span> <span class="p">(</span><span class="nx">y</span> <span class="o">/</span> <span class="mi">3</span><span class="p">);</span>
  <span class="k">return</span> <span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">z</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// Object{value:6, done:false}</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// Object{value:NaN, done:false}</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// Object{value:NaN, done:true}</span>

<span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="nx">b</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// { value:6, done:false }</span>
<span class="nx">b</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span> <span class="c1">// { value:8, done:false }</span>
<span class="nx">b</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="mi">13</span><span class="p">)</span> <span class="c1">// { value:42, done:true }</span>
</pre></div>
</div>
<p>上面代码中，第二次运行 <code class="docutils literal"><span class="pre">next</span></code> 方法的时候不带参数，导致 <code class="docutils literal"><span class="pre">y</span></code> 的值等于 <code class="docutils literal"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">undefined</span></code> （即 <code class="docutils literal"><span class="pre">NaN</span></code> ），除以 <code class="docutils literal"><span class="pre">3</span></code> 以后还是 <code class="docutils literal"><span class="pre">NaN</span></code> ，因此返回对象的 <code class="docutils literal"><span class="pre">value</span></code> 属性也等于 <code class="docutils literal"><span class="pre">NaN</span></code> 。第三次运行 <code class="docutils literal"><span class="pre">Next</span></code> 方法的时候不带参数，所以 <code class="docutils literal"><span class="pre">z</span></code> 等于 <code class="docutils literal"><span class="pre">undefined</span></code> ，返回对象的 <code class="docutils literal"><span class="pre">value</span></code> 属性等于 <code class="docutils literal"><span class="pre">5</span> <span class="pre">+</span> <span class="pre">NaN</span> <span class="pre">+</span> <span class="pre">undefined</span></code> ，即 <code class="docutils literal"><span class="pre">NaN</span></code> 。</p>
<p>如果向 <code class="docutils literal"><span class="pre">next</span></code> 方法提供参数，返回结果就完全不一样了。上面代码第一次调用 <code class="docutils literal"><span class="pre">b</span></code> 的 <code class="docutils literal"><span class="pre">next</span></code> 方法时，返回 <code class="docutils literal"><span class="pre">x+1</span></code> 的值 6 ；第二次调用 <code class="docutils literal"><span class="pre">next</span></code> 方法，将上一次 <code class="docutils literal"><span class="pre">yield</span></code> 表达式的值设为 12 ，因此y等于 24 ，返回 <code class="docutils literal"><span class="pre">y</span> <span class="pre">/</span> <span class="pre">3</span></code> 的值 8 ；第三次调用 <code class="docutils literal"><span class="pre">next</span></code> 方法，将上一次 <code class="docutils literal"><span class="pre">yield</span></code> 表达式的值设为 13 ，因此 <code class="docutils literal"><span class="pre">z</span></code> 等于 13 ，这时 <code class="docutils literal"><span class="pre">x</span></code> 等于 5 ， <code class="docutils literal"><span class="pre">y</span></code> 等于 24 ，所以 <code class="docutils literal"><span class="pre">return</span></code> 语句的值等于 42 。</p>
<p>注意，由于 <code class="docutils literal"><span class="pre">next</span></code> 方法的参数表示上一个 <code class="docutils literal"><span class="pre">yield</span></code> 表达式的返回值，所以在第一次使用 <code class="docutils literal"><span class="pre">next</span></code> 方法时，传递参数是无效的。 V8 引擎直接忽略第一次使用 <code class="docutils literal"><span class="pre">next</span></code> 方法时的参数，只有从第二次使用 <code class="docutils literal"><span class="pre">next</span></code> 方法开始，参数才是有效的。从语义上讲，第一个 <code class="docutils literal"><span class="pre">next</span></code> 方法用来启动遍历器对象，所以不用带有参数。</p>
<p>再看一个通过 <code class="docutils literal"><span class="pre">next</span></code> 方法的参数，向 <code class="docutils literal"><span class="pre">Generator</span></code> 函数内部输入值的例子。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">dataConsumer</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Started&#39;</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`1. </span><span class="si">${</span><span class="k">yield</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`2. </span><span class="si">${</span><span class="k">yield</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
  <span class="k">return</span> <span class="s1">&#39;result&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">genObj</span> <span class="o">=</span> <span class="nx">dataConsumer</span><span class="p">();</span>
<span class="nx">genObj</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
<span class="c1">// Started</span>
<span class="nx">genObj</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="c1">// 1. a</span>
<span class="nx">genObj</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="c1">// 2. b</span>
</pre></div>
</div>
<p>上面代码是一个很直观的例子，每次通过 <code class="docutils literal"><span class="pre">next</span></code> 方法向 <code class="docutils literal"><span class="pre">Generator</span></code> 函数输入值，然后打印出来。</p>
<p>如果想要第一次调用 <code class="docutils literal"><span class="pre">next</span></code> 方法时，就能够输入值，可以在 <code class="docutils literal"><span class="pre">Generator</span></code> 函数外面再包一层。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">wrapper</span><span class="p">(</span><span class="nx">generatorFunction</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="p">(...</span><span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">generatorObject</span> <span class="o">=</span> <span class="nx">generatorFunction</span><span class="p">(...</span><span class="nx">args</span><span class="p">);</span>
    <span class="nx">generatorObject</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
    <span class="k">return</span> <span class="nx">generatorObject</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">wrapped</span> <span class="o">=</span> <span class="nx">wrapper</span><span class="p">(</span><span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`First input: </span><span class="si">${</span><span class="k">yield</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
  <span class="k">return</span> <span class="s1">&#39;DONE&#39;</span><span class="p">;</span>
<span class="p">});</span>

<span class="nx">wrapped</span><span class="p">().</span><span class="nx">next</span><span class="p">(</span><span class="s1">&#39;hello!&#39;</span><span class="p">)</span>
<span class="c1">// First input: hello!</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">Generator</span></code> 函数如果不用 <code class="docutils literal"><span class="pre">wrapper</span></code> 先包一层，是无法第一次调用 <code class="docutils literal"><span class="pre">next</span></code> 方法，就输入参数的。</p>
</div>
<div class="section" id="for-of">
<h2>17.3. for…of 循环<a class="headerlink" href="#for-of" title="永久链接至标题">¶</a></h2>
<p><code class="docutils literal"><span class="pre">for...of</span></code> 循环可以自动遍历 <code class="docutils literal"><span class="pre">Generator</span></code> 函数时生成的 <code class="docutils literal"><span class="pre">Iterator</span></code> 对象，且此时不再需要调用 <code class="docutils literal"><span class="pre">next</span></code> 方法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
  <span class="k">yield</span> <span class="mi">4</span><span class="p">;</span>
  <span class="k">yield</span> <span class="mi">5</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">6</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">v</span> <span class="k">of</span> <span class="nx">foo</span><span class="p">())</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 1 2 3 4 5</span>
</pre></div>
</div>
<p>上面代码使用 <code class="docutils literal"><span class="pre">for...of</span></code> 循环，依次显示 5 个 <code class="docutils literal"><span class="pre">yield</span></code> 表达式的值。这里需要注意，一旦 <code class="docutils literal"><span class="pre">next</span></code> 方法的返回对象的 <code class="docutils literal"><span class="pre">done</span></code> 属性为 <code class="docutils literal"><span class="pre">true</span></code> ， <code class="docutils literal"><span class="pre">for...of</span></code> 循环就会中止，且不包含该返回对象，所以上面代码的 <code class="docutils literal"><span class="pre">return</span></code> 语句返回的 6 ，不包括在 <code class="docutils literal"><span class="pre">for...of</span></code> 循环之中。</p>
<p>下面是一个利用 <code class="docutils literal"><span class="pre">Generator</span></code> 函数和 <code class="docutils literal"><span class="pre">for...of</span></code> 循环，实现斐波那契数列的例子。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">fibonacci</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="p">[</span><span class="nx">prev</span><span class="p">,</span> <span class="nx">curr</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">];</span>
  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="k">yield</span> <span class="nx">curr</span><span class="p">;</span>
    <span class="p">[</span><span class="nx">prev</span><span class="p">,</span> <span class="nx">curr</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">curr</span><span class="p">,</span> <span class="nx">prev</span> <span class="o">+</span> <span class="nx">curr</span><span class="p">];</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">n</span> <span class="k">of</span> <span class="nx">fibonacci</span><span class="p">())</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">n</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>从上面代码可见，使用 <code class="docutils literal"><span class="pre">for...of</span></code> 语句时不需要使用 <code class="docutils literal"><span class="pre">next</span></code> 方法。</p>
<p>利用 <code class="docutils literal"><span class="pre">for...of</span></code> 循环，可以写出遍历任意对象（ <code class="docutils literal"><span class="pre">object</span></code> ）的方法。原生的 <code class="docutils literal"><span class="pre">JavaScript</span></code> 对象没有遍历接口，无法使用 <code class="docutils literal"><span class="pre">for...of</span></code> 循环，通过 <code class="docutils literal"><span class="pre">Generator</span></code> 函数为它加上这个接口，就可以用了。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">objectEntries</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">propKeys</span> <span class="o">=</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">ownKeys</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">propKey</span> <span class="k">of</span> <span class="nx">propKeys</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">yield</span> <span class="p">[</span><span class="nx">propKey</span><span class="p">,</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">propKey</span><span class="p">]];</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">jane</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">first</span><span class="o">:</span> <span class="s1">&#39;Jane&#39;</span><span class="p">,</span> <span class="nx">last</span><span class="o">:</span> <span class="s1">&#39;Doe&#39;</span> <span class="p">};</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">]</span> <span class="k">of</span> <span class="nx">objectEntries</span><span class="p">(</span><span class="nx">jane</span><span class="p">))</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`</span><span class="si">${</span><span class="nx">key</span><span class="si">}</span><span class="sb">: </span><span class="si">${</span><span class="nx">value</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// first: Jane</span>
<span class="c1">// last: Doe</span>
</pre></div>
</div>
<p>上面代码中，对象 <code class="docutils literal"><span class="pre">jane</span></code> 原生不具备 <code class="docutils literal"><span class="pre">Iterator</span></code> 接口，无法用 <code class="docutils literal"><span class="pre">for...of</span></code> 遍历。这时，我们通过 <code class="docutils literal"><span class="pre">Generator</span></code> 函数 <code class="docutils literal"><span class="pre">objectEntries</span></code> 为它加上遍历器接口，就可以用 <code class="docutils literal"><span class="pre">for...of</span></code> 遍历了。加上遍历器接口的另一种写法是，将 <code class="docutils literal"><span class="pre">Generator</span></code> 函数加到对象的 <code class="docutils literal"><span class="pre">Symbol.iterator</span></code> 属性上面。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">objectEntries</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">propKeys</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">propKey</span> <span class="k">of</span> <span class="nx">propKeys</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">yield</span> <span class="p">[</span><span class="nx">propKey</span><span class="p">,</span> <span class="k">this</span><span class="p">[</span><span class="nx">propKey</span><span class="p">]];</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">jane</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">first</span><span class="o">:</span> <span class="s1">&#39;Jane&#39;</span><span class="p">,</span> <span class="nx">last</span><span class="o">:</span> <span class="s1">&#39;Doe&#39;</span> <span class="p">};</span>

<span class="nx">jane</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]</span> <span class="o">=</span> <span class="nx">objectEntries</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">]</span> <span class="k">of</span> <span class="nx">jane</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`</span><span class="si">${</span><span class="nx">key</span><span class="si">}</span><span class="sb">: </span><span class="si">${</span><span class="nx">value</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// first: Jane</span>
<span class="c1">// last: Doe</span>
</pre></div>
</div>
<p>除了 <code class="docutils literal"><span class="pre">for...of</span></code> 循环以外，扩展运算符（ <code class="docutils literal"><span class="pre">...</span></code> ）、解构赋值和 <code class="docutils literal"><span class="pre">Array.from</span></code> 方法内部调用的，都是遍历器接口。这意味着，它们都可以将 <code class="docutils literal"><span class="pre">Generator</span></code> 函数返回的 <code class="docutils literal"><span class="pre">Iterator</span></code> 对象，作为参数。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">numbers</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="mi">1</span>
  <span class="k">yield</span> <span class="mi">2</span>
  <span class="k">return</span> <span class="mi">3</span>
  <span class="k">yield</span> <span class="mi">4</span>
<span class="p">}</span>

<span class="c1">// 扩展运算符</span>
<span class="p">[...</span><span class="nx">numbers</span><span class="p">()]</span> <span class="c1">// [1, 2]</span>

<span class="c1">// Array.from 方法</span>
<span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">(</span><span class="nx">numbers</span><span class="p">())</span> <span class="c1">// [1, 2]</span>

<span class="c1">// 解构赋值</span>
<span class="kd">let</span> <span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">]</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">();</span>
<span class="nx">x</span> <span class="c1">// 1</span>
<span class="nx">y</span> <span class="c1">// 2</span>

<span class="c1">// for...of 循环</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">n</span> <span class="k">of</span> <span class="nx">numbers</span><span class="p">())</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// 1</span>
<span class="c1">// 2</span>
</pre></div>
</div>
</div>
<div class="section" id="generator-prototype-throw">
<h2>17.4. Generator.prototype.throw()<a class="headerlink" href="#generator-prototype-throw" title="永久链接至标题">¶</a></h2>
<p><code class="docutils literal"><span class="pre">Generator</span></code> 函数返回的遍历器对象，都有一个 <code class="docutils literal"><span class="pre">throw</span></code> 方法，可以在函数体外抛出错误，然后在 <code class="docutils literal"><span class="pre">Generator</span></code> 函数体内捕获。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="k">yield</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;内部捕获&#39;</span><span class="p">,</span> <span class="nx">e</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">g</span><span class="p">();</span>
<span class="nx">i</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>

<span class="k">try</span> <span class="p">{</span>
  <span class="nx">i</span><span class="p">.</span><span class="k">throw</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">);</span>
  <span class="nx">i</span><span class="p">.</span><span class="k">throw</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">);</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;外部捕获&#39;</span><span class="p">,</span> <span class="nx">e</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 内部捕获 a</span>
<span class="c1">// 外部捕获 b</span>
</pre></div>
</div>
<p>上面代码中，遍历器对象 <code class="docutils literal"><span class="pre">i</span></code> 连续抛出两个错误。第一个错误被 <code class="docutils literal"><span class="pre">Generator</span></code> 函数体内的 <code class="docutils literal"><span class="pre">catch</span></code> 语句捕获。<code class="docutils literal"><span class="pre">i</span></code> 第二次抛出错误，由于 <code class="docutils literal"><span class="pre">Generator</span></code> 函数内部的 <code class="docutils literal"><span class="pre">catch</span></code> 语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 <code class="docutils literal"><span class="pre">Generator</span></code> 函数体，被函数体外的 <code class="docutils literal"><span class="pre">catch</span></code> 语句捕获。</p>
<p><code class="docutils literal"><span class="pre">throw</span></code> 方法可以接受一个参数，该参数会被 <code class="docutils literal"><span class="pre">catch</span></code> 语句接收，建议抛出 <code class="docutils literal"><span class="pre">Error</span></code> 对象的实例。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="k">yield</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">g</span><span class="p">();</span>
<span class="nx">i</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
<span class="nx">i</span><span class="p">.</span><span class="k">throw</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;出错了！&#39;</span><span class="p">));</span>
<span class="c1">// Error: 出错了！(…)</span>
</pre></div>
</div>
<p>注意，不要混淆遍历器对象的 <code class="docutils literal"><span class="pre">throw</span></code> 方法和全局的 <code class="docutils literal"><span class="pre">throw</span></code> 命令。上面代码的错误，是用遍历器对象的 <code class="docutils literal"><span class="pre">throw</span></code> 方法抛出的，而不是用 <code class="docutils literal"><span class="pre">throw</span></code> 命令抛出的。后者只能被函数体外的 <code class="docutils literal"><span class="pre">catch</span></code> 语句捕获。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
      <span class="k">yield</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">e</span> <span class="o">!=</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="k">throw</span> <span class="nx">e</span><span class="p">;</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;内部捕获&#39;</span><span class="p">,</span> <span class="nx">e</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">g</span><span class="p">();</span>
<span class="nx">i</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>

<span class="k">try</span> <span class="p">{</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">);</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">);</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;外部捕获&#39;</span><span class="p">,</span> <span class="nx">e</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 外部捕获 [Error: a]</span>
</pre></div>
</div>
<p>上面代码之所以只捕获了 <code class="docutils literal"><span class="pre">a</span></code> ，是因为函数体外的 <code class="docutils literal"><span class="pre">catch</span></code> 语句块，捕获了抛出的 <code class="docutils literal"><span class="pre">a</span></code> 错误以后，就不会再继续 <code class="docutils literal"><span class="pre">try</span></code> 代码块里面剩余的语句了。</p>
<p>如果 <code class="docutils literal"><span class="pre">Generator</span></code> 函数内部没有部署 <code class="docutils literal"><span class="pre">try...catch</span></code> 代码块，那么 <code class="docutils literal"><span class="pre">throw</span></code> 方法抛出的错误，将被外部 <code class="docutils literal"><span class="pre">try...catch</span></code> 代码块捕获。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">yield</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;内部捕获&#39;</span><span class="p">,</span> <span class="nx">e</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">g</span><span class="p">();</span>
<span class="nx">i</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>

<span class="k">try</span> <span class="p">{</span>
  <span class="nx">i</span><span class="p">.</span><span class="k">throw</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">);</span>
  <span class="nx">i</span><span class="p">.</span><span class="k">throw</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">);</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;外部捕获&#39;</span><span class="p">,</span> <span class="nx">e</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 外部捕获 a</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">Generator</span></code> 函数 <code class="docutils literal"><span class="pre">g</span></code> 内部没有部署 <code class="docutils literal"><span class="pre">try...catch</span></code> 代码块，所以抛出的错误直接被外部 <code class="docutils literal"><span class="pre">catch</span></code> 代码块捕获。</p>
<p>如果 <code class="docutils literal"><span class="pre">Generator</span></code> 函数内部和外部，都没有部署 <code class="docutils literal"><span class="pre">try...catch</span></code> 代码块，那么程序将报错，直接中断执行。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">gen</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="nx">gen</span><span class="p">(){</span>
  <span class="k">yield</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">);</span>
  <span class="k">yield</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;world&#39;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">();</span>
<span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
<span class="nx">g</span><span class="p">.</span><span class="k">throw</span><span class="p">();</span>
<span class="c1">// hello</span>
<span class="c1">// Uncaught undefined</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">g.throw</span></code> 抛出错误以后，没有任何 <code class="docutils literal"><span class="pre">try...catch</span></code> 代码块可以捕获这个错误，导致程序报错，中断执行。</p>
<p><code class="docutils literal"><span class="pre">throw</span></code> 方法抛出的错误要被内部捕获，前提是必须至少执行过一次 <code class="docutils literal"><span class="pre">next</span></code> 方法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">gen</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;内部捕获&#39;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">();</span>
<span class="nx">g</span><span class="p">.</span><span class="k">throw</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="c1">// Uncaught 1</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">g.throw(1)</span></code> 执行时， <code class="docutils literal"><span class="pre">next</span></code> 方法一次都没有执行过。这时，抛出的错误不会被内部捕获，而是直接在外部抛出，导致程序出错。这种行为其实很好理解，因为第一次执行 <code class="docutils literal"><span class="pre">next</span></code> 方法，等同于启动执行 <code class="docutils literal"><span class="pre">Generator</span></code> 函数的内部代码，否则 <code class="docutils literal"><span class="pre">Generator</span></code> 函数还没有开始执行，这时 <code class="docutils literal"><span class="pre">throw</span></code> 方法抛错只可能抛出在函数外部。</p>
<p><code class="docutils literal"><span class="pre">throw</span></code> 方法被捕获以后，会附带执行下一条 <code class="docutils literal"><span class="pre">yield</span></code> 表达式。也就是说，会附带执行一次 <code class="docutils literal"><span class="pre">next</span></code> 方法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">gen</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="nx">gen</span><span class="p">(){</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="k">yield</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
  <span class="k">yield</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">);</span>
  <span class="k">yield</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">();</span>
<span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// a</span>
<span class="nx">g</span><span class="p">.</span><span class="k">throw</span><span class="p">()</span> <span class="c1">// b</span>
<span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// c</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">g.throw</span></code> 方法被捕获以后，自动执行了一次 <code class="docutils literal"><span class="pre">next</span></code> 方法，所以会打印 <code class="docutils literal"><span class="pre">b</span></code> 。另外，也可以看到，只要 <code class="docutils literal"><span class="pre">Generator</span></code> 函数内部部署了 <code class="docutils literal"><span class="pre">try...catch</span></code> 代码块，那么遍历器的 <code class="docutils literal"><span class="pre">throw</span></code> 方法抛出的错误，不影响下一次遍历。</p>
<p>另外， <code class="docutils literal"><span class="pre">throw</span></code> 命令与 <code class="docutils literal"><span class="pre">g.throw</span></code> 方法是无关的，两者互不影响。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">gen</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="nx">gen</span><span class="p">(){</span>
  <span class="k">yield</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">);</span>
  <span class="k">yield</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;world&#39;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">();</span>
<span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>

<span class="k">try</span> <span class="p">{</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">();</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
<span class="p">}</span>
<span class="c1">// hello</span>
<span class="c1">// world</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">throw</span></code> 命令抛出的错误不会影响到遍历器的状态，所以两次执行 <code class="docutils literal"><span class="pre">next</span></code> 方法，都进行了正确的操作。</p>
<p>这种函数体内捕获错误的机制，大大方便了对错误的处理。多个 <code class="docutils literal"><span class="pre">yield</span></code> 表达式，可以只用一个 <code class="docutils literal"><span class="pre">try...catch</span></code> 代码块来捕获错误。如果使用回调函数的写法，想要捕获多个错误，就不得不为每个函数内部写一个错误处理语句，现在只在 <code class="docutils literal"><span class="pre">Generator</span></code> 函数内部写一次 <code class="docutils literal"><span class="pre">catch</span></code> 语句就可以了。</p>
<p><code class="docutils literal"><span class="pre">Generator</span></code> 函数体外抛出的错误，可以在函数体内捕获；反过来， <code class="docutils literal"><span class="pre">Generator</span></code> 函数体内抛出的错误，也可以被函数体外的 <code class="docutils literal"><span class="pre">catch</span></code> 捕获。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">x</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">();</span>
  <span class="k">yield</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">it</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">();</span>

<span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span> <span class="c1">// { value:3, done:false }</span>

<span class="k">try</span> <span class="p">{</span>
  <span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码中，第二个 <code class="docutils literal"><span class="pre">next</span></code> 方法向函数体内传入一个参数 42 ，数值是没有 <code class="docutils literal"><span class="pre">toUpperCase</span></code> 方法的，所以会抛出一个 <code class="docutils literal"><span class="pre">TypeError</span></code> 错误，被函数体外的 <code class="docutils literal"><span class="pre">catch</span></code> 捕获。</p>
<p>一旦 <code class="docutils literal"><span class="pre">Generator</span></code> 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用 <code class="docutils literal"><span class="pre">next</span></code> 方法，将返回一个 <code class="docutils literal"><span class="pre">value</span></code> 属性等于 <code class="docutils literal"><span class="pre">undefined</span></code> 、 <code class="docutils literal"><span class="pre">done</span></code> 属性等于 <code class="docutils literal"><span class="pre">true</span></code> 的对象，即 <code class="docutils literal"><span class="pre">JavaScript</span></code> 引擎认为这个 <code class="docutils literal"><span class="pre">Generator</span></code> 已经运行结束了。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">g</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;throwing an exception&#39;</span><span class="p">);</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;generator broke!&#39;</span><span class="p">);</span>
  <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">log</span><span class="p">(</span><span class="nx">generator</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">v</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;starting generator&#39;</span><span class="p">);</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="nx">v</span> <span class="o">=</span> <span class="nx">generator</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;第一次运行next方法&#39;</span><span class="p">,</span> <span class="nx">v</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;捕捉错误&#39;</span><span class="p">,</span> <span class="nx">v</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="nx">v</span> <span class="o">=</span> <span class="nx">generator</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;第二次运行next方法&#39;</span><span class="p">,</span> <span class="nx">v</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;捕捉错误&#39;</span><span class="p">,</span> <span class="nx">v</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="nx">v</span> <span class="o">=</span> <span class="nx">generator</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;第三次运行next方法&#39;</span><span class="p">,</span> <span class="nx">v</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;捕捉错误&#39;</span><span class="p">,</span> <span class="nx">v</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;caller done&#39;</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">log</span><span class="p">(</span><span class="nx">g</span><span class="p">());</span>
<span class="c1">// starting generator</span>
<span class="c1">// 第一次运行next方法 { value: 1, done: false }</span>
<span class="c1">// throwing an exception</span>
<span class="c1">// 捕捉错误 { value: 1, done: false }</span>
<span class="c1">// 第三次运行next方法 { value: undefined, done: true }</span>
<span class="c1">// caller done</span>
</pre></div>
</div>
<p>上面代码一共三次运行 <code class="docutils literal"><span class="pre">next</span></code> 方法，第二次运行的时候会抛出错误，然后第三次运行的时候， <code class="docutils literal"><span class="pre">Generator</span></code> 函数就已经结束了，不再执行下去了。</p>
</div>
<div class="section" id="generator-prototype-return">
<h2>17.5. Generator.prototype.return()<a class="headerlink" href="#generator-prototype-return" title="永久链接至标题">¶</a></h2>
<p><code class="docutils literal"><span class="pre">Generator</span></code> 函数返回的遍历器对象，还有一个 <code class="docutils literal"><span class="pre">return</span></code> 方法，可以返回给定的值，并且终结遍历 <code class="docutils literal"><span class="pre">Generator</span></code> 函数。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">gen</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">();</span>

<span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>        <span class="c1">// { value: 1, done: false }</span>
<span class="nx">g</span><span class="p">.</span><span class="k">return</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span> <span class="c1">// { value: &quot;foo&quot;, done: true }</span>
<span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>        <span class="c1">// { value: undefined, done: true }</span>
</pre></div>
</div>
<p>上面代码中，遍历器对象 <code class="docutils literal"><span class="pre">g</span></code> 调用 <code class="docutils literal"><span class="pre">return</span></code> 方法后，返回值的 <code class="docutils literal"><span class="pre">value</span></code> 属性就是 <code class="docutils literal"><span class="pre">return</span></code> 方法的参数 <code class="docutils literal"><span class="pre">foo</span></code> 。并且， <code class="docutils literal"><span class="pre">Generator</span></code> 函数的遍历就终止了，返回值的 <code class="docutils literal"><span class="pre">done</span></code> 属性为 <code class="docutils literal"><span class="pre">true</span></code> ，以后再调用 <code class="docutils literal"><span class="pre">next</span></code> 方法， <code class="docutils literal"><span class="pre">done</span></code> 属性总是返回 <code class="docutils literal"><span class="pre">true</span></code> 。</p>
<p>如果 <code class="docutils literal"><span class="pre">return</span></code> 方法调用时，不提供参数，则返回值的 <code class="docutils literal"><span class="pre">value</span></code> 属性为 <code class="docutils literal"><span class="pre">undefined</span></code> 。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">gen</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">();</span>

<span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>        <span class="c1">// { value: 1, done: false }</span>
<span class="nx">g</span><span class="p">.</span><span class="k">return</span><span class="p">()</span> <span class="c1">// { value: undefined, done: true }</span>
</pre></div>
</div>
<p>如果 <code class="docutils literal"><span class="pre">Generator</span></code> 函数内部有 <code class="docutils literal"><span class="pre">try...finally</span></code> 代码块，那么 <code class="docutils literal"><span class="pre">return</span></code> 方法会推迟到 <code class="docutils literal"><span class="pre">finally</span></code> 代码块执行完再执行。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">numbers</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
    <span class="k">yield</span> <span class="mi">4</span><span class="p">;</span>
    <span class="k">yield</span> <span class="mi">5</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">yield</span> <span class="mi">6</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">();</span>
<span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// { value: 1, done: false }</span>
<span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// { value: 2, done: false }</span>
<span class="nx">g</span><span class="p">.</span><span class="k">return</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span> <span class="c1">// { value: 4, done: false }</span>
<span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// { value: 5, done: false }</span>
<span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// { value: 7, done: true }</span>
</pre></div>
</div>
<p>上面代码中，调用 <code class="docutils literal"><span class="pre">return</span></code> 方法后，就开始执行 <code class="docutils literal"><span class="pre">finally</span></code> 代码块，然后等到 <code class="docutils literal"><span class="pre">finally</span></code> 代码块执行完，再执行 <code class="docutils literal"><span class="pre">return</span></code> 方法。</p>
</div>
<div class="section" id="next-throw-return">
<h2>17.6. next()、throw()、return() 的共同点<a class="headerlink" href="#next-throw-return" title="永久链接至标题">¶</a></h2>
<p><code class="docutils literal"><span class="pre">next()</span></code> 、 <code class="docutils literal"><span class="pre">throw()</span></code> 、 <code class="docutils literal"><span class="pre">return()</span></code> 这三个方法本质上是同一件事，可以放在一起理解。它们的作用都是让 <code class="docutils literal"><span class="pre">Generator</span></code> 函数恢复执行，并且使用不同的语句替换 <code class="docutils literal"><span class="pre">yield</span></code> 表达式。</p>
<p><code class="docutils literal"><span class="pre">next()</span></code> 是将 <code class="docutils literal"><span class="pre">yield</span></code> 表达式替换成一个值。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">g</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">};</span>

<span class="kr">const</span> <span class="nx">gen</span> <span class="o">=</span> <span class="nx">g</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="nx">gen</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span> <span class="c1">// Object {value: 3, done: false}</span>

<span class="nx">gen</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// Object {value: 1, done: true}</span>
<span class="c1">// 相当于将 let result = yield x + y</span>
<span class="c1">// 替换成 let result = 1;</span>
</pre></div>
</div>
<p>上面代码中，第二个 <code class="docutils literal"><span class="pre">next(1)</span></code> 方法就相当于将 <code class="docutils literal"><span class="pre">yield</span></code> 表达式替换成一个值 1 。如果 <code class="docutils literal"><span class="pre">next</span></code> 方法没有参数，就相当于替换成 <code class="docutils literal"><span class="pre">undefined</span></code> 。</p>
<p><code class="docutils literal"><span class="pre">throw()</span></code> 是将 <code class="docutils literal"><span class="pre">yield</span></code> 表达式替换成一个 <code class="docutils literal"><span class="pre">throw</span></code> 语句。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">gen</span><span class="p">.</span><span class="k">throw</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;出错了&#39;</span><span class="p">));</span> <span class="c1">// Uncaught Error: 出错了</span>
<span class="c1">// 相当于将 let result = yield x + y</span>
<span class="c1">// 替换成 let result = throw(new Error(&#39;出错了&#39;));</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">return()</span></code> 是将 <code class="docutils literal"><span class="pre">yield</span></code> 表达式替换成一个 <code class="docutils literal"><span class="pre">return</span></code> 语句。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">gen</span><span class="p">.</span><span class="k">return</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// Object {value: 2, done: true}</span>
<span class="c1">// 相当于将 let result = yield x + y</span>
<span class="c1">// 替换成 let result = return 2;</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h2>17.7. yield* 表达式<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>如果在 <code class="docutils literal"><span class="pre">Generator</span></code> 函数内部，调用另一个 <code class="docutils literal"><span class="pre">Generator</span></code> 函数，默认情况下是没有效果的。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="s1">&#39;a&#39;</span><span class="p">;</span>
  <span class="k">yield</span> <span class="s1">&#39;b&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span><span class="o">*</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="s1">&#39;x&#39;</span><span class="p">;</span>
  <span class="nx">foo</span><span class="p">();</span>
  <span class="k">yield</span> <span class="s1">&#39;y&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">v</span> <span class="k">of</span> <span class="nx">bar</span><span class="p">()){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// &quot;x&quot;</span>
<span class="c1">// &quot;y&quot;</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">foo</span></code> 和 <code class="docutils literal"><span class="pre">bar</span></code> 都是 <code class="docutils literal"><span class="pre">Generator</span></code> 函数，在 <code class="docutils literal"><span class="pre">bar</span></code> 里面调用 <code class="docutils literal"><span class="pre">foo</span></code> ，是不会有效果的。</p>
<p>这个就需要用到 <code class="docutils literal"><span class="pre">yield*</span></code> 表达式，用来在一个 <code class="docutils literal"><span class="pre">Generator</span></code> 函数里面执行另一个 <code class="docutils literal"><span class="pre">Generator</span></code> 函数。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="s1">&#39;x&#39;</span><span class="p">;</span>
  <span class="k">yield</span><span class="o">*</span> <span class="nx">foo</span><span class="p">();</span>
  <span class="k">yield</span> <span class="s1">&#39;y&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 等同于</span>
<span class="kd">function</span><span class="o">*</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="s1">&#39;x&#39;</span><span class="p">;</span>
  <span class="k">yield</span> <span class="s1">&#39;a&#39;</span><span class="p">;</span>
  <span class="k">yield</span> <span class="s1">&#39;b&#39;</span><span class="p">;</span>
  <span class="k">yield</span> <span class="s1">&#39;y&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 等同于</span>
<span class="kd">function</span><span class="o">*</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="s1">&#39;x&#39;</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">v</span> <span class="k">of</span> <span class="nx">foo</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">yield</span> <span class="nx">v</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">yield</span> <span class="s1">&#39;y&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">v</span> <span class="k">of</span> <span class="nx">bar</span><span class="p">()){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// &quot;x&quot;</span>
<span class="c1">// &quot;a&quot;</span>
<span class="c1">// &quot;b&quot;</span>
<span class="c1">// &quot;y&quot;</span>
</pre></div>
</div>
<p>再来看一个对比的例子。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">inner</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="s1">&#39;hello!&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span><span class="o">*</span> <span class="nx">outer1</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="s1">&#39;open&#39;</span><span class="p">;</span>
  <span class="k">yield</span> <span class="nx">inner</span><span class="p">();</span>
  <span class="k">yield</span> <span class="s1">&#39;close&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">gen</span> <span class="o">=</span> <span class="nx">outer1</span><span class="p">()</span>
<span class="nx">gen</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span> <span class="c1">// &quot;open&quot;</span>
<span class="nx">gen</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span> <span class="c1">// 返回一个遍历器对象</span>
<span class="nx">gen</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span> <span class="c1">// &quot;close&quot;</span>

<span class="kd">function</span><span class="o">*</span> <span class="nx">outer2</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="s1">&#39;open&#39;</span>
  <span class="k">yield</span><span class="o">*</span> <span class="nx">inner</span><span class="p">()</span>
  <span class="k">yield</span> <span class="s1">&#39;close&#39;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">gen</span> <span class="o">=</span> <span class="nx">outer2</span><span class="p">()</span>
<span class="nx">gen</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span> <span class="c1">// &quot;open&quot;</span>
<span class="nx">gen</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span> <span class="c1">// &quot;hello!&quot;</span>
<span class="nx">gen</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span> <span class="c1">// &quot;close&quot;</span>
</pre></div>
</div>
<p>上面例子中， <code class="docutils literal"><span class="pre">outer2</span></code> 使用了 <code class="docutils literal"><span class="pre">yield*</span></code> ， <code class="docutils literal"><span class="pre">outer1</span></code> 没使用。结果就是， <code class="docutils literal"><span class="pre">outer1</span></code> 返回一个遍历器对象， <code class="docutils literal"><span class="pre">outer2</span></code> 返回该遍历器对象的内部值。</p>
<p>从语法角度看，如果 <code class="docutils literal"><span class="pre">yield</span></code> 表达式后面跟的是一个遍历器对象，需要在 <code class="docutils literal"><span class="pre">yield</span></code> 表达式后面加上星号，表明它返回的是一个遍历器对象。这被称为 <code class="docutils literal"><span class="pre">yield*</span></code> 表达式。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">delegatedIterator</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="s1">&#39;Hello!&#39;</span><span class="p">;</span>
  <span class="k">yield</span> <span class="s1">&#39;Bye!&#39;</span><span class="p">;</span>
<span class="p">}());</span>

<span class="kd">let</span> <span class="nx">delegatingIterator</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="s1">&#39;Greetings!&#39;</span><span class="p">;</span>
  <span class="k">yield</span><span class="o">*</span> <span class="nx">delegatedIterator</span><span class="p">;</span>
  <span class="k">yield</span> <span class="s1">&#39;Ok, bye.&#39;</span><span class="p">;</span>
<span class="p">}());</span>

<span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">value</span> <span class="k">of</span> <span class="nx">delegatingIterator</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// &quot;Greetings!</span>
<span class="c1">// &quot;Hello!&quot;</span>
<span class="c1">// &quot;Bye!&quot;</span>
<span class="c1">// &quot;Ok, bye.&quot;</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">delegatingIterator</span></code> 是代理者， <code class="docutils literal"><span class="pre">delegatedIterator</span></code> 是被代理者。由于 <code class="docutils literal"><span class="pre">yield*</span> <span class="pre">delegatedIterator</span></code> 语句得到的值，是一个遍历器，所以要用星号表示。运行结果就是使用一个遍历器，遍历了多个 <code class="docutils literal"><span class="pre">Generator</span></code> 函数，有递归的效果。</p>
<p><code class="docutils literal"><span class="pre">yield*</span></code> 后面的 <code class="docutils literal"><span class="pre">Generator</span></code> 函数（没有 <code class="docutils literal"><span class="pre">return</span></code> 语句时），等同于在 <code class="docutils literal"><span class="pre">Generator</span></code> 函数内部，部署一个 <code class="docutils literal"><span class="pre">for...of</span></code> 循环。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">concat</span><span class="p">(</span><span class="nx">iter1</span><span class="p">,</span> <span class="nx">iter2</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">yield</span><span class="o">*</span> <span class="nx">iter1</span><span class="p">;</span>
  <span class="k">yield</span><span class="o">*</span> <span class="nx">iter2</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 等同于</span>

<span class="kd">function</span><span class="o">*</span> <span class="nx">concat</span><span class="p">(</span><span class="nx">iter1</span><span class="p">,</span> <span class="nx">iter2</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">value</span> <span class="k">of</span> <span class="nx">iter1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">yield</span> <span class="nx">value</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">value</span> <span class="k">of</span> <span class="nx">iter2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">yield</span> <span class="nx">value</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码说明， <code class="docutils literal"><span class="pre">yield*</span></code> 后面的 <code class="docutils literal"><span class="pre">Generator</span></code> 函数（没有 <code class="docutils literal"><span class="pre">return</span></code> 语句时），不过是 <code class="docutils literal"><span class="pre">for...of</span></code> 的一种简写形式，完全可以用后者替代前者。反之，在有 <code class="docutils literal"><span class="pre">return</span></code> 语句时，则需要用 <code class="docutils literal"><span class="pre">var</span> <span class="pre">value</span> <span class="pre">=</span> <span class="pre">yield*</span> <span class="pre">iterator</span></code> 的形式获取 <code class="docutils literal"><span class="pre">return</span></code> 语句的值。</p>
<p>如果 <code class="docutils literal"><span class="pre">yield*</span></code> 后面跟着一个数组，由于数组原生支持遍历器，因此就会遍历数组成员。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">gen</span><span class="p">(){</span>
  <span class="k">yield</span><span class="o">*</span> <span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">];</span>
<span class="p">}</span>

<span class="nx">gen</span><span class="p">().</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// { value:&quot;a&quot;, done:false }</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">yield</span></code> 命令后面如果不加星号，返回的是整个数组，加了星号就表示返回的是数组的遍历器对象。</p>
<p>实际上，任何数据结构只要有 <code class="docutils literal"><span class="pre">Iterator</span></code> 接口，就可以被 <code class="docutils literal"><span class="pre">yield*</span></code> 遍历。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">read</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="s1">&#39;hello&#39;</span><span class="p">;</span>
  <span class="k">yield</span><span class="o">*</span> <span class="s1">&#39;hello&#39;</span><span class="p">;</span>
<span class="p">})();</span>

<span class="nx">read</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span> <span class="c1">// &quot;hello&quot;</span>
<span class="nx">read</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span> <span class="c1">// &quot;h&quot;</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">yield</span></code> 表达式返回整个字符串， <code class="docutils literal"><span class="pre">yield*</span></code> 语句返回单个字符。因为字符串具有 <code class="docutils literal"><span class="pre">Iterator</span></code> 接口，所以被 <code class="docutils literal"><span class="pre">yield*</span></code> 遍历。</p>
<p>如果被代理的 <code class="docutils literal"><span class="pre">Generator</span></code> 函数有 <code class="docutils literal"><span class="pre">return</span></code> 语句，那么就可以向代理它的 <code class="docutils literal"><span class="pre">Generator</span></code> 函数返回数据。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
  <span class="k">return</span> <span class="s2">&quot;foo&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span><span class="o">*</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">v</span> <span class="o">=</span> <span class="k">yield</span><span class="o">*</span> <span class="nx">foo</span><span class="p">();</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;v: &quot;</span> <span class="o">+</span> <span class="nx">v</span><span class="p">);</span>
  <span class="k">yield</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">it</span> <span class="o">=</span> <span class="nx">bar</span><span class="p">();</span>

<span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>
<span class="c1">// {value: 1, done: false}</span>
<span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>
<span class="c1">// {value: 2, done: false}</span>
<span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>
<span class="c1">// {value: 3, done: false}</span>
<span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
<span class="c1">// &quot;v: foo&quot;</span>
<span class="c1">// {value: 4, done: false}</span>
<span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>
<span class="c1">// {value: undefined, done: true}</span>
</pre></div>
</div>
<p>上面代码在第四次调用 <code class="docutils literal"><span class="pre">next</span></code> 方法的时候，屏幕上会有输出，这是因为函数 <code class="docutils literal"><span class="pre">foo</span></code> 的 <code class="docutils literal"><span class="pre">return</span></code> 语句，向函数 <code class="docutils literal"><span class="pre">bar</span></code> 提供了返回值。</p>
<p>再看一个例子。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">genFuncWithReturn</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="s1">&#39;a&#39;</span><span class="p">;</span>
  <span class="k">yield</span> <span class="s1">&#39;b&#39;</span><span class="p">;</span>
  <span class="k">return</span> <span class="s1">&#39;The result&#39;</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">function</span><span class="o">*</span> <span class="nx">logReturned</span><span class="p">(</span><span class="nx">genObj</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">yield</span><span class="o">*</span> <span class="nx">genObj</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">[...</span><span class="nx">logReturned</span><span class="p">(</span><span class="nx">genFuncWithReturn</span><span class="p">())]</span>
<span class="c1">// The result</span>
<span class="c1">// 值为 [ &#39;a&#39;, &#39;b&#39; ]</span>
</pre></div>
</div>
<p>上面代码中，存在两次遍历。第一次是扩展运算符遍历函数 <code class="docutils literal"><span class="pre">logReturned</span></code> 返回的遍历器对象，第二次是 <code class="docutils literal"><span class="pre">yield*</span></code> 语句遍历函数 <code class="docutils literal"><span class="pre">genFuncWithReturn</span></code> 返回的遍历器对象。这两次遍历的效果是叠加的，最终表现为扩展运算符遍历函数 <code class="docutils literal"><span class="pre">genFuncWithReturn</span></code> 返回的遍历器对象。所以，最后的数据表达式得到的值等于 <code class="docutils literal"><span class="pre">[</span> <span class="pre">'a',</span> <span class="pre">'b'</span> <span class="pre">]</span></code> 。但是，函数 <code class="docutils literal"><span class="pre">genFuncWithReturn</span></code> 的 <code class="docutils literal"><span class="pre">return</span></code> 语句的返回值 <code class="docutils literal"><span class="pre">The</span> <span class="pre">result</span></code> ，会返回给函数 <code class="docutils literal"><span class="pre">logReturned</span></code> 内部的 <code class="docutils literal"><span class="pre">result</span></code> 变量，因此会有终端输出。</p>
<p><code class="docutils literal"><span class="pre">yield*</span></code> 命令可以很方便地取出嵌套数组的所有成员。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">iterTree</span><span class="p">(</span><span class="nx">tree</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">tree</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">tree</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">yield</span><span class="o">*</span> <span class="nx">iterTree</span><span class="p">(</span><span class="nx">tree</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">yield</span> <span class="nx">tree</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">tree</span> <span class="o">=</span> <span class="p">[</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">]</span> <span class="p">];</span>

<span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="k">of</span> <span class="nx">iterTree</span><span class="p">(</span><span class="nx">tree</span><span class="p">))</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// a</span>
<span class="c1">// b</span>
<span class="c1">// c</span>
<span class="c1">// d</span>
<span class="c1">// e</span>
</pre></div>
</div>
<p>下面是一个稍微复杂的例子，使用 <code class="docutils literal"><span class="pre">yield*</span></code> 语句遍历完全二叉树。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// 下面是二叉树的构造函数，</span>
<span class="c1">// 三个参数分别是左树、当前节点和右树</span>
<span class="kd">function</span> <span class="nx">Tree</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="nx">label</span><span class="p">,</span> <span class="nx">right</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="nx">left</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">label</span> <span class="o">=</span> <span class="nx">label</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">right</span> <span class="o">=</span> <span class="nx">right</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 下面是中序（inorder）遍历函数。</span>
<span class="c1">// 由于返回的是一个遍历器，所以要用generator函数。</span>
<span class="c1">// 函数体内采用递归算法，所以左树和右树要用yield*遍历</span>
<span class="kd">function</span><span class="o">*</span> <span class="nx">inorder</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">yield</span><span class="o">*</span> <span class="nx">inorder</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">left</span><span class="p">);</span>
    <span class="k">yield</span> <span class="nx">t</span><span class="p">.</span><span class="nx">label</span><span class="p">;</span>
    <span class="k">yield</span><span class="o">*</span> <span class="nx">inorder</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">right</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 下面生成二叉树</span>
<span class="kd">function</span> <span class="nx">make</span><span class="p">(</span><span class="nx">array</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 判断是否为叶节点</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">array</span><span class="p">.</span><span class="nx">length</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="k">new</span> <span class="nx">Tree</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">array</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">null</span><span class="p">);</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nx">Tree</span><span class="p">(</span><span class="nx">make</span><span class="p">(</span><span class="nx">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nx">array</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nx">make</span><span class="p">(</span><span class="nx">array</span><span class="p">[</span><span class="mi">2</span><span class="p">]));</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">tree</span> <span class="o">=</span> <span class="nx">make</span><span class="p">([[[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">]],</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="p">[[</span><span class="s1">&#39;e&#39;</span><span class="p">],</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;g&#39;</span><span class="p">]]]);</span>

<span class="c1">// 遍历二叉树</span>
<span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">node</span> <span class="k">of</span> <span class="nx">inorder</span><span class="p">(</span><span class="nx">tree</span><span class="p">))</span> <span class="p">{</span>
  <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">result</span>
<span class="c1">// [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;]</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h2>17.8. 作为对象属性的 Generator 函数<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<p>如果一个对象的属性是 <code class="docutils literal"><span class="pre">Generator</span></code> 函数，可以简写成下面的形式。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span>let obj = {
  * myGeneratorMethod() {
    ···
  }
};
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">myGeneratorMethod</span></code> 属性前面有一个星号，表示这个属性是一个 <code class="docutils literal"><span class="pre">Generator</span></code> 函数。</p>
<p>它的完整形式如下，与上面的写法是等价的。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">myGeneratorMethod</span><span class="o">:</span> <span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ···</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="generator-this">
<h2>17.9. Generator 函数的this<a class="headerlink" href="#generator-this" title="永久链接至标题">¶</a></h2>
<p><code class="docutils literal"><span class="pre">Generator</span></code> 函数总是返回一个遍历器，ES6 规定这个遍历器是 <code class="docutils literal"><span class="pre">Generator</span></code> 函数的实例，也继承了 <code class="docutils literal"><span class="pre">Generator</span></code> 函数的 <code class="docutils literal"><span class="pre">prototype</span></code> 对象上的方法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">g</span><span class="p">()</span> <span class="p">{}</span>

<span class="nx">g</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">hello</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="s1">&#39;hi!&#39;</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nx">g</span><span class="p">();</span>

<span class="nx">obj</span> <span class="k">instanceof</span> <span class="nx">g</span> <span class="c1">// true</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">hello</span><span class="p">()</span> <span class="c1">// &#39;hi!&#39;</span>
</pre></div>
</div>
<p>上面代码表明， <code class="docutils literal"><span class="pre">Generator</span></code> 函数g返回的遍历器 <code class="docutils literal"><span class="pre">obj</span></code> ，是 <code class="docutils literal"><span class="pre">g</span></code> 的实例，而且继承了 <code class="docutils literal"><span class="pre">g.prototype</span></code> 。但是，如果把 <code class="docutils literal"><span class="pre">g</span></code> 当作普通的构造函数，并不会生效，因为 <code class="docutils literal"><span class="pre">g</span></code> 返回的总是遍历器对象，而不是 <code class="docutils literal"><span class="pre">this</span></code> 对象。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">g</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nx">g</span><span class="p">();</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">a</span> <span class="c1">// undefined</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">Generator</span></code> 函数 <code class="docutils literal"><span class="pre">g</span></code> 在 <code class="docutils literal"><span class="pre">this</span></code> 对象上面添加了一个属性 <code class="docutils literal"><span class="pre">a</span></code> ，但是 <code class="docutils literal"><span class="pre">obj</span></code> 对象拿不到这个属性。</p>
<p><code class="docutils literal"><span class="pre">Generator</span></code> 函数也不能跟 <code class="docutils literal"><span class="pre">new</span></code> 命令一起用，会报错。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">F</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">yield</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">new</span> <span class="nx">F</span><span class="p">()</span>
<span class="c1">// TypeError: F is not a constructor</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">new</span></code> 命令跟构造函数 <code class="docutils literal"><span class="pre">F</span></code> 一起使用，结果报错，因为 <code class="docutils literal"><span class="pre">F</span></code> 不是构造函数。</p>
<p>那么，有没有办法让 <code class="docutils literal"><span class="pre">Generator</span></code> 函数返回一个正常的对象实例，既可以用 <code class="docutils literal"><span class="pre">next</span></code> 方法，又可以获得正常的 <code class="docutils literal"><span class="pre">this</span></code> ？</p>
<p>下面是一个变通方法。首先，生成一个空对象，使用 <code class="docutils literal"><span class="pre">call</span></code> 方法绑定 <code class="docutils literal"><span class="pre">Generator</span></code> 函数内部的 <code class="docutils literal"><span class="pre">this</span></code> 。这样，构造函数调用以后，这个空对象就是 <code class="docutils literal"><span class="pre">Generator</span></code> 函数的实例对象了。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">F</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">yield</span> <span class="k">this</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">yield</span> <span class="k">this</span><span class="p">.</span><span class="nx">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
<span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="nx">F</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>

<span class="nx">f</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>  <span class="c1">// Object {value: 2, done: false}</span>
<span class="nx">f</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>  <span class="c1">// Object {value: 3, done: false}</span>
<span class="nx">f</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>  <span class="c1">// Object {value: undefined, done: true}</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">a</span> <span class="c1">// 1</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">b</span> <span class="c1">// 2</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">c</span> <span class="c1">// 3</span>
</pre></div>
</div>
<p>上面代码中，首先是 <code class="docutils literal"><span class="pre">F</span></code> 内部的 <code class="docutils literal"><span class="pre">this</span></code> 对象绑定 <code class="docutils literal"><span class="pre">obj</span></code> 对象，然后调用它，返回一个 <code class="docutils literal"><span class="pre">Iterator</span></code> 对象。这个对象执行三次 <code class="docutils literal"><span class="pre">next</span></code> 方法（因为F内部有两个 <code class="docutils literal"><span class="pre">yield</span></code> 表达式），完成 <code class="docutils literal"><span class="pre">F</span></code> 内部所有代码的运行。这时，所有内部属性都绑定在 <code class="docutils literal"><span class="pre">obj</span></code> 对象上了，因此 <code class="docutils literal"><span class="pre">obj</span></code> 对象也就成了 <code class="docutils literal"><span class="pre">F</span></code> 的实例。</p>
<p>上面代码中，执行的是遍历器对象 <code class="docutils literal"><span class="pre">f</span></code> ，但是生成的对象实例是 <code class="docutils literal"><span class="pre">obj</span></code> ，有没有办法将这两个对象统一呢？</p>
<p>一个办法就是将 <code class="docutils literal"><span class="pre">obj</span></code> 换成 <code class="docutils literal"><span class="pre">F.prototype</span></code> 。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">F</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">yield</span> <span class="k">this</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">yield</span> <span class="k">this</span><span class="p">.</span><span class="nx">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="nx">F</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">F</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>

<span class="nx">f</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>  <span class="c1">// Object {value: 2, done: false}</span>
<span class="nx">f</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>  <span class="c1">// Object {value: 3, done: false}</span>
<span class="nx">f</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>  <span class="c1">// Object {value: undefined, done: true}</span>

<span class="nx">f</span><span class="p">.</span><span class="nx">a</span> <span class="c1">// 1</span>
<span class="nx">f</span><span class="p">.</span><span class="nx">b</span> <span class="c1">// 2</span>
<span class="nx">f</span><span class="p">.</span><span class="nx">c</span> <span class="c1">// 3</span>
</pre></div>
</div>
<p>再将 <code class="docutils literal"><span class="pre">F</span></code> 改成构造函数，就可以对它执行 <code class="docutils literal"><span class="pre">new</span></code> 命令了。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">gen</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">yield</span> <span class="k">this</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">yield</span> <span class="k">this</span><span class="p">.</span><span class="nx">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">F</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">gen</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">gen</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">F</span><span class="p">();</span>

<span class="nx">f</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>  <span class="c1">// Object {value: 2, done: false}</span>
<span class="nx">f</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>  <span class="c1">// Object {value: 3, done: false}</span>
<span class="nx">f</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>  <span class="c1">// Object {value: undefined, done: true}</span>

<span class="nx">f</span><span class="p">.</span><span class="nx">a</span> <span class="c1">// 1</span>
<span class="nx">f</span><span class="p">.</span><span class="nx">b</span> <span class="c1">// 2</span>
<span class="nx">f</span><span class="p">.</span><span class="nx">c</span> <span class="c1">// 3</span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h2>17.10. 含义<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<p><code class="docutils literal"><span class="pre">Generator</span></code> 是实现状态机的最佳结构。比如，下面的 <code class="docutils literal"><span class="pre">clock</span></code> 函数就是一个状态机。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">ticking</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">clock</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">ticking</span><span class="p">)</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Tick!&#39;</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Tock!&#39;</span><span class="p">);</span>
  <span class="nx">ticking</span> <span class="o">=</span> <span class="o">!</span><span class="nx">ticking</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码的 <code class="docutils literal"><span class="pre">clock</span></code> 函数一共有两种状态（ <code class="docutils literal"><span class="pre">Tick</span></code> 和 <code class="docutils literal"><span class="pre">Tock</span></code> ），每运行一次，就改变一次状态。这个函数如果用 <code class="docutils literal"><span class="pre">Generator</span></code> 实现，就是下面这样。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">clock</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Tick!&#39;</span><span class="p">);</span>
    <span class="k">yield</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Tock!&#39;</span><span class="p">);</span>
    <span class="k">yield</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>上面的 <code class="docutils literal"><span class="pre">Generator</span></code> 实现与 ES5 实现对比，可以看到少了用来保存状态的外部变量 <code class="docutils literal"><span class="pre">ticking</span></code> ，这样就更简洁，更安全（状态不会被非法篡改）、更符合函数式编程的思想，在写法上也更优雅。 <code class="docutils literal"><span class="pre">Generator</span></code> 之所以可以不用外部变量保存状态，是因为它本身就包含了一个状态信息，即目前是否处于暂停态。</p>
<div class="section" id="id6">
<h3>17.10.1. Generator 与协程<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<p>协程（coroutine）是一种程序运行的方式，可以理解成“协作的线程”或“协作的函数”。协程既可以用单线程实现，也可以用多线程实现。前者是一种特殊的子例程，后者是一种特殊的线程。</p>
<ol class="arabic simple">
<li>协程与子例程的差异</li>
</ol>
<p>传统的“子例程”（subroutine）采用堆栈式“后进先出”的执行方式，只有当调用的子函数完全执行完毕，才会结束执行父函数。协程与其不同，多个线程（单线程情况下，即多个函数）可以并行执行，但是只有一个线程（或函数）处于正在运行的状态，其他线程（或函数）都处于暂停态（suspended），线程（或函数）之间可以交换执行权。也就是说，一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程。</p>
<p>从实现上看，在内存中，子例程只使用一个栈（stack），而协程是同时存在多个栈，但只有一个栈是在运行状态，也就是说，协程是以多占用内存为代价，实现多任务的并行。</p>
<ol class="arabic simple" start="2">
<li>协程与普通线程的差异</li>
</ol>
<p>不难看出，协程适合用于多任务运行的环境。在这个意义上，它与普通的线程很相似，都有自己的执行上下文、可以分享全局变量。它们的不同之处在于，同一时间可以有多个线程处于运行状态，但是运行的协程只能有一个，其他协程都处于暂停状态。此外，普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配。</p>
<p>由于 JavaScript 是单线程语言，只能保持一个调用栈。引入协程以后，每个任务可以保持自己的调用栈。这样做的最大好处，就是抛出错误的时候，可以找到原始的调用栈。不至于像异步操作的回调函数那样，一旦出错，原始的调用栈早就结束。</p>
<p><code class="docutils literal"><span class="pre">Generator</span></code> 函数是 ES6 对协程的实现，但属于不完全实现。 <code class="docutils literal"><span class="pre">Generator</span></code> 函数被称为“半协程”（semi-coroutine），意思是只有 <code class="docutils literal"><span class="pre">Generator</span></code> 函数的调用者，才能将程序的执行权还给 <code class="docutils literal"><span class="pre">Generator</span></code> 函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。</p>
<p>如果将 <code class="docutils literal"><span class="pre">Generator</span></code> 函数当作协程，完全可以将多个需要互相协作的任务写成 <code class="docutils literal"><span class="pre">Generator</span></code> 函数，它们之间使用 <code class="docutils literal"><span class="pre">yield</span></code> 表达式交换控制权。</p>
</div>
<div class="section" id="id7">
<h3>17.10.2. Generator 与上下文<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h3>
<p>JavaScript 代码运行时，会产生一个全局的上下文环境（context，又称运行环境），包含了当前所有的变量和对象。然后，执行函数（或块级代码）的时候，又会在当前上下文环境的上层，产生一个函数运行的上下文，变成当前（active）的上下文，由此形成一个上下文环境的堆栈（context stack）。</p>
<p>这个堆栈是“后进先出”的数据结构，最后产生的上下文环境首先执行完成，退出堆栈，然后再执行完成它下层的上下文，直至所有代码执行完成，堆栈清空。</p>
<p><code class="docutils literal"><span class="pre">Generator</span></code> 函数不是这样，它执行产生的上下文环境，一旦遇到 <code class="docutils literal"><span class="pre">yield</span></code> 命令，就会暂时退出堆栈，但是并不消失，里面的所有变量和对象会冻结在当前状态。等到对它执行 <code class="docutils literal"><span class="pre">next</span></code> 命令时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">gen</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">();</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
  <span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span><span class="p">,</span>
  <span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span><span class="p">,</span>
<span class="p">);</span>
</pre></div>
</div>
<p>上面代码中，第一次执行 <code class="docutils literal"><span class="pre">g.next()</span></code> 时， <code class="docutils literal"><span class="pre">Generator</span></code> 函数 <code class="docutils literal"><span class="pre">gen</span></code> 的上下文会加入堆栈，即开始运行 <code class="docutils literal"><span class="pre">gen</span></code> 内部的代码。等遇到`` yield 1`` 时， <code class="docutils literal"><span class="pre">gen</span></code> 上下文退出堆栈，内部状态冻结。第二次执行 <code class="docutils literal"><span class="pre">g.next()</span></code> 时， <code class="docutils literal"><span class="pre">gen</span></code> 上下文重新加入堆栈，变成当前的上下文，重新恢复执行。</p>
</div>
</div>
<div class="section" id="id8">
<h2>17.11. 应用<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h2>
<p><code class="docutils literal"><span class="pre">Generator</span></code> 可以暂停函数执行，返回任意表达式的值。这种特点使得 <code class="docutils literal"><span class="pre">Generator</span></code> 有多种应用场景。</p>
<p>1) 异步操作的同步化表达
<code class="docutils literal"><span class="pre">Generator</span></code> 函数的暂停执行的效果，意味着可以把异步操作写在 <code class="docutils literal"><span class="pre">yield</span></code> 表达式里面，等到调用 <code class="docutils literal"><span class="pre">next</span></code> 方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在 <code class="docutils literal"><span class="pre">yield</span></code> 表达式下面，反正要等到调用 <code class="docutils literal"><span class="pre">next</span></code> 方法时再执行。所以， <code class="docutils literal"><span class="pre">Generator</span></code>  函数的一个重要实际意义就是用来处理异步操作，改写回调函数。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">loadUI</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">showLoadingScreen</span><span class="p">();</span>
  <span class="k">yield</span> <span class="nx">loadUIDataAsynchronously</span><span class="p">();</span>
  <span class="nx">hideLoadingScreen</span><span class="p">();</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">loader</span> <span class="o">=</span> <span class="nx">loadUI</span><span class="p">();</span>
<span class="c1">// 加载UI</span>
<span class="nx">loader</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>

<span class="c1">// 卸载UI</span>
<span class="nx">loader</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>
</pre></div>
</div>
<p>上面代码中，第一次调用 <code class="docutils literal"><span class="pre">loadUI</span></code> 函数时，该函数不会执行，仅返回一个遍历器。下一次对该遍历器调用 <code class="docutils literal"><span class="pre">next</span></code> 方法，则会显示 <code class="docutils literal"><span class="pre">Loading</span></code> 界面（ <code class="docutils literal"><span class="pre">showLoadingScreen</span></code> ），并且异步加载数据（ <code class="docutils literal"><span class="pre">loadUIDataAsynchronously</span></code> ）。等到数据加载完成，再一次使用 <code class="docutils literal"><span class="pre">next</span></code> 方法，则会隐藏 <code class="docutils literal"><span class="pre">Loading</span></code> 界面。可以看到，这种写法的好处是所有 <code class="docutils literal"><span class="pre">Loading</span></code> 界面的逻辑，都被封装在一个函数，按部就班非常清晰。</p>
<p><code class="docutils literal"><span class="pre">Ajax</span></code> 是典型的异步操作，通过 <code class="docutils literal"><span class="pre">Generator</span></code> 函数部署 <code class="docutils literal"><span class="pre">Ajax</span></code> 操作，可以用同步的方式表达。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">request</span><span class="p">(</span><span class="s2">&quot;http://some.url&quot;</span><span class="p">);</span> <span class="c1">//</span>
  <span class="kd">var</span> <span class="nx">resp</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">request</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">makeAjaxCall</span><span class="p">(</span><span class="nx">url</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">response</span><span class="p">){</span>
    <span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">response</span><span class="p">);</span> <span class="c1">// 恢复main执行</span>
  <span class="p">});</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">it</span> <span class="o">=</span> <span class="nx">main</span><span class="p">();</span>
<span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span> <span class="c1">// 执行到request函数，暂停main执行</span>
</pre></div>
</div>
<p>上面代码的 <code class="docutils literal"><span class="pre">main</span></code> 函数，就是通过 <code class="docutils literal"><span class="pre">Ajax</span></code> 操作获取数据。可以看到，除了多了一个 <code class="docutils literal"><span class="pre">yield</span></code> ，它几乎与同步操作的写法完全一样。注意， <code class="docutils literal"><span class="pre">makeAjaxCall</span></code> 函数中的 <code class="docutils literal"><span class="pre">next</span></code> 方法，必须加上 <code class="docutils literal"><span class="pre">response</span></code> 参数，因为 <code class="docutils literal"><span class="pre">yield</span></code> 表达式，本身是没有值的，总是等于 <code class="docutils literal"><span class="pre">undefined</span></code> 。</p>
<p>下面是另一个例子，通过 <code class="docutils literal"><span class="pre">Generator</span></code> 函数逐行读取文本文件。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">numbers</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">FileReader</span><span class="p">(</span><span class="s2">&quot;numbers.txt&quot;</span><span class="p">);</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="nx">file</span><span class="p">.</span><span class="nx">eof</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">yield</span> <span class="nb">parseInt</span><span class="p">(</span><span class="nx">file</span><span class="p">.</span><span class="nx">readLine</span><span class="p">(),</span> <span class="mi">10</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
    <span class="nx">file</span><span class="p">.</span><span class="nx">close</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码打开文本文件，使用 <code class="docutils literal"><span class="pre">yield</span></code> 表达式可以手动逐行读取文件。</p>
<p>2) 控制流管理
如果有一个多步操作非常耗时，采用回调函数，可能会写成下面这样。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">step1</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">value1</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">step2</span><span class="p">(</span><span class="nx">value1</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">value2</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">step3</span><span class="p">(</span><span class="nx">value2</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">value3</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">step4</span><span class="p">(</span><span class="nx">value3</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">value4</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Do something with value4</span>
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">});</span>
<span class="p">});</span>
</pre></div>
</div>
<p>采用 <code class="docutils literal"><span class="pre">Promise</span></code> 改写上面的代码。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">step1</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">step2</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">step3</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">step4</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">value4</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Do something with value4</span>
  <span class="p">},</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Handle any error from step1 through step4</span>
  <span class="p">}).</span><span class="nx">done</span><span class="p">();</span>
</pre></div>
</div>
<p>上面代码已经把回调函数，改成了直线执行的形式，但是加入了大量 <code class="docutils literal"><span class="pre">Promise</span></code> 的语法。 <code class="docutils literal"><span class="pre">Generator</span></code> 函数可以进一步改善代码运行流程。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">longRunningTask</span><span class="p">(</span><span class="nx">value1</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">value2</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">step1</span><span class="p">(</span><span class="nx">value1</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">value3</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">step2</span><span class="p">(</span><span class="nx">value2</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">value4</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">step3</span><span class="p">(</span><span class="nx">value3</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">value5</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">step4</span><span class="p">(</span><span class="nx">value4</span><span class="p">);</span>
    <span class="c1">// Do something with value4</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Handle any error from step1 through step4</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>然后，使用一个函数，按次序自动执行所有步骤。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">scheduler</span><span class="p">(</span><span class="nx">longRunningTask</span><span class="p">(</span><span class="nx">initialValue</span><span class="p">));</span>

<span class="kd">function</span> <span class="nx">scheduler</span><span class="p">(</span><span class="nx">task</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">taskObj</span> <span class="o">=</span> <span class="nx">task</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">task</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span> <span class="c1">//第一次next传入值无用</span>
  <span class="c1">// 如果Generator函数未结束，就继续调用</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">taskObj</span><span class="p">.</span><span class="nx">done</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">task</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">taskObj</span><span class="p">.</span><span class="nx">value</span>
    <span class="nx">scheduler</span><span class="p">(</span><span class="nx">task</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>注意，上面这种做法，只适合同步操作，即所有的 <code class="docutils literal"><span class="pre">task</span></code> 都必须是同步的，不能有异步操作。因为这里的代码一得到返回值，就继续往下执行，没有判断异步操作何时完成。如果要控制异步的操作流程，详见后面的《异步操作》一章。</p>
<p>下面，利用 <code class="docutils literal"><span class="pre">for...of</span></code> 循环会自动依次执行 <code class="docutils literal"><span class="pre">yield</span></code> 命令的特性，提供一种更一般的控制流管理的方法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">steps</span> <span class="o">=</span> <span class="p">[</span><span class="nx">step1Func</span><span class="p">,</span> <span class="nx">step2Func</span><span class="p">,</span> <span class="nx">step3Func</span><span class="p">];</span>

<span class="kd">function</span><span class="o">*</span> <span class="nx">iterateSteps</span><span class="p">(</span><span class="nx">steps</span><span class="p">){</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span> <span class="nx">steps</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">step</span> <span class="o">=</span> <span class="nx">steps</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="k">yield</span> <span class="nx">step</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码中，数组 <code class="docutils literal"><span class="pre">steps</span></code> 封装了一个任务的多个步骤， <code class="docutils literal"><span class="pre">Generator</span></code> 函数 <code class="docutils literal"><span class="pre">iterateSteps</span></code> 则是依次为这些步骤加上 <code class="docutils literal"><span class="pre">yield</span></code> 命令。</p>
<p>将任务分解成步骤之后，还可以将项目分解成多个依次执行的任务。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">jobs</span> <span class="o">=</span> <span class="p">[</span><span class="nx">job1</span><span class="p">,</span> <span class="nx">job2</span><span class="p">,</span> <span class="nx">job3</span><span class="p">];</span>

<span class="kd">function</span><span class="o">*</span> <span class="nx">iterateJobs</span><span class="p">(</span><span class="nx">jobs</span><span class="p">){</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span> <span class="nx">jobs</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">job</span> <span class="o">=</span> <span class="nx">jobs</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="k">yield</span><span class="o">*</span> <span class="nx">iterateSteps</span><span class="p">(</span><span class="nx">job</span><span class="p">.</span><span class="nx">steps</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码中，数组 <code class="docutils literal"><span class="pre">jobs</span></code> 封装了一个项目的多个任务， <code class="docutils literal"><span class="pre">Generator</span></code> 函数 <code class="docutils literal"><span class="pre">iterateJobs</span></code> 则是依次为这些任务加上 <code class="docutils literal"><span class="pre">yield*</span></code> 命令。</p>
<p>最后，就可以用 <code class="docutils literal"><span class="pre">for...of</span></code> 循环一次性依次执行所有任务的所有步骤。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">step</span> <span class="k">of</span> <span class="nx">iterateJobs</span><span class="p">(</span><span class="nx">jobs</span><span class="p">)){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">step</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>再次提醒，上面的做法只能用于所有步骤都是同步操作的情况，不能有异步操作的步骤。如果想要依次执行异步的步骤，必须使用后面的《异步操作》一章介绍的方法。</p>
<p><code class="docutils literal"><span class="pre">for...of</span></code> 的本质是一个 <code class="docutils literal"><span class="pre">while</span></code> 循环，所以上面的代码实质上执行的是下面的逻辑。</p>
<p>3) 部署 Iterator 接口
利用 <code class="docutils literal"><span class="pre">Generator</span></code> 函数，可以在任意对象上部署 <code class="docutils literal"><span class="pre">Iterator</span></code> 接口。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">iterEntries</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">keys</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">keys</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">key</span> <span class="o">=</span> <span class="nx">keys</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="k">yield</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">key</span><span class="p">]];</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">myObj</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">foo</span><span class="o">:</span> <span class="mi">3</span><span class="p">,</span> <span class="nx">bar</span><span class="o">:</span> <span class="mi">7</span> <span class="p">};</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">]</span> <span class="k">of</span> <span class="nx">iterEntries</span><span class="p">(</span><span class="nx">myObj</span><span class="p">))</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// foo 3</span>
<span class="c1">// bar 7</span>
</pre></div>
</div>
<p>上述代码中， <code class="docutils literal"><span class="pre">myObj</span></code> 是一个普通对象，通过 <code class="docutils literal"><span class="pre">iterEntries</span></code> 函数，就有了 <code class="docutils literal"><span class="pre">Iterator</span></code> 接口。也就是说，可以在任意对象上部署 <code class="docutils literal"><span class="pre">next</span></code> 方法。</p>
<p>下面是一个对数组部署 <code class="docutils literal"><span class="pre">Iterator</span></code> 接口的例子，尽管数组原生具有这个接口。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">makeSimpleGenerator</span><span class="p">(</span><span class="nx">array</span><span class="p">){</span>
  <span class="kd">var</span> <span class="nx">nextIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">while</span><span class="p">(</span><span class="nx">nextIndex</span> <span class="o">&lt;</span> <span class="nx">array</span><span class="p">.</span><span class="nx">length</span><span class="p">){</span>
    <span class="k">yield</span> <span class="nx">array</span><span class="p">[</span><span class="nx">nextIndex</span><span class="o">++</span><span class="p">];</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">gen</span> <span class="o">=</span> <span class="nx">makeSimpleGenerator</span><span class="p">([</span><span class="s1">&#39;yo&#39;</span><span class="p">,</span> <span class="s1">&#39;ya&#39;</span><span class="p">]);</span>

<span class="nx">gen</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span> <span class="c1">// &#39;yo&#39;</span>
<span class="nx">gen</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span> <span class="c1">// &#39;ya&#39;</span>
<span class="nx">gen</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">done</span>  <span class="c1">// true</span>
</pre></div>
</div>
<p>4) 作为数据结构
<code class="docutils literal"><span class="pre">Generator</span></code> 可以看作是数据结构，更确切地说，可以看作是一个数组结构，因为 <code class="docutils literal"><span class="pre">Generator</span></code> 函数可以返回一系列的值，这意味着它可以对任意表达式，提供类似数组的接口。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">doStuff</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="s1">&#39;hello.txt&#39;</span><span class="p">);</span>
  <span class="k">yield</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="s1">&#39;world.txt&#39;</span><span class="p">);</span>
  <span class="k">yield</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="s1">&#39;and-such.txt&#39;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码就是依次返回三个函数，但是由于使用了 <code class="docutils literal"><span class="pre">Generator</span></code> 函数，导致可以像处理数组那样，处理这三个返回的函数。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="nx">task</span> <span class="k">of</span> <span class="nx">doStuff</span><span class="p">())</span> <span class="p">{</span>
  <span class="c1">// task是一个函数，可以像回调函数那样使用它</span>
<span class="p">}</span>
</pre></div>
</div>
<p>实际上，如果用 ES5 表达，完全可以用数组模拟 <code class="docutils literal"><span class="pre">Generator</span></code> 的这种用法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">doStuff</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span>
    <span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="s1">&#39;hello.txt&#39;</span><span class="p">),</span>
    <span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="s1">&#39;world.txt&#39;</span><span class="p">),</span>
    <span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="s1">&#39;and-such.txt&#39;</span><span class="p">)</span>
  <span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的函数，可以用一模一样的 <code class="docutils literal"><span class="pre">for...of</span></code> 循环处理！两相一比较，就不难看出 <code class="docutils literal"><span class="pre">Generator</span></code> 使得数据或者操作，具备了类似数组的接口。</p>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Generator函数的异步应用.html" class="btn btn-neutral float-right" title="18. Generator 函数的异步应用" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="Iterator和for...of循环.html" class="btn btn-neutral" title="16. Iterator 和 for…of 循环" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, lzh.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.0',
            LANGUAGE:'zh_CN',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="_static/translations.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();

      });


      $(document).ready(function(){
        var offset = sessionStorage.getItem("offsetTop");
        $('.wy-side-scroll').scrollTop(offset);
        sessionStorage.setItem("offsetTop", 0);


        $('.wy-menu > ul').click(function(){
            sessionStorage.setItem("offsetTop", $('.wy-side-scroll').scrollTop());
        });
      })

  </script>
   

</body>
</html>