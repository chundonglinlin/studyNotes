

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>8. 函数的扩展 &mdash; ECMAScript6入门 1.0 文档</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="索引"
              href="genindex.html"/>
        <link rel="search" title="搜索" href="search.html"/>
    <link rel="top" title="ECMAScript6入门 1.0 文档" href="index.html"/>
        <link rel="next" title="9. 数组的扩展" href="数组的扩展.html"/>
        <link rel="prev" title="7. 数值的扩展" href="数值的扩展.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> ECMAScript6入门
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="前言.html">1. 前言</a></li>
<li class="toctree-l1"><a class="reference internal" href="ECMAScript6简介.html">2. ECMAScript6简介</a></li>
<li class="toctree-l1"><a class="reference internal" href="let和const命令.html">3. let 和 const 命令</a></li>
<li class="toctree-l1"><a class="reference internal" href="变量的解构赋值.html">4. 变量的解构赋值</a></li>
<li class="toctree-l1"><a class="reference internal" href="字符串的扩展.html">5. 字符串的扩展</a></li>
<li class="toctree-l1"><a class="reference internal" href="正则的扩展.html">6. 正则的扩展</a></li>
<li class="toctree-l1"><a class="reference internal" href="数值的扩展.html">7. 数值的扩展</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">8. 函数的扩展</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id2">8.1. 函数参数的默认值</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id3">8.1.1. 基本用法</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">8.1.2. 与解构赋值默认值结合使用</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">8.1.3. 参数默认值的位置</a></li>
<li class="toctree-l3"><a class="reference internal" href="#length">8.1.4. 函数的 length 属性</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id6">8.1.5. 作用域</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id7">8.1.6. 应用</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rest">8.2. rest 参数</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id8">8.3. 严格模式</a></li>
<li class="toctree-l2"><a class="reference internal" href="#name">8.4. name 属性</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id9">8.5. 箭头函数</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id10">8.5.1. 基本用法</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id11">8.5.2. 使用注意点</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id12">8.5.3. 嵌套的箭头函数</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id13">8.6. 双冒号运算符</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id14">8.7. 尾调用优化</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id15">8.7.1. 什么是尾调用？</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id16">8.7.2. 尾调用优化</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id17">8.7.3. 尾递归</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id18">8.7.4. 递归函数的改写</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id19">8.7.5. 尾递归优化的实现</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id20">8.8. 函数参数的尾逗号</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="数组的扩展.html">9. 数组的扩展</a></li>
<li class="toctree-l1"><a class="reference internal" href="对象的扩展.html">10. 对象的扩展</a></li>
<li class="toctree-l1"><a class="reference internal" href="Symbol.html">11. Symbol</a></li>
<li class="toctree-l1"><a class="reference internal" href="Set和Map数据结构.html">12. Set和Map数据结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="Proxy.html">13. Proxy</a></li>
<li class="toctree-l1"><a class="reference internal" href="Reflect.html">14. Reflect</a></li>
<li class="toctree-l1"><a class="reference internal" href="Promise对象.html">15. Promise对象</a></li>
<li class="toctree-l1"><a class="reference internal" href="Iterator和for...of循环.html">16. Iterator 和 for…of 循环</a></li>
<li class="toctree-l1"><a class="reference internal" href="Generator函数的语法.html">17. Generator函数的语法</a></li>
<li class="toctree-l1"><a class="reference internal" href="Generator函数的异步应用.html">18. Generator 函数的异步应用</a></li>
<li class="toctree-l1"><a class="reference internal" href="async函数.html">19. asyn函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="Class的基本语法.html">20. Class 的基本语法</a></li>
<li class="toctree-l1"><a class="reference internal" href="Class的继承.html">21. Class的继承</a></li>
<li class="toctree-l1"><a class="reference internal" href="Decorator.html">22. 修饰器</a></li>
<li class="toctree-l1"><a class="reference internal" href="Module的语法.html">23. Module 的语法</a></li>
<li class="toctree-l1"><a class="reference internal" href="Module的加载实现.html">24. Module 的加载实现</a></li>
<li class="toctree-l1"><a class="reference internal" href="编程风格.html">25. 编程风格</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">ECMAScript6入门</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>8. 函数的扩展</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>8. 函数的扩展<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<div class="section" id="id2">
<h2>8.1. 函数参数的默认值<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<div class="section" id="id3">
<h3>8.1.1. 基本用法<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<p>ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">||</span> <span class="s1">&#39;World&#39;</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Hello&#39;</span><span class="p">)</span> <span class="c1">// Hello World</span>
<span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Hello&#39;</span><span class="p">,</span> <span class="s1">&#39;China&#39;</span><span class="p">)</span> <span class="c1">// Hello China</span>
<span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Hello&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="c1">// Hello World</span>
</pre></div>
</div>
<p>上面代码检查函数 <code class="docutils literal"><span class="pre">log</span></code> 的参数 <code class="docutils literal"><span class="pre">y</span></code> 有没有赋值，如果没有，则指定默认值为 <code class="docutils literal"><span class="pre">World</span></code> 。这种写法的缺点在于，如果参数 <code class="docutils literal"><span class="pre">y</span></code> 赋值了，但是对应的布尔值为 <code class="docutils literal"><span class="pre">false</span></code> ，则该赋值不起作用。就像上面代码的最后一行，参数 <code class="docutils literal"><span class="pre">y</span></code> 等于空字符，结果被改为默认值。</p>
<p>为了避免这个问题，通常需要先判断一下参数 <code class="docutils literal"><span class="pre">y</span></code> 是否被赋值，如果没有，再等于默认值。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">y</span> <span class="o">===</span> <span class="s1">&#39;undefined&#39;</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">y</span> <span class="o">=</span> <span class="s1">&#39;World&#39;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="s1">&#39;World&#39;</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Hello&#39;</span><span class="p">)</span> <span class="c1">// Hello World</span>
<span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Hello&#39;</span><span class="p">,</span> <span class="s1">&#39;China&#39;</span><span class="p">)</span> <span class="c1">// Hello China</span>
<span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Hello&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="c1">// Hello</span>
</pre></div>
</div>
<p>可以看到，ES6 的写法比 ES5 简洁许多，而且非常自然。下面是另一个例子。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">Point</span><span class="p">(</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point</span><span class="p">();</span>
<span class="nx">p</span> <span class="c1">// { x: 0, y: 0 }</span>
</pre></div>
</div>
<p>除了简洁，ES6 的写法还有两个好处：首先，阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。</p>
<p>参数变量是默认声明的，所以不能用 <code class="docutils literal"><span class="pre">let</span></code> 或 <code class="docutils literal"><span class="pre">const</span></code> 再次声明。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// error</span>
  <span class="kr">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// error</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码中，参数变量x是默认声明的，在函数体中，不能用 <code class="docutils literal"><span class="pre">let</span></code> 或 <code class="docutils literal"><span class="pre">const</span></code> 再次声明，否则会报错。</p>
<p>使用参数默认值时，函数不能有同名参数。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// 不报错</span>
<span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// 报错</span>
<span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
<span class="c1">// SyntaxError: Duplicate parameter name not allowed in this context</span>
</pre></div>
</div>
<p>另外，一个容易忽略的地方是，参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">99</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">p</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">foo</span><span class="p">()</span> <span class="c1">// 100</span>

<span class="nx">x</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="nx">foo</span><span class="p">()</span> <span class="c1">// 101</span>
</pre></div>
</div>
<p>上面代码中，参数 <code class="docutils literal"><span class="pre">p</span></code> 的默认值是 <code class="docutils literal"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span></code> 。这时，每次调用函数 <code class="docutils literal"><span class="pre">foo</span></code> ，都会重新计算 <code class="docutils literal"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span></code> ，而不是默认 <code class="docutils literal"><span class="pre">p</span></code> 等于 <code class="docutils literal"><span class="pre">100</span></code> 。</p>
</div>
<div class="section" id="id4">
<h3>8.1.2. 与解构赋值默认值结合使用<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<p>参数默认值可以与解构赋值的默认值，结合起来使用。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">foo</span><span class="p">({</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">5</span><span class="p">})</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">foo</span><span class="p">({})</span> <span class="c1">// undefined 5</span>
<span class="nx">foo</span><span class="p">({</span><span class="nx">x</span><span class="o">:</span> <span class="mi">1</span><span class="p">})</span> <span class="c1">// 1 5</span>
<span class="nx">foo</span><span class="p">({</span><span class="nx">x</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mi">2</span><span class="p">})</span> <span class="c1">// 1 2</span>
<span class="nx">foo</span><span class="p">()</span> <span class="c1">// TypeError: Cannot read property &#39;x&#39; of undefined</span>
</pre></div>
</div>
<p>上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数 <code class="docutils literal"><span class="pre">foo</span></code> 的参数是一个对象时，变量 <code class="docutils literal"><span class="pre">x</span></code> 和 <code class="docutils literal"><span class="pre">y</span></code> 才会通过解构赋值生成。如果函数 <code class="docutils literal"><span class="pre">foo</span></code> 调用时没提供参数，变量 <code class="docutils literal"><span class="pre">x</span></code> 和 <code class="docutils literal"><span class="pre">y</span></code> 就不会生成，从而报错。通过提供函数参数的默认值，就可以避免这种情况。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">foo</span><span class="p">({</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">5</span><span class="p">}</span> <span class="o">=</span> <span class="p">{})</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">foo</span><span class="p">()</span> <span class="c1">// undefined 5</span>
</pre></div>
</div>
<p>上面代码指定，如果没有提供参数，函数 <code class="docutils literal"><span class="pre">foo</span></code> 的参数默认为一个空对象。</p>
<p>下面是另一个解构赋值默认值的例子。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">,</span> <span class="p">{</span> <span class="nx">body</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="nx">method</span> <span class="o">=</span> <span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="nx">headers</span> <span class="o">=</span> <span class="p">{}</span> <span class="p">})</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">method</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;http://example.com&#39;</span><span class="p">,</span> <span class="p">{})</span>
<span class="c1">// &quot;GET&quot;</span>

<span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;http://example.com&#39;</span><span class="p">)</span>
<span class="c1">// 报错</span>
</pre></div>
</div>
<p>上面代码中，如果函数 <code class="docutils literal"><span class="pre">fetch</span></code> 的第二个参数是一个对象，就可以为它的三个属性设置默认值。这种写法不能省略第二个参数，如果结合函数参数的默认值，就可以省略第二个参数。这时，就出现了双重默认值。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">,</span> <span class="p">{</span> <span class="nx">body</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="nx">method</span> <span class="o">=</span> <span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="nx">headers</span> <span class="o">=</span> <span class="p">{}</span> <span class="p">}</span> <span class="o">=</span> <span class="p">{})</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">method</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;http://example.com&#39;</span><span class="p">)</span>
<span class="c1">// &quot;GET&quot;</span>
</pre></div>
</div>
<p>上面代码中，函数 <code class="docutils literal"><span class="pre">fetch</span></code> 没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量 <code class="docutils literal"><span class="pre">method</span></code> 才会取到默认值 <code class="docutils literal"><span class="pre">GET</span></code> 。</p>
<p>作为练习，请问下面两种写法有什么差别？</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// 写法一</span>
<span class="kd">function</span> <span class="nx">m1</span><span class="p">({</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">}</span> <span class="o">=</span> <span class="p">{})</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">];</span>
<span class="p">}</span>

<span class="c1">// 写法二</span>
<span class="kd">function</span> <span class="nx">m2</span><span class="p">({</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">}</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">x</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mi">0</span> <span class="p">})</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// 函数没有参数的情况</span>
<span class="nx">m1</span><span class="p">()</span> <span class="c1">// [0, 0]</span>
<span class="nx">m2</span><span class="p">()</span> <span class="c1">// [0, 0]</span>

<span class="c1">// x 和 y 都有值的情况</span>
<span class="nx">m1</span><span class="p">({</span><span class="nx">x</span><span class="o">:</span> <span class="mi">3</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mi">8</span><span class="p">})</span> <span class="c1">// [3, 8]</span>
<span class="nx">m2</span><span class="p">({</span><span class="nx">x</span><span class="o">:</span> <span class="mi">3</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mi">8</span><span class="p">})</span> <span class="c1">// [3, 8]</span>

<span class="c1">// x 有值，y 无值的情况</span>
<span class="nx">m1</span><span class="p">({</span><span class="nx">x</span><span class="o">:</span> <span class="mi">3</span><span class="p">})</span> <span class="c1">// [3, 0]</span>
<span class="nx">m2</span><span class="p">({</span><span class="nx">x</span><span class="o">:</span> <span class="mi">3</span><span class="p">})</span> <span class="c1">// [3, undefined]</span>

<span class="c1">// x 和 y 都无值的情况</span>
<span class="nx">m1</span><span class="p">({})</span> <span class="c1">// [0, 0];</span>
<span class="nx">m2</span><span class="p">({})</span> <span class="c1">// [undefined, undefined]</span>

<span class="nx">m1</span><span class="p">({</span><span class="nx">z</span><span class="o">:</span> <span class="mi">3</span><span class="p">})</span> <span class="c1">// [0, 0]</span>
<span class="nx">m2</span><span class="p">({</span><span class="nx">z</span><span class="o">:</span> <span class="mi">3</span><span class="p">})</span> <span class="c1">// [undefined, undefined]</span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h3>8.1.3. 参数默认值的位置<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<p>通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// 例一</span>
<span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">];</span>
<span class="p">}</span>

<span class="nx">f</span><span class="p">()</span> <span class="c1">// [1, undefined]</span>
<span class="nx">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// [2, undefined])</span>
<span class="nx">f</span><span class="p">(,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// 报错</span>
<span class="nx">f</span><span class="p">(</span><span class="kc">undefined</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// [1, 1]</span>

<span class="c1">// 例二</span>
<span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="nx">z</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">];</span>
<span class="p">}</span>

<span class="nx">f</span><span class="p">()</span> <span class="c1">// [undefined, 5, undefined]</span>
<span class="nx">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// [1, 5, undefined]</span>
<span class="nx">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// 报错</span>
<span class="nx">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">undefined</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">// [1, 5, 2]</span>
</pre></div>
</div>
<p>上面代码中，有默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入 <code class="docutils literal"><span class="pre">undefined</span></code> 。</p>
<p>如果传入 <code class="docutils literal"><span class="pre">undefined</span></code> ，将触发该参数等于默认值， <code class="docutils literal"><span class="pre">null</span></code> 则没有这个效果。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">6</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">foo</span><span class="p">(</span><span class="kc">undefined</span><span class="p">,</span> <span class="kc">null</span><span class="p">)</span>
<span class="c1">// 5 null</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">x</span></code> 参数对应 <code class="docutils literal"><span class="pre">undefined</span></code> ，结果触发了默认值， <code class="docutils literal"><span class="pre">y</span></code> 参数等于 <code class="docutils literal"><span class="pre">null</span></code> ，就没有触发默认值。</p>
</div>
<div class="section" id="length">
<h3>8.1.4. 函数的 length 属性<a class="headerlink" href="#length" title="永久链接至标题">¶</a></h3>
<p>指定了默认值以后，函数的 <code class="docutils literal"><span class="pre">length</span></code> 属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后， <code class="docutils literal"><span class="pre">length</span></code> 属性将失真。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{}).</span><span class="nx">length</span> <span class="c1">// 1</span>
<span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{}).</span><span class="nx">length</span> <span class="c1">// 0</span>
<span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{}).</span><span class="nx">length</span> <span class="c1">// 2</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">length</span></code> 属性的返回值，等于函数的参数个数减去指定了默认值的参数个数。比如，上面最后一个函数，定义了 3 个参数，其中有一个参数 <code class="docutils literal"><span class="pre">c</span></code> 指定了默认值，因此 <code class="docutils literal"><span class="pre">length</span></code> 属性等于 3 减去 1，最后得到 2。</p>
<p>这是因为 <code class="docutils literal"><span class="pre">length</span></code> 属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，后文的 <code class="docutils literal"><span class="pre">rest</span></code> 参数也不会计入 <code class="docutils literal"><span class="pre">length</span></code> 属性。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="p">(</span><span class="kd">function</span><span class="p">(...</span><span class="nx">args</span><span class="p">)</span> <span class="p">{}).</span><span class="nx">length</span> <span class="c1">// 0</span>
</pre></div>
</div>
<p>如果设置了默认值的参数不是尾参数，那么 <code class="docutils literal"><span class="pre">length</span></code> 属性也不再计入后面的参数了。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="p">{}).</span><span class="nx">length</span> <span class="c1">// 0</span>
<span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="p">{}).</span><span class="nx">length</span> <span class="c1">// 1</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h3>8.1.5. 作用域<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// 2</span>
</pre></div>
</div>
<p>上面代码中，参数 <code class="docutils literal"><span class="pre">y</span></code> 的默认值等于变量 <code class="docutils literal"><span class="pre">x</span></code> 。调用函数 <code class="docutils literal"><span class="pre">f</span></code> 时，参数形成一个单独的作用域。在这个作用域里面，默认值变量 <code class="docutils literal"><span class="pre">x</span></code> 指向第一个参数 <code class="docutils literal"><span class="pre">x</span></code> ，而不是全局变量 <code class="docutils literal"><span class="pre">x</span></code> ，所以输出是 2 。</p>
<p>再看下面的例子。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">f</span><span class="p">()</span> <span class="c1">// 1</span>
</pre></div>
</div>
<p>上面代码中，函数 <code class="docutils literal"><span class="pre">f</span></code> 调用时，参数 <code class="docutils literal"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">x</span></code> 形成一个单独的作用域。这个作用域里面，变量 <code class="docutils literal"><span class="pre">x</span></code> 本身没有定义，所以指向外层的全局变量 <code class="docutils literal"><span class="pre">x</span></code> 。函数调用时，函数体内部的局部变量 <code class="docutils literal"><span class="pre">x</span></code> 影响不到默认值变量 <code class="docutils literal"><span class="pre">x</span></code> 。</p>
<p>如果此时，全局变量 <code class="docutils literal"><span class="pre">x</span></code> 不存在，就会报错。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">f</span><span class="p">()</span> <span class="c1">// ReferenceError: x is not defined</span>
</pre></div>
</div>
<p>下面这样写，也会报错。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="nx">foo</span><span class="p">()</span> <span class="c1">// ReferenceError: x is not defined</span>
</pre></div>
</div>
<p>上面代码中，参数 <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x</span></code> 形成一个单独作用域。实际执行的是 <code class="docutils literal"><span class="pre">let</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">x</span></code> ，由于暂时性死区的原因，这行代码会报错”x 未定义“。</p>
<p>如果参数的默认值是一个函数，该函数的作用域也遵守这个规则。请看下面的例子。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">foo</span> <span class="o">=</span> <span class="s1">&#39;outer&#39;</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">bar</span><span class="p">(</span><span class="nx">func</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">foo</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">foo</span> <span class="o">=</span> <span class="s1">&#39;inner&#39;</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">func</span><span class="p">());</span>
<span class="p">}</span>

<span class="nx">bar</span><span class="p">();</span> <span class="c1">// outer</span>
</pre></div>
</div>
<p>上面代码中，函数 <code class="docutils literal"><span class="pre">bar</span></code> 的参数 <code class="docutils literal"><span class="pre">func</span></code> 的默认值是一个匿名函数，返回值为变量 <code class="docutils literal"><span class="pre">foo</span></code> 。函数参数形成的单独作用域里面，并没有定义变量 <code class="docutils literal"><span class="pre">foo</span></code> ，所以 <code class="docutils literal"><span class="pre">foo</span></code> 指向外层的全局变量 <code class="docutils literal"><span class="pre">foo</span></code> ，因此输出 <code class="docutils literal"><span class="pre">outer</span></code> 。</p>
<p>如果写成下面这样，就会报错。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">bar</span><span class="p">(</span><span class="nx">func</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">foo</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">foo</span> <span class="o">=</span> <span class="s1">&#39;inner&#39;</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">func</span><span class="p">());</span>
<span class="p">}</span>

<span class="nx">bar</span><span class="p">()</span> <span class="c1">// ReferenceError: foo is not defined</span>
</pre></div>
</div>
<p>上面代码中，匿名函数里面的 <code class="docutils literal"><span class="pre">foo</span></code> 指向函数外层，但是函数外层并没有声明变量 <code class="docutils literal"><span class="pre">foo</span></code> ，所以就报错了。</p>
<p>下面是一个更复杂的例子。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="p">})</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
  <span class="nx">y</span><span class="p">();</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">foo</span><span class="p">()</span> <span class="c1">// 3</span>
<span class="nx">x</span> <span class="c1">// 1</span>
</pre></div>
</div>
<p>上面代码中，函数 <code class="docutils literal"><span class="pre">foo</span></code> 的参数形成一个单独作用域。这个作用域里面，首先声明了变量 <code class="docutils literal"><span class="pre">x</span></code> ，然后声明了变量 <code class="docutils literal"><span class="pre">y</span></code> ， <code class="docutils literal"><span class="pre">y</span></code> 的默认值是一个匿名函数。这个匿名函数内部的变量 <code class="docutils literal"><span class="pre">x</span></code> ，指向同一个作用域的第一个参数 <code class="docutils literal"><span class="pre">x</span></code> 。函数 <code class="docutils literal"><span class="pre">foo</span></code> 内部又声明了一个内部变量 <code class="docutils literal"><span class="pre">x</span></code> ，该变量与第一个参数 <code class="docutils literal"><span class="pre">x</span></code> 由于不是同一个作用域，所以不是同一个变量，因此执行 <code class="docutils literal"><span class="pre">y</span></code> 后，内部变量 <code class="docutils literal"><span class="pre">x</span></code> 和外部全局变量 <code class="docutils literal"><span class="pre">x</span></code> 的值都没变。</p>
<p>如果将 <code class="docutils literal"><span class="pre">var</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">3</span></code> 的 <code class="docutils literal"><span class="pre">var</span></code> 去除，函数 <code class="docutils literal"><span class="pre">foo</span></code> 的内部变量 <code class="docutils literal"><span class="pre">x</span></code> 就指向第一个参数 <code class="docutils literal"><span class="pre">x</span></code> ，与匿名函数内部的 <code class="docutils literal"><span class="pre">x</span></code> 是一致的，所以最后输出的就是 2 ，而外层的全局变量 <code class="docutils literal"><span class="pre">x</span></code> 依然不受影响。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="p">})</span> <span class="p">{</span>
  <span class="nx">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
  <span class="nx">y</span><span class="p">();</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">foo</span><span class="p">()</span> <span class="c1">// 2</span>
<span class="nx">x</span> <span class="c1">// 1</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h3>8.1.6. 应用<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h3>
<p>利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">throwIfMissing</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;Missing parameter&#39;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">mustBeProvided</span> <span class="o">=</span> <span class="nx">throwIfMissing</span><span class="p">())</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">mustBeProvided</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">foo</span><span class="p">()</span>
<span class="c1">// Error: Missing parameter</span>
</pre></div>
</div>
<p>上面代码的 <code class="docutils literal"><span class="pre">foo</span></code> 函数，如果调用的时候没有参数，就会调用默认值 <code class="docutils literal"><span class="pre">throwIfMissing</span></code> 函数，从而抛出一个错误。</p>
<p>从上面代码还可以看到，参数 <code class="docutils literal"><span class="pre">mustBeProvided</span></code> 的默认值等于 <code class="docutils literal"><span class="pre">throwIfMissing</span></code> 函数的运行结果（注意函数名 <code class="docutils literal"><span class="pre">throwIfMissing</span></code> 之后有一对圆括号），这表明参数的默认值不是在定义时执行，而是在运行时执行。如果参数已经赋值，默认值中的函数就不会运行。</p>
<p>另外，可以将参数默认值设为 <code class="docutils literal"><span class="pre">undefined</span></code> ，表明这个参数是可以省略的。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span>function foo(optional = undefined) { ··· }
</pre></div>
</div>
</div>
</div>
<div class="section" id="rest">
<h2>8.2. rest 参数<a class="headerlink" href="#rest" title="永久链接至标题">¶</a></h2>
<p>ES6 引入 <code class="docutils literal"><span class="pre">rest</span></code> 参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用 <code class="docutils literal"><span class="pre">arguments</span></code> 对象了。 <code class="docutils literal"><span class="pre">rest</span></code>  参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">add</span><span class="p">(...</span><span class="nx">values</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">val</span> <span class="k">of</span> <span class="nx">values</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">val</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">sum</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">// 10</span>
</pre></div>
</div>
<p>上面代码的 <code class="docutils literal"><span class="pre">add</span></code> 函数是一个求和函数，利用 <code class="docutils literal"><span class="pre">rest</span></code> 参数，可以向该函数传入任意数目的参数。</p>
<p>下面是一个 <code class="docutils literal"><span class="pre">rest</span></code> 参数代替 <code class="docutils literal"><span class="pre">arguments</span></code> 变量的例子。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// arguments变量的写法</span>
<span class="kd">function</span> <span class="nx">sortNumbers</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">).</span><span class="nx">sort</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// rest参数的写法</span>
<span class="kr">const</span> <span class="nx">sortNumbers</span> <span class="o">=</span> <span class="p">(...</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">sort</span><span class="p">();</span>
</pre></div>
</div>
<p>上面代码的两种写法，比较后可以发现， <code class="docutils literal"><span class="pre">rest</span></code> 参数的写法更自然也更简洁。</p>
<p><code class="docutils literal"><span class="pre">arguments</span></code> 对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用``Array.prototype.slice.call`` 先将其转为数组。 <code class="docutils literal"><span class="pre">rest</span></code> 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。下面是一个利用 <code class="docutils literal"><span class="pre">rest</span></code>  参数改写数组 <code class="docutils literal"><span class="pre">push</span></code> 方法的例子。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">push</span><span class="p">(</span><span class="nx">array</span><span class="p">,</span> <span class="p">...</span><span class="nx">items</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">items</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">array</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[];</span>
<span class="nx">push</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>注意， <code class="docutils literal"><span class="pre">rest</span></code> 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// 报错</span>
<span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="p">...</span><span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>函数的 <code class="docutils literal"><span class="pre">length</span></code> 属性，不包括 <code class="docutils literal"><span class="pre">rest</span></code> 参数。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{}).</span><span class="nx">length</span>  <span class="c1">// 1</span>
<span class="p">(</span><span class="kd">function</span><span class="p">(...</span><span class="nx">a</span><span class="p">)</span> <span class="p">{}).</span><span class="nx">length</span>  <span class="c1">// 0</span>
<span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="p">...</span><span class="nx">b</span><span class="p">)</span> <span class="p">{}).</span><span class="nx">length</span>  <span class="c1">// 1</span>
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h2>8.3. 严格模式<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h2>
<p>从 ES5 开始，函数内部可以设定为严格模式。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">doSomething</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="s1">&#39;use strict&#39;</span><span class="p">;</span>
  <span class="c1">// code</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// 报错</span>
<span class="kd">function</span> <span class="nx">doSomething</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="o">=</span> <span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="s1">&#39;use strict&#39;</span><span class="p">;</span>
  <span class="c1">// code</span>
<span class="p">}</span>

<span class="c1">// 报错</span>
<span class="kr">const</span> <span class="nx">doSomething</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">({</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">})</span> <span class="p">{</span>
  <span class="s1">&#39;use strict&#39;</span><span class="p">;</span>
  <span class="c1">// code</span>
<span class="p">};</span>

<span class="c1">// 报错</span>
<span class="kr">const</span> <span class="nx">doSomething</span> <span class="o">=</span> <span class="p">(...</span><span class="nx">a</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="s1">&#39;use strict&#39;</span><span class="p">;</span>
  <span class="c1">// code</span>
<span class="p">};</span>

<span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="c1">// 报错</span>
  <span class="nx">doSomething</span><span class="p">({</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">})</span> <span class="p">{</span>
    <span class="s1">&#39;use strict&#39;</span><span class="p">;</span>
    <span class="c1">// code</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>这样规定的原因是，函数内部的严格模式，同时适用于函数体和函数参数。但是，函数执行的时候，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// 报错</span>
<span class="kd">function</span> <span class="nx">doSomething</span><span class="p">(</span><span class="nx">value</span> <span class="o">=</span> <span class="mi">070</span><span class="p">)</span> <span class="p">{</span>
  <span class="s1">&#39;use strict&#39;</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">value</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码中，参数 <code class="docutils literal"><span class="pre">value</span></code> 的默认值是八进制数 <code class="docutils literal"><span class="pre">070</span></code> ，但是严格模式下不能用前缀0表示八进制，所以应该报错。但是实际上，JavaScript 引擎会先成功执行 <code class="docutils literal"><span class="pre">value</span> <span class="pre">=</span> <span class="pre">070</span></code> ，然后进入函数体内部，发现需要用严格模式执行，这时才会报错。</p>
<p>虽然可以先解析函数体代码，再执行参数代码，但是这样无疑就增加了复杂性。因此，标准索性禁止了这种用法，只要参数使用了默认值、解构赋值、或者扩展运算符，就不能显式指定严格模式。</p>
<p>两种方法可以规避这种限制。第一种是设定全局性的严格模式，这是合法的。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="s1">&#39;use strict&#39;</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">doSomething</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="o">=</span> <span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// code</span>
<span class="p">}</span>
</pre></div>
</div>
<p>第二种是把函数包在一个无参数的立即执行函数里面。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">doSomething</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="s1">&#39;use strict&#39;</span><span class="p">;</span>
  <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">value</span> <span class="o">=</span> <span class="mi">42</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">value</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}());</span>
</pre></div>
</div>
</div>
<div class="section" id="name">
<h2>8.4. name 属性<a class="headerlink" href="#name" title="永久链接至标题">¶</a></h2>
<p>函数的 <code class="docutils literal"><span class="pre">name</span></code> 属性，返回该函数的函数名。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{}</span>
<span class="nx">foo</span><span class="p">.</span><span class="nx">name</span> <span class="c1">// &quot;foo&quot;</span>
</pre></div>
</div>
<p>这个属性早就被浏览器广泛支持，但是直到 ES6，才将其写入了标准。</p>
<p>需要注意的是，ES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5 的 <code class="docutils literal"><span class="pre">name</span></code> 属性，会返回空字符串，而 ES6 的 <code class="docutils literal"><span class="pre">name</span></code> 属性会返回实际的函数名。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{};</span>

<span class="c1">// ES5</span>
<span class="nx">f</span><span class="p">.</span><span class="nx">name</span> <span class="c1">// &quot;&quot;</span>

<span class="c1">// ES6</span>
<span class="nx">f</span><span class="p">.</span><span class="nx">name</span> <span class="c1">// &quot;f&quot;</span>
</pre></div>
</div>
<p>上面代码中，变量 <code class="docutils literal"><span class="pre">f</span></code> 等于一个匿名函数，ES5 和 ES6 的 <code class="docutils literal"><span class="pre">name</span></code> 属性返回的值不一样。</p>
<p>如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的 <code class="docutils literal"><span class="pre">name</span></code> 属性都返回这个具名函数原本的名字。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">bar</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">baz</span><span class="p">()</span> <span class="p">{};</span>

<span class="c1">// ES5</span>
<span class="nx">bar</span><span class="p">.</span><span class="nx">name</span> <span class="c1">// &quot;baz&quot;</span>

<span class="c1">// ES6</span>
<span class="nx">bar</span><span class="p">.</span><span class="nx">name</span> <span class="c1">// &quot;baz&quot;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">Function</span></code> 构造函数返回的函数实例， <code class="docutils literal"><span class="pre">name</span></code> 属性的值为 <code class="docutils literal"><span class="pre">anonymous</span></code> 。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">new</span> <span class="nb">Function</span><span class="p">).</span><span class="nx">name</span> <span class="c1">// &quot;anonymous&quot;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">bind</span></code> 返回的函数， <code class="docutils literal"><span class="pre">name</span></code> 属性值会加上 <code class="docutils literal"><span class="pre">bound</span></code> 前缀。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{};</span>
<span class="nx">foo</span><span class="p">.</span><span class="nx">bind</span><span class="p">({}).</span><span class="nx">name</span> <span class="c1">// &quot;bound foo&quot;</span>

<span class="p">(</span><span class="kd">function</span><span class="p">(){}).</span><span class="nx">bind</span><span class="p">({}).</span><span class="nx">name</span> <span class="c1">// &quot;bound &quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h2>8.5. 箭头函数<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h2>
<div class="section" id="id10">
<h3>8.5.1. 基本用法<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h3>
<p>ES6 允许使用“箭头”（ <code class="docutils literal"><span class="pre">=&gt;</span></code> ）定义函数。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="nx">v</span> <span class="p">=&gt;</span> <span class="nx">v</span><span class="p">;</span>

<span class="c1">// 等同于</span>
<span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">v</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="mi">5</span><span class="p">;</span>
<span class="c1">// 等同于</span>
<span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">5</span> <span class="p">};</span>

<span class="kd">var</span> <span class="nx">sum</span> <span class="o">=</span> <span class="p">(</span><span class="nx">num1</span><span class="p">,</span> <span class="nx">num2</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">num1</span> <span class="o">+</span> <span class="nx">num2</span><span class="p">;</span>
<span class="c1">// 等同于</span>
<span class="kd">var</span> <span class="nx">sum</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">num1</span><span class="p">,</span> <span class="nx">num2</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">num1</span> <span class="o">+</span> <span class="nx">num2</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用 <code class="docutils literal"><span class="pre">return</span></code> 语句返回。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">sum</span> <span class="o">=</span> <span class="p">(</span><span class="nx">num1</span><span class="p">,</span> <span class="nx">num2</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">num1</span> <span class="o">+</span> <span class="nx">num2</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
</div>
<p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// 报错</span>
<span class="kd">let</span> <span class="nx">getTempItem</span> <span class="o">=</span> <span class="nx">id</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="nx">id</span><span class="o">:</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;Temp&quot;</span> <span class="p">};</span>

<span class="c1">// 不报错</span>
<span class="kd">let</span> <span class="nx">getTempItem</span> <span class="o">=</span> <span class="nx">id</span> <span class="p">=&gt;</span> <span class="p">({</span> <span class="nx">id</span><span class="o">:</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;Temp&quot;</span> <span class="p">});</span>
</pre></div>
</div>
<p>下面是一种特殊情况，虽然可以运行，但会得到错误的结果。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">foo</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="nx">a</span><span class="o">:</span> <span class="mi">1</span> <span class="p">};</span>
<span class="nx">foo</span><span class="p">()</span> <span class="c1">// undefined</span>
</pre></div>
</div>
<p>上面代码中，原始意图是返回一个对象 <code class="docutils literal"><span class="pre">{</span> <span class="pre">a:</span> <span class="pre">1</span> <span class="pre">}</span></code> ，但是由于引擎认为大括号是代码块，所以执行了一行语句 <code class="docutils literal"><span class="pre">a:</span> <span class="pre">1</span></code> 。这时，a可以被解释为语句的标签，因此实际执行的语句是 1;，然后函数就结束了，没有返回值。</p>
<p>如果箭头函数只有一行语句，且不需要返回值，可以采用下面的写法，就不用写大括号了。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">fn</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="k">void</span> <span class="nx">doesNotReturn</span><span class="p">();</span>
</pre></div>
</div>
<p>箭头函数可以与变量解构结合使用。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">full</span> <span class="o">=</span> <span class="p">({</span> <span class="nx">first</span><span class="p">,</span> <span class="nx">last</span> <span class="p">})</span> <span class="p">=&gt;</span> <span class="nx">first</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="nx">last</span><span class="p">;</span>

<span class="c1">// 等同于</span>
<span class="kd">function</span> <span class="nx">full</span><span class="p">(</span><span class="nx">person</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">person</span><span class="p">.</span><span class="nx">first</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="nx">person</span><span class="p">.</span><span class="nx">last</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>箭头函数使得表达更加简洁。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">isEven</span> <span class="o">=</span> <span class="nx">n</span> <span class="p">=&gt;</span> <span class="nx">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">square</span> <span class="o">=</span> <span class="nx">n</span> <span class="p">=&gt;</span> <span class="nx">n</span> <span class="o">*</span> <span class="nx">n</span><span class="p">;</span>
</pre></div>
</div>
<p>上面代码只用了两行，就定义了两个简单的工具函数。如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。</p>
<p>箭头函数的一个用处是简化回调函数。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// 正常函数写法</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">].</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span><span class="p">;</span>
<span class="p">});</span>

<span class="c1">// 箭头函数写法</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">].</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="p">=&gt;</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span><span class="p">);</span>
</pre></div>
</div>
<p>另一个例子是</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// 正常函数写法</span>
<span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">values</span><span class="p">.</span><span class="nx">sort</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span><span class="p">;</span>
<span class="p">});</span>

<span class="c1">// 箭头函数写法</span>
<span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">values</span><span class="p">.</span><span class="nx">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span><span class="p">);</span>
</pre></div>
</div>
<p>下面是 <code class="docutils literal"><span class="pre">rest</span></code> 参数与箭头函数结合的例子。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">numbers</span> <span class="o">=</span> <span class="p">(...</span><span class="nx">nums</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">nums</span><span class="p">;</span>

<span class="nx">numbers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="c1">// [1,2,3,4,5]</span>

<span class="kr">const</span> <span class="nx">headAndTail</span> <span class="o">=</span> <span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="p">...</span><span class="nx">tail</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">[</span><span class="nx">head</span><span class="p">,</span> <span class="nx">tail</span><span class="p">];</span>

<span class="nx">headAndTail</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="c1">// [1,[2,3,4,5]]</span>
</pre></div>
</div>
</div>
<div class="section" id="id11">
<h3>8.5.2. 使用注意点<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h3>
<p>箭头函数有几个使用注意点。</p>
<ol class="arabic simple">
<li>函数体内的 <code class="docutils literal"><span class="pre">this</span></code> 对象，就是定义时所在的对象，而不是使用时所在的对象。</li>
<li>不可以当作构造函数，也就是说，不可以使用 <code class="docutils literal"><span class="pre">new</span></code> 命令，否则会抛出一个错误。</li>
<li>不可以使用 <code class="docutils literal"><span class="pre">arguments</span></code> 对象，该对象在函数体内不存在。如果要用，可以用 <code class="docutils literal"><span class="pre">rest</span></code> 参数代替。</li>
<li>不可以使用 <code class="docutils literal"><span class="pre">yield</span></code> 命令，因此箭头函数不能用作 <code class="docutils literal"><span class="pre">Generator</span></code> 函数。</li>
</ol>
<p>上面四点中，第一点尤其值得注意。 <code class="docutils literal"><span class="pre">this</span></code> 对象的指向是可变的，但是在箭头函数中，它是固定的。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;id:&#39;</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span>
  <span class="p">},</span> <span class="mi">100</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">id</span> <span class="o">=</span> <span class="mi">21</span><span class="p">;</span>

<span class="nx">foo</span><span class="p">.</span><span class="nx">call</span><span class="p">({</span> <span class="nx">id</span><span class="o">:</span> <span class="mi">42</span> <span class="p">});</span>
<span class="c1">// id: 42</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">setTimeout</span></code> 的参数是一个箭头函数，这个箭头函数的定义生效是在 <code class="docutils literal"><span class="pre">foo</span></code> 函数生成时，而它的真正执行要等到 <code class="docutils literal"><span class="pre">100</span></code> 毫秒后。如果是普通函数，执行时 <code class="docutils literal"><span class="pre">this</span></code> 应该指向全局对象 <code class="docutils literal"><span class="pre">window</span></code> ，这时应该输出 21。但是，箭头函数导致 <code class="docutils literal"><span class="pre">this</span></code> 总是指向函数定义生效时所在的对象（本例是 <code class="docutils literal"><span class="pre">{id:</span> <span class="pre">42}</span></code> ），所以输出的是 42。</p>
<p>箭头函数可以让 <code class="docutils literal"><span class="pre">setTimeout</span></code> 里面的 <code class="docutils literal"><span class="pre">this</span></code> ，绑定定义时所在的作用域，而不是指向运行时所在的作用域。下面是另一个例子。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">Timer</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">s1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">s2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">// 箭头函数</span>
  <span class="nx">setInterval</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">s1</span><span class="o">++</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
  <span class="c1">// 普通函数</span>
  <span class="nx">setInterval</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">s2</span><span class="o">++</span><span class="p">;</span>
  <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">timer</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Timer</span><span class="p">();</span>

<span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;s1: &#39;</span><span class="p">,</span> <span class="nx">timer</span><span class="p">.</span><span class="nx">s1</span><span class="p">),</span> <span class="mi">3100</span><span class="p">);</span>
<span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;s2: &#39;</span><span class="p">,</span> <span class="nx">timer</span><span class="p">.</span><span class="nx">s2</span><span class="p">),</span> <span class="mi">3100</span><span class="p">);</span>
<span class="c1">// s1: 3</span>
<span class="c1">// s2: 0</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">Timer</span></code> 函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的 <code class="docutils literal"><span class="pre">this</span></code> 绑定定义时所在的作用域（即 <code class="docutils literal"><span class="pre">Timer</span></code> 函数），后者的 <code class="docutils literal"><span class="pre">this</span></code> 指向运行时所在的作用域（即全局对象）。所以，3100 毫秒之后， <code class="docutils literal"><span class="pre">timer.s1</span></code> 被更新了 3 次，而 <code class="docutils literal"><span class="pre">timer.s2</span></code> 一次都没更新。</p>
<p>箭头函数可以让 <code class="docutils literal"><span class="pre">this</span></code> 指向固定化，这种特性很有利于封装回调函数。下面是一个例子， <code class="docutils literal"><span class="pre">DOM</span></code> 事件的回调函数封装在一个对象里面。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">handler</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">id</span><span class="o">:</span> <span class="s1">&#39;123456&#39;</span><span class="p">,</span>

  <span class="nx">init</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nb">document</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;click&#39;</span><span class="p">,</span>
      <span class="nx">event</span> <span class="p">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">doSomething</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">type</span><span class="p">),</span> <span class="kc">false</span><span class="p">);</span>
  <span class="p">},</span>

  <span class="nx">doSomething</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Handling &#39;</span> <span class="o">+</span> <span class="nx">type</span>  <span class="o">+</span> <span class="s1">&#39; for &#39;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>上面代码的 <code class="docutils literal"><span class="pre">init</span></code> 方法中，使用了箭头函数，这导致这个箭头函数里面的 <code class="docutils literal"><span class="pre">this</span></code> ，总是指向 <code class="docutils literal"><span class="pre">handler</span></code> 对象。否则，回调函数运行时， <code class="docutils literal"><span class="pre">this.doSomething</span></code> 这一行会报错，因为此时 <code class="docutils literal"><span class="pre">this</span></code> 指向 <code class="docutils literal"><span class="pre">document</span></code> 对象。</p>
<p><code class="docutils literal"><span class="pre">this</span></code> 指向的固定化，并不是因为箭头函数内部有绑定 <code class="docutils literal"><span class="pre">this</span></code> 的机制，实际原因是箭头函数根本没有自己的 <code class="docutils literal"><span class="pre">this</span></code> ，导致内部的 <code class="docutils literal"><span class="pre">this</span></code> 就是外层代码块的 <code class="docutils literal"><span class="pre">this</span></code> 。正是因为它没有 <code class="docutils literal"><span class="pre">this</span></code> ，所以也就不能用作构造函数。</p>
<p>所以，箭头函数转成 ES5 的代码如下。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// ES6</span>
<span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;id:&#39;</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span>
  <span class="p">},</span> <span class="mi">100</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ES5</span>
<span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">_this</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>

  <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;id:&#39;</span><span class="p">,</span> <span class="nx">_this</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span>
  <span class="p">},</span> <span class="mi">100</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码中，转换后的 ES5 版本清楚地说明了，箭头函数里面根本没有自己的 <code class="docutils literal"><span class="pre">this</span></code> ，而是引用外层的 <code class="docutils literal"><span class="pre">this</span></code> 。</p>
<p>请问下面的代码之中有几个 <code class="docutils literal"><span class="pre">this</span></code> ？</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;id:&#39;</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span>
      <span class="p">};</span>
    <span class="p">};</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">.</span><span class="nx">call</span><span class="p">({</span><span class="nx">id</span><span class="o">:</span> <span class="mi">1</span><span class="p">});</span>

<span class="kd">var</span> <span class="nx">t1</span> <span class="o">=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">call</span><span class="p">({</span><span class="nx">id</span><span class="o">:</span> <span class="mi">2</span><span class="p">})()();</span> <span class="c1">// id: 1</span>
<span class="kd">var</span> <span class="nx">t2</span> <span class="o">=</span> <span class="nx">f</span><span class="p">().</span><span class="nx">call</span><span class="p">({</span><span class="nx">id</span><span class="o">:</span> <span class="mi">3</span><span class="p">})();</span> <span class="c1">// id: 1</span>
<span class="kd">var</span> <span class="nx">t3</span> <span class="o">=</span> <span class="nx">f</span><span class="p">()().</span><span class="nx">call</span><span class="p">({</span><span class="nx">id</span><span class="o">:</span> <span class="mi">4</span><span class="p">});</span> <span class="c1">// id: 1</span>
</pre></div>
</div>
<p>上面代码之中，只有一个 <code class="docutils literal"><span class="pre">this</span></code> ，就是函数 <code class="docutils literal"><span class="pre">foo</span></code> 的 <code class="docutils literal"><span class="pre">this</span></code> ，所以 <code class="docutils literal"><span class="pre">t1</span></code> 、 <code class="docutils literal"><span class="pre">t2</span></code> 、 <code class="docutils literal"><span class="pre">t3</span></code> 都输出同样的结果。因为所有的内层函数都是箭头函数，都没有自己的 <code class="docutils literal"><span class="pre">this</span></code> ，它们的 <code class="docutils literal"><span class="pre">this</span></code> 其实都是最外层 <code class="docutils literal"><span class="pre">foo</span></code> 函数的 <code class="docutils literal"><span class="pre">this</span></code> 。</p>
<p>除了 <code class="docutils literal"><span class="pre">this</span></code> ，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量： <code class="docutils literal"><span class="pre">arguments</span></code> 、 <code class="docutils literal"><span class="pre">super</span></code> 、 <code class="docutils literal"><span class="pre">new.target</span></code> 。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;args:&#39;</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
  <span class="p">},</span> <span class="mi">100</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">foo</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="c1">// args: [2, 4, 6, 8]</span>
</pre></div>
</div>
<p>上面代码中，箭头函数内部的变量 <code class="docutils literal"><span class="pre">arguments</span></code> ，其实是函数 <code class="docutils literal"><span class="pre">foo</span></code> 的 <code class="docutils literal"><span class="pre">arguments</span></code> 变量。</p>
<p>另外，由于箭头函数没有自己的 <code class="docutils literal"><span class="pre">this</span></code> ，所以当然也就不能用 <code class="docutils literal"><span class="pre">call()</span></code> 、 <code class="docutils literal"><span class="pre">apply()</span></code> 、 <code class="docutils literal"><span class="pre">bind()</span></code> 这些方法去改变 <code class="docutils literal"><span class="pre">this</span></code> 的指向。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span>
    <span class="p">(()</span> <span class="p">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">).</span><span class="nx">bind</span><span class="p">({</span> <span class="nx">x</span><span class="o">:</span> <span class="s1">&#39;inner&#39;</span> <span class="p">})()</span>
  <span class="p">];</span>
<span class="p">}).</span><span class="nx">call</span><span class="p">({</span> <span class="nx">x</span><span class="o">:</span> <span class="s1">&#39;outer&#39;</span> <span class="p">});</span>
<span class="c1">// [&#39;outer&#39;]</span>
</pre></div>
</div>
<p>上面代码中，箭头函数没有自己的 <code class="docutils literal"><span class="pre">this</span></code> ，所以 <code class="docutils literal"><span class="pre">bind</span></code> 方法无效，内部的 <code class="docutils literal"><span class="pre">this</span></code> 指向外部的 <code class="docutils literal"><span class="pre">this</span></code> 。</p>
<p>长期以来，JavaScript 语言的 <code class="docutils literal"><span class="pre">this</span></code> 对象一直是一个令人头痛的问题，在对象方法中使用 <code class="docutils literal"><span class="pre">this</span></code> ，必须非常小心。箭头函数”绑定” <code class="docutils literal"><span class="pre">this</span></code> ，很大程度上解决了这个困扰。</p>
</div>
<div class="section" id="id12">
<h3>8.5.3. 嵌套的箭头函数<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h3>
<p>箭头函数内部，还可以再使用箭头函数。下面是一个 ES5 语法的多重嵌套函数。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">insert</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span><span class="nx">into</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">array</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span><span class="nx">after</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">afterValue</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">array</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">array</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">afterValue</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
      <span class="k">return</span> <span class="nx">array</span><span class="p">;</span>
    <span class="p">}};</span>
  <span class="p">}};</span>
<span class="p">}</span>

<span class="nx">insert</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nx">into</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]).</span><span class="nx">after</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//[1, 2, 3]</span>
</pre></div>
</div>
<p>上面这个函数，可以使用箭头函数改写。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">insert</span> <span class="o">=</span> <span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">({</span><span class="nx">into</span><span class="o">:</span> <span class="p">(</span><span class="nx">array</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">({</span><span class="nx">after</span><span class="o">:</span> <span class="p">(</span><span class="nx">afterValue</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">array</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">array</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">afterValue</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">array</span><span class="p">;</span>
<span class="p">}})});</span>

<span class="nx">insert</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nx">into</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]).</span><span class="nx">after</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//[1, 2, 3]</span>
</pre></div>
</div>
<p>下面是一个部署管道机制（ <code class="docutils literal"><span class="pre">pipeline</span></code> ）的例子，即前一个函数的输出是后一个函数的输入。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">pipeline</span> <span class="o">=</span> <span class="p">(...</span><span class="nx">funcs</span><span class="p">)</span> <span class="p">=&gt;</span>
  <span class="nx">val</span> <span class="p">=&gt;</span> <span class="nx">funcs</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">b</span><span class="p">(</span><span class="nx">a</span><span class="p">),</span> <span class="nx">val</span><span class="p">);</span>

<span class="kr">const</span> <span class="nx">plus1</span> <span class="o">=</span> <span class="nx">a</span> <span class="p">=&gt;</span> <span class="nx">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">mult2</span> <span class="o">=</span> <span class="nx">a</span> <span class="p">=&gt;</span> <span class="nx">a</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">addThenMult</span> <span class="o">=</span> <span class="nx">pipeline</span><span class="p">(</span><span class="nx">plus1</span><span class="p">,</span> <span class="nx">mult2</span><span class="p">);</span>

<span class="nx">addThenMult</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="c1">// 12</span>
</pre></div>
</div>
<p>如果觉得上面的写法可读性比较差，也可以采用下面的写法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">plus1</span> <span class="o">=</span> <span class="nx">a</span> <span class="p">=&gt;</span> <span class="nx">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">mult2</span> <span class="o">=</span> <span class="nx">a</span> <span class="p">=&gt;</span> <span class="nx">a</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>

<span class="nx">mult2</span><span class="p">(</span><span class="nx">plus1</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="c1">// 12</span>
</pre></div>
</div>
<p>箭头函数还有一个功能，就是可以很方便地改写 <code class="docutils literal"><span class="pre">λ</span></code> 演算。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// λ演算的写法</span>
<span class="nx">fix</span> <span class="o">=</span> <span class="nx">λf</span><span class="p">.(</span><span class="nx">λx</span><span class="p">.</span><span class="nx">f</span><span class="p">(</span><span class="nx">λv</span><span class="p">.</span><span class="nx">x</span><span class="p">(</span><span class="nx">x</span><span class="p">)(</span><span class="nx">v</span><span class="p">)))(</span><span class="nx">λx</span><span class="p">.</span><span class="nx">f</span><span class="p">(</span><span class="nx">λv</span><span class="p">.</span><span class="nx">x</span><span class="p">(</span><span class="nx">x</span><span class="p">)(</span><span class="nx">v</span><span class="p">)))</span>

<span class="c1">// ES6的写法</span>
<span class="kd">var</span> <span class="nx">fix</span> <span class="o">=</span> <span class="nx">f</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="nx">x</span> <span class="p">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">v</span> <span class="p">=&gt;</span> <span class="nx">x</span><span class="p">(</span><span class="nx">x</span><span class="p">)(</span><span class="nx">v</span><span class="p">)))</span>
               <span class="p">(</span><span class="nx">x</span> <span class="p">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">v</span> <span class="p">=&gt;</span> <span class="nx">x</span><span class="p">(</span><span class="nx">x</span><span class="p">)(</span><span class="nx">v</span><span class="p">)));</span>
</pre></div>
</div>
<p>上面两种写法，几乎是一一对应的。由于 <code class="docutils literal"><span class="pre">λ</span></code> 演算对于计算机科学非常重要，这使得我们可以用 ES6 作为替代工具，探索计算机科学。</p>
</div>
</div>
<div class="section" id="id13">
<h2>8.6. 双冒号运算符<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h2>
<p>箭头函数可以绑定 <code class="docutils literal"><span class="pre">this</span></code> 对象，大大减少了显式绑定 <code class="docutils literal"><span class="pre">this</span></code> 对象的写法（ <code class="docutils literal"><span class="pre">call</span></code> 、 <code class="docutils literal"><span class="pre">apply</span></code> 、 <code class="docutils literal"><span class="pre">bind</span></code> ）。但是，箭头函数并不适用于所有场合，所以现在有一个提案，提出了“函数绑定”（function bind）运算符，用来取代 <code class="docutils literal"><span class="pre">call</span></code> 、 <code class="docutils literal"><span class="pre">apply</span></code> 、 <code class="docutils literal"><span class="pre">bind</span></code> 调用。</p>
<p>函数绑定运算符是并排的两个冒号（ <code class="docutils literal"><span class="pre">::</span></code> ），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即 <code class="docutils literal"><span class="pre">this</span></code> 对象），绑定到右边的函数上面。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">foo</span><span class="o">::</span><span class="nx">bar</span><span class="p">;</span>
<span class="c1">// 等同于</span>
<span class="nx">bar</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">foo</span><span class="p">);</span>

<span class="nx">foo</span><span class="o">::</span><span class="nx">bar</span><span class="p">(...</span><span class="nx">arguments</span><span class="p">);</span>
<span class="c1">// 等同于</span>
<span class="nx">bar</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">foo</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>

<span class="kr">const</span> <span class="nx">hasOwnProperty</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">hasOwn</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">obj</span><span class="o">::</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">method</span> <span class="o">=</span> <span class="nx">obj</span><span class="o">::</span><span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">;</span>
<span class="c1">// 等同于</span>
<span class="kd">var</span> <span class="nx">method</span> <span class="o">=</span> <span class="o">::</span><span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">;</span>

<span class="kd">let</span> <span class="nx">log</span> <span class="o">=</span> <span class="o">::</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">;</span>
<span class="c1">// 等同于</span>
<span class="kd">var</span> <span class="nx">log</span> <span class="o">=</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">console</span><span class="p">);</span>
</pre></div>
</div>
<p>如果双冒号运算符的运算结果，还是一个对象，就可以采用链式写法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="p">{</span> <span class="nx">map</span><span class="p">,</span> <span class="nx">takeWhile</span><span class="p">,</span> <span class="nx">forEach</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;iterlib&quot;</span><span class="p">;</span>

<span class="nx">getPlayers</span><span class="p">()</span>
<span class="o">::</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="p">=&gt;</span> <span class="nx">x</span><span class="p">.</span><span class="nx">character</span><span class="p">())</span>
<span class="o">::</span><span class="nx">takeWhile</span><span class="p">(</span><span class="nx">x</span> <span class="p">=&gt;</span> <span class="nx">x</span><span class="p">.</span><span class="nx">strength</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">)</span>
<span class="o">::</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">x</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="section" id="id14">
<h2>8.7. 尾调用优化<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h2>
<div class="section" id="id15">
<h3>8.7.1. 什么是尾调用？<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h3>
<p>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">){</span>
  <span class="k">return</span> <span class="nx">g</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码中，函数 <code class="docutils literal"><span class="pre">f</span></code> 的最后一步是调用函数 <code class="docutils literal"><span class="pre">g</span></code> ，这就叫尾调用。</p>
<p>以下三种情况，都不属于尾调用。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// 情况一</span>
<span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">){</span>
  <span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">g</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 情况二</span>
<span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">){</span>
  <span class="k">return</span> <span class="nx">g</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 情况三</span>
<span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">){</span>
  <span class="nx">g</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码中，情况一是调用函数 <code class="docutils literal"><span class="pre">g</span></code> 之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。情况三等同于下面的代码。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">){</span>
  <span class="nx">g</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
  <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>尾调用不一定出现在函数尾部，只要是最后一步操作即可。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">m</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">n</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码中，函数 <code class="docutils literal"><span class="pre">m</span></code> 和 <code class="docutils literal"><span class="pre">n</span></code> 都属于尾调用，因为它们都是函数 <code class="docutils literal"><span class="pre">f</span></code> 的最后一步操作。</p>
</div>
<div class="section" id="id16">
<h3>8.7.2. 尾调用优化<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h3>
<p>尾调用之所以与其他调用不同，就在于它的特殊的调用位置。</p>
<p>我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数 <code class="docutils literal"><span class="pre">A</span></code> 的内部调用函数 <code class="docutils literal"><span class="pre">B</span></code> ，那么在 <code class="docutils literal"><span class="pre">A</span></code> 的调用帧上方，还会形成一个 <code class="docutils literal"><span class="pre">B</span></code> 的调用帧。等到 <code class="docutils literal"><span class="pre">B</span></code> 运行结束，将结果返回到 <code class="docutils literal"><span class="pre">A</span></code> ， <code class="docutils literal"><span class="pre">B</span></code> 的调用帧才会消失。如果函数 <code class="docutils literal"><span class="pre">B</span></code> 内部还调用函数 <code class="docutils literal"><span class="pre">C</span></code> ，那就还有一个 <code class="docutils literal"><span class="pre">C</span></code> 的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。</p>
<p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">m</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">n</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">g</span><span class="p">(</span><span class="nx">m</span> <span class="o">+</span> <span class="nx">n</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">f</span><span class="p">();</span>

<span class="c1">// 等同于</span>
<span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">g</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">f</span><span class="p">();</span>

<span class="c1">// 等同于</span>
<span class="nx">g</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</pre></div>
</div>
<p>上面代码中，如果函数 <code class="docutils literal"><span class="pre">g</span></code> 不是尾调用，函数 <code class="docutils literal"><span class="pre">f</span></code> 就需要保存内部变量 <code class="docutils literal"><span class="pre">m</span></code> 和 <code class="docutils literal"><span class="pre">n</span></code> 的值、 <code class="docutils literal"><span class="pre">g</span></code> 的调用位置等信息。但由于调用 <code class="docutils literal"><span class="pre">g</span></code> 之后，函数 <code class="docutils literal"><span class="pre">f</span></code> 就结束了，所以执行到最后一步，完全可以删除 <code class="docutils literal"><span class="pre">f(x)</span></code> 的调用帧，只保留 <code class="docutils literal"><span class="pre">g(3)</span></code> 的调用帧。</p>
<p>这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。</p>
<p><strong>注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。</strong></p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">addOne</span><span class="p">(</span><span class="nx">a</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">one</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kd">function</span> <span class="nx">inner</span><span class="p">(</span><span class="nx">b</span><span class="p">){</span>
        <span class="k">return</span> <span class="nx">b</span> <span class="o">+</span> <span class="nx">one</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">inner</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的函数不会进行尾调用优化，因为内层函数 <code class="docutils literal"><span class="pre">inner</span></code> 用到了外层函数 <code class="docutils literal"><span class="pre">addOne</span></code> 的内部变量 <code class="docutils literal"><span class="pre">one</span></code> 。</p>
</div>
<div class="section" id="id17">
<h3>8.7.3. 尾递归<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h3>
<p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p>
<p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">factorial</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">n</span> <span class="o">*</span> <span class="nx">factorial</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">factorial</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="c1">// 120</span>
</pre></div>
</div>
<p>上面代码是一个阶乘函数，计算 <code class="docutils literal"><span class="pre">n</span></code> 的阶乘，最多需要保存 <code class="docutils literal"><span class="pre">n</span></code> 个调用记录，复杂度 <code class="docutils literal"><span class="pre">O(n)</span></code> 。</p>
<p>如果改写成尾递归，只保留一个调用记录，复杂度 <code class="docutils literal"><span class="pre">O(1)</span></code> 。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">factorial</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">total</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nx">total</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">factorial</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">n</span> <span class="o">*</span> <span class="nx">total</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">factorial</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// 120</span>
</pre></div>
</div>
<p>还有一个比较著名的例子，就是计算 <code class="docutils literal"><span class="pre">Fibonacci</span></code> 数列，也能充分说明尾递归优化的重要性。</p>
<p>非尾递归的 <code class="docutils literal"><span class="pre">Fibonacci</span></code> 数列实现如下。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">Fibonacci</span> <span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span> <span class="nx">n</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="mi">1</span><span class="p">};</span>

  <span class="k">return</span> <span class="nx">Fibonacci</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nx">Fibonacci</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">Fibonacci</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="c1">// 89</span>
<span class="nx">Fibonacci</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="c1">// 堆栈溢出</span>
<span class="nx">Fibonacci</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span> <span class="c1">// 堆栈溢出</span>
</pre></div>
</div>
<p>尾递归优化过的 <code class="docutils literal"><span class="pre">Fibonacci</span></code> 数列实现如下。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">Fibonacci2</span> <span class="p">(</span><span class="nx">n</span> <span class="p">,</span> <span class="nx">ac1</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">,</span> <span class="nx">ac2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span> <span class="nx">n</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="nx">ac2</span><span class="p">};</span>

  <span class="k">return</span> <span class="nx">Fibonacci2</span> <span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">ac2</span><span class="p">,</span> <span class="nx">ac1</span> <span class="o">+</span> <span class="nx">ac2</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">Fibonacci2</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="c1">// 573147844013817200000</span>
<span class="nx">Fibonacci2</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span> <span class="c1">// 7.0330367711422765e+208</span>
<span class="nx">Fibonacci2</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span> <span class="c1">// Infinity</span>
</pre></div>
</div>
<p>由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6 是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，ES6 中只要使用尾递归，就不会发生栈溢出，相对节省内存。</p>
</div>
<div class="section" id="id18">
<h3>8.7.4. 递归函数的改写<a class="headerlink" href="#id18" title="永久链接至标题">¶</a></h3>
<p>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 <code class="docutils literal"><span class="pre">factorial</span></code> 需要用到一个中间变量 <code class="docutils literal"><span class="pre">total</span></code> ，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算5的阶乘，需要传入两个参数5和1？</p>
<p>两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">tailFactorial</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">total</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nx">total</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">tailFactorial</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">n</span> <span class="o">*</span> <span class="nx">total</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">factorial</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">tailFactorial</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">factorial</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="c1">// 120</span>
</pre></div>
</div>
<p>上面代码通过一个正常形式的阶乘函数 <code class="docutils literal"><span class="pre">factorial</span></code> ，调用尾递归函数 <code class="docutils literal"><span class="pre">tailFactorial</span></code> ，看起来就正常多了。</p>
<p>函数式编程有一个概念，叫做柯里化（ <code class="docutils literal"><span class="pre">currying</span></code> ），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">currying</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">m</span><span class="p">,</span> <span class="nx">n</span><span class="p">);</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">tailFactorial</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">total</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nx">total</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">tailFactorial</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">n</span> <span class="o">*</span> <span class="nx">total</span><span class="p">);</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">factorial</span> <span class="o">=</span> <span class="nx">currying</span><span class="p">(</span><span class="nx">tailFactorial</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="nx">factorial</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="c1">// 120</span>
</pre></div>
</div>
<p>上面代码通过柯里化，将尾递归函数 <code class="docutils literal"><span class="pre">tailFactorial</span></code> 变为只接受一个参数的 <code class="docutils literal"><span class="pre">factorial</span></code> 。</p>
<p>第二种方法就简单多了，就是采用 ES6 的函数默认值。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">factorial</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">total</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nx">total</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">factorial</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">n</span> <span class="o">*</span> <span class="nx">total</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">factorial</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="c1">// 120</span>
</pre></div>
</div>
<p>上面代码中，参数 <code class="docutils literal"><span class="pre">total</span></code> 有默认值 1，所以调用时不用提供这个值。</p>
<p>总结一下，递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾调用优化”的语言（比如 Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。</p>
</div>
<div class="section" id="id19">
<h3>8.7.5. 尾递归优化的实现<a class="headerlink" href="#id19" title="永久链接至标题">¶</a></h3>
<p>尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。</p>
<p>它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。</p>
<p>下面是一个正常的递归函数。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">100000</span><span class="p">)</span>
<span class="c1">// Uncaught RangeError: Maximum call stack size exceeded(…)</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">sum</span></code> 是一个递归函数，参数 <code class="docutils literal"><span class="pre">x</span></code> 是需要累加的值，参数 <code class="docutils literal"><span class="pre">y</span></code> 控制递归次数。一旦指定 <code class="docutils literal"><span class="pre">sum</span></code> 递归 100000 次，就会报错，提示超出调用栈的最大次数。</p>
<p>蹦床函数（trampoline）可以将递归执行转为循环执行。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">trampoline</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">f</span> <span class="o">&amp;&amp;</span> <span class="nx">f</span> <span class="k">instanceof</span> <span class="nb">Function</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">f</span> <span class="o">=</span> <span class="nx">f</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">f</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面就是蹦床函数的一个实现，它接受一个函数 <code class="docutils literal"><span class="pre">f</span></code> 作为参数。只要 <code class="docutils literal"><span class="pre">f</span></code> 执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。</p>
<p>然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">sum</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">sum</span></code> 函数的每次执行，都会返回自身的另一个版本。</p>
<p>现在，使用蹦床函数执行 <code class="docutils literal"><span class="pre">sum</span></code> ，就不会发生调用栈溢出。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">trampoline</span><span class="p">(</span><span class="nx">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">100000</span><span class="p">))</span> <span class="c1">// 100001</span>
</pre></div>
</div>
<p>蹦床函数并不是真正的尾递归优化，下面的实现才是。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">tco</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">value</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">active</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">accumulated</span> <span class="o">=</span> <span class="p">[];</span>

  <span class="k">return</span> <span class="kd">function</span> <span class="nx">accumulator</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">accumulated</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">active</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">active</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
      <span class="k">while</span> <span class="p">(</span><span class="nx">accumulated</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">value</span> <span class="o">=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">accumulated</span><span class="p">.</span><span class="nx">shift</span><span class="p">());</span>
      <span class="p">}</span>
      <span class="nx">active</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
      <span class="k">return</span> <span class="nx">value</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">sum</span> <span class="o">=</span> <span class="nx">tco</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span>
  <span class="p">}</span>
<span class="p">});</span>

<span class="nx">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">100000</span><span class="p">)</span>
<span class="c1">// 100001</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">tco</span></code> 函数是尾递归优化的实现，它的奥妙就在于状态变量 <code class="docutils literal"><span class="pre">active</span></code> 。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归 <code class="docutils literal"><span class="pre">sum</span></code> 返回的都是 <code class="docutils literal"><span class="pre">undefined</span></code> ，所以就避免了递归执行；而 <code class="docutils literal"><span class="pre">accumulated</span></code> 数组存放每一轮 <code class="docutils literal"><span class="pre">sum</span></code> 执行的参数，总是有值的，这就保证了 <code class="docutils literal"><span class="pre">accumulator</span></code> 函数内部的 <code class="docutils literal"><span class="pre">while</span></code> 循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。</p>
</div>
</div>
<div class="section" id="id20">
<h2>8.8. 函数参数的尾逗号<a class="headerlink" href="#id20" title="永久链接至标题">¶</a></h2>
<p>ES2017 允许函数的最后一个参数有尾逗号（trailing comma）。</p>
<p>此前，函数定义和调用时，都不允许最后一个参数后面出现逗号。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">clownsEverywhere</span><span class="p">(</span>
  <span class="nx">param1</span><span class="p">,</span>
  <span class="nx">param2</span>
<span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>

<span class="nx">clownsEverywhere</span><span class="p">(</span>
  <span class="s1">&#39;foo&#39;</span><span class="p">,</span>
  <span class="s1">&#39;bar&#39;</span>
<span class="p">);</span>
</pre></div>
</div>
<p>上面代码中，如果在 <code class="docutils literal"><span class="pre">param2</span></code> 或 <code class="docutils literal"><span class="pre">bar</span></code> 后面加一个逗号，就会报错。</p>
<p>如果像上面这样，将参数写成多行（即每个参数占据一行），以后修改代码的时候，想为函数 <code class="docutils literal"><span class="pre">clownsEverywhere</span></code> 添加第三个参数，或者调整参数的次序，就势必要在原来最后一个参数后面添加一个逗号。这对于版本管理系统来说，就会显示添加逗号的那一行也发生了变动。这看上去有点冗余，因此新的语法允许定义和调用时，尾部直接有一个逗号。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">clownsEverywhere</span><span class="p">(</span>
  <span class="nx">param1</span><span class="p">,</span>
  <span class="nx">param2</span><span class="p">,</span>
<span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>

<span class="nx">clownsEverywhere</span><span class="p">(</span>
  <span class="s1">&#39;foo&#39;</span><span class="p">,</span>
  <span class="s1">&#39;bar&#39;</span><span class="p">,</span>
<span class="p">);</span>
</pre></div>
</div>
<p>这样的规定也使得，函数参数与数组和对象的尾逗号规则，保持一致了。</p>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="数组的扩展.html" class="btn btn-neutral float-right" title="9. 数组的扩展" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="数值的扩展.html" class="btn btn-neutral" title="7. 数值的扩展" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, lzh.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.0',
            LANGUAGE:'zh_CN',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="_static/translations.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();

      });


      $(document).ready(function(){
        var offset = sessionStorage.getItem("offsetTop");
        $('.wy-side-scroll').scrollTop(offset);
        sessionStorage.setItem("offsetTop", 0);


        $('.wy-menu > ul').click(function(){
            sessionStorage.setItem("offsetTop", $('.wy-side-scroll').scrollTop());
        });
      })

  </script>
   

</body>
</html>