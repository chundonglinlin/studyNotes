

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>10. 对象的扩展 &mdash; ECMAScript6入门 1.0 文档</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="索引"
              href="genindex.html"/>
        <link rel="search" title="搜索" href="search.html"/>
    <link rel="top" title="ECMAScript6入门 1.0 文档" href="index.html"/>
        <link rel="next" title="11. Symbol" href="Symbol.html"/>
        <link rel="prev" title="9. 数组的扩展" href="数组的扩展.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> ECMAScript6入门
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="前言.html">1. 前言</a></li>
<li class="toctree-l1"><a class="reference internal" href="ECMAScript6简介.html">2. ECMAScript6简介</a></li>
<li class="toctree-l1"><a class="reference internal" href="let和const命令.html">3. let 和 const 命令</a></li>
<li class="toctree-l1"><a class="reference internal" href="变量的解构赋值.html">4. 变量的解构赋值</a></li>
<li class="toctree-l1"><a class="reference internal" href="字符串的扩展.html">5. 字符串的扩展</a></li>
<li class="toctree-l1"><a class="reference internal" href="正则的扩展.html">6. 正则的扩展</a></li>
<li class="toctree-l1"><a class="reference internal" href="数值的扩展.html">7. 数值的扩展</a></li>
<li class="toctree-l1"><a class="reference internal" href="函数的扩展.html">8. 函数的扩展</a></li>
<li class="toctree-l1"><a class="reference internal" href="数组的扩展.html">9. 数组的扩展</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">10. 对象的扩展</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id2">10.1. 属性的简洁表示法</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">10.2. 属性名表达式</a></li>
<li class="toctree-l2"><a class="reference internal" href="#name">10.3. 方法的 name 属性</a></li>
<li class="toctree-l2"><a class="reference internal" href="#object-is">10.4. Object.is()</a></li>
<li class="toctree-l2"><a class="reference internal" href="#object-assign">10.5. Object.assign()</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id4">10.5.1. 基本用法</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">10.5.2. 注意点</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id6">10.5.3. 常见用途</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id7">10.6. 属性的可枚举性和遍历</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id8">10.6.1. 可枚举性</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id9">10.6.2. 属性的遍历</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#object-getownpropertydescriptors">10.7. Object.getOwnPropertyDescriptors()</a></li>
<li class="toctree-l2"><a class="reference internal" href="#proto-object-setprototypeof-object-getprototypeof">10.8. __proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#proto">10.8.1. __proto__属性</a></li>
<li class="toctree-l3"><a class="reference internal" href="#object-setprototypeof">10.8.2. Object.setPrototypeOf()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#object-getprototypeof">10.8.3. Object.getPrototypeOf()</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#super">10.9. super 关键字</a></li>
<li class="toctree-l2"><a class="reference internal" href="#object-keys-object-values-object-entries">10.10. Object.keys()，Object.values()，Object.entries()</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#object-keys">10.10.1. Object.keys()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#object-values">10.10.2. Object.values()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#object-entries">10.10.3. Object.entries</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id10">10.11. 对象的扩展运算符</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id11">10.11.1. 解构赋值</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id12">10.11.2. 扩展运算符</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Symbol.html">11. Symbol</a></li>
<li class="toctree-l1"><a class="reference internal" href="Set和Map数据结构.html">12. Set和Map数据结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="Proxy.html">13. Proxy</a></li>
<li class="toctree-l1"><a class="reference internal" href="Reflect.html">14. Reflect</a></li>
<li class="toctree-l1"><a class="reference internal" href="Promise对象.html">15. Promise对象</a></li>
<li class="toctree-l1"><a class="reference internal" href="Iterator和for...of循环.html">16. Iterator 和 for…of 循环</a></li>
<li class="toctree-l1"><a class="reference internal" href="Generator函数的语法.html">17. Generator函数的语法</a></li>
<li class="toctree-l1"><a class="reference internal" href="Generator函数的异步应用.html">18. Generator 函数的异步应用</a></li>
<li class="toctree-l1"><a class="reference internal" href="async函数.html">19. asyn函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="Class的基本语法.html">20. Class 的基本语法</a></li>
<li class="toctree-l1"><a class="reference internal" href="Class的继承.html">21. Class的继承</a></li>
<li class="toctree-l1"><a class="reference internal" href="Decorator.html">22. 修饰器</a></li>
<li class="toctree-l1"><a class="reference internal" href="Module的语法.html">23. Module 的语法</a></li>
<li class="toctree-l1"><a class="reference internal" href="Module的加载实现.html">24. Module 的加载实现</a></li>
<li class="toctree-l1"><a class="reference internal" href="编程风格.html">25. 编程风格</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">ECMAScript6入门</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>10. 对象的扩展</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>10. 对象的扩展<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<div class="section" id="id2">
<h2>10.1. 属性的简洁表示法<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="s1">&#39;bar&#39;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">baz</span> <span class="o">=</span> <span class="p">{</span><span class="nx">foo</span><span class="p">};</span>
<span class="nx">baz</span> <span class="c1">// {foo: &quot;bar&quot;}</span>

<span class="c1">// 等同于</span>
<span class="kr">const</span> <span class="nx">baz</span> <span class="o">=</span> <span class="p">{</span><span class="nx">foo</span><span class="o">:</span> <span class="nx">foo</span><span class="p">};</span>
</pre></div>
</div>
<p>上面代码表明，ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。下面是另一个例子。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">};</span>
<span class="p">}</span>

<span class="c1">// 等同于</span>

<span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span><span class="nx">x</span><span class="o">:</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="nx">y</span><span class="p">};</span>
<span class="p">}</span>

<span class="nx">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">// Object {x: 1, y: 2}</span>
</pre></div>
</div>
<p>除了属性简写，方法也可以简写。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">method</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s2">&quot;Hello!&quot;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 等同于</span>

<span class="kr">const</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">method</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s2">&quot;Hello!&quot;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>下面是一个实际的例子。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">birth</span> <span class="o">=</span> <span class="s1">&#39;2000/01/01&#39;</span><span class="p">;</span>

<span class="kr">const</span> <span class="nx">Person</span> <span class="o">=</span> <span class="p">{</span>

  <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;张三&#39;</span><span class="p">,</span>

  <span class="c1">//等同于birth: birth</span>
  <span class="nx">birth</span><span class="p">,</span>

  <span class="c1">// 等同于hello: function ()...</span>
  <span class="nx">hello</span><span class="p">()</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;我的名字是&#39;</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="p">}</span>

<span class="p">};</span>
</pre></div>
</div>
<p>这种写法用于函数的返回值，将会非常方便。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">getPoint</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kr">const</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="k">return</span> <span class="p">{</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">};</span>
<span class="p">}</span>

<span class="nx">getPoint</span><span class="p">()</span>
<span class="c1">// {x:1, y:10}</span>
</pre></div>
</div>
<p>CommonJS 模块输出一组变量，就非常合适使用简洁写法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">ms</span> <span class="o">=</span> <span class="p">{};</span>

<span class="kd">function</span> <span class="nx">getItem</span> <span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">key</span> <span class="k">in</span> <span class="nx">ms</span> <span class="o">?</span> <span class="nx">ms</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">:</span> <span class="kc">null</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">setItem</span> <span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">ms</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">clear</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">ms</span> <span class="o">=</span> <span class="p">{};</span>
<span class="p">}</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">getItem</span><span class="p">,</span> <span class="nx">setItem</span><span class="p">,</span> <span class="nx">clear</span> <span class="p">};</span>
<span class="c1">// 等同于</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">getItem</span><span class="o">:</span> <span class="nx">getItem</span><span class="p">,</span>
  <span class="nx">setItem</span><span class="o">:</span> <span class="nx">setItem</span><span class="p">,</span>
  <span class="nx">clear</span><span class="o">:</span> <span class="nx">clear</span>
<span class="p">};</span>
</pre></div>
</div>
<p>属性的赋值器（ <code class="docutils literal"><span class="pre">setter</span></code> ）和取值器（ <code class="docutils literal"><span class="pre">getter</span></code> ），事实上也是采用这种写法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">cart</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">_wheels</span><span class="o">:</span> <span class="mi">4</span><span class="p">,</span>

  <span class="nx">get</span> <span class="nx">wheels</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_wheels</span><span class="p">;</span>
  <span class="p">},</span>

  <span class="nx">set</span> <span class="nx">wheels</span> <span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">_wheels</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;数值太小了！&#39;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">_wheels</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>注意，简洁写法的属性名总是字符串，这会导致一些看上去比较奇怪的结果。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="kr">class</span> <span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="c1">// 等同于</span>

<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s1">&#39;class&#39;</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">class</span></code> 是字符串，所以不会因为它属于关键字，而导致语法解析报错。</p>
<p>如果某个方法的值是一个 <code class="docutils literal"><span class="pre">Generator</span></code> 函数，前面需要加上星号。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="o">*</span> <span class="nx">m</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">yield</span> <span class="s1">&#39;hello world&#39;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h2>10.2. 属性名表达式<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>JavaScript 定义对象的属性，有两种方法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// 方法一</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>

<span class="c1">// 方法二</span>
<span class="nx">obj</span><span class="p">[</span><span class="s1">&#39;a&#39;</span> <span class="o">+</span> <span class="s1">&#39;bc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
</pre></div>
</div>
<p>上面代码的方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。</p>
<p>但是，如果使用字面量方式定义对象（使用大括号），在 ES5 中只能使用方法一（标识符）定义属性。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">foo</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="nx">abc</span><span class="o">:</span> <span class="mi">123</span>
<span class="p">};</span>
</pre></div>
</div>
<p>ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">propKey</span> <span class="o">=</span> <span class="s1">&#39;foo&#39;</span><span class="p">;</span>

<span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">[</span><span class="nx">propKey</span><span class="p">]</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="p">[</span><span class="s1">&#39;a&#39;</span> <span class="o">+</span> <span class="s1">&#39;bc&#39;</span><span class="p">]</span><span class="o">:</span> <span class="mi">123</span>
<span class="p">};</span>
</pre></div>
</div>
<p>下面是另一个例子。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">lastWord</span> <span class="o">=</span> <span class="s1">&#39;last word&#39;</span><span class="p">;</span>

<span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s1">&#39;first word&#39;</span><span class="o">:</span> <span class="s1">&#39;hello&#39;</span><span class="p">,</span>
  <span class="p">[</span><span class="nx">lastWord</span><span class="p">]</span><span class="o">:</span> <span class="s1">&#39;world&#39;</span>
<span class="p">};</span>

<span class="nx">a</span><span class="p">[</span><span class="s1">&#39;first word&#39;</span><span class="p">]</span> <span class="c1">// &quot;hello&quot;</span>
<span class="nx">a</span><span class="p">[</span><span class="nx">lastWord</span><span class="p">]</span> <span class="c1">// &quot;world&quot;</span>
<span class="nx">a</span><span class="p">[</span><span class="s1">&#39;last word&#39;</span><span class="p">]</span> <span class="c1">// &quot;world&quot;</span>
</pre></div>
</div>
<p>表达式还可以用于定义方法名。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">[</span><span class="s1">&#39;h&#39;</span> <span class="o">+</span> <span class="s1">&#39;ello&#39;</span><span class="p">]()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s1">&#39;hi&#39;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">hello</span><span class="p">()</span> <span class="c1">// hi</span>
</pre></div>
</div>
<p>注意，属性名表达式与简洁表示法，不能同时使用，会报错。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// 报错</span>
<span class="kr">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="s1">&#39;bar&#39;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">bar</span> <span class="o">=</span> <span class="s1">&#39;abc&#39;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">baz</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="nx">foo</span><span class="p">]</span> <span class="p">};</span>

<span class="c1">// 正确</span>
<span class="kr">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="s1">&#39;bar&#39;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">baz</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="nx">foo</span><span class="p">]</span><span class="o">:</span> <span class="s1">&#39;abc&#39;</span><span class="p">};</span>
</pre></div>
</div>
<p>注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串 <code class="docutils literal"><span class="pre">[object</span> <span class="pre">Object]</span></code> ，这一点要特别小心。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">keyA</span> <span class="o">=</span> <span class="p">{</span><span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">};</span>
<span class="kr">const</span> <span class="nx">keyB</span> <span class="o">=</span> <span class="p">{</span><span class="nx">b</span><span class="o">:</span> <span class="mi">2</span><span class="p">};</span>

<span class="kr">const</span> <span class="nx">myObject</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">[</span><span class="nx">keyA</span><span class="p">]</span><span class="o">:</span> <span class="s1">&#39;valueA&#39;</span><span class="p">,</span>
  <span class="p">[</span><span class="nx">keyB</span><span class="p">]</span><span class="o">:</span> <span class="s1">&#39;valueB&#39;</span>
<span class="p">};</span>

<span class="nx">myObject</span> <span class="c1">// Object {[object Object]: &quot;valueB&quot;}</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">[keyA]</span></code> 和 <code class="docutils literal"><span class="pre">[keyB]</span></code> 得到的都是 <code class="docutils literal"><span class="pre">[object</span> <span class="pre">Object]</span></code> ，所以 <code class="docutils literal"><span class="pre">[keyB]</span></code> 会把 <code class="docutils literal"><span class="pre">[keyA]</span></code> 覆盖掉，而 <code class="docutils literal"><span class="pre">myObject</span></code> 最后只有一个 <code class="docutils literal"><span class="pre">[object</span> <span class="pre">Object]</span></code> 属性。</p>
</div>
<div class="section" id="name">
<h2>10.3. 方法的 name 属性<a class="headerlink" href="#name" title="永久链接至标题">¶</a></h2>
<p>函数的 <code class="docutils literal"><span class="pre">name</span></code> 属性，返回函数名。对象方法也是函数，因此也有 <code class="docutils literal"><span class="pre">name</span></code> 属性。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">sayName</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;hello!&#39;</span><span class="p">);</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="nx">person</span><span class="p">.</span><span class="nx">sayName</span><span class="p">.</span><span class="nx">name</span>   <span class="c1">// &quot;sayName&quot;</span>
</pre></div>
</div>
<p>上面代码中，方法的 <code class="docutils literal"><span class="pre">name</span></code> 属性返回函数名（即方法名）。</p>
<p>如果对象的方法使用了取值函数（ <code class="docutils literal"><span class="pre">getter</span></code> ）和存值函数（ <code class="docutils literal"><span class="pre">setter</span></code> ），则 <code class="docutils literal"><span class="pre">name</span></code> 属性不是在该方法上面，而是该方法的属性的描述对象的 <code class="docutils literal"><span class="pre">get</span></code> 和 <code class="docutils literal"><span class="pre">set</span></code> 属性上面，返回值是方法名前加上 <code class="docutils literal"><span class="pre">get</span></code> 和 <code class="docutils literal"><span class="pre">set</span></code> 。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">get</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{},</span>
  <span class="nx">set</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">.</span><span class="nx">name</span>
<span class="c1">// TypeError: Cannot read property &#39;name&#39; of undefined</span>

<span class="kr">const</span> <span class="nx">descriptor</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">);</span>

<span class="nx">descriptor</span><span class="p">.</span><span class="nx">get</span><span class="p">.</span><span class="nx">name</span> <span class="c1">// &quot;get foo&quot;</span>
<span class="nx">descriptor</span><span class="p">.</span><span class="nx">set</span><span class="p">.</span><span class="nx">name</span> <span class="c1">// &quot;set foo&quot;</span>
</pre></div>
</div>
<p>有两种特殊情况： <code class="docutils literal"><span class="pre">bind</span></code> 方法创造的函数， <code class="docutils literal"><span class="pre">name</span></code> 属性返回 <code class="docutils literal"><span class="pre">bound</span></code> 加上原函数的名字； <code class="docutils literal"><span class="pre">Function</span></code> 构造函数创造的函数， <code class="docutils literal"><span class="pre">name</span></code> 属性返回 <code class="docutils literal"><span class="pre">anonymous</span></code> 。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">new</span> <span class="nb">Function</span><span class="p">()).</span><span class="nx">name</span> <span class="c1">// &quot;anonymous&quot;</span>

<span class="kd">var</span> <span class="nx">doSomething</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">};</span>
<span class="nx">doSomething</span><span class="p">.</span><span class="nx">bind</span><span class="p">().</span><span class="nx">name</span> <span class="c1">// &quot;bound doSomething&quot;</span>
</pre></div>
</div>
<p>如果对象的方法是一个 <code class="docutils literal"><span class="pre">Symbol</span></code> 值，那么 <code class="docutils literal"><span class="pre">name</span></code> 属性返回的是这个 <code class="docutils literal"><span class="pre">Symbol</span></code> 值的描述。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">key1</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s1">&#39;description&#39;</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">key2</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">();</span>
<span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">[</span><span class="nx">key1</span><span class="p">]()</span> <span class="p">{},</span>
  <span class="p">[</span><span class="nx">key2</span><span class="p">]()</span> <span class="p">{},</span>
<span class="p">};</span>
<span class="nx">obj</span><span class="p">[</span><span class="nx">key1</span><span class="p">].</span><span class="nx">name</span> <span class="c1">// &quot;[description]&quot;</span>
<span class="nx">obj</span><span class="p">[</span><span class="nx">key2</span><span class="p">].</span><span class="nx">name</span> <span class="c1">// &quot;&quot;</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">key1</span></code> 对应的 <code class="docutils literal"><span class="pre">Symbol</span></code> 值有描述， <code class="docutils literal"><span class="pre">key2</span></code> 没有。</p>
</div>
<div class="section" id="object-is">
<h2>10.4. Object.is()<a class="headerlink" href="#object-is" title="永久链接至标题">¶</a></h2>
<p>ES5 比较两个值是否相等，只有两个运算符：相等运算符（ <code class="docutils literal"><span class="pre">==</span></code> ）和严格相等运算符（ <code class="docutils literal"><span class="pre">===</span></code> ）。它们都有缺点，前者会自动转换数据类型，后者的 <code class="docutils literal"><span class="pre">NaN</span></code> 不等于自身，以及 <code class="docutils literal"><span class="pre">+0</span></code> 等于 <code class="docutils literal"><span class="pre">-0</span></code> 。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。</p>
<p>ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。 <code class="docutils literal"><span class="pre">Object.is</span></code> 就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（ <code class="docutils literal"><span class="pre">===</span></code> ）的行为基本一致。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nb">Object</span><span class="p">.</span><span class="nx">is</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">)</span>
<span class="c1">// true</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">is</span><span class="p">({},</span> <span class="p">{})</span>
<span class="c1">// false</span>
</pre></div>
</div>
<p>不同之处只有两个：一是 <code class="docutils literal"><span class="pre">+0</span></code> 不等于 <code class="docutils literal"><span class="pre">-0</span></code> ，二是 <code class="docutils literal"><span class="pre">NaN</span></code> 等于自身。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="o">+</span><span class="mi">0</span> <span class="o">===</span> <span class="o">-</span><span class="mi">0</span> <span class="c1">//true</span>
<span class="kc">NaN</span> <span class="o">===</span> <span class="kc">NaN</span> <span class="c1">// false</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">is</span><span class="p">(</span><span class="o">+</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// false</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">is</span><span class="p">(</span><span class="kc">NaN</span><span class="p">,</span> <span class="kc">NaN</span><span class="p">)</span> <span class="c1">// true</span>
</pre></div>
</div>
<p>ES5 可以通过下面的代码，部署 <code class="docutils literal"><span class="pre">Object.is</span></code> 。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nb">Object</span><span class="p">,</span> <span class="s1">&#39;is&#39;</span><span class="p">,</span> <span class="p">{</span>
  <span class="nx">value</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">===</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 针对+0 不等于 -0的情况</span>
      <span class="k">return</span> <span class="nx">x</span> <span class="o">!==</span> <span class="mi">0</span> <span class="o">||</span> <span class="mi">1</span> <span class="o">/</span> <span class="nx">x</span> <span class="o">===</span> <span class="mi">1</span> <span class="o">/</span> <span class="nx">y</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 针对NaN的情况</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">!==</span> <span class="nx">x</span> <span class="o">&amp;&amp;</span> <span class="nx">y</span> <span class="o">!==</span> <span class="nx">y</span><span class="p">;</span>
  <span class="p">},</span>
  <span class="nx">configurable</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="nx">enumerable</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
  <span class="nx">writable</span><span class="o">:</span> <span class="kc">true</span>
<span class="p">});</span>
</pre></div>
</div>
</div>
<div class="section" id="object-assign">
<h2>10.5. Object.assign()<a class="headerlink" href="#object-assign" title="永久链接至标题">¶</a></h2>
<div class="section" id="id4">
<h3>10.5.1. 基本用法<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal"><span class="pre">Object.assign</span></code> 方法用于对象的合并，将源对象（ <code class="docutils literal"><span class="pre">source</span></code> ）的所有可枚举属性，复制到目标对象（ <code class="docutils literal"><span class="pre">target</span></code> ）。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">a</span><span class="o">:</span> <span class="mi">1</span> <span class="p">};</span>

<span class="kr">const</span> <span class="nx">source1</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">b</span><span class="o">:</span> <span class="mi">2</span> <span class="p">};</span>
<span class="kr">const</span> <span class="nx">source2</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">c</span><span class="o">:</span> <span class="mi">3</span> <span class="p">};</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">source1</span><span class="p">,</span> <span class="nx">source2</span><span class="p">);</span>
<span class="nx">target</span> <span class="c1">// {a:1, b:2, c:3}</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">Object.assign</span></code> 方法的第一个参数是目标对象，后面的参数都是源对象。</p>
<p><strong>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</strong></p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span><span class="o">:</span> <span class="mi">1</span> <span class="p">};</span>

<span class="kr">const</span> <span class="nx">source1</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">b</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">c</span><span class="o">:</span> <span class="mi">2</span> <span class="p">};</span>
<span class="kr">const</span> <span class="nx">source2</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">c</span><span class="o">:</span> <span class="mi">3</span> <span class="p">};</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">source1</span><span class="p">,</span> <span class="nx">source2</span><span class="p">);</span>
<span class="nx">target</span> <span class="c1">// {a:1, b:2, c:3}</span>
</pre></div>
</div>
<p>如果只有一个参数， <code class="docutils literal"><span class="pre">Object.assign</span></code> 会直接返回该参数。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span><span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">};</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="o">===</span> <span class="nx">obj</span> <span class="c1">// true</span>
</pre></div>
</div>
<p>如果该参数不是对象，则会先转成对象，然后返回。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="k">typeof</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// &quot;object&quot;</span>
</pre></div>
</div>
<p>由于 <code class="docutils literal"><span class="pre">undefined</span></code> 和 <code class="docutils literal"><span class="pre">null</span></code> 无法转成对象，所以如果它们作为参数，就会报错。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="kc">undefined</span><span class="p">)</span> <span class="c1">// 报错</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="kc">null</span><span class="p">)</span> <span class="c1">// 报错</span>
</pre></div>
</div>
<p>如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果 <code class="docutils literal"><span class="pre">undefined</span></code> 和 <code class="docutils literal"><span class="pre">null</span></code> 不在首参数，就不会报错。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span><span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">};</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="kc">undefined</span><span class="p">)</span> <span class="o">===</span> <span class="nx">obj</span> <span class="c1">// true</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="kc">null</span><span class="p">)</span> <span class="o">===</span> <span class="nx">obj</span> <span class="c1">// true</span>
</pre></div>
</div>
<p>其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">v1</span> <span class="o">=</span> <span class="s1">&#39;abc&#39;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">v2</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">v3</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

<span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">({},</span> <span class="nx">v1</span><span class="p">,</span> <span class="nx">v2</span><span class="p">,</span> <span class="nx">v3</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span> <span class="c1">// { &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; }</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">v1</span></code> 、 <code class="docutils literal"><span class="pre">v2</span></code> 、 <code class="docutils literal"><span class="pre">v3</span></code> 分别是字符串、布尔值和数值，结果只有字符串合入目标对象（以字符数组的形式），数值和布尔值都会被忽略。这是因为只有字符串的包装对象，会产生可枚举属性。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nb">Object</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="c1">// {[[PrimitiveValue]]: true}</span>
<span class="nb">Object</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  <span class="c1">//  {[[PrimitiveValue]]: 10}</span>
<span class="nb">Object</span><span class="p">(</span><span class="s1">&#39;abc&#39;</span><span class="p">)</span> <span class="c1">// {0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3, [[PrimitiveValue]]: &quot;abc&quot;}</span>
</pre></div>
</div>
<p>上面代码中，布尔值、数值、字符串分别转成对应的包装对象，可以看到它们的原始值都在包装对象的内部属性 <code class="docutils literal"><span class="pre">[[PrimitiveValue]]</span></code> 上面，这个属性是不会被 <code class="docutils literal"><span class="pre">Object.assign</span></code> 拷贝的。只有字符串的包装对象，会产生可枚举的实义属性，那些属性则会被拷贝。</p>
<p><code class="docutils literal"><span class="pre">Object.assign</span></code> 拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（ <code class="docutils literal"><span class="pre">enumerable:</span> <span class="pre">false</span></code> ）。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">({</span><span class="nx">b</span><span class="o">:</span> <span class="s1">&#39;c&#39;</span><span class="p">},</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">({},</span> <span class="s1">&#39;invisible&#39;</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">enumerable</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
    <span class="nx">value</span><span class="o">:</span> <span class="s1">&#39;hello&#39;</span>
  <span class="p">})</span>
<span class="p">)</span>
<span class="c1">// { b: &#39;c&#39; }</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">Object.assign</span></code> 要拷贝的对象只有一个不可枚举属性 <code class="docutils literal"><span class="pre">invisible</span></code> ，这个属性并没有被拷贝进去。</p>
<p>属性名为 <code class="docutils literal"><span class="pre">Symbol</span></code> 值的属性，也会被 <code class="docutils literal"><span class="pre">Object.assign</span></code> 拷贝。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">({</span> <span class="nx">a</span><span class="o">:</span> <span class="s1">&#39;b&#39;</span> <span class="p">},</span> <span class="p">{</span> <span class="p">[</span><span class="nx">Symbol</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">)]</span><span class="o">:</span> <span class="s1">&#39;d&#39;</span> <span class="p">})</span>
<span class="c1">// { a: &#39;b&#39;, Symbol(c): &#39;d&#39; }</span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h3>10.5.2. 注意点<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<ol class="arabic simple">
<li>浅拷贝</li>
</ol>
<p><code class="docutils literal"><span class="pre">Object.assign</span></code> 方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">obj1</span> <span class="o">=</span> <span class="p">{</span><span class="nx">a</span><span class="o">:</span> <span class="p">{</span><span class="nx">b</span><span class="o">:</span> <span class="mi">1</span><span class="p">}};</span>
<span class="kr">const</span> <span class="nx">obj2</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">({},</span> <span class="nx">obj1</span><span class="p">);</span>

<span class="nx">obj1</span><span class="p">.</span><span class="nx">a</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="nx">obj2</span><span class="p">.</span><span class="nx">a</span><span class="p">.</span><span class="nx">b</span> <span class="c1">// 2</span>
</pre></div>
</div>
<p>上面代码中，源对象 <code class="docutils literal"><span class="pre">obj1</span></code> 的 <code class="docutils literal"><span class="pre">a</span></code> 属性的值是一个对象， <code class="docutils literal"><span class="pre">Object.assign</span></code> 拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。</p>
<ol class="arabic simple" start="2">
<li>同名属性的替换</li>
</ol>
<p>对于这种嵌套的对象，一旦遇到同名属性， <code class="docutils literal"><span class="pre">Object.assign</span></code> 的处理方法是替换，而不是添加。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">a</span><span class="o">:</span> <span class="p">{</span> <span class="nx">b</span><span class="o">:</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="nx">d</span><span class="o">:</span> <span class="s1">&#39;e&#39;</span> <span class="p">}</span> <span class="p">}</span>
<span class="kr">const</span> <span class="nx">source</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">a</span><span class="o">:</span> <span class="p">{</span> <span class="nx">b</span><span class="o">:</span> <span class="s1">&#39;hello&#39;</span> <span class="p">}</span> <span class="p">}</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">source</span><span class="p">)</span>
<span class="c1">// { a: { b: &#39;hello&#39; } }</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">target</span></code> 对象的 <code class="docutils literal"><span class="pre">a</span></code> 属性被 <code class="docutils literal"><span class="pre">source</span></code> 对象的 <code class="docutils literal"><span class="pre">a</span></code> 属性整个替换掉了，而不会得到 <code class="docutils literal"><span class="pre">{</span> <span class="pre">a:</span> <span class="pre">{</span> <span class="pre">b:</span> <span class="pre">'hello',</span> <span class="pre">d:</span> <span class="pre">'e'</span> <span class="pre">}</span> <span class="pre">}</span></code> 的结果。这通常不是开发者想要的，需要特别小心。</p>
<p>一些函数库提供 <code class="docutils literal"><span class="pre">Object.assign</span></code> 的定制版本（比如 <code class="docutils literal"><span class="pre">Lodash</span></code> 的 <code class="docutils literal"><span class="pre">_.defaultsDeep</span></code> 方法），可以得到深拷贝的合并。</p>
<ol class="arabic simple" start="3">
<li>数组的处理</li>
</ol>
<p><code class="docutils literal"><span class="pre">Object.assign</span></code> 可以用来处理数组，但是会把数组视为对象。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span> <span class="c1">// [4, 5, 3]</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">Object.assign</span></code> 把数组视为属性名为 0、1、2 的对象，因此源数组的 0 号属性 4 覆盖了目标数组的 0 号属性 1。</p>
<ol class="arabic simple" start="4">
<li>取值函数的处理</li>
</ol>
<p><code class="docutils literal"><span class="pre">Object.assign</span></code> 只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">source</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">get</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span> <span class="p">}</span>
<span class="p">};</span>
<span class="kr">const</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{};</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">source</span><span class="p">)</span>
<span class="c1">// { foo: 1 }</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">source</span></code> 对象的 <code class="docutils literal"><span class="pre">foo</span></code> 属性是一个取值函数， <code class="docutils literal"><span class="pre">Object.assign</span></code> 不会复制这个取值函数，只会拿到值以后，将这个值复制过去。</p>
</div>
<div class="section" id="id6">
<h3>10.5.3. 常见用途<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal"><span class="pre">Object.assign</span></code> 方法有很多用处。</p>
<ol class="arabic simple">
<li>为对象添加属性</li>
</ol>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Point</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="p">{</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">});</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面方法通过 <code class="docutils literal"><span class="pre">Object.assign</span></code> 方法，将 <code class="docutils literal"><span class="pre">x</span></code> 属性和 <code class="docutils literal"><span class="pre">y</span></code> 属性添加到 <code class="docutils literal"><span class="pre">Point</span></code> 类的对象实例。</p>
<ol class="arabic simple" start="2">
<li>为对象添加方法</li>
</ol>
<div class="highlight-js"><div class="highlight"><pre><span></span>Object.assign(SomeClass.prototype, {
  someMethod(arg1, arg2) {
    ···
  },
  anotherMethod() {
    ···
  }
});

// 等同于下面的写法
SomeClass.prototype.someMethod = function (arg1, arg2) {
  ···
};
SomeClass.prototype.anotherMethod = function () {
  ···
};
</pre></div>
</div>
<p>上面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用 <code class="docutils literal"><span class="pre">assign</span></code> 方法添加到 <code class="docutils literal"><span class="pre">SomeClass.prototype</span></code> 之中。</p>
<ol class="arabic simple" start="3">
<li>克隆对象</li>
</ol>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">clone</span><span class="p">(</span><span class="nx">origin</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">({},</span> <span class="nx">origin</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。</p>
<p>不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">clone</span><span class="p">(</span><span class="nx">origin</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">originProto</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">origin</span><span class="p">);</span>
  <span class="k">return</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">originProto</span><span class="p">),</span> <span class="nx">origin</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<ol class="arabic simple" start="4">
<li>合并多个对象</li>
</ol>
<p>将多个对象合并到某个对象。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">merge</span> <span class="o">=</span> <span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="p">...</span><span class="nx">sources</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="p">...</span><span class="nx">sources</span><span class="p">);</span>
</pre></div>
</div>
<p>如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">merge</span> <span class="o">=</span> <span class="p">(...</span><span class="nx">sources</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">({},</span> <span class="p">...</span><span class="nx">sources</span><span class="p">);</span>
</pre></div>
</div>
<ol class="arabic simple" start="5">
<li>为属性指定默认值</li>
</ol>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">DEFAULTS</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">logLevel</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="nx">outputFormat</span><span class="o">:</span> <span class="s1">&#39;html&#39;</span>
<span class="p">};</span>

<span class="kd">function</span> <span class="nx">processContent</span><span class="p">(</span><span class="nx">options</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">options</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">({},</span> <span class="nx">DEFAULTS</span><span class="p">,</span> <span class="nx">options</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">options</span><span class="p">);</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">DEFAULTS</span></code> 对象是默认值， <code class="docutils literal"><span class="pre">options</span></code> 对象是用户提供的参数。 <code class="docutils literal"><span class="pre">Object.assign</span></code> 方法将 <code class="docutils literal"><span class="pre">DEFAULTS</span></code> 和 <code class="docutils literal"><span class="pre">options</span></code> 合并成一个新对象，如果两者有同名属性，则 <code class="docutils literal"><span class="pre">option</span></code> 的属性值会覆盖 <code class="docutils literal"><span class="pre">DEFAULTS</span></code> 的属性值。</p>
<p><strong>注意，由于存在浅拷贝的问题，DEFAULTS对象和options对象的所有属性的值，最好都是简单类型，不要指向另一个对象。否则，DEFAULTS对象的该属性很可能不起作用。</strong></p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">DEFAULTS</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">url</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">host</span><span class="o">:</span> <span class="s1">&#39;example.com&#39;</span><span class="p">,</span>
    <span class="nx">port</span><span class="o">:</span> <span class="mi">7070</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="nx">processContent</span><span class="p">({</span> <span class="nx">url</span><span class="o">:</span> <span class="p">{</span><span class="nx">port</span><span class="o">:</span> <span class="mi">8000</span><span class="p">}</span> <span class="p">})</span>
<span class="c1">// {</span>
<span class="c1">//   url: {port: 8000}</span>
<span class="c1">// }</span>
</pre></div>
</div>
<p>上面代码的原意是将 <code class="docutils literal"><span class="pre">url.port</span></code> 改成 <code class="docutils literal"><span class="pre">8000</span></code> ， <code class="docutils literal"><span class="pre">url.host</span></code> 不变。实际结果却是 <code class="docutils literal"><span class="pre">options.url</span></code> 覆盖掉 <code class="docutils literal"><span class="pre">DEFAULTS.url</span></code> ，所以 <code class="docutils literal"><span class="pre">url.host</span></code> 就不存在了。</p>
</div>
</div>
<div class="section" id="id7">
<h2>10.6. 属性的可枚举性和遍历<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h2>
<div class="section" id="id8">
<h3>10.6.1. 可枚举性<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h3>
<p>对象的每个属性都有一个描述对象（ <code class="docutils literal"><span class="pre">Descriptor</span></code> ），用来控制该属性的行为。 <code class="docutils literal"><span class="pre">Object.getOwnPropertyDescriptor</span></code> 方法可以获取该属性的描述对象。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">foo</span><span class="o">:</span> <span class="mi">123</span> <span class="p">};</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">)</span>
<span class="c1">//  {</span>
<span class="c1">//    value: 123,</span>
<span class="c1">//    writable: true,</span>
<span class="c1">//    enumerable: true,</span>
<span class="c1">//    configurable: true</span>
<span class="c1">//  }</span>
</pre></div>
</div>
<p>描述对象的 <code class="docutils literal"><span class="pre">enumerable</span></code> 属性，称为”可枚举性“，如果该属性为 <code class="docutils literal"><span class="pre">false</span></code> ，就表示某些操作会忽略当前属性。</p>
<p>目前，有四个操作会忽略 <code class="docutils literal"><span class="pre">enumerable</span></code> 为 <code class="docutils literal"><span class="pre">false</span></code> 的属性。</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">for...in</span></code> 循环：只遍历对象自身的和继承的可枚举的属性。</li>
<li><code class="docutils literal"><span class="pre">Object.keys()</span></code> ：返回对象自身的所有可枚举的属性的键名。</li>
<li><code class="docutils literal"><span class="pre">JSON.stringify()</span></code> ：只串行化对象自身的可枚举的属性。</li>
<li><code class="docutils literal"><span class="pre">Object.assign()</span></code> ： 忽略 <code class="docutils literal"><span class="pre">enumerable</span></code> 为 <code class="docutils literal"><span class="pre">false</span></code> 的属性，只拷贝对象自身的可枚举的属性。</li>
</ul>
<p>这四个操作之中，前三个是 ES5 就有的，最后一个 <code class="docutils literal"><span class="pre">Object.assign()</span></code> 是 ES6 新增的。其中，只有 <code class="docutils literal"><span class="pre">for...in</span></code> 会返回继承的属性，其他三个方法都会忽略继承的属性，只处理对象自身的属性。实际上，引入“可枚举”（ <code class="docutils literal"><span class="pre">enumerable</span></code> ）这个概念的最初目的，就是让某些属性可以规避掉 <code class="docutils literal"><span class="pre">for...in</span></code> 操作，不然所有内部属性和方法都会被遍历到。比如，对象原型的 <code class="docutils literal"><span class="pre">toString</span></code> 方法，以及数组的 <code class="docutils literal"><span class="pre">length</span></code> 属性，就通过“可枚举性”，从而避免被 <code class="docutils literal"><span class="pre">for...in</span></code> 遍历到。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="s1">&#39;toString&#39;</span><span class="p">).</span><span class="nx">enumerable</span>
<span class="c1">// false</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">([],</span> <span class="s1">&#39;length&#39;</span><span class="p">).</span><span class="nx">enumerable</span>
<span class="c1">// false</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">toString</span></code> 和 <code class="docutils literal"><span class="pre">length</span></code> 属性的 <code class="docutils literal"><span class="pre">enumerable</span></code> 都是 <code class="docutils literal"><span class="pre">false</span></code> ，因此 <code class="docutils literal"><span class="pre">for...in</span></code> 不会遍历到这两个继承自原型的属性。</p>
<p>另外，ES6 规定，所有 <code class="docutils literal"><span class="pre">Class</span></code> 的原型的方法都是不可枚举的。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="kr">class</span> <span class="p">{</span><span class="nx">foo</span><span class="p">()</span> <span class="p">{}}.</span><span class="nx">prototype</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">).</span><span class="nx">enumerable</span>
<span class="c1">// false</span>
</pre></div>
</div>
<p>总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用 <code class="docutils literal"><span class="pre">for...in</span></code> 循环，而用 <code class="docutils literal"><span class="pre">Object.keys()</span></code> 代替。</p>
</div>
<div class="section" id="id9">
<h3>10.6.2. 属性的遍历<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h3>
<p>ES6 一共有 5 种方法可以遍历对象的属性。</p>
<ol class="arabic simple">
<li>for…in</li>
</ol>
<p><code class="docutils literal"><span class="pre">for...in</span></code> 循环遍历对象自身的和继承的可枚举属性（不含 <code class="docutils literal"><span class="pre">Symbol</span></code> 属性）。</p>
<ol class="arabic simple" start="2">
<li>Object.keys(obj)</li>
</ol>
<p><code class="docutils literal"><span class="pre">Object.keys</span></code> 返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</p>
<ol class="arabic simple" start="3">
<li>Object.getOwnPropertyNames(obj)</li>
</ol>
<p><code class="docutils literal"><span class="pre">Object.getOwnPropertyNames</span></code> 返回一个数组，包含对象自身的所有属性（不含 <code class="docutils literal"><span class="pre">Symbol</span></code> 属性，但是包括不可枚举属性）的键名。</p>
<ol class="arabic simple" start="4">
<li>Object.getOwnPropertySymbols(obj)</li>
</ol>
<p><code class="docutils literal"><span class="pre">Object.getOwnPropertySymbols</span></code> 返回一个数组，包含对象自身的所有 <code class="docutils literal"><span class="pre">Symbol</span></code> 属性的键名。</p>
<ol class="arabic simple" start="5">
<li>Reflect.ownKeys(obj)</li>
</ol>
<p><code class="docutils literal"><span class="pre">Reflect.ownKeys</span></code> 返回一个数组，包含对象自身的所有键名，不管键名是 <code class="docutils literal"><span class="pre">Symbol</span></code> 或字符串，也不管是否可枚举。</p>
<p>以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。</p>
<ul class="simple">
<li>首先遍历所有数值键，按照数值升序排列。</li>
<li>其次遍历所有字符串键，按照加入时间升序排列。</li>
<li>最后遍历所有 <code class="docutils literal"><span class="pre">Symbol</span></code> 键，按照加入时间升序排列。</li>
</ul>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">Reflect</span><span class="p">.</span><span class="nx">ownKeys</span><span class="p">({</span> <span class="p">[</span><span class="nx">Symbol</span><span class="p">()]</span><span class="o">:</span><span class="mi">0</span><span class="p">,</span> <span class="nx">b</span><span class="o">:</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="o">:</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">,</span> <span class="nx">a</span><span class="o">:</span><span class="mi">0</span> <span class="p">})</span>
<span class="c1">// [&#39;2&#39;, &#39;10&#39;, &#39;b&#39;, &#39;a&#39;, Symbol()]</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">Reflect.ownKeys</span></code> 方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性 2 和 10 ，其次是字符串属性 b 和 a ，最后是 <code class="docutils literal"><span class="pre">Symbol</span></code> 属性。</p>
</div>
</div>
<div class="section" id="object-getownpropertydescriptors">
<h2>10.7. Object.getOwnPropertyDescriptors()<a class="headerlink" href="#object-getownpropertydescriptors" title="永久链接至标题">¶</a></h2>
<p>前面说过， <code class="docutils literal"><span class="pre">Object.getOwnPropertyDescriptor</span></code> 方法会返回某个对象属性的描述对象（ <code class="docutils literal"><span class="pre">descriptor</span></code> ）。ES2017 引入了 <code class="docutils literal"><span class="pre">Object.getOwnPropertyDescriptors</span></code> 方法，返回指定对象所有自身属性（非继承属性）的描述对象。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">foo</span><span class="o">:</span> <span class="mi">123</span><span class="p">,</span>
  <span class="nx">get</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="s1">&#39;abc&#39;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptors</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span>
<span class="c1">// { foo:</span>
<span class="c1">//    { value: 123,</span>
<span class="c1">//      writable: true,</span>
<span class="c1">//      enumerable: true,</span>
<span class="c1">//      configurable: true },</span>
<span class="c1">//   bar:</span>
<span class="c1">//    { get: [Function: get bar],</span>
<span class="c1">//      set: undefined,</span>
<span class="c1">//      enumerable: true,</span>
<span class="c1">//      configurable: true } }</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">Object.getOwnPropertyDescriptors</span></code> 方法返回一个对象，所有原对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象。</p>
<p>该方法的实现非常容易。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">getOwnPropertyDescriptors</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">key</span> <span class="k">of</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">ownKeys</span><span class="p">(</span><span class="nx">obj</span><span class="p">))</span> <span class="p">{</span>
    <span class="nx">result</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">key</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>该方法的引入目的，主要是为了解决 <code class="docutils literal"><span class="pre">Object.assign()</span></code> 无法正确拷贝 <code class="docutils literal"><span class="pre">get</span></code> 属性和 <code class="docutils literal"><span class="pre">set</span></code> 属性的问题。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">source</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">set</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kr">const</span> <span class="nx">target1</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">target1</span><span class="p">,</span> <span class="nx">source</span><span class="p">);</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">target1</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">)</span>
<span class="c1">// { value: undefined,</span>
<span class="c1">//   writable: true,</span>
<span class="c1">//   enumerable: true,</span>
<span class="c1">//   configurable: true }</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">source</span></code> 对象的 <code class="docutils literal"><span class="pre">foo</span></code> 属性的值是一个赋值函数， <code class="docutils literal"><span class="pre">Object.assign</span></code> 方法将这个属性拷贝给 <code class="docutils literal"><span class="pre">target1</span></code> 对象，结果该属性的值变成了 <code class="docutils literal"><span class="pre">undefined</span></code> 。这是因为 <code class="docutils literal"><span class="pre">Object.assign</span></code> 方法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法。</p>
<p>这时， <code class="docutils literal"><span class="pre">Object.getOwnPropertyDescriptors</span></code> 方法配合 <code class="docutils literal"><span class="pre">Object.defineProperties</span></code> 方法，就可以实现正确拷贝。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">source</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">set</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kr">const</span> <span class="nx">target2</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperties</span><span class="p">(</span><span class="nx">target2</span><span class="p">,</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptors</span><span class="p">(</span><span class="nx">source</span><span class="p">));</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">target2</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">)</span>
<span class="c1">// { get: undefined,</span>
<span class="c1">//   set: [Function: set foo],</span>
<span class="c1">//   enumerable: true,</span>
<span class="c1">//   configurable: true }</span>
</pre></div>
</div>
<p>上面代码中，两个对象合并的逻辑可以写成一个函数。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">shallowMerge</span> <span class="o">=</span> <span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">source</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperties</span><span class="p">(</span>
  <span class="nx">target</span><span class="p">,</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptors</span><span class="p">(</span><span class="nx">source</span><span class="p">)</span>
<span class="p">);</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">Object.getOwnPropertyDescriptors</span></code> 方法的另一个用处，是配合 <code class="docutils literal"><span class="pre">Object.create</span></code> 方法，将对象属性克隆到一个新对象。这属于浅拷贝。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">clone</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">),</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptors</span><span class="p">(</span><span class="nx">obj</span><span class="p">));</span>

<span class="c1">// 或者</span>

<span class="kr">const</span> <span class="nx">shallowClone</span> <span class="o">=</span> <span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">),</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptors</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span>
<span class="p">);</span>
</pre></div>
</div>
<p>上面代码会克隆对象 <code class="docutils literal"><span class="pre">obj</span></code> 。</p>
<p>另外， <code class="docutils literal"><span class="pre">Object.getOwnPropertyDescriptors</span></code> 方法可以实现一个对象继承另一个对象。以前，继承另一个对象，常常写成下面这样。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">__proto__</span><span class="o">:</span> <span class="nx">prot</span><span class="p">,</span>
  <span class="nx">foo</span><span class="o">:</span> <span class="mi">123</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
<p>ES6 规定 <code class="docutils literal"><span class="pre">__proto__</span></code> 只有浏览器要部署，其他环境不用部署。如果去除 <code class="docutils literal"><span class="pre">__proto__</span></code> ，上面代码就要改成下面这样。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">prot</span><span class="p">);</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>

<span class="c1">// 或者</span>

<span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">prot</span><span class="p">),</span>
  <span class="p">{</span>
    <span class="nx">foo</span><span class="o">:</span> <span class="mi">123</span><span class="p">,</span>
  <span class="p">}</span>
<span class="p">);</span>
</pre></div>
</div>
<p>有了 <code class="docutils literal"><span class="pre">Object.getOwnPropertyDescriptors</span></code> ，我们就有了另一种写法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span>
  <span class="nx">prot</span><span class="p">,</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptors</span><span class="p">({</span>
    <span class="nx">foo</span><span class="o">:</span> <span class="mi">123</span><span class="p">,</span>
  <span class="p">})</span>
<span class="p">);</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">Object.getOwnPropertyDescriptors</span></code> 也可以用来实现 <code class="docutils literal"><span class="pre">Mixin</span></code> （混入）模式。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">mix</span> <span class="o">=</span> <span class="p">(</span><span class="nx">object</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">({</span>
  <span class="kd">with</span><span class="o">:</span> <span class="p">(...</span><span class="nx">mixins</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">mixins</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span>
    <span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">mixin</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span>
      <span class="nx">c</span><span class="p">,</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptors</span><span class="p">(</span><span class="nx">mixin</span><span class="p">)</span>
    <span class="p">),</span> <span class="nx">object</span><span class="p">)</span>
<span class="p">});</span>

<span class="c1">// multiple mixins example</span>
<span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{</span><span class="nx">a</span><span class="o">:</span> <span class="s1">&#39;a&#39;</span><span class="p">};</span>
<span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="p">{</span><span class="nx">b</span><span class="o">:</span> <span class="s1">&#39;b&#39;</span><span class="p">};</span>
<span class="kd">let</span> <span class="nx">c</span> <span class="o">=</span> <span class="p">{</span><span class="nx">c</span><span class="o">:</span> <span class="s1">&#39;c&#39;</span><span class="p">};</span>
<span class="kd">let</span> <span class="nx">d</span> <span class="o">=</span> <span class="nx">mix</span><span class="p">(</span><span class="nx">c</span><span class="p">).</span><span class="kd">with</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span>

<span class="nx">d</span><span class="p">.</span><span class="nx">c</span> <span class="c1">// &quot;c&quot;</span>
<span class="nx">d</span><span class="p">.</span><span class="nx">b</span> <span class="c1">// &quot;b&quot;</span>
<span class="nx">d</span><span class="p">.</span><span class="nx">a</span> <span class="c1">// &quot;a&quot;</span>
</pre></div>
</div>
<p>上面代码返回一个新的对象 <code class="docutils literal"><span class="pre">d</span></code> ，代表了对象 <code class="docutils literal"><span class="pre">a</span></code> 和 <code class="docutils literal"><span class="pre">b</span></code> 被混入了对象 <code class="docutils literal"><span class="pre">c</span></code> 的操作。</p>
<p>出于完整性的考虑， <code class="docutils literal"><span class="pre">Object.getOwnPropertyDescriptors</span></code> 进入标准以后，以后还会新增 <code class="docutils literal"><span class="pre">Reflect.getOwnPropertyDescriptors</span></code> 方法。</p>
</div>
<div class="section" id="proto-object-setprototypeof-object-getprototypeof">
<h2>10.8. __proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()<a class="headerlink" href="#proto-object-setprototypeof-object-getprototypeof" title="永久链接至标题">¶</a></h2>
<p>JavaScript 语言的对象继承是通过原型链实现的。ES6 提供了更多原型对象的操作方法。</p>
<div class="section" id="proto">
<h3>10.8.1. __proto__属性<a class="headerlink" href="#proto" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal"><span class="pre">__proto__</span></code> 属性（前后各两个下划线），用来读取或设置当前对象的 <code class="docutils literal"><span class="pre">prototype</span></code> 对象。目前，所有浏览器（包括 IE11）都部署了这个属性。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// es6 的写法</span>
<span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">method</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="p">};</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nx">someOtherObj</span><span class="p">;</span>

<span class="c1">// es5 的写法</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">someOtherObj</span><span class="p">);</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">method</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</pre></div>
</div>
<p>该属性没有写入 ES6 的正文，而是写入了附录，原因是 <code class="docutils literal"><span class="pre">__proto__</span></code> 前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 <code class="docutils literal"><span class="pre">API</span></code> ，只是由于浏览器广泛支持，才被加入了 ES6。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的 <code class="docutils literal"><span class="pre">Object.setPrototypeOf()</span></code> （写操作）、 <code class="docutils literal"><span class="pre">Object.getPrototypeOf()</span></code> （读操作）、 <code class="docutils literal"><span class="pre">Object.create()</span></code> （生成操作）代替。</p>
<p>实现上， <code class="docutils literal"><span class="pre">__proto__</span></code> 调用的是 <code class="docutils literal"><span class="pre">Object.prototype.__proto__</span></code> ，具体实现如下。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="s1">&#39;__proto__&#39;</span><span class="p">,</span> <span class="p">{</span>
  <span class="nx">get</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">_thisObj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">_thisObj</span><span class="p">);</span>
  <span class="p">},</span>
  <span class="nx">set</span><span class="p">(</span><span class="nx">proto</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="o">===</span> <span class="kc">undefined</span> <span class="o">||</span> <span class="k">this</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nx">TypeError</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">isObject</span><span class="p">(</span><span class="k">this</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">isObject</span><span class="p">(</span><span class="nx">proto</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kd">let</span> <span class="nx">status</span> <span class="o">=</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">proto</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">status</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nx">TypeError</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">},</span>
<span class="p">});</span>

<span class="kd">function</span> <span class="nx">isObject</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">Object</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="o">===</span> <span class="nx">value</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如果一个对象本身部署了 <code class="docutils literal"><span class="pre">__proto__</span></code> 属性，该属性的值就是对象的原型。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">({</span> <span class="nx">__proto__</span><span class="o">:</span> <span class="kc">null</span> <span class="p">})</span> <span class="c1">// null</span>
</pre></div>
</div>
</div>
<div class="section" id="object-setprototypeof">
<h3>10.8.2. Object.setPrototypeOf()<a class="headerlink" href="#object-setprototypeof" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal"><span class="pre">Object.setPrototypeOf</span></code> 方法的作用与 <code class="docutils literal"><span class="pre">__proto__</span></code> 相同，用来设置一个对象的 <code class="docutils literal"><span class="pre">prototype</span></code> 对象，返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// 格式</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">object</span><span class="p">,</span> <span class="nx">prototype</span><span class="p">)</span>

<span class="c1">// 用法</span>
<span class="kr">const</span> <span class="nx">o</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">({},</span> <span class="kc">null</span><span class="p">);</span>
</pre></div>
</div>
<p>该方法等同于下面的函数。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">proto</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">obj</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nx">proto</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">obj</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>下面是一个例子。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">proto</span> <span class="o">=</span> <span class="p">{};</span>
<span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">x</span><span class="o">:</span> <span class="mi">10</span> <span class="p">};</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">proto</span><span class="p">);</span>

<span class="nx">proto</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="nx">proto</span><span class="p">.</span><span class="nx">z</span> <span class="o">=</span> <span class="mi">40</span><span class="p">;</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">x</span> <span class="c1">// 10</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">y</span> <span class="c1">// 20</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">z</span> <span class="c1">// 40</span>
</pre></div>
</div>
<p>上面代码将 <code class="docutils literal"><span class="pre">proto</span></code> 对象设为 <code class="docutils literal"><span class="pre">obj</span></code> 对象的原型，所以从 <code class="docutils literal"><span class="pre">obj</span></code> 对象可以读取 <code class="docutils literal"><span class="pre">proto</span></code> 对象的属性。</p>
<p>如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">{})</span> <span class="o">===</span> <span class="mi">1</span> <span class="c1">// true</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="p">{})</span> <span class="o">===</span> <span class="s1">&#39;foo&#39;</span> <span class="c1">// true</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="p">{})</span> <span class="o">===</span> <span class="kc">true</span> <span class="c1">// true</span>
</pre></div>
</div>
<p>由于 <code class="docutils literal"><span class="pre">undefined</span></code> 和 <code class="docutils literal"><span class="pre">null</span></code> 无法转为对象，所以如果第一个参数是 <code class="docutils literal"><span class="pre">undefined</span></code> 或 <code class="docutils literal"><span class="pre">null</span></code> ，就会报错。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="kc">undefined</span><span class="p">,</span> <span class="p">{})</span>
<span class="c1">// TypeError: Object.setPrototypeOf called on null or undefined</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="p">{})</span>
<span class="c1">// TypeError: Object.setPrototypeOf called on null or undefined</span>
</pre></div>
</div>
</div>
<div class="section" id="object-getprototypeof">
<h3>10.8.3. Object.getPrototypeOf()<a class="headerlink" href="#object-getprototypeof" title="永久链接至标题">¶</a></h3>
<p>该方法与 <code class="docutils literal"><span class="pre">Object.setPrototypeOf</span></code> 方法配套，用于读取一个对象的原型对象。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
</pre></div>
</div>
<p>下面是一个例子。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">Rectangle</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">rec</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Rectangle</span><span class="p">();</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">rec</span><span class="p">)</span> <span class="o">===</span> <span class="nx">Rectangle</span><span class="p">.</span><span class="nx">prototype</span> <span class="c1">// true</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">rec</span><span class="p">,</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">rec</span><span class="p">)</span> <span class="o">===</span> <span class="nx">Rectangle</span><span class="p">.</span><span class="nx">prototype</span> <span class="c1">// false</span>
</pre></div>
</div>
<p>如果参数不是对象，会被自动转为对象。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// 等同于 Object.getPrototypeOf(Number(1))</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="c1">// Number {[[PrimitiveValue]]: 0}</span>

<span class="c1">// 等同于 Object.getPrototypeOf(String(&#39;foo&#39;))</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span>
<span class="c1">// String {length: 0, [[PrimitiveValue]]: &quot;&quot;}</span>

<span class="c1">// 等同于 Object.getPrototypeOf(Boolean(true))</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
<span class="c1">// Boolean {[[PrimitiveValue]]: false}</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">===</span> <span class="nb">Number</span><span class="p">.</span><span class="nx">prototype</span> <span class="c1">// true</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span> <span class="o">===</span> <span class="nb">String</span><span class="p">.</span><span class="nx">prototype</span> <span class="c1">// true</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="o">===</span> <span class="nb">Boolean</span><span class="p">.</span><span class="nx">prototype</span> <span class="c1">// true</span>
</pre></div>
</div>
<p>如果参数是 <code class="docutils literal"><span class="pre">undefined</span></code> 或 <code class="docutils literal"><span class="pre">null</span></code> ，它们无法转为对象，所以会报错。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="kc">null</span><span class="p">)</span>
<span class="c1">// TypeError: Cannot convert undefined or null to object</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="kc">undefined</span><span class="p">)</span>
<span class="c1">// TypeError: Cannot convert undefined or null to object</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="super">
<h2>10.9. super 关键字<a class="headerlink" href="#super" title="永久链接至标题">¶</a></h2>
<p>我们知道， <code class="docutils literal"><span class="pre">this</span></code> 关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字 <code class="docutils literal"><span class="pre">super</span></code> ，指向当前对象的原型对象。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">proto</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;hello&#39;</span>
<span class="p">};</span>

<span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;world&#39;</span><span class="p">,</span>
  <span class="nx">find</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kr">super</span><span class="p">.</span><span class="nx">foo</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">proto</span><span class="p">);</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">find</span><span class="p">()</span> <span class="c1">// &quot;hello&quot;</span>
</pre></div>
</div>
<p>上面代码中，对象 <code class="docutils literal"><span class="pre">obj</span></code> 的 <code class="docutils literal"><span class="pre">find</span></code> 方法之中，通过 <code class="docutils literal"><span class="pre">super.foo</span></code> 引用了原型对象 <code class="docutils literal"><span class="pre">proto</span></code> 的 <code class="docutils literal"><span class="pre">foo</span></code> 属性。</p>
<p>注意， <code class="docutils literal"><span class="pre">super</span></code> 关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// 报错</span>
<span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">foo</span><span class="o">:</span> <span class="kr">super</span><span class="p">.</span><span class="nx">foo</span>
<span class="p">}</span>

<span class="c1">// 报错</span>
<span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">foo</span><span class="o">:</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="kr">super</span><span class="p">.</span><span class="nx">foo</span>
<span class="p">}</span>

<span class="c1">// 报错</span>
<span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">foo</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kr">super</span><span class="p">.</span><span class="nx">foo</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面三种 <code class="docutils literal"><span class="pre">super</span></code> 的用法都会报错，因为对于 <code class="docutils literal"><span class="pre">JavaScript</span></code> 引擎来说，这里的 <code class="docutils literal"><span class="pre">super</span></code> 都没有用在对象的方法之中。第一种写法是 <code class="docutils literal"><span class="pre">super</span></code> 用在属性里面，第二种和第三种写法是 <code class="docutils literal"><span class="pre">super</span></code> 用在一个函数里面，然后赋值给 <code class="docutils literal"><span class="pre">foo</span></code> 属性。目前，只有对象方法的简写法可以让 <code class="docutils literal"><span class="pre">JavaScript</span></code> 引擎确认，定义的是对象的方法。</p>
<p>JavaScript 引擎内部， <code class="docutils literal"><span class="pre">super.foo</span></code> 等同于 <code class="docutils literal"><span class="pre">Object.getPrototypeOf(this).foo</span></code> （属性）或 <code class="docutils literal"><span class="pre">Object.getPrototypeOf(this).foo.call(this)</span></code> （方法）。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">proto</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">x</span><span class="o">:</span> <span class="s1">&#39;hello&#39;</span><span class="p">,</span>
  <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">x</span><span class="o">:</span> <span class="s1">&#39;world&#39;</span><span class="p">,</span>
  <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="kr">super</span><span class="p">.</span><span class="nx">foo</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">proto</span><span class="p">);</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">()</span> <span class="c1">// &quot;world&quot;</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">super.foo</span></code> 指向原型对象 <code class="docutils literal"><span class="pre">proto</span></code> 的 <code class="docutils literal"><span class="pre">foo</span></code> 方法，但是绑定的 <code class="docutils literal"><span class="pre">this</span></code> 却还是当前对象 <code class="docutils literal"><span class="pre">obj</span></code> ，因此输出的就是 <code class="docutils literal"><span class="pre">world</span></code> 。</p>
</div>
<div class="section" id="object-keys-object-values-object-entries">
<h2>10.10. Object.keys()，Object.values()，Object.entries()<a class="headerlink" href="#object-keys-object-values-object-entries" title="永久链接至标题">¶</a></h2>
<div class="section" id="object-keys">
<h3>10.10.1. Object.keys()<a class="headerlink" href="#object-keys" title="永久链接至标题">¶</a></h3>
<p>ES5 引入了 <code class="docutils literal"><span class="pre">Object.keys</span></code> 方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（ <code class="docutils literal"><span class="pre">enumerable</span></code> ）属性的键名。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="nx">baz</span><span class="o">:</span> <span class="mi">42</span> <span class="p">};</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span>
<span class="c1">// [&quot;foo&quot;, &quot;baz&quot;]</span>
</pre></div>
</div>
<p>ES2017 引入了跟 <code class="docutils literal"><span class="pre">Object.keys</span></code> 配套的 <code class="docutils literal"><span class="pre">Object.values</span></code> 和 <code class="docutils literal"><span class="pre">Object.entries</span></code> ，作为遍历一个对象的补充手段，供 <code class="docutils literal"><span class="pre">for...of</span></code> 循环使用。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="p">{</span><span class="nx">keys</span><span class="p">,</span> <span class="nx">values</span><span class="p">,</span> <span class="nx">entries</span><span class="p">}</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">c</span><span class="o">:</span> <span class="mi">3</span> <span class="p">};</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">key</span> <span class="k">of</span> <span class="nx">keys</span><span class="p">(</span><span class="nx">obj</span><span class="p">))</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span> <span class="c1">// &#39;a&#39;, &#39;b&#39;, &#39;c&#39;</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">value</span> <span class="k">of</span> <span class="nx">values</span><span class="p">(</span><span class="nx">obj</span><span class="p">))</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span> <span class="c1">// 1, 2, 3</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">]</span> <span class="k">of</span> <span class="nx">entries</span><span class="p">(</span><span class="nx">obj</span><span class="p">))</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">([</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">]);</span> <span class="c1">// [&#39;a&#39;, 1], [&#39;b&#39;, 2], [&#39;c&#39;, 3]</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="object-values">
<h3>10.10.2. Object.values()<a class="headerlink" href="#object-values" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal"><span class="pre">Object.values</span></code> 方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（ <code class="docutils literal"><span class="pre">enumerable</span></code> ）属性的键值。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="nx">baz</span><span class="o">:</span> <span class="mi">42</span> <span class="p">};</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">values</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span>
<span class="c1">// [&quot;bar&quot;, 42]</span>
</pre></div>
</div>
<p>返回数组的成员顺序，与本章的《属性的遍历》部分介绍的排列规则一致。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">100</span><span class="o">:</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="o">:</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">7</span><span class="o">:</span> <span class="s1">&#39;c&#39;</span> <span class="p">};</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">values</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span>
<span class="c1">// [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;]</span>
</pre></div>
</div>
<p>上面代码中，属性名为数值的属性，是按照数值大小，从小到大遍历的，因此返回的顺序是 <code class="docutils literal"><span class="pre">b、c、a</span></code> 。</p>
<p><code class="docutils literal"><span class="pre">Object.values</span></code> 只返回对象自身的可遍历属性。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">({},</span> <span class="p">{</span><span class="nx">p</span><span class="o">:</span> <span class="p">{</span><span class="nx">value</span><span class="o">:</span> <span class="mi">42</span><span class="p">}});</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">values</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="c1">// []</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">Object.create</span></code> 方法的第二个参数添加的对象属性（属性 <code class="docutils literal"><span class="pre">p</span></code> ），如果不显式声明，默认是不可遍历的，因为 <code class="docutils literal"><span class="pre">p</span></code> 的属性描述对象的 <code class="docutils literal"><span class="pre">enumerable</span></code> 默认是 <code class="docutils literal"><span class="pre">false</span></code> ， <code class="docutils literal"><span class="pre">Object.values</span></code> 不会返回这个属性。只要把 <code class="docutils literal"><span class="pre">enumerable</span></code> 改成 <code class="docutils literal"><span class="pre">true</span></code> ， <code class="docutils literal"><span class="pre">Object.values</span></code> 就会返回属性 <code class="docutils literal"><span class="pre">p</span></code> 的值。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">({},</span> <span class="p">{</span><span class="nx">p</span><span class="o">:</span>
  <span class="p">{</span>
    <span class="nx">value</span><span class="o">:</span> <span class="mi">42</span><span class="p">,</span>
    <span class="nx">enumerable</span><span class="o">:</span> <span class="kc">true</span>
  <span class="p">}</span>
<span class="p">});</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">values</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="c1">// [42]</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">Object.values</span></code> 会过滤属性名为 <code class="docutils literal"><span class="pre">Symbol</span></code> 值的属性。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nb">Object</span><span class="p">.</span><span class="nx">values</span><span class="p">({</span> <span class="p">[</span><span class="nx">Symbol</span><span class="p">()]</span><span class="o">:</span> <span class="mi">123</span><span class="p">,</span> <span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;abc&#39;</span> <span class="p">});</span> <span class="c1">// [&#39;abc&#39;]</span>
</pre></div>
</div>
<p>如果 <code class="docutils literal"><span class="pre">Object.values</span></code> 方法的参数是一个字符串，会返回各个字符组成的一个数组。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nb">Object</span><span class="p">.</span><span class="nx">values</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span> <span class="c1">// [&#39;f&#39;, &#39;o&#39;, &#39;o&#39;]</span>
</pre></div>
</div>
<p>上面代码中，字符串会先转成一个类似数组的对象。字符串的每个字符，就是该对象的一个属性。因此， <code class="docutils literal"><span class="pre">Object.values</span></code> 返回每个属性的键值，就是各个字符组成的一个数组。</p>
<p>如果参数不是对象， <code class="docutils literal"><span class="pre">Object.values</span></code> 会先将其转为对象。由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以， <code class="docutils literal"><span class="pre">Object.values</span></code> 会返回空数组。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nb">Object</span><span class="p">.</span><span class="nx">values</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="c1">// []</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">values</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="c1">// []</span>
</pre></div>
</div>
</div>
<div class="section" id="object-entries">
<h3>10.10.3. Object.entries<a class="headerlink" href="#object-entries" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal"><span class="pre">Object.entries</span></code> 方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（ <code class="docutils literal"><span class="pre">enumerable</span></code> ）属性的键值对数组。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="nx">baz</span><span class="o">:</span> <span class="mi">42</span> <span class="p">};</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span>
<span class="c1">// [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ]</span>
</pre></div>
</div>
<p>除了返回值不一样，该方法的行为与 <code class="docutils literal"><span class="pre">Object.values</span></code> 基本一致。</p>
<p>如果原对象的属性名是一个 <code class="docutils literal"><span class="pre">Symbol</span></code> 值，该属性会被忽略。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">({</span> <span class="p">[</span><span class="nx">Symbol</span><span class="p">()]</span><span class="o">:</span> <span class="mi">123</span><span class="p">,</span> <span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;abc&#39;</span> <span class="p">});</span> <span class="c1">// [ [ &#39;foo&#39;, &#39;abc&#39; ] ]</span>
</pre></div>
</div>
<p>上面代码中，原对象有两个属性， <code class="docutils literal"><span class="pre">Object.entries</span></code> 只输出属性名非 <code class="docutils literal"><span class="pre">Symbol</span></code> 值的属性。将来可能会有 <code class="docutils literal"><span class="pre">Reflect.ownEntries()</span></code> 方法，返回对象自身的所有属性。</p>
<p><code class="docutils literal"><span class="pre">Object.entries</span></code> 的基本用途是遍历对象的属性。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">one</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">two</span><span class="o">:</span> <span class="mi">2</span> <span class="p">};</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">]</span> <span class="k">of</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">(</span><span class="nx">obj</span><span class="p">))</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
    <span class="sb">`</span><span class="si">${</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span><span class="si">}</span><span class="sb">: </span><span class="si">${</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span><span class="si">}</span><span class="sb">`</span>
  <span class="p">);</span>
<span class="p">}</span>
<span class="c1">// &quot;one&quot;: 1</span>
<span class="c1">// &quot;two&quot;: 2</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">Object.entries</span></code> 方法的另一个用处是，将对象转为真正的 <code class="docutils literal"><span class="pre">Map</span></code> 结构。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="nx">baz</span><span class="o">:</span> <span class="mi">42</span> <span class="p">};</span>
<span class="kr">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">(</span><span class="nx">obj</span><span class="p">));</span>
<span class="nx">map</span> <span class="c1">// Map { foo: &quot;bar&quot;, baz: 42 }</span>
</pre></div>
</div>
<p>自己实现 <code class="docutils literal"><span class="pre">Object.entries</span></code> 方法，非常简单。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// Generator函数的版本</span>
<span class="kd">function</span><span class="o">*</span> <span class="nx">entries</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">key</span> <span class="k">of</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">obj</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">yield</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">key</span><span class="p">]];</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 非Generator函数的版本</span>
<span class="kd">function</span> <span class="nx">entries</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">key</span> <span class="k">of</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">obj</span><span class="p">))</span> <span class="p">{</span>
    <span class="nx">arr</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="nx">key</span><span class="p">,</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">key</span><span class="p">]]);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">arr</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id10">
<h2>10.11. 对象的扩展运算符<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h2>
<p>《数组的扩展》一章中，已经介绍过扩展运算符（ <code class="docutils literal"><span class="pre">...</span></code> ）。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="p">...</span><span class="nx">b</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
<span class="nx">a</span> <span class="c1">// 1</span>
<span class="nx">b</span> <span class="c1">// [2, 3]</span>
</pre></div>
</div>
<p>ES2018 将这个运算符引入了对象。</p>
<div class="section" id="id11">
<h3>10.11.1. 解构赋值<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h3>
<p>对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（ <code class="docutils literal"><span class="pre">enumerable</span></code> ）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="p">{</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="p">...</span><span class="nx">z</span> <span class="p">}</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">x</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">a</span><span class="o">:</span> <span class="mi">3</span><span class="p">,</span> <span class="nx">b</span><span class="o">:</span> <span class="mi">4</span> <span class="p">};</span>
<span class="nx">x</span> <span class="c1">// 1</span>
<span class="nx">y</span> <span class="c1">// 2</span>
<span class="nx">z</span> <span class="c1">// { a: 3, b: 4 }</span>
</pre></div>
</div>
<p>上面代码中，变量 <code class="docutils literal"><span class="pre">z</span></code> 是解构赋值所在的对象。它获取等号右边的所有尚未读取的键（ <code class="docutils literal"><span class="pre">a</span></code> 和 <code class="docutils literal"><span class="pre">b</span></code> ），将它们连同值一起拷贝过来。</p>
<p>由于解构赋值要求等号右边是一个对象，所以如果等号右边是 <code class="docutils literal"><span class="pre">undefined</span></code> 或 <code class="docutils literal"><span class="pre">null</span></code> ，就会报错，因为它们无法转为对象。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="p">{</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="p">...</span><span class="nx">z</span> <span class="p">}</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// 运行时错误</span>
<span class="kd">let</span> <span class="p">{</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="p">...</span><span class="nx">z</span> <span class="p">}</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span> <span class="c1">// 运行时错误</span>
</pre></div>
</div>
<p>解构赋值必须是最后一个参数，否则会报错。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="p">{</span> <span class="p">...</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">;</span> <span class="c1">// 句法错误</span>
<span class="kd">let</span> <span class="p">{</span> <span class="nx">x</span><span class="p">,</span> <span class="p">...</span><span class="nx">y</span><span class="p">,</span> <span class="p">...</span><span class="nx">z</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">;</span> <span class="c1">// 句法错误</span>
</pre></div>
</div>
<p>上面代码中，解构赋值不是最后一个参数，所以会报错。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。</p>
</div>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">a</span><span class="o">:</span> <span class="p">{</span> <span class="nx">b</span><span class="o">:</span> <span class="mi">1</span> <span class="p">}</span> <span class="p">};</span>
<span class="kd">let</span> <span class="p">{</span> <span class="p">...</span><span class="nx">x</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">;</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">a</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="nx">x</span><span class="p">.</span><span class="nx">a</span><span class="p">.</span><span class="nx">b</span> <span class="c1">// 2</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">x</span></code> 是解构赋值所在的对象，拷贝了对象 <code class="docutils literal"><span class="pre">obj</span></code> 的 <code class="docutils literal"><span class="pre">a</span></code> 属性。 <code class="docutils literal"><span class="pre">a</span></code> 属性引用了一个对象，修改这个对象的值，会影响到解构赋值对它的引用。</p>
<p>另外，扩展运算符的解构赋值，不能复制继承自原型对象的属性。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">o1</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">a</span><span class="o">:</span> <span class="mi">1</span> <span class="p">};</span>
<span class="kd">let</span> <span class="nx">o2</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">b</span><span class="o">:</span> <span class="mi">2</span> <span class="p">};</span>
<span class="nx">o2</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nx">o1</span><span class="p">;</span>
<span class="kd">let</span> <span class="p">{</span> <span class="p">...</span><span class="nx">o3</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">o2</span><span class="p">;</span>
<span class="nx">o3</span> <span class="c1">// { b: 2 }</span>
<span class="nx">o3</span><span class="p">.</span><span class="nx">a</span> <span class="c1">// undefined</span>
</pre></div>
</div>
<p>上面代码中，对象 <code class="docutils literal"><span class="pre">o3</span></code> 复制了 <code class="docutils literal"><span class="pre">o2</span></code> ，但是只复制了 <code class="docutils literal"><span class="pre">o2</span></code> 自身的属性，没有复制它的原型对象 <code class="docutils literal"><span class="pre">o1</span></code> 的属性。</p>
<p>下面是另一个例子。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">o</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">({</span> <span class="nx">x</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mi">2</span> <span class="p">});</span>
<span class="nx">o</span><span class="p">.</span><span class="nx">z</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

<span class="kd">let</span> <span class="p">{</span> <span class="nx">x</span><span class="p">,</span> <span class="p">...</span><span class="nx">newObj</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">o</span><span class="p">;</span>
<span class="kd">let</span> <span class="p">{</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">newObj</span><span class="p">;</span>
<span class="nx">x</span> <span class="c1">// 1</span>
<span class="nx">y</span> <span class="c1">// undefined</span>
<span class="nx">z</span> <span class="c1">// 3</span>
</pre></div>
</div>
<p>上面代码中，变量 <code class="docutils literal"><span class="pre">x</span></code> 是单纯的解构赋值，所以可以读取对象 <code class="docutils literal"><span class="pre">o</span></code> 继承的属性；变量 <code class="docutils literal"><span class="pre">y</span></code> 和 <code class="docutils literal"><span class="pre">z</span></code> 是扩展运算符的解构赋值，只能读取对象 <code class="docutils literal"><span class="pre">o</span></code> 自身的属性，所以变量 <code class="docutils literal"><span class="pre">z</span></code> 可以赋值成功，变量 <code class="docutils literal"><span class="pre">y</span></code> 取不到值。ES6 规定，变量声明语句之中，如果使用解构赋值，扩展运算符后面必须是一个变量名，而不能是一个解构赋值表达式，所以上面代码引入了中间变量 <code class="docutils literal"><span class="pre">newObj</span></code> ，如果写成下面这样会报错。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="p">{</span> <span class="nx">x</span><span class="p">,</span> <span class="p">...{</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span> <span class="p">}</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">o</span><span class="p">;</span> <span class="c1">// SyntaxError: ... must be followed by an identifier in declaration contexts</span>
</pre></div>
</div>
<p>解构赋值的一个用处，是扩展某个函数的参数，引入其他操作。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">baseFunction</span><span class="p">({</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="p">})</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">wrapperFunction</span><span class="p">({</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="p">...</span><span class="nx">restConfig</span> <span class="p">})</span> <span class="p">{</span>
  <span class="c1">// 使用 x 和 y 参数进行操作</span>
  <span class="c1">// 其余参数传给原始函数</span>
  <span class="k">return</span> <span class="nx">baseFunction</span><span class="p">(</span><span class="nx">restConfig</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码中，原始函数 <code class="docutils literal"><span class="pre">baseFunction</span></code> 接受 <code class="docutils literal"><span class="pre">a</span></code> 和 <code class="docutils literal"><span class="pre">b</span></code> 作为参数，函数 <code class="docutils literal"><span class="pre">wrapperFunction</span></code> 在 <code class="docutils literal"><span class="pre">baseFunction</span></code> 的基础上进行了扩展，能够接受多余的参数，并且保留原始函数的行为。</p>
</div>
<div class="section" id="id12">
<h3>10.11.2. 扩展运算符<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h3>
<p>对象的扩展运算符（ <code class="docutils literal"><span class="pre">...</span></code> ）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">z</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">a</span><span class="o">:</span> <span class="mi">3</span><span class="p">,</span> <span class="nx">b</span><span class="o">:</span> <span class="mi">4</span> <span class="p">};</span>
<span class="kd">let</span> <span class="nx">n</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span><span class="nx">z</span> <span class="p">};</span>
<span class="nx">n</span> <span class="c1">// { a: 3, b: 4 }</span>
</pre></div>
</div>
<p>这等同于使用 <code class="docutils literal"><span class="pre">Object.assign</span></code> 方法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">aClone</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span><span class="nx">a</span> <span class="p">};</span>
<span class="c1">// 等同于</span>
<span class="kd">let</span> <span class="nx">aClone</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">({},</span> <span class="nx">a</span><span class="p">);</span>
</pre></div>
</div>
<p>上面的例子只是拷贝了对象实例的属性，如果想完整克隆一个对象，还拷贝对象原型的属性，可以采用下面的写法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// 写法一</span>
<span class="kr">const</span> <span class="nx">clone1</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">__proto__</span><span class="o">:</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">),</span>
  <span class="p">...</span><span class="nx">obj</span>
<span class="p">};</span>

<span class="c1">// 写法二</span>
<span class="kr">const</span> <span class="nx">clone2</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">)),</span>
  <span class="nx">obj</span>
<span class="p">);</span>

<span class="c1">// 写法三</span>
<span class="kr">const</span> <span class="nx">clone3</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">),</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptors</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>上面代码中，写法一的 <code class="docutils literal"><span class="pre">__proto__</span></code> 属性在非浏览器的环境不一定部署，因此推荐使用写法二和写法三。</p>
<p>扩展运算符可以用于合并两个对象。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">ab</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span><span class="nx">a</span><span class="p">,</span> <span class="p">...</span><span class="nx">b</span> <span class="p">};</span>
<span class="c1">// 等同于</span>
<span class="kd">let</span> <span class="nx">ab</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">({},</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span>
</pre></div>
</div>
<p>如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">aWithOverrides</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span><span class="nx">a</span><span class="p">,</span> <span class="nx">x</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mi">2</span> <span class="p">};</span>
<span class="c1">// 等同于</span>
<span class="kd">let</span> <span class="nx">aWithOverrides</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span><span class="nx">a</span><span class="p">,</span> <span class="p">...{</span> <span class="nx">x</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mi">2</span> <span class="p">}</span> <span class="p">};</span>
<span class="c1">// 等同于</span>
<span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">aWithOverrides</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span><span class="nx">a</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">};</span>
<span class="c1">// 等同于</span>
<span class="kd">let</span> <span class="nx">aWithOverrides</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">({},</span> <span class="nx">a</span><span class="p">,</span> <span class="p">{</span> <span class="nx">x</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mi">2</span> <span class="p">});</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">a</span></code> 对象的 <code class="docutils literal"><span class="pre">x</span></code> 属性和 <code class="docutils literal"><span class="pre">y</span></code> 属性，拷贝到新对象后会被覆盖掉。</p>
<p>这用来修改现有对象部分的属性就很方便了。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">newVersion</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">...</span><span class="nx">previousVersion</span><span class="p">,</span>
  <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;New Name&#39;</span> <span class="c1">// Override the name property</span>
<span class="p">};</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">newVersion</span></code> 对象自定义了 <code class="docutils literal"><span class="pre">name</span></code> 属性，其他属性全部复制自 <code class="docutils literal"><span class="pre">previousVersion</span></code> 对象。</p>
<p>如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span>let aWithDefaults = { x: 1, y: 2, ...a };
// 等同于
 even if property keys don’t clash, because objects record insertion order:

let aWithDefaults = Object.assign({}, { x: 1, y: 2 }, a);
// 等同于
let aWithDefaults = Object.assign({ x: 1, y: 2 }, a);
</pre></div>
</div>
<p>与数组的扩展运算符一样，对象的扩展运算符后面可以跟表达式。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">...(</span><span class="nx">x</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">?</span> <span class="p">{</span><span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span>
  <span class="nx">b</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
<p>如果扩展运算符后面是一个空对象，则没有任何效果。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span>{...{}, a: 1}
// { a: 1 }
 even if property keys don’t clash, because objects record insertion order:
</pre></div>
</div>
<p>如果扩展运算符的参数是 <code class="docutils literal"><span class="pre">null</span></code> 或 <code class="docutils literal"><span class="pre">undefined</span></code> ，这两个值会被忽略，不会报错。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">emptyObject</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span><span class="kc">null</span><span class="p">,</span> <span class="p">...</span><span class="kc">undefined</span> <span class="p">};</span> <span class="c1">// 不报错</span>
</pre></div>
</div>
<p>扩展运算符的参数对象之中，如果有取值函数 <code class="docutils literal"><span class="pre">get</span></code> ，这个函数是会执行的。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// 并不会抛出错误，因为 x 属性只是被定义，但没执行</span>
<span class="kd">let</span> <span class="nx">aWithXGetter</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">...</span><span class="nx">a</span><span class="p">,</span>
  <span class="nx">get</span> <span class="nx">x</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;not throw yet&#39;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 会抛出错误，因为 x 属性被执行了</span>
<span class="kd">let</span> <span class="nx">runtimeError</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">...</span><span class="nx">a</span><span class="p">,</span>
  <span class="p">...{</span>
    <span class="nx">get</span> <span class="nx">x</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;throw now&#39;</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Symbol.html" class="btn btn-neutral float-right" title="11. Symbol" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="数组的扩展.html" class="btn btn-neutral" title="9. 数组的扩展" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, lzh.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.0',
            LANGUAGE:'zh_CN',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="_static/translations.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();

      });


      $(document).ready(function(){
        var offset = sessionStorage.getItem("offsetTop");
        $('.wy-side-scroll').scrollTop(offset);
        sessionStorage.setItem("offsetTop", 0);


        $('.wy-menu > ul').click(function(){
            sessionStorage.setItem("offsetTop", $('.wy-side-scroll').scrollTop());
        });
      })

  </script>
   

</body>
</html>