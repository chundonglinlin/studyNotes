

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>16. Iterator 和 for…of 循环 &mdash; ECMAScript6入门 1.0 文档</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="索引"
              href="genindex.html"/>
        <link rel="search" title="搜索" href="search.html"/>
    <link rel="top" title="ECMAScript6入门 1.0 文档" href="index.html"/>
        <link rel="next" title="17. Generator函数的语法" href="Generator函数的语法.html"/>
        <link rel="prev" title="15. Promise对象" href="Promise对象.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> ECMAScript6入门
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="前言.html">1. 前言</a></li>
<li class="toctree-l1"><a class="reference internal" href="ECMAScript6简介.html">2. ECMAScript6简介</a></li>
<li class="toctree-l1"><a class="reference internal" href="let和const命令.html">3. let 和 const 命令</a></li>
<li class="toctree-l1"><a class="reference internal" href="变量的解构赋值.html">4. 变量的解构赋值</a></li>
<li class="toctree-l1"><a class="reference internal" href="字符串的扩展.html">5. 字符串的扩展</a></li>
<li class="toctree-l1"><a class="reference internal" href="正则的扩展.html">6. 正则的扩展</a></li>
<li class="toctree-l1"><a class="reference internal" href="数值的扩展.html">7. 数值的扩展</a></li>
<li class="toctree-l1"><a class="reference internal" href="函数的扩展.html">8. 函数的扩展</a></li>
<li class="toctree-l1"><a class="reference internal" href="数组的扩展.html">9. 数组的扩展</a></li>
<li class="toctree-l1"><a class="reference internal" href="对象的扩展.html">10. 对象的扩展</a></li>
<li class="toctree-l1"><a class="reference internal" href="Symbol.html">11. Symbol</a></li>
<li class="toctree-l1"><a class="reference internal" href="Set和Map数据结构.html">12. Set和Map数据结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="Proxy.html">13. Proxy</a></li>
<li class="toctree-l1"><a class="reference internal" href="Reflect.html">14. Reflect</a></li>
<li class="toctree-l1"><a class="reference internal" href="Promise对象.html">15. Promise对象</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">16. Iterator 和 for…of 循环</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#iterator">16.1. Iterator（遍历器）的概念</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id1">16.2. 默认 Iterator 接口</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id2">16.3. 调用 Iterator 接口的场合</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">16.4. 字符串的 Iterator 接口</a></li>
<li class="toctree-l2"><a class="reference internal" href="#iterator-generator">16.5. Iterator 接口与 Generator 函数</a></li>
<li class="toctree-l2"><a class="reference internal" href="#return-throw">16.6. 遍历器对象的 return()，throw()</a></li>
<li class="toctree-l2"><a class="reference internal" href="#for-of">16.7. for…of 循环</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id4">16.7.1. 数组</a></li>
<li class="toctree-l3"><a class="reference internal" href="#set-map">16.7.2. Set 和 Map 结构</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">16.7.3. 计算生成的数据结构</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id6">16.7.4. 类似数组的对象</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id7">16.7.5. 对象</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id8">16.7.6. 与其他遍历语法的比较</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Generator函数的语法.html">17. Generator函数的语法</a></li>
<li class="toctree-l1"><a class="reference internal" href="Generator函数的异步应用.html">18. Generator 函数的异步应用</a></li>
<li class="toctree-l1"><a class="reference internal" href="async函数.html">19. asyn函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="Class的基本语法.html">20. Class 的基本语法</a></li>
<li class="toctree-l1"><a class="reference internal" href="Class的继承.html">21. Class的继承</a></li>
<li class="toctree-l1"><a class="reference internal" href="Decorator.html">22. 修饰器</a></li>
<li class="toctree-l1"><a class="reference internal" href="Module的语法.html">23. Module 的语法</a></li>
<li class="toctree-l1"><a class="reference internal" href="Module的加载实现.html">24. Module 的加载实现</a></li>
<li class="toctree-l1"><a class="reference internal" href="编程风格.html">25. 编程风格</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">ECMAScript6入门</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>16. Iterator 和 for…of 循环</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="iterator-for-of">
<h1>16. Iterator 和 for…of 循环<a class="headerlink" href="#iterator-for-of" title="永久链接至标题">¶</a></h1>
<div class="section" id="iterator">
<h2>16.1. Iterator（遍历器）的概念<a class="headerlink" href="#iterator" title="永久链接至标题">¶</a></h2>
<p><code class="docutils literal"><span class="pre">JavaScript</span></code> 原有的表示“集合”的数据结构，主要是数组（ <code class="docutils literal"><span class="pre">Array</span></code> ）和对象（ <code class="docutils literal"><span class="pre">Object</span></code> ），ES6 又添加了 <code class="docutils literal"><span class="pre">Map</span></code> 和 <code class="docutils literal"><span class="pre">Set</span></code> 。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是 <code class="docutils literal"><span class="pre">Map</span></code> ， <code class="docutils literal"><span class="pre">Map</span></code> 的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。</p>
<p>遍历器（ <code class="docutils literal"><span class="pre">Iterator</span></code> ）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 <code class="docutils literal"><span class="pre">Iterator</span></code> 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p>
<p><code class="docutils literal"><span class="pre">Iterator</span></code> 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令 <code class="docutils literal"><span class="pre">for...of</span></code> <code class="docutils literal"><span class="pre">循环，Iterator</span></code> 接口主要供 <code class="docutils literal"><span class="pre">for...of</span></code> 消费。</p>
<p><code class="docutils literal"><span class="pre">Iterator</span></code> 的遍历过程是这样的。</p>
<ol class="arabic simple">
<li>创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</li>
<li>第一次调用指针对象的 <code class="docutils literal"><span class="pre">next</span></code> 方法，可以将指针指向数据结构的第一个成员。</li>
<li>第二次调用指针对象的 <code class="docutils literal"><span class="pre">next</span></code> 方法，指针就指向数据结构的第二个成员。</li>
<li>不断调用指针对象的 <code class="docutils literal"><span class="pre">next</span></code> 方法，直到它指向数据结构的结束位置。</li>
</ol>
<p>每一次调用 <code class="docutils literal"><span class="pre">next</span></code> 方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含 <code class="docutils literal"><span class="pre">value</span></code> 和 <code class="docutils literal"><span class="pre">done</span></code> 两个属性的对象。其中， <code class="docutils literal"><span class="pre">value</span></code> 属性是当前成员的值， <code class="docutils literal"><span class="pre">done</span></code> 属性是一个布尔值，表示遍历是否结束。</p>
<p>下面是一个模拟 <code class="docutils literal"><span class="pre">next</span></code> 方法返回值的例子。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">it</span> <span class="o">=</span> <span class="nx">makeIterator</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]);</span>

<span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// { value: &quot;a&quot;, done: false }</span>
<span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// { value: &quot;b&quot;, done: false }</span>
<span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// { value: undefined, done: true }</span>

<span class="kd">function</span> <span class="nx">makeIterator</span><span class="p">(</span><span class="nx">array</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">nextIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="nx">next</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">nextIndex</span> <span class="o">&lt;</span> <span class="nx">array</span><span class="p">.</span><span class="nx">length</span> <span class="o">?</span>
        <span class="p">{</span><span class="nx">value</span><span class="o">:</span> <span class="nx">array</span><span class="p">[</span><span class="nx">nextIndex</span><span class="o">++</span><span class="p">],</span> <span class="nx">done</span><span class="o">:</span> <span class="kc">false</span><span class="p">}</span> <span class="o">:</span>
        <span class="p">{</span><span class="nx">value</span><span class="o">:</span> <span class="kc">undefined</span><span class="p">,</span> <span class="nx">done</span><span class="o">:</span> <span class="kc">true</span><span class="p">};</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码定义了一个 <code class="docutils literal"><span class="pre">makeIterator</span></code> 函数，它是一个遍历器生成函数，作用就是返回一个遍历器对象。对数组 <code class="docutils literal"><span class="pre">['a',</span> <span class="pre">'b']``执行这个函数，就会返回该数组的遍历器对象（即指针对象）</span> <span class="pre">``it</span></code> 。</p>
<p>指针对象的 <code class="docutils literal"><span class="pre">next</span></code> 方法，用来移动指针。开始时，指针指向数组的开始位置。然后，每次调用 <code class="docutils literal"><span class="pre">next</span></code> 方法，指针就会指向数组的下一个成员。第一次调用，指向 <code class="docutils literal"><span class="pre">a</span></code> ；第二次调用，指向 <code class="docutils literal"><span class="pre">b</span></code> 。</p>
<p><code class="docutils literal"><span class="pre">next</span></code> 方法返回一个对象，表示当前数据成员的信息。这个对象具有 <code class="docutils literal"><span class="pre">value</span></code> 和 <code class="docutils literal"><span class="pre">done</span></code> 两个属性， <code class="docutils literal"><span class="pre">value</span></code> 属性返回当前位置的成员， <code class="docutils literal"><span class="pre">done</span></code> 属性是一个布尔值，表示遍历是否结束，即是否还有必要再一次调用 <code class="docutils literal"><span class="pre">next</span></code> 方法。</p>
<p>总之，调用指针对象的 <code class="docutils literal"><span class="pre">next</span></code> 方法，就可以遍历事先给定的数据结构。</p>
<p>对于遍历器对象来说， <code class="docutils literal"><span class="pre">done:false</span></code> 和 <code class="docutils literal"><span class="pre">value:undefined</span></code> 属性都是可以省略的，因此上面的 <code class="docutils literal"><span class="pre">makeIterator</span></code> 函数可以简写成下面的形式。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">makeIterator</span><span class="p">(</span><span class="nx">array</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">nextIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="nx">next</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">nextIndex</span> <span class="o">&lt;</span> <span class="nx">array</span><span class="p">.</span><span class="nx">length</span> <span class="o">?</span>
        <span class="p">{</span><span class="nx">value</span><span class="o">:</span> <span class="nx">array</span><span class="p">[</span><span class="nx">nextIndex</span><span class="o">++</span><span class="p">]}</span> <span class="o">:</span>
        <span class="p">{</span><span class="nx">done</span><span class="o">:</span> <span class="kc">true</span><span class="p">};</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>由于 <code class="docutils literal"><span class="pre">Iterator</span></code> 只是把接口规格加到数据结构之上，所以，遍历器与它所遍历的那个数据结构，实际上是分开的，完全可以写出没有对应数据结构的遍历器对象，或者说用遍历器对象模拟出数据结构。下面是一个无限运行的遍历器对象的例子。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">it</span> <span class="o">=</span> <span class="nx">idMaker</span><span class="p">();</span>

<span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span> <span class="c1">// 0</span>
<span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span> <span class="c1">// 1</span>
<span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span> <span class="c1">// 2</span>
<span class="c1">// ...</span>

<span class="kd">function</span> <span class="nx">idMaker</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">return</span> <span class="p">{</span>
    <span class="nx">next</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">{</span><span class="nx">value</span><span class="o">:</span> <span class="nx">index</span><span class="o">++</span><span class="p">,</span> <span class="nx">done</span><span class="o">:</span> <span class="kc">false</span><span class="p">};</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的例子中，遍历器生成函数 <code class="docutils literal"><span class="pre">idMaker</span></code> ，返回一个遍历器对象（即指针对象）。但是并没有对应的数据结构，或者说，遍历器对象自己描述了一个数据结构出来。</p>
<p>如果使用 <code class="docutils literal"><span class="pre">TypeScript</span></code> 的写法，遍历器接口（ <code class="docutils literal"><span class="pre">Iterable</span></code> ）、指针对象（ <code class="docutils literal"><span class="pre">Iterator</span></code> ）和 <code class="docutils literal"><span class="pre">next</span></code> 方法返回值的规格可以描述如下。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">interface</span> <span class="nx">Iterable</span> <span class="p">{</span>
  <span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]()</span> <span class="o">:</span> <span class="nx">Iterator</span><span class="p">,</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">Iterator</span> <span class="p">{</span>
  <span class="nx">next</span><span class="p">(</span><span class="nx">value</span><span class="o">?:</span> <span class="nx">any</span><span class="p">)</span> <span class="o">:</span> <span class="nx">IterationResult</span><span class="p">,</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">IterationResult</span> <span class="p">{</span>
  <span class="nx">value</span><span class="o">:</span> <span class="nx">any</span><span class="p">,</span>
  <span class="nx">done</span><span class="o">:</span> <span class="kr">boolean</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id1">
<h2>16.2. 默认 Iterator 接口<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p><code class="docutils literal"><span class="pre">Iterator</span></code> 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即 <code class="docutils literal"><span class="pre">for...of</span></code> 循环（详见下文）。当使用 <code class="docutils literal"><span class="pre">for...of</span></code> 循环遍历某种数据结构时，该循环会自动去寻找 <code class="docutils literal"><span class="pre">Iterator</span></code> 接口。</p>
<p>一种数据结构只要部署了 <code class="docutils literal"><span class="pre">Iterator</span></code> 接口，我们就称这种数据结构是“可遍历的”（ <code class="docutils literal"><span class="pre">iterable</span></code> ）。</p>
<p>ES6 规定，默认的 <code class="docutils literal"><span class="pre">Iterator</span></code> 接口部署在数据结构的 <code class="docutils literal"><span class="pre">Symbol.iterator</span></code> 属性，或者说，一个数据结构只要具有 <code class="docutils literal"><span class="pre">Symbol.iterator</span></code> 属性，就可以认为是“可遍历的”（ <code class="docutils literal"><span class="pre">iterable</span></code> ）。 <code class="docutils literal"><span class="pre">Symbol.iterator</span></code> 属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。至于属性名 <code class="docutils literal"><span class="pre">Symbol.iterator</span></code> ，它是一个表达式，返回 <code class="docutils literal"><span class="pre">Symbol</span></code> 对象的 <code class="docutils literal"><span class="pre">iterator</span></code> 属性，这是一个预定义好的、类型为 <code class="docutils literal"><span class="pre">Symbol</span></code> 的特殊值，所以要放在方括号内（参见《Symbol》一章）。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]</span> <span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
      <span class="nx">next</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">{</span>
          <span class="nx">value</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
          <span class="nx">done</span><span class="o">:</span> <span class="kc">true</span>
        <span class="p">};</span>
      <span class="p">}</span>
    <span class="p">};</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>上面代码中，对象 <code class="docutils literal"><span class="pre">obj</span></code> 是可遍历的（ <code class="docutils literal"><span class="pre">iterable</span></code> ），因为具有 <code class="docutils literal"><span class="pre">Symbol.iterator</span></code> 属性。执行这个属性，会返回一个遍历器对象。该对象的根本特征就是具有 <code class="docutils literal"><span class="pre">next</span></code> 方法。每次调用 <code class="docutils literal"><span class="pre">next</span></code> 方法，都会返回一个代表当前成员的信息对象，具有 <code class="docutils literal"><span class="pre">value</span></code> 和 <code class="docutils literal"><span class="pre">done</span></code> 两个属性。</p>
<p>ES6 的有些数据结构原生具备 <code class="docutils literal"><span class="pre">Iterator</span></code> 接口（比如数组），即不用任何处理，就可以被 <code class="docutils literal"><span class="pre">for...of</span></code> 循环遍历。原因在于，这些数据结构原生部署了 <code class="docutils literal"><span class="pre">Symbol.iterator</span></code> 属性（详见下文），另外一些数据结构没有（比如对象）。凡是部署了 <code class="docutils literal"><span class="pre">Symbol.iterator</span></code> 属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。</p>
<p>原生具备 <code class="docutils literal"><span class="pre">Iterator</span></code> 接口的数据结构如下。</p>
<ul class="simple">
<li>Array</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>TypedArray</li>
<li>函数的 <code class="docutils literal"><span class="pre">arguments</span></code> 对象</li>
<li>NodeList 对象</li>
</ul>
<p>下面的例子是数组的 <code class="docutils literal"><span class="pre">Symbol.iterator</span></code> 属性。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">iter</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]();</span>

<span class="nx">iter</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// { value: &#39;a&#39;, done: false }</span>
<span class="nx">iter</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// { value: &#39;b&#39;, done: false }</span>
<span class="nx">iter</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// { value: &#39;c&#39;, done: false }</span>
<span class="nx">iter</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// { value: undefined, done: true }</span>
</pre></div>
</div>
<p>上面代码中，变量 <code class="docutils literal"><span class="pre">arr</span></code> 是一个数组，原生就具有遍历器接口，部署在 <code class="docutils literal"><span class="pre">arr</span></code> 的 <code class="docutils literal"><span class="pre">Symbol.iterator</span></code> 属性上面。所以，调用这个属性，就得到遍历器对象。</p>
<p>对于原生部署 <code class="docutils literal"><span class="pre">Iterator</span></code> 接口的数据结构，不用自己写遍历器生成函数， <code class="docutils literal"><span class="pre">for...of</span></code> 循环会自动遍历它们。除此之外，其他数据结构（主要是对象）的 <code class="docutils literal"><span class="pre">Iterator</span></code> 接口，都需要自己在 <code class="docutils literal"><span class="pre">Symbol.iterator</span></code> 属性上面部署，这样才会被 <code class="docutils literal"><span class="pre">for...of</span></code> 循环遍历。</p>
<p>对象（ <code class="docutils literal"><span class="pre">Object</span> <span class="pre">``）之所以没有默认部署</span> <span class="pre">``Iterator</span></code> 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。不过，严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当作 <code class="docutils literal"><span class="pre">Map</span></code> 结构使用，ES5 没有 <code class="docutils literal"><span class="pre">Map</span></code> 结构，而 ES6 原生提供了。</p>
<p>一个对象如果要具备可被 <code class="docutils literal"><span class="pre">for...of</span></code> 循环调用的 <code class="docutils literal"><span class="pre">Iterator</span></code> 接口，就必须在 <code class="docutils literal"><span class="pre">Symbol.iterator</span></code> 的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">RangeIterator</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="nx">stop</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">start</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">stop</span> <span class="o">=</span> <span class="nx">stop</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="p">;</span> <span class="p">}</span>

  <span class="nx">next</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">stop</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="o">++</span><span class="p">;</span>
      <span class="k">return</span> <span class="p">{</span><span class="nx">done</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">value</span><span class="p">};</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">{</span><span class="nx">done</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">value</span><span class="o">:</span> <span class="kc">undefined</span><span class="p">};</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="nx">stop</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nx">RangeIterator</span><span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="nx">stop</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">value</span> <span class="k">of</span> <span class="nx">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span> <span class="c1">// 0, 1, 2</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码是一个类部署 <code class="docutils literal"><span class="pre">Iterator</span></code> 接口的写法。 <code class="docutils literal"><span class="pre">Symbol.iterator</span></code> 属性对应一个函数，执行后返回当前对象的遍历器对象。</p>
<p>下面是通过遍历器实现指针结构的例子。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">Obj</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">Obj</span><span class="p">.</span><span class="nx">prototype</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">iterator</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">next</span><span class="o">:</span> <span class="nx">next</span> <span class="p">};</span>

  <span class="kd">var</span> <span class="nx">current</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>

  <span class="kd">function</span> <span class="nx">next</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">current</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="nx">current</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
      <span class="nx">current</span> <span class="o">=</span> <span class="nx">current</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
      <span class="k">return</span> <span class="p">{</span> <span class="nx">done</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">value</span> <span class="p">};</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">{</span> <span class="nx">done</span><span class="o">:</span> <span class="kc">true</span> <span class="p">};</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">iterator</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">one</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Obj</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">two</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Obj</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">three</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Obj</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>

<span class="nx">one</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">two</span><span class="p">;</span>
<span class="nx">two</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">three</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="k">of</span> <span class="nx">one</span><span class="p">){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span> <span class="c1">// 1, 2, 3</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码首先在构造函数的原型链上部署 <code class="docutils literal"><span class="pre">Symbol.iterator</span></code> 方法，调用该方法会返回遍历器对象 <code class="docutils literal"><span class="pre">iterator</span></code> ，调用该对象的 <code class="docutils literal"><span class="pre">next</span></code> 方法，在返回一个值的同时，自动将内部指针移到下一个实例。</p>
<p>下面是另一个为对象添加 <code class="docutils literal"><span class="pre">Iterator</span></code> 接口的例子。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">data</span><span class="o">:</span> <span class="p">[</span> <span class="s1">&#39;hello&#39;</span><span class="p">,</span> <span class="s1">&#39;world&#39;</span> <span class="p">],</span>
  <span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]()</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">self</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">{</span>
      <span class="nx">next</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">index</span> <span class="o">&lt;</span> <span class="nx">self</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="p">{</span>
            <span class="nx">value</span><span class="o">:</span> <span class="nx">self</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">index</span><span class="o">++</span><span class="p">],</span>
            <span class="nx">done</span><span class="o">:</span> <span class="kc">false</span>
          <span class="p">};</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="k">return</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="kc">undefined</span><span class="p">,</span> <span class="nx">done</span><span class="o">:</span> <span class="kc">true</span> <span class="p">};</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">};</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>对于类似数组的对象（存在数值键名和 <code class="docutils literal"><span class="pre">length</span></code> 属性），部署 <code class="docutils literal"><span class="pre">Iterator</span></code> 接口，有一个简便方法，就是 <code class="docutils literal"><span class="pre">Symbol.iterator</span></code> 方法直接引用数组的 <code class="docutils literal"><span class="pre">Iterator</span></code> 接口。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">NodeList</span><span class="p">.</span><span class="nx">prototype</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">];</span>
<span class="c1">// 或者</span>
<span class="nx">NodeList</span><span class="p">.</span><span class="nx">prototype</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]</span> <span class="o">=</span> <span class="p">[][</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">];</span>

<span class="p">[...</span><span class="nb">document</span><span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="s1">&#39;div&#39;</span><span class="p">)]</span> <span class="c1">// 可以执行了</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">NodeList</span></code> 对象是类似数组的对象，本来就具有遍历接口，可以直接遍历。上面代码中，我们将它的遍历接口改成数组的 <code class="docutils literal"><span class="pre">Symbol.iterator</span></code> 属性，可以看到没有任何影响。</p>
<p>下面是另一个类似数组的对象调用数组的 <code class="docutils literal"><span class="pre">Symbol.iterator</span></code> 方法的例子。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">iterable</span> <span class="o">=</span> <span class="p">{</span>
  <span class="mi">0</span><span class="o">:</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span>
  <span class="mi">1</span><span class="o">:</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span>
  <span class="mi">2</span><span class="o">:</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span>
  <span class="nx">length</span><span class="o">:</span> <span class="mi">3</span><span class="p">,</span>
  <span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]</span><span class="o">:</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]</span>
<span class="p">};</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">item</span> <span class="k">of</span> <span class="nx">iterable</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span> <span class="c1">// &#39;a&#39;, &#39;b&#39;, &#39;c&#39;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>注意，普通对象部署数组的 <code class="docutils literal"><span class="pre">Symbol.Iterator</span></code> 方法，并无效果。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">iterable</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">a</span><span class="o">:</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span>
  <span class="nx">b</span><span class="o">:</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span>
  <span class="nx">c</span><span class="o">:</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span>
  <span class="nx">length</span><span class="o">:</span> <span class="mi">3</span><span class="p">,</span>
  <span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]</span><span class="o">:</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]</span>
<span class="p">};</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">item</span> <span class="k">of</span> <span class="nx">iterable</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span> <span class="c1">// undefined, undefined, undefined</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如果 <code class="docutils literal"><span class="pre">Symbol.iterator</span></code> 方法对应的不是遍历器生成函数（即会返回一个遍历器对象），解释引擎将会报错。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>

<span class="nx">obj</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="mi">1</span><span class="p">;</span>

<span class="p">[...</span><span class="nx">obj</span><span class="p">]</span> <span class="c1">// TypeError: [] is not a function</span>
</pre></div>
</div>
<p>上面代码中，变量 <code class="docutils literal"><span class="pre">obj</span></code> 的 <code class="docutils literal"><span class="pre">Symbol.iterator</span></code> 方法对应的不是遍历器生成函数，因此报错。</p>
<p>有了遍历器接口，数据结构就可以用 <code class="docutils literal"><span class="pre">for...of</span></code> 循环遍历（详见下文），也可以使用 <code class="docutils literal"><span class="pre">while</span></code> 循环遍历。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">$iterator</span> <span class="o">=</span> <span class="nx">ITERABLE</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]();</span>
<span class="kd">var</span> <span class="nx">$result</span> <span class="o">=</span> <span class="nx">$iterator</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="nx">$result</span><span class="p">.</span><span class="nx">done</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">$result</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
  <span class="c1">// ...</span>
  <span class="nx">$result</span> <span class="o">=</span> <span class="nx">$iterator</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">ITERABLE</span></code> 代表某种可遍历的数据结构， <code class="docutils literal"><span class="pre">$iterator</span></code> 是它的遍历器对象。遍历器对象每次移动指针（ <code class="docutils literal"><span class="pre">next</span></code> 方法），都检查一下返回值的 <code class="docutils literal"><span class="pre">done</span></code> 属性，如果遍历还没结束，就移动遍历器对象的指针到下一步（ <code class="docutils literal"><span class="pre">next</span></code> 方法），不断循环。</p>
</div>
<div class="section" id="id2">
<h2>16.3. 调用 Iterator 接口的场合<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>有一些场合会默认调用 <code class="docutils literal"><span class="pre">Iterator</span></code> 接口（即 <code class="docutils literal"><span class="pre">Symbol.iterator</span></code> 方法），除了下文会介绍的 <code class="docutils literal"><span class="pre">for...of</span></code> 循环，还有几个别的场合。</p>
<ol class="arabic simple">
<li>解构赋值</li>
</ol>
<p>对数组和 <code class="docutils literal"><span class="pre">Set</span></code> 结构进行解构赋值时，会默认调用 <code class="docutils literal"><span class="pre">Symbol.iterator</span></code> 方法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">().</span><span class="nx">add</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">).</span><span class="nx">add</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">).</span><span class="nx">add</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">);</span>

<span class="kd">let</span> <span class="p">[</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">]</span> <span class="o">=</span> <span class="nx">set</span><span class="p">;</span>
<span class="c1">// x=&#39;a&#39;; y=&#39;b&#39;</span>

<span class="kd">let</span> <span class="p">[</span><span class="nx">first</span><span class="p">,</span> <span class="p">...</span><span class="nx">rest</span><span class="p">]</span> <span class="o">=</span> <span class="nx">set</span><span class="p">;</span>
<span class="c1">// first=&#39;a&#39;; rest=[&#39;b&#39;,&#39;c&#39;];</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li>扩展运算符</li>
</ol>
<p>扩展运算符（ <code class="docutils literal"><span class="pre">...</span></code> ）也会调用默认的 <code class="docutils literal"><span class="pre">Iterator</span></code> 接口。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// 例一</span>
<span class="kd">var</span> <span class="nx">str</span> <span class="o">=</span> <span class="s1">&#39;hello&#39;</span><span class="p">;</span>
<span class="p">[...</span><span class="nx">str</span><span class="p">]</span> <span class="c1">//  [&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;]</span>

<span class="c1">// 例二</span>
<span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">];</span>
<span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="p">...</span><span class="nx">arr</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">]</span>
<span class="c1">// [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</span>
</pre></div>
</div>
<p>上面代码的扩展运算符内部就调用 <code class="docutils literal"><span class="pre">Iterator</span></code> 接口。</p>
<p>实际上，这提供了一种简便机制，可以将任何部署了 <code class="docutils literal"><span class="pre">Iterator</span></code> 接口的数据结构，转为数组。也就是说，只要某个数据结构部署了 <code class="docutils literal"><span class="pre">Iterator</span></code> 接口，就可以对它使用扩展运算符，将其转为数组。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">iterable</span><span class="p">];</span>
</pre></div>
</div>
<ol class="arabic simple" start="3">
<li>yield*</li>
</ol>
<p><code class="docutils literal"><span class="pre">yield*</span></code> 后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">generator</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">yield</span><span class="o">*</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">];</span>
  <span class="k">yield</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">iterator</span> <span class="o">=</span> <span class="nx">generator</span><span class="p">();</span>

<span class="nx">iterator</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// { value: 1, done: false }</span>
<span class="nx">iterator</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// { value: 2, done: false }</span>
<span class="nx">iterator</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// { value: 3, done: false }</span>
<span class="nx">iterator</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// { value: 4, done: false }</span>
<span class="nx">iterator</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// { value: 5, done: false }</span>
<span class="nx">iterator</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// { value: undefined, done: true }</span>
</pre></div>
</div>
<ol class="arabic simple" start="4">
<li>其他场合</li>
</ol>
<p>由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。</p>
<ul class="simple">
<li>for…of</li>
<li>Array.from()</li>
<li>Map(), Set(), WeakMap(), WeakSet()（比如new Map([[‘a’,1],[‘b’,2]])）</li>
<li>Promise.all()</li>
<li>Promise.race()</li>
</ul>
</div>
<div class="section" id="id3">
<h2>16.4. 字符串的 Iterator 接口<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>字符串是一个类似数组的对象，也原生具有 <code class="docutils literal"><span class="pre">Iterator</span></code> 接口。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">someString</span> <span class="o">=</span> <span class="s2">&quot;hi&quot;</span><span class="p">;</span>
<span class="k">typeof</span> <span class="nx">someString</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]</span>
<span class="c1">// &quot;function&quot;</span>

<span class="kd">var</span> <span class="nx">iterator</span> <span class="o">=</span> <span class="nx">someString</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]();</span>

<span class="nx">iterator</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>  <span class="c1">// { value: &quot;h&quot;, done: false }</span>
<span class="nx">iterator</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>  <span class="c1">// { value: &quot;i&quot;, done: false }</span>
<span class="nx">iterator</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>  <span class="c1">// { value: undefined, done: true }</span>
</pre></div>
</div>
<p>上面代码中，调用 <code class="docutils literal"><span class="pre">Symbol.iterator</span></code> 方法返回一个遍历器对象，在这个遍历器上可以调用 <code class="docutils literal"><span class="pre">next</span></code> 方法，实现对于字符串的遍历。</p>
<p>可以覆盖原生的 <code class="docutils literal"><span class="pre">Symbol.iterator</span></code> 方法，达到修改遍历器行为的目的。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">str</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">String</span><span class="p">(</span><span class="s2">&quot;hi&quot;</span><span class="p">);</span>

<span class="p">[...</span><span class="nx">str</span><span class="p">]</span> <span class="c1">// [&quot;h&quot;, &quot;i&quot;]</span>

<span class="nx">str</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="nx">next</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_first</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">_first</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
        <span class="k">return</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="s2">&quot;bye&quot;</span><span class="p">,</span> <span class="nx">done</span><span class="o">:</span> <span class="kc">false</span> <span class="p">};</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">{</span> <span class="nx">done</span><span class="o">:</span> <span class="kc">true</span> <span class="p">};</span>
      <span class="p">}</span>
    <span class="p">},</span>
    <span class="nx">_first</span><span class="o">:</span> <span class="kc">true</span>
  <span class="p">};</span>
<span class="p">};</span>

<span class="p">[...</span><span class="nx">str</span><span class="p">]</span> <span class="c1">// [&quot;bye&quot;]</span>
<span class="nx">str</span> <span class="c1">// &quot;hi&quot;</span>
</pre></div>
</div>
<p>上面代码中，字符串 <code class="docutils literal"><span class="pre">str</span></code> 的 <code class="docutils literal"><span class="pre">Symbol.iterator</span></code> 方法被修改了，所以扩展运算符（ <code class="docutils literal"><span class="pre">...</span></code> ）返回的值变成了 <code class="docutils literal"><span class="pre">bye</span></code> ，而字符串本身还是 <code class="docutils literal"><span class="pre">hi</span></code> 。</p>
</div>
<div class="section" id="iterator-generator">
<h2>16.5. Iterator 接口与 Generator 函数<a class="headerlink" href="#iterator-generator" title="永久链接至标题">¶</a></h2>
<p><code class="docutils literal"><span class="pre">Symbol.iterator</span></code> 方法的最简单实现，还是使用下一章要介绍的 <code class="docutils literal"><span class="pre">Generator</span></code> 函数。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">myIterable</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]</span><span class="o">:</span> <span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="p">[...</span><span class="nx">myIterable</span><span class="p">]</span> <span class="c1">// [1, 2, 3]</span>

<span class="c1">// 或者采用下面的简洁写法</span>

<span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="o">*</span> <span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]()</span> <span class="p">{</span>
    <span class="k">yield</span> <span class="s1">&#39;hello&#39;</span><span class="p">;</span>
    <span class="k">yield</span> <span class="s1">&#39;world&#39;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="k">of</span> <span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// &quot;hello&quot;</span>
<span class="c1">// &quot;world&quot;</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">Symbol.iterator</span></code> 方法几乎不用部署任何代码，只要用 <code class="docutils literal"><span class="pre">yield</span></code> 命令给出每一步的返回值即可。</p>
</div>
<div class="section" id="return-throw">
<h2>16.6. 遍历器对象的 return()，throw()<a class="headerlink" href="#return-throw" title="永久链接至标题">¶</a></h2>
<p>遍历器对象除了具有 <code class="docutils literal"><span class="pre">next</span></code> 方法，还可以具有 <code class="docutils literal"><span class="pre">return</span></code> 方法和 <code class="docutils literal"><span class="pre">throw</span></code> 方法。如果你自己写遍历器对象生成函数，那么 <code class="docutils literal"><span class="pre">next</span></code> 方法是必须部署的， <code class="docutils literal"><span class="pre">return</span></code> 方法和 <code class="docutils literal"><span class="pre">throw</span></code> 方法是否部署是可选的。</p>
<p><code class="docutils literal"><span class="pre">return</span></code> 方法的使用场合是，如果 <code class="docutils literal"><span class="pre">for...of</span></code> 循环提前退出（通常是因为出错，或者有 <code class="docutils literal"><span class="pre">break</span></code> 语句或 <code class="docutils literal"><span class="pre">continue</span></code> 语句），就会调用 <code class="docutils literal"><span class="pre">return</span></code> 方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署 <code class="docutils literal"><span class="pre">return</span></code> 方法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">readLinesSync</span><span class="p">(</span><span class="nx">file</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">{</span>
        <span class="nx">next</span><span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="p">{</span> <span class="nx">done</span><span class="o">:</span> <span class="kc">false</span> <span class="p">};</span>
        <span class="p">},</span>
        <span class="k">return</span><span class="p">()</span> <span class="p">{</span>
          <span class="nx">file</span><span class="p">.</span><span class="nx">close</span><span class="p">();</span>
          <span class="k">return</span> <span class="p">{</span> <span class="nx">done</span><span class="o">:</span> <span class="kc">true</span> <span class="p">};</span>
        <span class="p">}</span>
      <span class="p">};</span>
    <span class="p">},</span>
  <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码中，函数 <code class="docutils literal"><span class="pre">readLinesSync</span></code> 接受一个文件对象作为参数，返回一个遍历器对象，其中除了 <code class="docutils literal"><span class="pre">next</span></code> 方法，还部署了 <code class="docutils literal"><span class="pre">return</span></code> 方法。下面的三种情况，都会触发执行 <code class="docutils literal"><span class="pre">return</span></code> 方法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// 情况一</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">line</span> <span class="k">of</span> <span class="nx">readLinesSync</span><span class="p">(</span><span class="nx">fileName</span><span class="p">))</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">line</span><span class="p">);</span>
  <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 情况二</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">line</span> <span class="k">of</span> <span class="nx">readLinesSync</span><span class="p">(</span><span class="nx">fileName</span><span class="p">))</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">line</span><span class="p">);</span>
  <span class="k">continue</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 情况三</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">line</span> <span class="k">of</span> <span class="nx">readLinesSync</span><span class="p">(</span><span class="nx">fileName</span><span class="p">))</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">line</span><span class="p">);</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码中，情况一输出文件的第一行以后，就会执行 <code class="docutils literal"><span class="pre">return</span></code> 方法，关闭这个文件；情况二输出所有行以后，执行 <code class="docutils literal"><span class="pre">return</span></code> 方法，关闭该文件；情况三会在执行 <code class="docutils literal"><span class="pre">return</span></code> 方法关闭文件之后，再抛出错误。</p>
<p>注意， <code class="docutils literal"><span class="pre">return</span></code> 方法必须返回一个对象，这是 <code class="docutils literal"><span class="pre">Generator</span></code> 规格决定的。</p>
<p><code class="docutils literal"><span class="pre">throw</span></code> 方法主要是配合 <code class="docutils literal"><span class="pre">Generator</span></code> 函数使用，一般的遍历器对象用不到这个方法。请参阅《 <code class="docutils literal"><span class="pre">Generator</span></code> 函数》一章。</p>
</div>
<div class="section" id="for-of">
<h2>16.7. for…of 循环<a class="headerlink" href="#for-of" title="永久链接至标题">¶</a></h2>
<p>ES6 借鉴 <code class="docutils literal"><span class="pre">C++</span></code> 、 <code class="docutils literal"><span class="pre">Java</span></code> 、 <code class="docutils literal"><span class="pre">C#</span></code> 和 <code class="docutils literal"><span class="pre">Python</span></code> 语言，引入了 <code class="docutils literal"><span class="pre">for...of</span></code> 循环，作为遍历所有数据结构的统一的方法。</p>
<p>一个数据结构只要部署了`` Symbol.iterator`` 属性，就被视为具有 <code class="docutils literal"><span class="pre">iterator</span></code> 接口，就可以用 <code class="docutils literal"><span class="pre">for...of</span></code> 循环遍历它的成员。也就是说， <code class="docutils literal"><span class="pre">for...of</span></code> 循环内部调用的是数据结构的 <code class="docutils literal"><span class="pre">Symbol.iterator</span></code> 方法。</p>
<p><code class="docutils literal"><span class="pre">for...of</span></code> 循环可以使用的范围包括数组、 <code class="docutils literal"><span class="pre">Set</span></code> 和 <code class="docutils literal"><span class="pre">Map</span></code> 结构、某些类似数组的对象（比如 <code class="docutils literal"><span class="pre">arguments</span></code> 对象、 <code class="docutils literal"><span class="pre">DOM</span> <span class="pre">NodeList</span></code> 对象）、后文的 <code class="docutils literal"><span class="pre">Generator</span></code> 对象，以及字符串。</p>
<div class="section" id="id4">
<h3>16.7.1. 数组<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<p>数组原生具备 <code class="docutils literal"><span class="pre">iterator</span></code> 接口（即默认部署了 <code class="docutils literal"><span class="pre">Symbol.iterator</span></code> 属性）， <code class="docutils literal"><span class="pre">for...of</span></code> 循环本质上就是调用这个接口产生的遍历器，可以用下面的代码证明。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="s1">&#39;blue&#39;</span><span class="p">];</span>

<span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">v</span> <span class="k">of</span> <span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span> <span class="c1">// red green blue</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nx">obj</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">].</span><span class="nx">bind</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span>

<span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">v</span> <span class="k">of</span> <span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span> <span class="c1">// red green blue</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码中，空对象 <code class="docutils literal"><span class="pre">obj</span></code> 部署了数组 <code class="docutils literal"><span class="pre">arr</span></code> 的 <code class="docutils literal"><span class="pre">Symbol.iterator</span></code> 属性，结果 <code class="docutils literal"><span class="pre">obj</span></code> 的 <code class="docutils literal"><span class="pre">for...of</span></code> 循环，产生了与 <code class="docutils literal"><span class="pre">arr</span></code> 完全一样的结果。</p>
<p><code class="docutils literal"><span class="pre">for...of</span></code> 循环可以代替数组实例的 <code class="docutils literal"><span class="pre">forEach</span></code> 方法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="s1">&#39;blue&#39;</span><span class="p">];</span>

<span class="nx">arr</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">element</span><span class="p">);</span> <span class="c1">// red green blue</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">index</span><span class="p">);</span>   <span class="c1">// 0 1 2</span>
<span class="p">});</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">JavaScript</span></code> 原有的 <code class="docutils literal"><span class="pre">for...in</span></code> 循环，只能获得对象的键名，不能直接获取键值。ES6 提供 <code class="docutils literal"><span class="pre">for...of</span></code> 循环，允许遍历获得键值。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">];</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">a</span> <span class="k">in</span> <span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="c1">// 0 1 2 3</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">a</span> <span class="k">of</span> <span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="c1">// a b c d</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码表明， <code class="docutils literal"><span class="pre">for...in</span></code> 循环读取键名， <code class="docutils literal"><span class="pre">for...of</span></code> 循环读取键值。如果要通过 <code class="docutils literal"><span class="pre">for...of</span></code> 循环，获取数组的索引，可以借助数组实例的 <code class="docutils literal"><span class="pre">entries</span></code> 方法和 <code class="docutils literal"><span class="pre">keys</span></code> 方法（参见《数组的扩展》一章）。</p>
<p><code class="docutils literal"><span class="pre">for...of</span></code> 循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟 <code class="docutils literal"><span class="pre">for...in</span></code> 循环也不一样。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">];</span>
<span class="nx">arr</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="s1">&#39;hello&#39;</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="k">in</span> <span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span> <span class="c1">// &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot;</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="k">of</span> <span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span> <span class="c1">//  &quot;3&quot;, &quot;5&quot;, &quot;7&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">for...of</span></code> 循环不会返回数组 <code class="docutils literal"><span class="pre">arr</span></code> 的 <code class="docutils literal"><span class="pre">foo</span></code> 属性。</p>
</div>
<div class="section" id="set-map">
<h3>16.7.2. Set 和 Map 结构<a class="headerlink" href="#set-map" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal"><span class="pre">Set</span></code> 和 <code class="docutils literal"><span class="pre">Map</span></code> 结构也原生具有 <code class="docutils literal"><span class="pre">Iterator</span></code> 接口，可以直接使用 <code class="docutils literal"><span class="pre">for...of</span></code> 循环。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">engines</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([</span><span class="s2">&quot;Gecko&quot;</span><span class="p">,</span> <span class="s2">&quot;Trident&quot;</span><span class="p">,</span> <span class="s2">&quot;Webkit&quot;</span><span class="p">,</span> <span class="s2">&quot;Webkit&quot;</span><span class="p">]);</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">e</span> <span class="k">of</span> <span class="nx">engines</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// Gecko</span>
<span class="c1">// Trident</span>
<span class="c1">// Webkit</span>

<span class="kd">var</span> <span class="nx">es6</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">();</span>
<span class="nx">es6</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s2">&quot;edition&quot;</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
<span class="nx">es6</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s2">&quot;committee&quot;</span><span class="p">,</span> <span class="s2">&quot;TC39&quot;</span><span class="p">);</span>
<span class="nx">es6</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s2">&quot;standard&quot;</span><span class="p">,</span> <span class="s2">&quot;ECMA-262&quot;</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="p">[</span><span class="nx">name</span><span class="p">,</span> <span class="nx">value</span><span class="p">]</span> <span class="k">of</span> <span class="nx">es6</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">name</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// edition: 6</span>
<span class="c1">// committee: TC39</span>
<span class="c1">// standard: ECMA-262</span>
</pre></div>
</div>
<p>上面代码演示了如何遍历 <code class="docutils literal"><span class="pre">Set</span></code> 结构和 <code class="docutils literal"><span class="pre">Map</span></code> 结构。值得注意的地方有两个，首先，遍历的顺序是按照各个成员被添加进数据结构的顺序。其次， <code class="docutils literal"><span class="pre">Set</span></code> 结构遍历时，返回的是一个值，而 <code class="docutils literal"><span class="pre">Map</span></code> 结构遍历时，返回的是一个数组，该数组的两个成员分别为当前 <code class="docutils literal"><span class="pre">Map</span></code> 成员的键名和键值。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">().</span><span class="nx">set</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">).</span><span class="nx">set</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">pair</span> <span class="k">of</span> <span class="nx">map</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">pair</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// [&#39;a&#39;, 1]</span>
<span class="c1">// [&#39;b&#39;, 2]</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">]</span> <span class="k">of</span> <span class="nx">map</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">key</span> <span class="o">+</span> <span class="s1">&#39; : &#39;</span> <span class="o">+</span> <span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// a : 1</span>
<span class="c1">// b : 2</span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h3>16.7.3. 计算生成的数据结构<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<p>有些数据结构是在现有数据结构的基础上，计算生成的。比如，ES6 的数组、 <code class="docutils literal"><span class="pre">Set</span></code> 、 <code class="docutils literal"><span class="pre">Map</span></code> 都部署了以下三个方法，调用后都返回遍历器对象。</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">entries()</span></code> 返回一个遍历器对象，用来遍历 <code class="docutils literal"><span class="pre">[键名,</span> <span class="pre">键值]</span></code> 组成的数组。对于数组，键名就是索引值；对于 <code class="docutils literal"><span class="pre">Set</span></code> ，键名与键值相同。 <code class="docutils literal"><span class="pre">Map</span></code> 结构的 <code class="docutils literal"><span class="pre">Iterator</span></code> 接口，默认就是调用 <code class="docutils literal"><span class="pre">entries</span></code> 方法。</li>
<li><code class="docutils literal"><span class="pre">keys()</span></code> 返回一个遍历器对象，用来遍历所有的键名。</li>
<li><code class="docutils literal"><span class="pre">values()</span></code> 返回一个遍历器对象，用来遍历所有的键值。</li>
</ul>
<p>这三个方法调用后生成的遍历器对象，所遍历的都是计算生成的数据结构。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">];</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">pair</span> <span class="k">of</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">entries</span><span class="p">())</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">pair</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// [0, &#39;a&#39;]</span>
<span class="c1">// [1, &#39;b&#39;]</span>
<span class="c1">// [2, &#39;c&#39;]</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h3>16.7.4. 类似数组的对象<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<p>类似数组的对象包括好几类。下面是 <code class="docutils literal"><span class="pre">for...of</span></code> 循环用于字符串、 <code class="docutils literal"><span class="pre">DOM</span> <span class="pre">NodeList</span></code>  对象、 <code class="docutils literal"><span class="pre">arguments</span></code> 对象的例子。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// 字符串</span>
<span class="kd">let</span> <span class="nx">str</span> <span class="o">=</span> <span class="s2">&quot;hello&quot;</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">s</span> <span class="k">of</span> <span class="nx">str</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span> <span class="c1">// h e l l o</span>
<span class="p">}</span>

<span class="c1">// DOM NodeList对象</span>
<span class="kd">let</span> <span class="nx">paras</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">);</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">p</span> <span class="k">of</span> <span class="nx">paras</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">p</span><span class="p">.</span><span class="nx">classList</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="s2">&quot;test&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// arguments对象</span>
<span class="kd">function</span> <span class="nx">printArgs</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="k">of</span> <span class="nx">arguments</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="nx">printArgs</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">);</span>
<span class="c1">// &#39;a&#39;</span>
<span class="c1">// &#39;b&#39;</span>
</pre></div>
</div>
<p>对于字符串来说， <code class="docutils literal"><span class="pre">for...of</span></code> 循环还有一个特点，就是会正确识别 32 位 UTF-16 字符。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="k">of</span> <span class="s1">&#39;a\uD83D\uDC0A&#39;</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// &#39;a&#39;</span>
<span class="c1">// &#39;\uD83D\uDC0A&#39;</span>
</pre></div>
</div>
<p>并不是所有类似数组的对象都具有 <code class="docutils literal"><span class="pre">Iterator</span></code> 接口，一个简便的解决方法，就是使用 <code class="docutils literal"><span class="pre">Array.from</span></code> 方法将其转为数组。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">arrayLike</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">length</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="o">:</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="o">:</span> <span class="s1">&#39;b&#39;</span> <span class="p">};</span>

<span class="c1">// 报错</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="k">of</span> <span class="nx">arrayLike</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 正确</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="k">of</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">(</span><span class="nx">arrayLike</span><span class="p">))</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h3>16.7.5. 对象<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h3>
<p>对于普通的对象， <code class="docutils literal"><span class="pre">for...of</span></code> 结构不能直接使用，会报错，必须部署了 <code class="docutils literal"><span class="pre">Iterator</span></code> 接口后才能使用。但是，这样情况下， <code class="docutils literal"><span class="pre">for...in</span></code> 循环依然可以用来遍历键名。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">es6</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">edition</span><span class="o">:</span> <span class="mi">6</span><span class="p">,</span>
  <span class="nx">committee</span><span class="o">:</span> <span class="s2">&quot;TC39&quot;</span><span class="p">,</span>
  <span class="nx">standard</span><span class="o">:</span> <span class="s2">&quot;ECMA-262&quot;</span>
<span class="p">};</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">e</span> <span class="k">in</span> <span class="nx">es6</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// edition</span>
<span class="c1">// committee</span>
<span class="c1">// standard</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">e</span> <span class="k">of</span> <span class="nx">es6</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// TypeError: es6[Symbol.iterator] is not a function</span>
</pre></div>
</div>
<p>上面代码表示，对于普通的对象， <code class="docutils literal"><span class="pre">for...in</span></code> 循环可以遍历键名， <code class="docutils literal"><span class="pre">for...of</span></code> 循环会报错。</p>
<p>一种解决方法是，使用 <code class="docutils literal"><span class="pre">Object.keys</span></code> 方法将对象的键名生成一个数组，然后遍历这个数组。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">key</span> <span class="k">of</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">someObject</span><span class="p">))</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">key</span> <span class="o">+</span> <span class="s1">&#39;: &#39;</span> <span class="o">+</span> <span class="nx">someObject</span><span class="p">[</span><span class="nx">key</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>另一个方法是使用 <code class="docutils literal"><span class="pre">Generator</span></code> 函数将对象重新包装一下。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">entries</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">key</span> <span class="k">of</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">obj</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">yield</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">key</span><span class="p">]];</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">]</span> <span class="k">of</span> <span class="nx">entries</span><span class="p">(</span><span class="nx">obj</span><span class="p">))</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="s1">&#39;-&gt;&#39;</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// a -&gt; 1</span>
<span class="c1">// b -&gt; 2</span>
<span class="c1">// c -&gt; 3</span>
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h3>16.7.6. 与其他遍历语法的比较<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h3>
<p>以数组为例， <code class="docutils literal"><span class="pre">JavaScript</span></code> 提供多种遍历语法。最原始的写法就是 <code class="docutils literal"><span class="pre">for</span></code> 循环。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">index</span> <span class="o">&lt;</span> <span class="nx">myArray</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">myArray</span><span class="p">[</span><span class="nx">index</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这种写法比较麻烦，因此数组提供内置的 <code class="docutils literal"><span class="pre">forEach</span></code> 方法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">myArray</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>
</div>
<p>这种写法的问题在于，无法中途跳出 <code class="docutils literal"><span class="pre">forEach</span></code> 循环， <code class="docutils literal"><span class="pre">break</span></code> 命令或 <code class="docutils literal"><span class="pre">return</span></code> 命令都不能奏效。</p>
<p><code class="docutils literal"><span class="pre">for...in</span></code> 循环可以遍历数组的键名。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">index</span> <span class="k">in</span> <span class="nx">myArray</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">myArray</span><span class="p">[</span><span class="nx">index</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">for...in</span></code> 循环有几个缺点。</p>
<ul class="simple">
<li>数组的键名是数字，但是 <code class="docutils literal"><span class="pre">for...in</span></code> 循环是以字符串作为键名“0”、“1”、“2”等等。</li>
<li><code class="docutils literal"><span class="pre">for...in</span></code> 循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。</li>
<li>某些情况下， <code class="docutils literal"><span class="pre">for...in</span></code> 循环会以任意顺序遍历键名。</li>
</ul>
<p>总之， <code class="docutils literal"><span class="pre">for...in</span></code> 循环主要是为遍历对象而设计的，不适用于遍历数组。</p>
<p><code class="docutils literal"><span class="pre">for...of</span></code> 循环相比上面几种做法，有一些显著的优点。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">value</span> <span class="k">of</span> <span class="nx">myArray</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li>有着同 <code class="docutils literal"><span class="pre">for...in</span></code> 一样的简洁语法，但是没有 <code class="docutils literal"><span class="pre">for...in</span></code> 那些缺点。</li>
<li>不同于 <code class="docutils literal"><span class="pre">forEach</span></code> 方法，它可以与 <code class="docutils literal"><span class="pre">break</span></code> 、 <code class="docutils literal"><span class="pre">continue</span></code> 和 <code class="docutils literal"><span class="pre">return</span></code> 配合使用。</li>
<li>提供了遍历所有数据结构的统一操作接口。</li>
</ul>
<p>下面是一个使用 <code class="docutils literal"><span class="pre">break</span></code> 语句，跳出 <code class="docutils literal"><span class="pre">for...of</span></code> 循环的例子。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">n</span> <span class="k">of</span> <span class="nx">fibonacci</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="p">)</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">n</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的例子，会输出斐波纳契数列小于等于 1000 的项。如果当前项大于 1000，就会使用 <code class="docutils literal"><span class="pre">break</span></code> 语句跳出 <code class="docutils literal"><span class="pre">for...of</span></code> 循环。</p>
</div>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Generator函数的语法.html" class="btn btn-neutral float-right" title="17. Generator函数的语法" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="Promise对象.html" class="btn btn-neutral" title="15. Promise对象" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, lzh.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.0',
            LANGUAGE:'zh_CN',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="_static/translations.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();

      });


      $(document).ready(function(){
        var offset = sessionStorage.getItem("offsetTop");
        $('.wy-side-scroll').scrollTop(offset);
        sessionStorage.setItem("offsetTop", 0);


        $('.wy-menu > ul').click(function(){
            sessionStorage.setItem("offsetTop", $('.wy-side-scroll').scrollTop());
        });
      })

  </script>
   

</body>
</html>