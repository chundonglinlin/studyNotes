

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>12. Set和Map数据结构 &mdash; ECMAScript6入门 1.0 文档</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="索引"
              href="genindex.html"/>
        <link rel="search" title="搜索" href="search.html"/>
    <link rel="top" title="ECMAScript6入门 1.0 文档" href="index.html"/>
        <link rel="next" title="13. Proxy" href="Proxy.html"/>
        <link rel="prev" title="11. Symbol" href="Symbol.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> ECMAScript6入门
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="前言.html">1. 前言</a></li>
<li class="toctree-l1"><a class="reference internal" href="ECMAScript6简介.html">2. ECMAScript6简介</a></li>
<li class="toctree-l1"><a class="reference internal" href="let和const命令.html">3. let 和 const 命令</a></li>
<li class="toctree-l1"><a class="reference internal" href="变量的解构赋值.html">4. 变量的解构赋值</a></li>
<li class="toctree-l1"><a class="reference internal" href="字符串的扩展.html">5. 字符串的扩展</a></li>
<li class="toctree-l1"><a class="reference internal" href="正则的扩展.html">6. 正则的扩展</a></li>
<li class="toctree-l1"><a class="reference internal" href="数值的扩展.html">7. 数值的扩展</a></li>
<li class="toctree-l1"><a class="reference internal" href="函数的扩展.html">8. 函数的扩展</a></li>
<li class="toctree-l1"><a class="reference internal" href="数组的扩展.html">9. 数组的扩展</a></li>
<li class="toctree-l1"><a class="reference internal" href="对象的扩展.html">10. 对象的扩展</a></li>
<li class="toctree-l1"><a class="reference internal" href="Symbol.html">11. Symbol</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">12. Set和Map数据结构</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#set">12.1. Set</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">12.1.1. 基本用法</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">12.1.2. Set 实例的属性和方法</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">12.1.3. 遍历操作</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#weakset">12.2. WeakSet</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id4">12.2.1. 含义</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">12.2.2. 语法</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#map">12.3. Map</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id6">12.3.1. 含义和基本用法</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id7">12.3.2. 实例的属性和操作方法</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id8">12.3.3. 遍历方法</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id9">12.3.4. 与其他数据结构的互相转换</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#weakmap">12.4. WeakMap</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id10">12.4.1. 含义</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id11">12.4.2. WeakMap 的语法</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id12">12.4.3. WeakMap 的示例</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id13">12.4.4. WeakMap 的用途</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Proxy.html">13. Proxy</a></li>
<li class="toctree-l1"><a class="reference internal" href="Reflect.html">14. Reflect</a></li>
<li class="toctree-l1"><a class="reference internal" href="Promise对象.html">15. Promise对象</a></li>
<li class="toctree-l1"><a class="reference internal" href="Iterator和for...of循环.html">16. Iterator 和 for…of 循环</a></li>
<li class="toctree-l1"><a class="reference internal" href="Generator函数的语法.html">17. Generator函数的语法</a></li>
<li class="toctree-l1"><a class="reference internal" href="Generator函数的异步应用.html">18. Generator 函数的异步应用</a></li>
<li class="toctree-l1"><a class="reference internal" href="async函数.html">19. asyn函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="Class的基本语法.html">20. Class 的基本语法</a></li>
<li class="toctree-l1"><a class="reference internal" href="Class的继承.html">21. Class的继承</a></li>
<li class="toctree-l1"><a class="reference internal" href="Decorator.html">22. 修饰器</a></li>
<li class="toctree-l1"><a class="reference internal" href="Module的语法.html">23. Module 的语法</a></li>
<li class="toctree-l1"><a class="reference internal" href="Module的加载实现.html">24. Module 的加载实现</a></li>
<li class="toctree-l1"><a class="reference internal" href="编程风格.html">25. 编程风格</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">ECMAScript6入门</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>12. Set和Map数据结构</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="setmap">
<h1>12. Set和Map数据结构<a class="headerlink" href="#setmap" title="永久链接至标题">¶</a></h1>
<div class="section" id="set">
<h2>12.1. Set<a class="headerlink" href="#set" title="永久链接至标题">¶</a></h2>
<div class="section" id="id1">
<h3>12.1.1. 基本用法<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<p>ES6 提供了新的数据结构 <code class="docutils literal"><span class="pre">Set</span></code> 。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>
<p><code class="docutils literal"><span class="pre">Set</span></code> 本身是一个构造函数，用来生成 <code class="docutils literal"><span class="pre">Set</span></code> 数据结构。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">s</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">();</span>

<span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">].</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">x</span> <span class="p">=&gt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">x</span><span class="p">));</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="k">of</span> <span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 2 3 5 4</span>
</pre></div>
</div>
<p>上面代码通过 <code class="docutils literal"><span class="pre">add</span></code> 方法向 <code class="docutils literal"><span class="pre">Set</span></code> 结构加入成员，结果表明 <code class="docutils literal"><span class="pre">Set</span></code> 结构不会添加重复的值。</p>
<p><code class="docutils literal"><span class="pre">Set</span></code> 函数可以接受一个数组（或者具有 <code class="docutils literal"><span class="pre">iterable</span></code> 接口的其他数据结构）作为参数，用来初始化。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// 例一</span>
<span class="kr">const</span> <span class="nx">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]);</span>
<span class="p">[...</span><span class="nx">set</span><span class="p">]</span>
<span class="c1">// [1, 2, 3, 4]</span>

<span class="c1">// 例二</span>
<span class="kr">const</span> <span class="nx">items</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">]);</span>
<span class="nx">items</span><span class="p">.</span><span class="nx">size</span> <span class="c1">// 5</span>

<span class="c1">// 例三</span>
<span class="kr">const</span> <span class="nx">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="s1">&#39;div&#39;</span><span class="p">));</span>
<span class="nx">set</span><span class="p">.</span><span class="nx">size</span> <span class="c1">// 56</span>

<span class="c1">// 类似于</span>
<span class="kr">const</span> <span class="nx">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">();</span>
<span class="nb">document</span>
 <span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="s1">&#39;div&#39;</span><span class="p">)</span>
 <span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">div</span> <span class="p">=&gt;</span> <span class="nx">set</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">div</span><span class="p">));</span>
<span class="nx">set</span><span class="p">.</span><span class="nx">size</span> <span class="c1">// 56</span>
</pre></div>
</div>
<p>上面代码中，例一和例二都是 <code class="docutils literal"><span class="pre">Set</span></code> 函数接受数组作为参数，例三是接受类似数组的对象作为参数。</p>
<p>上面代码也展示了一种去除数组重复成员的方法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// 去除数组的重复成员</span>
<span class="p">[...</span><span class="k">new</span> <span class="nx">Set</span><span class="p">(</span><span class="nx">array</span><span class="p">)]</span>
</pre></div>
</div>
<p>向 <code class="docutils literal"><span class="pre">Set</span></code> 加入值的时候，不会发生类型转换，所以 5 和 “5” 是两个不同的值。 <code class="docutils literal"><span class="pre">Set</span></code>  内部判断两个值是否不同，使用的算法叫做 <code class="docutils literal"><span class="pre">Same-value-zero</span> <span class="pre">equality</span></code> ，它类似于精确相等运算符（ <code class="docutils literal"><span class="pre">===</span></code> ），主要的区别是 <code class="docutils literal"><span class="pre">NaN</span></code> 等于自身，而精确相等运算符认为 <code class="docutils literal"><span class="pre">NaN</span></code> 不等于自身。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">();</span>
<span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="kc">NaN</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="kc">NaN</span><span class="p">;</span>
<span class="nx">set</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
<span class="nx">set</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span>
<span class="nx">set</span> <span class="c1">// Set {NaN}</span>
</pre></div>
</div>
<p>上面代码向 <code class="docutils literal"><span class="pre">Set</span></code> 实例添加了两个 <code class="docutils literal"><span class="pre">NaN</span></code> ，但是只能加入一个。这表明，在 <code class="docutils literal"><span class="pre">Set</span></code> 内部，两个 <code class="docutils literal"><span class="pre">NaN</span></code> 是相等。</p>
<p>另外，两个对象总是不相等的。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">();</span>

<span class="nx">set</span><span class="p">.</span><span class="nx">add</span><span class="p">({});</span>
<span class="nx">set</span><span class="p">.</span><span class="nx">size</span> <span class="c1">// 1</span>

<span class="nx">set</span><span class="p">.</span><span class="nx">add</span><span class="p">({});</span>
<span class="nx">set</span><span class="p">.</span><span class="nx">size</span> <span class="c1">// 2</span>
</pre></div>
</div>
<p>上面代码表示，由于两个空对象不相等，所以它们被视为两个值。</p>
</div>
<div class="section" id="id2">
<h3>12.1.2. Set 实例的属性和方法<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal"><span class="pre">Set</span></code> 结构的实例有以下属性。</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">Set.prototype.constructor</span></code> ：构造函数，默认就是 <code class="docutils literal"><span class="pre">Set</span></code> 函数。</li>
<li><code class="docutils literal"><span class="pre">Set.prototype.size</span></code> ：返回 <code class="docutils literal"><span class="pre">Set</span></code> 实例的成员总数。</li>
</ul>
<p><code class="docutils literal"><span class="pre">Set</span></code> 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">add(value)</span></code> ：添加某个值，返回 <code class="docutils literal"><span class="pre">Set</span></code> 结构本身。</li>
<li><code class="docutils literal"><span class="pre">delete(value)</span></code> ：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li><code class="docutils literal"><span class="pre">has(value)</span></code> ：返回一个布尔值，表示该值是否为 <code class="docutils literal"><span class="pre">Set</span></code> 的成员。</li>
<li><code class="docutils literal"><span class="pre">clear()</span></code> ：清除所有成员，没有返回值。</li>
</ul>
<p>上面这些属性和方法的实例如下。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">s</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nx">add</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nx">add</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="c1">// 注意2被加入了两次</span>

<span class="nx">s</span><span class="p">.</span><span class="nx">size</span> <span class="c1">// 2</span>

<span class="nx">s</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nx">s</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nx">s</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1">// false</span>

<span class="nx">s</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="nx">s</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// false</span>
</pre></div>
</div>
<p>下面是一个对比，看看在判断是否包括一个键上面， <code class="docutils literal"><span class="pre">Object</span></code> 结构和 <code class="docutils literal"><span class="pre">Set</span></code> 结构的写法不同。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// 对象的写法</span>
<span class="kr">const</span> <span class="nx">properties</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s1">&#39;width&#39;</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="s1">&#39;height&#39;</span><span class="o">:</span> <span class="mi">1</span>
<span class="p">};</span>

<span class="k">if</span> <span class="p">(</span><span class="nx">properties</span><span class="p">[</span><span class="nx">someName</span><span class="p">])</span> <span class="p">{</span>
  <span class="c1">// do something</span>
<span class="p">}</span>

<span class="c1">// Set的写法</span>
<span class="kr">const</span> <span class="nx">properties</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">();</span>

<span class="nx">properties</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="s1">&#39;width&#39;</span><span class="p">);</span>
<span class="nx">properties</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="nx">properties</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">someName</span><span class="p">))</span> <span class="p">{</span>
  <span class="c1">// do something</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">Array.from</span></code> 方法可以将 <code class="docutils literal"><span class="pre">Set</span></code> 结构转为数组。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">items</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]);</span>
<span class="kr">const</span> <span class="nx">array</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">(</span><span class="nx">items</span><span class="p">);</span>
</pre></div>
</div>
<p>这就提供了去除数组重复成员的另一种方法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">dedupe</span><span class="p">(</span><span class="nx">array</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">(</span><span class="k">new</span> <span class="nx">Set</span><span class="p">(</span><span class="nx">array</span><span class="p">));</span>
<span class="p">}</span>

<span class="nx">dedupe</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="c1">// [1, 2, 3]</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h3>12.1.3. 遍历操作<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal"><span class="pre">Set</span></code> 结构的实例有四个遍历方法，可以用于遍历成员。</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">keys()</span></code> ：返回键名的遍历器</li>
<li><code class="docutils literal"><span class="pre">values()</span></code> ：返回键值的遍历器</li>
<li><code class="docutils literal"><span class="pre">entries()</span></code> ：返回键值对的遍历器</li>
<li><code class="docutils literal"><span class="pre">forEach()</span></code> ：使用回调函数遍历每个成员</li>
</ul>
<p>需要特别指出的是， <code class="docutils literal"><span class="pre">Set</span></code> 的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 <code class="docutils literal"><span class="pre">Set</span></code> 保存一个回调函数列表，调用时就能保证按照添加顺序调用。</p>
<ol class="arabic simple">
<li>keys()，values()，entries()</li>
</ol>
<p><code class="docutils literal"><span class="pre">keys</span></code> 方法、 <code class="docutils literal"><span class="pre">values</span></code> 方法、 <code class="docutils literal"><span class="pre">entries</span></code> 方法返回的都是遍历器对象（详见《 <code class="docutils literal"><span class="pre">Iterator</span></code> 对象》一章）。由于 <code class="docutils literal"><span class="pre">Set</span></code> 结构没有键名，只有键值（或者说键名和键值是同一个值），所以 <code class="docutils literal"><span class="pre">keys</span></code> 方法和 <code class="docutils literal"><span class="pre">values</span></code> 方法的行为完全一致。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="s1">&#39;blue&#39;</span><span class="p">]);</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">item</span> <span class="k">of</span> <span class="nx">set</span><span class="p">.</span><span class="nx">keys</span><span class="p">())</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// red</span>
<span class="c1">// green</span>
<span class="c1">// blue</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">item</span> <span class="k">of</span> <span class="nx">set</span><span class="p">.</span><span class="nx">values</span><span class="p">())</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// red</span>
<span class="c1">// green</span>
<span class="c1">// blue</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">item</span> <span class="k">of</span> <span class="nx">set</span><span class="p">.</span><span class="nx">entries</span><span class="p">())</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// [&quot;red&quot;, &quot;red&quot;]</span>
<span class="c1">// [&quot;green&quot;, &quot;green&quot;]</span>
<span class="c1">// [&quot;blue&quot;, &quot;blue&quot;]</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">entries</span></code> 方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。</p>
<p><code class="docutils literal"><span class="pre">Set</span></code> 结构的实例默认可遍历，它的默认遍历器生成函数就是它的 <code class="docutils literal"><span class="pre">values</span></code> 方法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">Set</span><span class="p">.</span><span class="nx">prototype</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]</span> <span class="o">===</span> <span class="nx">Set</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">values</span> <span class="c1">// true</span>
</pre></div>
</div>
<p>这意味着，可以省略 <code class="docutils literal"><span class="pre">values</span></code> 方法，直接用 <code class="docutils literal"><span class="pre">for...of</span></code> 循环遍历 <code class="docutils literal"><span class="pre">Set</span></code> 。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="s1">&#39;blue&#39;</span><span class="p">]);</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="k">of</span> <span class="nx">set</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// red</span>
<span class="c1">// green</span>
<span class="c1">// blue</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li>forEach()</li>
</ol>
<p><code class="docutils literal"><span class="pre">Set</span></code>  结构的实例与数组一样，也拥有 <code class="docutils literal"><span class="pre">forEach</span></code> 方法，用于对每个成员执行某种操作，没有返回值。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">]);</span>
<span class="nx">set</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">value</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">key</span> <span class="o">+</span> <span class="s1">&#39; : &#39;</span> <span class="o">+</span> <span class="nx">value</span><span class="p">))</span>
<span class="c1">// 1 : 1</span>
<span class="c1">// 4 : 4</span>
<span class="c1">// 9 : 9</span>
</pre></div>
</div>
<p>上面代码说明， <code class="docutils literal"><span class="pre">forEach</span></code> 方法的参数就是一个处理函数。该函数的参数与数组的 <code class="docutils literal"><span class="pre">forEach</span></code> 一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意， <code class="docutils literal"><span class="pre">Set</span></code>  结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。</p>
<p>另外， <code class="docutils literal"><span class="pre">forEach</span></code> 方法还可以有第二个参数，表示绑定处理函数内部的 <code class="docutils literal"><span class="pre">this</span></code> 对象。</p>
<ol class="arabic simple" start="3">
<li>遍历的应用</li>
</ol>
<p>扩展运算符（ <code class="docutils literal"><span class="pre">...</span></code> ）内部使用 <code class="docutils literal"><span class="pre">for...of</span></code> 循环，所以也可以用于 <code class="docutils literal"><span class="pre">Set</span></code> 结构。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="s1">&#39;blue&#39;</span><span class="p">]);</span>
<span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">set</span><span class="p">];</span>
<span class="c1">// [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]</span>
</pre></div>
</div>
<p>扩展运算符和 <code class="docutils literal"><span class="pre">Set</span></code> 结构相结合，就可以去除数组的重复成员。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">unique</span> <span class="o">=</span> <span class="p">[...</span><span class="k">new</span> <span class="nx">Set</span><span class="p">(</span><span class="nx">arr</span><span class="p">)];</span>
<span class="c1">// [3, 5, 2]</span>
</pre></div>
</div>
<p>而且，数组的 <code class="docutils literal"><span class="pre">map</span></code> 和 <code class="docutils literal"><span class="pre">filter</span></code> 方法也可以间接用于 <code class="docutils literal"><span class="pre">Set</span></code> 了。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span>
<span class="nx">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([...</span><span class="nx">set</span><span class="p">].</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="p">=&gt;</span> <span class="nx">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">));</span>
<span class="c1">// 返回Set结构：{2, 4, 6}</span>

<span class="kd">let</span> <span class="nx">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]);</span>
<span class="nx">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([...</span><span class="nx">set</span><span class="p">].</span><span class="nx">filter</span><span class="p">(</span><span class="nx">x</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="nx">x</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">));</span>
<span class="c1">// 返回Set结构：{2, 4}</span>
</pre></div>
</div>
<p>因此使用 <code class="docutils literal"><span class="pre">Set</span></code> 可以很容易地实现并集（ <code class="docutils literal"><span class="pre">Union</span></code> ）、交集（ <code class="docutils literal"><span class="pre">Intersect</span></code> ）和差集（ <code class="docutils literal"><span class="pre">Difference</span></code> ）。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span>
<span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]);</span>

<span class="c1">// 并集</span>
<span class="kd">let</span> <span class="nx">union</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([...</span><span class="nx">a</span><span class="p">,</span> <span class="p">...</span><span class="nx">b</span><span class="p">]);</span>
<span class="c1">// Set {1, 2, 3, 4}</span>

<span class="c1">// 交集</span>
<span class="kd">let</span> <span class="nx">intersect</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([...</span><span class="nx">a</span><span class="p">].</span><span class="nx">filter</span><span class="p">(</span><span class="nx">x</span> <span class="p">=&gt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">x</span><span class="p">)));</span>
<span class="c1">// set {2, 3}</span>

<span class="c1">// 差集</span>
<span class="kd">let</span> <span class="nx">difference</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([...</span><span class="nx">a</span><span class="p">].</span><span class="nx">filter</span><span class="p">(</span><span class="nx">x</span> <span class="p">=&gt;</span> <span class="o">!</span><span class="nx">b</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">x</span><span class="p">)));</span>
<span class="c1">// Set {1}</span>
</pre></div>
</div>
<p>如果想在遍历操作中，同步改变原来的 <code class="docutils literal"><span class="pre">Set</span></code> 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 <code class="docutils literal"><span class="pre">Set</span></code> 结构映射出一个新的结构，然后赋值给原来的 <code class="docutils literal"><span class="pre">Set</span></code> 结构；另一种是利用 <code class="docutils literal"><span class="pre">Array.from</span></code> 方法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// 方法一</span>
<span class="kd">let</span> <span class="nx">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span>
<span class="nx">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([...</span><span class="nx">set</span><span class="p">].</span><span class="nx">map</span><span class="p">(</span><span class="nx">val</span> <span class="p">=&gt;</span> <span class="nx">val</span> <span class="o">*</span> <span class="mi">2</span><span class="p">));</span>
<span class="c1">// set的值是2, 4, 6</span>

<span class="c1">// 方法二</span>
<span class="kd">let</span> <span class="nx">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span>
<span class="nx">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">(</span><span class="nx">set</span><span class="p">,</span> <span class="nx">val</span> <span class="p">=&gt;</span> <span class="nx">val</span> <span class="o">*</span> <span class="mi">2</span><span class="p">));</span>
<span class="c1">// set的值是2, 4, 6</span>
</pre></div>
</div>
<p>上面代码提供了两种方法，直接在遍历操作中改变原来的 <code class="docutils literal"><span class="pre">Set</span></code> 结构。</p>
</div>
</div>
<div class="section" id="weakset">
<h2>12.2. WeakSet<a class="headerlink" href="#weakset" title="永久链接至标题">¶</a></h2>
<div class="section" id="id4">
<h3>12.2.1. 含义<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal"><span class="pre">WeakSet</span></code> 结构与 <code class="docutils literal"><span class="pre">Set</span></code> 类似，也是不重复的值的集合。但是，它与 <code class="docutils literal"><span class="pre">Set</span></code> 有两个区别。</p>
<p>首先， <code class="docutils literal"><span class="pre">WeakSet</span></code> 的成员只能是对象，而不能是其他类型的值。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">ws</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WeakSet</span><span class="p">();</span>
<span class="nx">ws</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="c1">// TypeError: Invalid value used in weak set</span>
<span class="nx">ws</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">Symbol</span><span class="p">())</span>
<span class="c1">// TypeError: invalid value used in weak set</span>
</pre></div>
</div>
<p>上面代码试图向 <code class="docutils literal"><span class="pre">WeakSet</span></code> 添加一个数值和 <code class="docutils literal"><span class="pre">Symbol</span></code> 值，结果报错，因为 <code class="docutils literal"><span class="pre">WeakSet</span></code> 只能放置对象。</p>
<p>其次， <code class="docutils literal"><span class="pre">WeakSet</span></code> 中的对象都是弱引用，即垃圾回收机制不考虑 <code class="docutils literal"><span class="pre">WeakSet</span></code> 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 <code class="docutils literal"><span class="pre">WeakSet</span></code> 之中。</p>
<p>这是因为垃圾回收机制依赖引用计数，如果一个值的引用次数不为 0 ，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。 <code class="docutils literal"><span class="pre">WeakSet</span></code>  里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。因此， <code class="docutils literal"><span class="pre">WeakSet</span></code>  适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 <code class="docutils literal"><span class="pre">WeakSet</span></code> 里面的引用就会自动消失。</p>
<p>由于上面这个特点， <code class="docutils literal"><span class="pre">WeakSet</span></code> 的成员是不适合引用的，因为它会随时消失。另外，由于 <code class="docutils literal"><span class="pre">WeakSet</span></code> 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 <code class="docutils literal"><span class="pre">WeakSet</span></code> 不可遍历。</p>
<p>这些特点同样适用于本章后面要介绍的 <code class="docutils literal"><span class="pre">WeakMap</span></code> 结构。</p>
</div>
<div class="section" id="id5">
<h3>12.2.2. 语法<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal"><span class="pre">WeakSet</span></code> 是一个构造函数，可以使用 <code class="docutils literal"><span class="pre">new</span></code> 命令，创建 <code class="docutils literal"><span class="pre">WeakSet</span></code> 数据结构。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">ws</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WeakSet</span><span class="p">();</span>
</pre></div>
</div>
<p>作为构造函数， <code class="docutils literal"><span class="pre">WeakSet</span></code> 可以接受一个数组或类似数组的对象作为参数。（实际上，任何具有 <code class="docutils literal"><span class="pre">Iterable</span></code>  接口的对象，都可以作为 <code class="docutils literal"><span class="pre">WeakSet</span></code> 的参数。）该数组的所有成员，都会自动成为 <code class="docutils literal"><span class="pre">WeakSet</span></code> 实例对象的成员。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]];</span>
<span class="kr">const</span> <span class="nx">ws</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WeakSet</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
<span class="c1">// WeakSet {[1, 2], [3, 4]}</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">a</span></code> 是一个数组，它有两个成员，也都是数组。将 <code class="docutils literal"><span class="pre">a</span></code> 作为 <code class="docutils literal"><span class="pre">WeakSet</span></code> 构造函数的参数， <code class="docutils literal"><span class="pre">a</span></code> 的成员会自动成为 <code class="docutils literal"><span class="pre">WeakSet</span></code> 的成员。</p>
<p>注意，是 <code class="docutils literal"><span class="pre">a</span></code> 数组的成员成为 <code class="docutils literal"><span class="pre">WeakSet</span></code> 的成员，而不是 <code class="docutils literal"><span class="pre">a</span></code> 数组本身。这意味着，数组的成员只能是对象。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
<span class="kr">const</span> <span class="nx">ws</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WeakSet</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span>
<span class="c1">// Uncaught TypeError: Invalid value used in weak set(…)</span>
</pre></div>
</div>
<p>上面代码中，数组 <code class="docutils literal"><span class="pre">b</span></code> 的成员不是对象，加入 <code class="docutils literal"><span class="pre">WeaKSet</span></code> 就会报错。</p>
<p><code class="docutils literal"><span class="pre">WeakSet</span></code> 结构有以下三个方法。</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">WeakSet.prototype.add(value)</span></code> ：向 <code class="docutils literal"><span class="pre">WeakSet</span></code> 实例添加一个新成员。</li>
<li><code class="docutils literal"><span class="pre">WeakSet.prototype.delete(value)</span></code> ：清除 <code class="docutils literal"><span class="pre">WeakSet</span></code> 实例的指定成员。</li>
<li><code class="docutils literal"><span class="pre">WeakSet.prototype.has(value)</span></code> ：返回一个布尔值，表示某个值是否在 <code class="docutils literal"><span class="pre">WeakSet</span></code> 实例之中。</li>
</ul>
<p>下面是一个例子。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">ws</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WeakSet</span><span class="p">();</span>
<span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
<span class="kr">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="p">{};</span>

<span class="nx">ws</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nb">window</span><span class="p">);</span>
<span class="nx">ws</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>

<span class="nx">ws</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nb">window</span><span class="p">);</span> <span class="c1">// true</span>
<span class="nx">ws</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">foo</span><span class="p">);</span>    <span class="c1">// false</span>

<span class="nx">ws</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="nb">window</span><span class="p">);</span>
<span class="nx">ws</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nb">window</span><span class="p">);</span>    <span class="c1">// false</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">WeakSet</span></code> 没有 <code class="docutils literal"><span class="pre">size</span></code> 属性，没有办法遍历它的成员。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">ws</span><span class="p">.</span><span class="nx">size</span> <span class="c1">// undefined</span>
<span class="nx">ws</span><span class="p">.</span><span class="nx">forEach</span> <span class="c1">// undefined</span>

<span class="nx">ws</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">item</span><span class="p">){</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;WeakSet has &#39;</span> <span class="o">+</span> <span class="nx">item</span><span class="p">)})</span>
<span class="c1">// TypeError: undefined is not a function</span>
</pre></div>
</div>
<p>上面代码试图获取 <code class="docutils literal"><span class="pre">size</span></code> 和 <code class="docutils literal"><span class="pre">forEach</span></code> 属性，结果都不能成功。</p>
<p><code class="docutils literal"><span class="pre">WeakSet</span></code> 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。 <code class="docutils literal"><span class="pre">WeakSet</span></code> 的一个用处，是储存 <code class="docutils literal"><span class="pre">DOM</span></code> 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p>
<p>下面是 <code class="docutils literal"><span class="pre">WeakSet</span></code> 的另一个例子。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">foos</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WeakSet</span><span class="p">()</span>
<span class="kr">class</span> <span class="nx">Foo</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">foos</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="k">this</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">method</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">foos</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="k">this</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nx">TypeError</span><span class="p">(</span><span class="s1">&#39;Foo.prototype.method 只能在Foo的实例上调用！&#39;</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码保证了 <code class="docutils literal"><span class="pre">Foo</span></code> 的实例方法，只能在 <code class="docutils literal"><span class="pre">Foo</span></code> 的实例上调用。这里使用 <code class="docutils literal"><span class="pre">WeakSet</span></code> 的好处是， <code class="docutils literal"><span class="pre">foos</span></code> 对实例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑 <code class="docutils literal"><span class="pre">foos</span></code> ，也不会出现内存泄漏。</p>
</div>
</div>
<div class="section" id="map">
<h2>12.3. Map<a class="headerlink" href="#map" title="永久链接至标题">¶</a></h2>
<div class="section" id="id6">
<h3>12.3.1. 含义和基本用法<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<p>JavaScript 的对象（ <code class="docutils literal"><span class="pre">Object</span></code> ），本质上是键值对的集合（ <code class="docutils literal"><span class="pre">Hash</span></code> 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="p">{};</span>
<span class="kr">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;myDiv&#39;</span><span class="p">);</span>

<span class="nx">data</span><span class="p">[</span><span class="nx">element</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;metadata&#39;</span><span class="p">;</span>
<span class="nx">data</span><span class="p">[</span><span class="s1">&#39;[object HTMLDivElement]&#39;</span><span class="p">]</span> <span class="c1">// &quot;metadata&quot;</span>
</pre></div>
</div>
<p>上面代码原意是将一个 <code class="docutils literal"><span class="pre">DOM</span></code> 节点作为对象 <code class="docutils literal"><span class="pre">data</span></code> 的键，但是由于对象只接受字符串作为键名，所以 <code class="docutils literal"><span class="pre">element</span></code> 被自动转为字符串 <code class="docutils literal"><span class="pre">[object</span> <span class="pre">HTMLDivElement]</span></code> 。</p>
<p>为了解决这个问题，ES6 提供了 <code class="docutils literal"><span class="pre">Map</span></code> 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说， <code class="docutils literal"><span class="pre">Object</span></code> 结构提供了“字符串—值”的对应， <code class="docutils literal"><span class="pre">Map</span></code> 结构提供了“值—值”的对应，是一种更完善的 <code class="docutils literal"><span class="pre">Hash</span></code> 结构实现。如果你需要“键值对”的数据结构， <code class="docutils literal"><span class="pre">Map</span></code> 比 <code class="docutils literal"><span class="pre">Object</span></code> 更合适。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">m</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">();</span>
<span class="kr">const</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span><span class="nx">p</span><span class="o">:</span> <span class="s1">&#39;Hello World&#39;</span><span class="p">};</span>

<span class="nx">m</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">o</span><span class="p">,</span> <span class="s1">&#39;content&#39;</span><span class="p">)</span>
<span class="nx">m</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="c1">// &quot;content&quot;</span>

<span class="nx">m</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nx">m</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nx">m</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="c1">// false</span>
</pre></div>
</div>
<p>上面代码使用 <code class="docutils literal"><span class="pre">Map</span></code> 结构的 <code class="docutils literal"><span class="pre">set</span></code> 方法，将对象 <code class="docutils literal"><span class="pre">o</span></code> 当作 <code class="docutils literal"><span class="pre">m``的一个键，然后又使用</span> <span class="pre">``get</span></code> 方法读取这个键，接着使用 <code class="docutils literal"><span class="pre">delete</span></code> 方法删除了这个键。</p>
<p>上面的例子展示了如何向 <code class="docutils literal"><span class="pre">Map</span></code> 添加成员。作为构造函数， <code class="docutils literal"><span class="pre">Map</span></code> 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">([</span>
  <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;张三&#39;</span><span class="p">],</span>
  <span class="p">[</span><span class="s1">&#39;title&#39;</span><span class="p">,</span> <span class="s1">&#39;Author&#39;</span><span class="p">]</span>
<span class="p">]);</span>

<span class="nx">map</span><span class="p">.</span><span class="nx">size</span> <span class="c1">// 2</span>
<span class="nx">map</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nx">map</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">)</span> <span class="c1">// &quot;张三&quot;</span>
<span class="nx">map</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="s1">&#39;title&#39;</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nx">map</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;title&#39;</span><span class="p">)</span> <span class="c1">// &quot;Author&quot;</span>
</pre></div>
</div>
<p>上面代码在新建 <code class="docutils literal"><span class="pre">Map</span></code> 实例时，就指定了两个键 <code class="docutils literal"><span class="pre">name</span></code> 和 <code class="docutils literal"><span class="pre">title</span></code> 。</p>
<p><code class="docutils literal"><span class="pre">Map</span></code> 构造函数接受数组作为参数，实际上执行的是下面的算法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">items</span> <span class="o">=</span> <span class="p">[</span>
  <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;张三&#39;</span><span class="p">],</span>
  <span class="p">[</span><span class="s1">&#39;title&#39;</span><span class="p">,</span> <span class="s1">&#39;Author&#39;</span><span class="p">]</span>
<span class="p">];</span>

<span class="kr">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">();</span>

<span class="nx">items</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span>
  <span class="p">([</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">])</span> <span class="p">=&gt;</span> <span class="nx">map</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
<span class="p">);</span>
</pre></div>
</div>
<p>事实上，不仅仅是数组，任何具有 <code class="docutils literal"><span class="pre">Iterator</span></code> 接口、且每个成员都是一个双元素的数组的数据结构（详见《 <code class="docutils literal"><span class="pre">Iterator</span></code> 》一章）都可以当作 <code class="docutils literal"><span class="pre">Map</span></code> 构造函数的参数。这就是说， <code class="docutils literal"><span class="pre">Set</span></code> 和 <code class="docutils literal"><span class="pre">Map</span></code> 都可以用来生成新的 <code class="docutils literal"><span class="pre">Map</span></code> 。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([</span>
  <span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
  <span class="p">[</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="p">]);</span>
<span class="kr">const</span> <span class="nx">m1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">(</span><span class="nx">set</span><span class="p">);</span>
<span class="nx">m1</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span> <span class="c1">// 1</span>

<span class="kr">const</span> <span class="nx">m2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">([[</span><span class="s1">&#39;baz&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]);</span>
<span class="kr">const</span> <span class="nx">m3</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">(</span><span class="nx">m2</span><span class="p">);</span>
<span class="nx">m3</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;baz&#39;</span><span class="p">)</span> <span class="c1">// 3</span>
</pre></div>
</div>
<p>上面代码中，我们分别使用 <code class="docutils literal"><span class="pre">Set</span></code> 对象和 <code class="docutils literal"><span class="pre">Map</span></code> 对象，当作 <code class="docutils literal"><span class="pre">Map</span></code> 构造函数的参数，结果都生成了新的 <code class="docutils literal"><span class="pre">Map</span></code> 对象。</p>
<p>如果对同一个键多次赋值，后面的值将覆盖前面的值。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">();</span>

<span class="nx">map</span>
<span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;aaa&#39;</span><span class="p">)</span>
<span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;bbb&#39;</span><span class="p">);</span>

<span class="nx">map</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// &quot;bbb&quot;</span>
</pre></div>
</div>
<p>上面代码对键 1 连续赋值两次，后一次的值覆盖前一次的值。</p>
<p>如果读取一个未知的键，则返回 <code class="docutils literal"><span class="pre">undefined</span></code> 。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="k">new</span> <span class="nx">Map</span><span class="p">().</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;asfddfsasadf&#39;</span><span class="p">)</span> <span class="c1">// undefined</span>
</pre></div>
</div>
<p>注意，只有对同一个对象的引用， <code class="docutils literal"><span class="pre">Map</span></code> 结构才将其视为同一个键。这一点要非常小心。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">();</span>

<span class="nx">map</span><span class="p">.</span><span class="nx">set</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="mi">555</span><span class="p">);</span>
<span class="nx">map</span><span class="p">.</span><span class="nx">get</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">])</span> <span class="c1">// undefined</span>
</pre></div>
</div>
<p>上面代码的 <code class="docutils literal"><span class="pre">set</span></code> 和 <code class="docutils literal"><span class="pre">get</span></code> 方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此 <code class="docutils literal"><span class="pre">get</span></code> 方法无法读取该键，返回 <code class="docutils literal"><span class="pre">undefined</span></code> 。</p>
<p>同理，同样的值的两个实例，在 <code class="docutils literal"><span class="pre">Map</span></code> 结构中被视为两个键。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">();</span>

<span class="kr">const</span> <span class="nx">k1</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">];</span>
<span class="kr">const</span> <span class="nx">k2</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">];</span>

<span class="nx">map</span>
<span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">k1</span><span class="p">,</span> <span class="mi">111</span><span class="p">)</span>
<span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">k2</span><span class="p">,</span> <span class="mi">222</span><span class="p">);</span>

<span class="nx">map</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">k1</span><span class="p">)</span> <span class="c1">// 111</span>
<span class="nx">map</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">k2</span><span class="p">)</span> <span class="c1">// 222</span>
</pre></div>
</div>
<p>上面代码中，变量 <code class="docutils literal"><span class="pre">k1</span></code> 和 <code class="docutils literal"><span class="pre">k2</span></code> 的值是一样的，但是它们在 <code class="docutils literal"><span class="pre">Map</span></code> 结构中被视为两个键。</p>
<p>由上可知， <code class="docutils literal"><span class="pre">Map</span></code> 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</p>
<p>如果 <code class="docutils literal"><span class="pre">Map</span></code>  的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等， <code class="docutils literal"><span class="pre">Map</span></code> 将其视为一个键，比如 0 和 -0 就是一个键，布尔值 <code class="docutils literal"><span class="pre">true</span></code> 和字符串 <code class="docutils literal"><span class="pre">true</span></code> 则是两个不同的键。另外， <code class="docutils literal"><span class="pre">undefined</span></code> 和 <code class="docutils literal"><span class="pre">null</span></code> 也是两个不同的键。虽然 <code class="docutils literal"><span class="pre">NaN</span></code> 不严格相等于自身，但 <code class="docutils literal"><span class="pre">Map</span></code> 将其视为同一个键。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">();</span>

<span class="nx">map</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="o">-</span><span class="mi">0</span><span class="p">,</span> <span class="mi">123</span><span class="p">);</span>
<span class="nx">map</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="o">+</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// 123</span>

<span class="nx">map</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="nx">map</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s1">&#39;true&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="nx">map</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="c1">// 1</span>

<span class="nx">map</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="kc">undefined</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="nx">map</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
<span class="nx">map</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="kc">undefined</span><span class="p">)</span> <span class="c1">// 3</span>

<span class="nx">map</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="kc">NaN</span><span class="p">,</span> <span class="mi">123</span><span class="p">);</span>
<span class="nx">map</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="kc">NaN</span><span class="p">)</span> <span class="c1">// 123</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h3>12.3.2. 实例的属性和操作方法<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal"><span class="pre">Map</span></code> 结构的实例有以下属性和操作方法。</p>
<ol class="arabic simple">
<li>size 属性</li>
</ol>
<p><code class="docutils literal"><span class="pre">size</span></code> 属性返回 <code class="docutils literal"><span class="pre">Map</span></code> 结构的成员总数。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">();</span>
<span class="nx">map</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
<span class="nx">map</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>

<span class="nx">map</span><span class="p">.</span><span class="nx">size</span> <span class="c1">// 2</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li>set(key, value)</li>
</ol>
<p><code class="docutils literal"><span class="pre">set</span></code> 方法设置键名 <code class="docutils literal"><span class="pre">key</span></code> 对应的键值为 <code class="docutils literal"><span class="pre">value</span></code> ，然后返回整个 <code class="docutils literal"><span class="pre">Map</span></code> 结构。如果 <code class="docutils literal"><span class="pre">key</span></code> 已经有值，则键值会被更新，否则就新生成该键。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">m</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">();</span>

<span class="nx">m</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s1">&#39;edition&#39;</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>        <span class="c1">// 键是字符串</span>
<span class="nx">m</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="mi">262</span><span class="p">,</span> <span class="s1">&#39;standard&#39;</span><span class="p">)</span>     <span class="c1">// 键是数值</span>
<span class="nx">m</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="kc">undefined</span><span class="p">,</span> <span class="s1">&#39;nah&#39;</span><span class="p">)</span>    <span class="c1">// 键是 undefined</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">set</span></code> 方法返回的是当前的 <code class="docutils literal"><span class="pre">Map</span></code> 对象，因此可以采用链式写法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">()</span>
  <span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">);</span>
</pre></div>
</div>
<ol class="arabic simple" start="3">
<li>get(key)</li>
</ol>
<p><code class="docutils literal"><span class="pre">get</span></code> 方法读取 <code class="docutils literal"><span class="pre">key</span></code> 对应的键值，如果找不到 <code class="docutils literal"><span class="pre">key</span></code> ，返回 <code class="docutils literal"><span class="pre">undefined</span></code> 。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">m</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">();</span>

<span class="kr">const</span> <span class="nx">hello</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">);};</span>
<span class="nx">m</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">hello</span><span class="p">,</span> <span class="s1">&#39;Hello ES6!&#39;</span><span class="p">)</span> <span class="c1">// 键是函数</span>

<span class="nx">m</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">hello</span><span class="p">)</span>  <span class="c1">// Hello ES6!</span>
</pre></div>
</div>
<ol class="arabic simple" start="4">
<li>has(key)</li>
</ol>
<p><code class="docutils literal"><span class="pre">has</span></code> 方法返回一个布尔值，表示某个键是否在当前 <code class="docutils literal"><span class="pre">Map</span></code> 对象之中。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">m</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">();</span>

<span class="nx">m</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s1">&#39;edition&#39;</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
<span class="nx">m</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="mi">262</span><span class="p">,</span> <span class="s1">&#39;standard&#39;</span><span class="p">);</span>
<span class="nx">m</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="kc">undefined</span><span class="p">,</span> <span class="s1">&#39;nah&#39;</span><span class="p">);</span>

<span class="nx">m</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="s1">&#39;edition&#39;</span><span class="p">)</span>     <span class="c1">// true</span>
<span class="nx">m</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="s1">&#39;years&#39;</span><span class="p">)</span>       <span class="c1">// false</span>
<span class="nx">m</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="mi">262</span><span class="p">)</span>           <span class="c1">// true</span>
<span class="nx">m</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="kc">undefined</span><span class="p">)</span>     <span class="c1">// true</span>
</pre></div>
</div>
<ol class="arabic simple" start="5">
<li>delete(key)</li>
</ol>
<p><code class="docutils literal"><span class="pre">delete</span></code> 方法删除某个键，返回 <code class="docutils literal"><span class="pre">true</span></code> 。如果删除失败，返回 <code class="docutils literal"><span class="pre">false</span></code> 。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">m</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">();</span>
<span class="nx">m</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="kc">undefined</span><span class="p">,</span> <span class="s1">&#39;nah&#39;</span><span class="p">);</span>
<span class="nx">m</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="kc">undefined</span><span class="p">)</span>     <span class="c1">// true</span>

<span class="nx">m</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="kc">undefined</span><span class="p">)</span>
<span class="nx">m</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="kc">undefined</span><span class="p">)</span>       <span class="c1">// false</span>
</pre></div>
</div>
<ol class="arabic simple" start="6">
<li>clear()</li>
</ol>
<p><code class="docutils literal"><span class="pre">clear</span></code> 方法清除所有成员，没有返回值。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">();</span>
<span class="nx">map</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
<span class="nx">map</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>

<span class="nx">map</span><span class="p">.</span><span class="nx">size</span> <span class="c1">// 2</span>
<span class="nx">map</span><span class="p">.</span><span class="nx">clear</span><span class="p">()</span>
<span class="nx">map</span><span class="p">.</span><span class="nx">size</span> <span class="c1">// 0</span>
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h3>12.3.3. 遍历方法<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal"><span class="pre">Map</span></code> 结构原生提供三个遍历器生成函数和一个遍历方法。</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">keys()</span></code> ：返回键名的遍历器。</li>
<li><code class="docutils literal"><span class="pre">values()</span></code> ：返回键值的遍历器。</li>
<li><code class="docutils literal"><span class="pre">entries()</span></code> ：返回所有成员的遍历器。</li>
<li><code class="docutils literal"><span class="pre">forEach()</span></code> ：遍历 <code class="docutils literal"><span class="pre">Map</span></code> 的所有成员。</li>
</ul>
<p>需要特别注意的是， <code class="docutils literal"><span class="pre">Map</span></code> 的遍历顺序就是插入顺序。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">([</span>
  <span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="s1">&#39;no&#39;</span><span class="p">],</span>
  <span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span>  <span class="s1">&#39;yes&#39;</span><span class="p">],</span>
<span class="p">]);</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">key</span> <span class="k">of</span> <span class="nx">map</span><span class="p">.</span><span class="nx">keys</span><span class="p">())</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// &quot;F&quot;</span>
<span class="c1">// &quot;T&quot;</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">value</span> <span class="k">of</span> <span class="nx">map</span><span class="p">.</span><span class="nx">values</span><span class="p">())</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// &quot;no&quot;</span>
<span class="c1">// &quot;yes&quot;</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">item</span> <span class="k">of</span> <span class="nx">map</span><span class="p">.</span><span class="nx">entries</span><span class="p">())</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">item</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="p">}</span>
<span class="c1">// &quot;F&quot; &quot;no&quot;</span>
<span class="c1">// &quot;T&quot; &quot;yes&quot;</span>

<span class="c1">// 或者</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">]</span> <span class="k">of</span> <span class="nx">map</span><span class="p">.</span><span class="nx">entries</span><span class="p">())</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// &quot;F&quot; &quot;no&quot;</span>
<span class="c1">// &quot;T&quot; &quot;yes&quot;</span>

<span class="c1">// 等同于使用map.entries()</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">]</span> <span class="k">of</span> <span class="nx">map</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// &quot;F&quot; &quot;no&quot;</span>
<span class="c1">// &quot;T&quot; &quot;yes&quot;</span>
</pre></div>
</div>
<p>上面代码最后的那个例子，表示 <code class="docutils literal"><span class="pre">Map</span></code> 结构的默认遍历器接口（ <code class="docutils literal"><span class="pre">Symbol.iterator</span></code> 属性），就是 <code class="docutils literal"><span class="pre">entries</span></code> 方法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">map</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]</span> <span class="o">===</span> <span class="nx">map</span><span class="p">.</span><span class="nx">entries</span> <span class="c1">// true</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">Map</span></code> 结构转为数组结构，比较快速的方法是使用扩展运算符（ <code class="docutils literal"><span class="pre">...</span></code> ）。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">([</span>
  <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">],</span>
  <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">],</span>
  <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;three&#39;</span><span class="p">],</span>
<span class="p">]);</span>

<span class="p">[...</span><span class="nx">map</span><span class="p">.</span><span class="nx">keys</span><span class="p">()]</span>
<span class="c1">// [1, 2, 3]</span>

<span class="p">[...</span><span class="nx">map</span><span class="p">.</span><span class="nx">values</span><span class="p">()]</span>
<span class="c1">// [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;]</span>

<span class="p">[...</span><span class="nx">map</span><span class="p">.</span><span class="nx">entries</span><span class="p">()]</span>
<span class="c1">// [[1,&#39;one&#39;], [2, &#39;two&#39;], [3, &#39;three&#39;]]</span>

<span class="p">[...</span><span class="nx">map</span><span class="p">]</span>
<span class="c1">// [[1,&#39;one&#39;], [2, &#39;two&#39;], [3, &#39;three&#39;]]</span>
</pre></div>
</div>
<p>结合数组的 <code class="docutils literal"><span class="pre">map</span></code> 方法、 <code class="docutils literal"><span class="pre">filter</span></code> 方法，可以实现 <code class="docutils literal"><span class="pre">Map</span></code> 的遍历和过滤（ <code class="docutils literal"><span class="pre">Map</span></code>  本身没有 <code class="docutils literal"><span class="pre">map</span></code> 和 <code class="docutils literal"><span class="pre">filter</span></code> 方法）。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">map0</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">()</span>
  <span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">);</span>

<span class="kr">const</span> <span class="nx">map1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">(</span>
  <span class="p">[...</span><span class="nx">map0</span><span class="p">].</span><span class="nx">filter</span><span class="p">(([</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">])</span> <span class="p">=&gt;</span> <span class="nx">k</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span>
<span class="p">);</span>
<span class="c1">// 产生 Map 结构 {1 =&gt; &#39;a&#39;, 2 =&gt; &#39;b&#39;}</span>

<span class="kr">const</span> <span class="nx">map2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">(</span>
  <span class="p">[...</span><span class="nx">map0</span><span class="p">].</span><span class="nx">map</span><span class="p">(([</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">])</span> <span class="p">=&gt;</span> <span class="p">[</span><span class="nx">k</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nx">v</span><span class="p">])</span>
    <span class="p">);</span>
<span class="c1">// 产生 Map 结构 {2 =&gt; &#39;_a&#39;, 4 =&gt; &#39;_b&#39;, 6 =&gt; &#39;_c&#39;}</span>
</pre></div>
</div>
<p>此外， <code class="docutils literal"><span class="pre">Map</span></code> 还有一个 <code class="docutils literal"><span class="pre">forEach</span></code> 方法，与数组的 <code class="docutils literal"><span class="pre">forEach</span></code> 方法类似，也可以实现遍历。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">map</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">map</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;Key: %s, Value: %s&quot;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">forEach</span></code> 方法还可以接受第二个参数，用来绑定 <code class="docutils literal"><span class="pre">this</span></code> 。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">reporter</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">report</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;Key: %s, Value: %s&quot;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="nx">map</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">map</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">report</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
<span class="p">},</span> <span class="nx">reporter</span><span class="p">);</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">forEach</span></code> 方法的回调函数的 <code class="docutils literal"><span class="pre">this</span></code> ，就指向 <code class="docutils literal"><span class="pre">reporter</span></code> 。</p>
</div>
<div class="section" id="id9">
<h3>12.3.4. 与其他数据结构的互相转换<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h3>
<ol class="arabic simple">
<li>Map 转为数组</li>
</ol>
<p>前面已经提过， <code class="docutils literal"><span class="pre">Map</span></code> 转为数组最方便的方法，就是使用扩展运算符（ <code class="docutils literal"><span class="pre">...</span></code> ）。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">myMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">()</span>
  <span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">set</span><span class="p">({</span><span class="nx">foo</span><span class="o">:</span> <span class="mi">3</span><span class="p">},</span> <span class="p">[</span><span class="s1">&#39;abc&#39;</span><span class="p">]);</span>
<span class="p">[...</span><span class="nx">myMap</span><span class="p">]</span>
<span class="c1">// [ [ true, 7 ], [ { foo: 3 }, [ &#39;abc&#39; ] ] ]</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li>数组 转为 Map</li>
</ol>
<p>将数组传入 <code class="docutils literal"><span class="pre">Map</span></code> 构造函数，就可以转为 <code class="docutils literal"><span class="pre">Map</span></code> 。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="k">new</span> <span class="nx">Map</span><span class="p">([</span>
  <span class="p">[</span><span class="kc">true</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span>
  <span class="p">[{</span><span class="nx">foo</span><span class="o">:</span> <span class="mi">3</span><span class="p">},</span> <span class="p">[</span><span class="s1">&#39;abc&#39;</span><span class="p">]]</span>
<span class="p">])</span>
<span class="c1">// Map {</span>
<span class="c1">//   true =&gt; 7,</span>
<span class="c1">//   Object {foo: 3} =&gt; [&#39;abc&#39;]</span>
<span class="c1">// }</span>
</pre></div>
</div>
<ol class="arabic simple" start="3">
<li>Map 转为对象</li>
</ol>
<p>如果所有 <code class="docutils literal"><span class="pre">Map</span></code> 的键都是字符串，它可以无损地转为对象。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">strMapToObj</span><span class="p">(</span><span class="nx">strMap</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">k</span><span class="p">,</span><span class="nx">v</span><span class="p">]</span> <span class="k">of</span> <span class="nx">strMap</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">obj</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="o">=</span> <span class="nx">v</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">obj</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">myMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">()</span>
  <span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s1">&#39;yes&#39;</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s1">&#39;no&#39;</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
<span class="nx">strMapToObj</span><span class="p">(</span><span class="nx">myMap</span><span class="p">)</span>
<span class="c1">// { yes: true, no: false }</span>
</pre></div>
</div>
<p>如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。</p>
<ol class="arabic simple" start="4">
<li>对象转为 Map</li>
</ol>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">objToStrMap</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">strMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">k</span> <span class="k">of</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">obj</span><span class="p">))</span> <span class="p">{</span>
    <span class="nx">strMap</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">k</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">strMap</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">objToStrMap</span><span class="p">({</span><span class="nx">yes</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">no</span><span class="o">:</span> <span class="kc">false</span><span class="p">})</span>
<span class="c1">// Map {&quot;yes&quot; =&gt; true, &quot;no&quot; =&gt; false}</span>
</pre></div>
</div>
<ol class="arabic simple" start="5">
<li>Map 转为 JSON</li>
</ol>
<p><code class="docutils literal"><span class="pre">Map</span></code> 转为 <code class="docutils literal"><span class="pre">JSON</span></code> 要区分两种情况。一种情况是， <code class="docutils literal"><span class="pre">Map</span></code>  的键名都是字符串，这时可以选择转为对象 <code class="docutils literal"><span class="pre">JSON</span></code> 。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">strMapToJson</span><span class="p">(</span><span class="nx">strMap</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">strMapToObj</span><span class="p">(</span><span class="nx">strMap</span><span class="p">));</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">myMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">().</span><span class="nx">set</span><span class="p">(</span><span class="s1">&#39;yes&#39;</span><span class="p">,</span> <span class="kc">true</span><span class="p">).</span><span class="nx">set</span><span class="p">(</span><span class="s1">&#39;no&#39;</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
<span class="nx">strMapToJson</span><span class="p">(</span><span class="nx">myMap</span><span class="p">)</span>
<span class="c1">// &#39;{&quot;yes&quot;:true,&quot;no&quot;:false}&#39;</span>
</pre></div>
</div>
<p>另一种情况是， <code class="docutils literal"><span class="pre">Map</span></code> 的键名有非字符串，这时可以选择转为数组 <code class="docutils literal"><span class="pre">JSON</span></code> 。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">mapToArrayJson</span><span class="p">(</span><span class="nx">map</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">([...</span><span class="nx">map</span><span class="p">]);</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">myMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">().</span><span class="nx">set</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="mi">7</span><span class="p">).</span><span class="nx">set</span><span class="p">({</span><span class="nx">foo</span><span class="o">:</span> <span class="mi">3</span><span class="p">},</span> <span class="p">[</span><span class="s1">&#39;abc&#39;</span><span class="p">]);</span>
<span class="nx">mapToArrayJson</span><span class="p">(</span><span class="nx">myMap</span><span class="p">)</span>
<span class="c1">// &#39;[[true,7],[{&quot;foo&quot;:3},[&quot;abc&quot;]]]&#39;</span>
</pre></div>
</div>
<ol class="arabic simple" start="6">
<li>JSON 转为 Map</li>
</ol>
<p><code class="docutils literal"><span class="pre">JSON</span></code> 转为 <code class="docutils literal"><span class="pre">Map</span></code> ，正常情况下，所有键名都是字符串。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">jsonToStrMap</span><span class="p">(</span><span class="nx">jsonStr</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">objToStrMap</span><span class="p">(</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">jsonStr</span><span class="p">));</span>
<span class="p">}</span>

<span class="nx">jsonToStrMap</span><span class="p">(</span><span class="s1">&#39;{&quot;yes&quot;: true, &quot;no&quot;: false}&#39;</span><span class="p">)</span>
<span class="c1">// Map {&#39;yes&#39; =&gt; true, &#39;no&#39; =&gt; false}</span>
</pre></div>
</div>
<p>但是，有一种特殊情况，整个 <code class="docutils literal"><span class="pre">JSON</span></code> 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 <code class="docutils literal"><span class="pre">Map</span></code> 。这往往是 <code class="docutils literal"><span class="pre">Map</span></code> 转为数组 <code class="docutils literal"><span class="pre">JSON</span></code> 的逆操作。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">jsonToMap</span><span class="p">(</span><span class="nx">jsonStr</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">(</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">jsonStr</span><span class="p">));</span>
<span class="p">}</span>

<span class="nx">jsonToMap</span><span class="p">(</span><span class="s1">&#39;[[true,7],[{&quot;foo&quot;:3},[&quot;abc&quot;]]]&#39;</span><span class="p">)</span>
<span class="c1">// Map {true =&gt; 7, Object {foo: 3} =&gt; [&#39;abc&#39;]}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="weakmap">
<h2>12.4. WeakMap<a class="headerlink" href="#weakmap" title="永久链接至标题">¶</a></h2>
<div class="section" id="id10">
<h3>12.4.1. 含义<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal"><span class="pre">WeakMap</span></code> 结构与 <code class="docutils literal"><span class="pre">Map</span></code> 结构类似，也是用于生成键值对的集合。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// WeakMap 可以使用 set 方法添加成员</span>
<span class="kr">const</span> <span class="nx">wm1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WeakMap</span><span class="p">();</span>
<span class="kr">const</span> <span class="nx">key</span> <span class="o">=</span> <span class="p">{</span><span class="nx">foo</span><span class="o">:</span> <span class="mi">1</span><span class="p">};</span>
<span class="nx">wm1</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="nx">wm1</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="c1">// 2</span>

<span class="c1">// WeakMap 也可以接受一个数组，</span>
<span class="c1">// 作为构造函数的参数</span>
<span class="kr">const</span> <span class="nx">k1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
<span class="kr">const</span> <span class="nx">k2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">];</span>
<span class="kr">const</span> <span class="nx">wm2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WeakMap</span><span class="p">([[</span><span class="nx">k1</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">],</span> <span class="p">[</span><span class="nx">k2</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">]]);</span>
<span class="nx">wm2</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">k2</span><span class="p">)</span> <span class="c1">// &quot;bar&quot;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">WeakMap</span></code> 与 <code class="docutils literal"><span class="pre">Map</span></code> 的区别有两点。</p>
<p>首先， <code class="docutils literal"><span class="pre">WeakMap</span></code> 只接受对象作为键名（ <code class="docutils literal"><span class="pre">null</span></code> 除外），不接受其他类型的值作为键名。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WeakMap</span><span class="p">();</span>
<span class="nx">map</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1">// TypeError: 1 is not an object!</span>
<span class="nx">map</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">Symbol</span><span class="p">(),</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1">// TypeError: Invalid value used as weak map key</span>
<span class="nx">map</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1">// TypeError: Invalid value used as weak map key</span>
</pre></div>
</div>
<p>上面代码中，如果将数值 <code class="docutils literal"><span class="pre">1</span></code> 和 <code class="docutils literal"><span class="pre">Symbol</span></code> 值作为 <code class="docutils literal"><span class="pre">WeakMap</span></code> 的键名，都会报错。</p>
<p>其次， <code class="docutils literal"><span class="pre">WeakMap</span></code> 的键名所指向的对象，不计入垃圾回收机制。</p>
<p><code class="docutils literal"><span class="pre">WeakMap</span></code> 的设计目的在于，有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。请看下面的例子。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">e1</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">e2</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;bar&#39;</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span>
  <span class="p">[</span><span class="nx">e1</span><span class="p">,</span> <span class="s1">&#39;foo 元素&#39;</span><span class="p">],</span>
  <span class="p">[</span><span class="nx">e2</span><span class="p">,</span> <span class="s1">&#39;bar 元素&#39;</span><span class="p">],</span>
<span class="p">];</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">e1</span></code> 和 <code class="docutils literal"><span class="pre">e2</span></code> 是两个对象，我们通过 <code class="docutils literal"><span class="pre">arr</span></code> 数组对这两个对象添加一些文字说明。这就形成了 <code class="docutils literal"><span class="pre">arr</span></code> 对 <code class="docutils literal"><span class="pre">e1</span></code> 和 <code class="docutils literal"><span class="pre">e2</span></code> 的引用。</p>
<p>一旦不再需要这两个对象，我们就必须手动删除这个引用，否则垃圾回收机制就不会释放 <code class="docutils literal"><span class="pre">e1</span></code> 和 <code class="docutils literal"><span class="pre">e2</span></code> 占用的内存。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// 不需要 e1 和 e2 的时候</span>
<span class="c1">// 必须手动删除引用</span>
<span class="nx">arr</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="nx">arr</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</pre></div>
</div>
<p>上面这样的写法显然很不方便。一旦忘了写，就会造成内存泄露。</p>
<p><code class="docutils literal"><span class="pre">WeakMap</span></code> 就是为了解决这个问题而诞生的，它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要， <code class="docutils literal"><span class="pre">WeakMap</span></code> 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。</p>
<p>基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 <code class="docutils literal"><span class="pre">WeakMap</span></code> 。一个典型应用场景是，在网页的 <code class="docutils literal"><span class="pre">DOM</span></code> 元素上添加数据，就可以使用 <code class="docutils literal"><span class="pre">WeakMap</span></code> 结构。当该 <code class="docutils literal"><span class="pre">DOM</span></code> 元素被清除，其所对应的 <code class="docutils literal"><span class="pre">WeakMap</span></code> 记录就会自动被移除。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">wm</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WeakMap</span><span class="p">();</span>

<span class="kr">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;example&#39;</span><span class="p">);</span>

<span class="nx">wm</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="s1">&#39;some information&#39;</span><span class="p">);</span>
<span class="nx">wm</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">element</span><span class="p">)</span> <span class="c1">// &quot;some information&quot;</span>
</pre></div>
</div>
<p>上面代码中，先新建一个 <code class="docutils literal"><span class="pre">Weakmap</span></code> 实例。然后，将一个 <code class="docutils literal"><span class="pre">DOM</span></code> 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 <code class="docutils literal"><span class="pre">WeakMap</span></code> 里面。这时， <code class="docutils literal"><span class="pre">WeakMap</span></code> 里面对 <code class="docutils literal"><span class="pre">element</span></code> 的引用就是弱引用，不会被计入垃圾回收机制。</p>
<p>也就是说，上面的 <code class="docutils literal"><span class="pre">DOM</span></code> 节点对象的引用计数是 1 ，而不是 2 。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。 <code class="docutils literal"><span class="pre">Weakmap</span></code>  保存的这个键值对，也会自动消失。</p>
<p>总之， <code class="docutils literal"><span class="pre">WeakMap</span></code> 的专用场合就是，它的键所对应的对象，可能会在将来消失。 <code class="docutils literal"><span class="pre">WeakMap</span></code> 结构有助于防止内存泄漏。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last"><code class="docutils literal"><span class="pre">WeakMap</span></code> 弱引用的只是键名，而不是键值。键值依然是正常引用。</p>
</div>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">wm</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WeakMap</span><span class="p">();</span>
<span class="kd">let</span> <span class="nx">key</span> <span class="o">=</span> <span class="p">{};</span>
<span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span><span class="nx">foo</span><span class="o">:</span> <span class="mi">1</span><span class="p">};</span>

<span class="nx">wm</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">obj</span><span class="p">);</span>
<span class="nx">obj</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="nx">wm</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
<span class="c1">// Object {foo: 1}</span>
</pre></div>
</div>
<p>上面代码中，键值 <code class="docutils literal"><span class="pre">obj</span></code> 是正常引用。所以，即使在 <code class="docutils literal"><span class="pre">WeakMap</span></code> 外部消除了 <code class="docutils literal"><span class="pre">obj</span></code> 的引用， <code class="docutils literal"><span class="pre">WeakMap</span></code> 内部的引用依然存在。(对象是引用，修改对象属性值会改变内部引用的值)</p>
</div>
<div class="section" id="id11">
<h3>12.4.2. WeakMap 的语法<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal"><span class="pre">WeakMap</span></code> 与 <code class="docutils literal"><span class="pre">Map</span></code> 在 <code class="docutils literal"><span class="pre">API</span></code> 上的区别主要是两个，一是没有遍历操作（即没有 <code class="docutils literal"><span class="pre">keys()</span></code> 、 <code class="docutils literal"><span class="pre">values()</span></code> 和 <code class="docutils literal"><span class="pre">entries()</span></code> 方法），也没有 <code class="docutils literal"><span class="pre">size</span></code> 属性。因为没有办法列出所有键名，某个键名是否存在完全不可预测，跟垃圾回收机制是否运行相关。这一刻可以取到键名，下一刻垃圾回收机制突然运行了，这个键名就没了，为了防止出现不确定性，就统一规定不能取到键名。二是无法清空，即不支持 <code class="docutils literal"><span class="pre">clear</span></code> 方法。因此， <code class="docutils literal"><span class="pre">WeakMap</span></code> 只有四个方法可用： <code class="docutils literal"><span class="pre">get()</span></code> 、 <code class="docutils literal"><span class="pre">set()</span></code> 、 <code class="docutils literal"><span class="pre">has()</span></code> 、 <code class="docutils literal"><span class="pre">delete()</span></code> 。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">wm</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WeakMap</span><span class="p">();</span>

<span class="c1">// size、forEach、clear 方法都不存在</span>
<span class="nx">wm</span><span class="p">.</span><span class="nx">size</span> <span class="c1">// undefined</span>
<span class="nx">wm</span><span class="p">.</span><span class="nx">forEach</span> <span class="c1">// undefined</span>
<span class="nx">wm</span><span class="p">.</span><span class="nx">clear</span> <span class="c1">// undefined</span>
</pre></div>
</div>
</div>
<div class="section" id="id12">
<h3>12.4.3. WeakMap 的示例<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal"><span class="pre">WeakMap</span></code> 的例子很难演示，因为无法观察它里面的引用会自动消失。此时，其他引用都解除了，已经没有引用指向 <code class="docutils literal"><span class="pre">WeakMap</span></code> 的键名了，导致无法证实那个键名是不是存在。</p>
<p>贺师俊老师提示，如果引用所指向的值占用特别多的内存，就可以通过 <code class="docutils literal"><span class="pre">Node</span></code> 的 <code class="docutils literal"><span class="pre">process.memoryUsage</span></code> 方法看出来。根据这个思路，网友vtxf补充了下面的例子。</p>
<p>首先，打开 <code class="docutils literal"><span class="pre">Node</span></code> 命令行。</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>$ node --expose-gc
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">--expose-gc</span></code> 参数表示允许手动执行垃圾回收机制。</p>
<p>然后，执行下面的代码。</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>// 手动执行一次垃圾回收，保证获取的内存使用状态准确
&gt; global.gc<span class="o">()</span><span class="p">;</span>
undefined

// 查看内存占用的初始状态，heapUsed 为 4M 左右
&gt; process.memoryUsage<span class="o">()</span><span class="p">;</span>
<span class="o">{</span> rss: <span class="m">21106688</span>,
  heapTotal: <span class="m">7376896</span>,
  heapUsed: <span class="m">4153936</span>,
  external: <span class="m">9059</span> <span class="o">}</span>

&gt; <span class="nb">let</span> <span class="nv">wm</span> <span class="o">=</span> new WeakMap<span class="o">()</span><span class="p">;</span>
undefined

// 新建一个变量 key，指向一个 <span class="m">5</span>*1024*1024 的数组
&gt; <span class="nb">let</span> <span class="nv">key</span> <span class="o">=</span> new Array<span class="o">(</span><span class="m">5</span> * <span class="m">1024</span> * <span class="m">1024</span><span class="o">)</span><span class="p">;</span>
undefined

// 设置 WeakMap 实例的键名，也指向 key 数组
// 这时，key 数组实际被引用了两次，
// 变量 key 引用一次，WeakMap 的键名引用了第二次
// 但是，WeakMap 是弱引用，对于引擎来说，引用计数还是1
&gt; wm.set<span class="o">(</span>key, <span class="m">1</span><span class="o">)</span><span class="p">;</span>
WeakMap <span class="o">{}</span>

&gt; global.gc<span class="o">()</span><span class="p">;</span>
undefined

// 这时内存占用 heapUsed 增加到 45M 了
&gt; process.memoryUsage<span class="o">()</span><span class="p">;</span>
<span class="o">{</span> rss: <span class="m">67538944</span>,
  heapTotal: <span class="m">7376896</span>,
  heapUsed: <span class="m">45782816</span>,
  external: <span class="m">8945</span> <span class="o">}</span>

// 清除变量 key 对数组的引用，
// 但没有手动清除 WeakMap 实例的键名对数组的引用
&gt; <span class="nv">key</span> <span class="o">=</span> null<span class="p">;</span>
null

// 再次执行垃圾回收
&gt; global.gc<span class="o">()</span><span class="p">;</span>
undefined

// 内存占用 heapUsed 变回 4M 左右，
// 可以看到 WeakMap 的键名引用没有阻止 gc 对内存的回收
&gt; process.memoryUsage<span class="o">()</span><span class="p">;</span>
<span class="o">{</span> rss: <span class="m">20639744</span>,
  heapTotal: <span class="m">8425472</span>,
  heapUsed: <span class="m">3979792</span>,
  external: <span class="m">8956</span> <span class="o">}</span>
</pre></div>
</div>
<p>上面代码中，只要外部的引用消失， <code class="docutils literal"><span class="pre">WeakMap</span></code>  内部的引用，就会自动被垃圾回收清除。由此可见，有了 <code class="docutils literal"><span class="pre">WeakMap</span></code> 的帮助，解决内存泄漏就会简单很多。</p>
</div>
<div class="section" id="id13">
<h3>12.4.4. WeakMap 的用途<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h3>
<p>前文说过， <code class="docutils literal"><span class="pre">WeakMap</span></code> 应用的典型场合就是 <code class="docutils literal"><span class="pre">DOM</span></code> 节点作为键名。下面是一个例子。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">myElement</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;logo&#39;</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">myWeakmap</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WeakMap</span><span class="p">();</span>

<span class="nx">myWeakmap</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">myElement</span><span class="p">,</span> <span class="p">{</span><span class="nx">timesClicked</span><span class="o">:</span> <span class="mi">0</span><span class="p">});</span>

<span class="nx">myElement</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;click&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">logoData</span> <span class="o">=</span> <span class="nx">myWeakmap</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">myElement</span><span class="p">);</span>
  <span class="nx">logoData</span><span class="p">.</span><span class="nx">timesClicked</span><span class="o">++</span><span class="p">;</span>
<span class="p">},</span> <span class="kc">false</span><span class="p">);</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">myElement</span></code> 是一个 <code class="docutils literal"><span class="pre">DOM</span></code> 节点，每当发生 <code class="docutils literal"><span class="pre">click</span></code> 事件，就更新一下状态。我们将这个状态作为键值放在 <code class="docutils literal"><span class="pre">WeakMap</span></code> 里，对应的键名就是 <code class="docutils literal"><span class="pre">myElement</span></code> 。一旦这个 <code class="docutils literal"><span class="pre">DOM</span></code> 节点删除，该状态就会自动消失，不存在内存泄漏风险。</p>
<p><code class="docutils literal"><span class="pre">WeakMap</span></code> 的另一个用处是部署私有属性。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">_counter</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WeakMap</span><span class="p">();</span>
<span class="kr">const</span> <span class="nx">_action</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WeakMap</span><span class="p">();</span>

<span class="kr">class</span> <span class="nx">Countdown</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">(</span><span class="nx">counter</span><span class="p">,</span> <span class="nx">action</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">_counter</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">counter</span><span class="p">);</span>
    <span class="nx">_action</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">action</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="nx">dec</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">counter</span> <span class="o">=</span> <span class="nx">_counter</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">counter</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="nx">counter</span><span class="o">--</span><span class="p">;</span>
    <span class="nx">_counter</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">counter</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">counter</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">_action</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="k">this</span><span class="p">)();</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Countdown</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;DONE&#39;</span><span class="p">));</span>

<span class="nx">c</span><span class="p">.</span><span class="nx">dec</span><span class="p">()</span>
<span class="nx">c</span><span class="p">.</span><span class="nx">dec</span><span class="p">()</span>
<span class="c1">// DONE</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">Countdown</span></code> 类的两个内部属性 <code class="docutils literal"><span class="pre">_counter</span></code> 和 <code class="docutils literal"><span class="pre">_action</span></code> ，是实例的弱引用，所以如果删除实例，它们也就随之消失，不会造成内存泄漏。</p>
</div>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Proxy.html" class="btn btn-neutral float-right" title="13. Proxy" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="Symbol.html" class="btn btn-neutral" title="11. Symbol" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, lzh.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.0',
            LANGUAGE:'zh_CN',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="_static/translations.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();

      });


      $(document).ready(function(){
        var offset = sessionStorage.getItem("offsetTop");
        $('.wy-side-scroll').scrollTop(offset);
        sessionStorage.setItem("offsetTop", 0);


        $('.wy-menu > ul').click(function(){
            sessionStorage.setItem("offsetTop", $('.wy-side-scroll').scrollTop());
        });
      })

  </script>
   

</body>
</html>