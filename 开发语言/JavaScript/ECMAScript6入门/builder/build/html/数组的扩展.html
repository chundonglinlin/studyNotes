

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>9. 数组的扩展 &mdash; ECMAScript6入门 1.0 文档</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="索引"
              href="genindex.html"/>
        <link rel="search" title="搜索" href="search.html"/>
    <link rel="top" title="ECMAScript6入门 1.0 文档" href="index.html"/>
        <link rel="next" title="10. 对象的扩展" href="对象的扩展.html"/>
        <link rel="prev" title="8. 函数的扩展" href="函数的扩展.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> ECMAScript6入门
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="前言.html">1. 前言</a></li>
<li class="toctree-l1"><a class="reference internal" href="ECMAScript6简介.html">2. ECMAScript6简介</a></li>
<li class="toctree-l1"><a class="reference internal" href="let和const命令.html">3. let 和 const 命令</a></li>
<li class="toctree-l1"><a class="reference internal" href="变量的解构赋值.html">4. 变量的解构赋值</a></li>
<li class="toctree-l1"><a class="reference internal" href="字符串的扩展.html">5. 字符串的扩展</a></li>
<li class="toctree-l1"><a class="reference internal" href="正则的扩展.html">6. 正则的扩展</a></li>
<li class="toctree-l1"><a class="reference internal" href="数值的扩展.html">7. 数值的扩展</a></li>
<li class="toctree-l1"><a class="reference internal" href="函数的扩展.html">8. 函数的扩展</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">9. 数组的扩展</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id2">9.1. 扩展运算符</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id3">9.1.1. 含义</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">9.1.2. 扩展运算符的应用</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#array-from">9.2. Array.from()</a></li>
<li class="toctree-l2"><a class="reference internal" href="#array-of">9.3. Array.of()</a></li>
<li class="toctree-l2"><a class="reference internal" href="#copywithin">9.4. 数组实例的 copyWithin()</a></li>
<li class="toctree-l2"><a class="reference internal" href="#find-findindex">9.5. 数组实例的 find() 和 findIndex()</a></li>
<li class="toctree-l2"><a class="reference internal" href="#fill">9.6. 数组实例的 fill()</a></li>
<li class="toctree-l2"><a class="reference internal" href="#entries-keys-values">9.7. 数组实例的 entries()，keys() 和 values()</a></li>
<li class="toctree-l2"><a class="reference internal" href="#includes">9.8. 数组实例的 includes()</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id5">9.9. 数组的空位</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="对象的扩展.html">10. 对象的扩展</a></li>
<li class="toctree-l1"><a class="reference internal" href="Symbol.html">11. Symbol</a></li>
<li class="toctree-l1"><a class="reference internal" href="Set和Map数据结构.html">12. Set和Map数据结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="Proxy.html">13. Proxy</a></li>
<li class="toctree-l1"><a class="reference internal" href="Reflect.html">14. Reflect</a></li>
<li class="toctree-l1"><a class="reference internal" href="Promise对象.html">15. Promise对象</a></li>
<li class="toctree-l1"><a class="reference internal" href="Iterator和for...of循环.html">16. Iterator 和 for…of 循环</a></li>
<li class="toctree-l1"><a class="reference internal" href="Generator函数的语法.html">17. Generator函数的语法</a></li>
<li class="toctree-l1"><a class="reference internal" href="Generator函数的异步应用.html">18. Generator 函数的异步应用</a></li>
<li class="toctree-l1"><a class="reference internal" href="async函数.html">19. asyn函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="Class的基本语法.html">20. Class 的基本语法</a></li>
<li class="toctree-l1"><a class="reference internal" href="Class的继承.html">21. Class的继承</a></li>
<li class="toctree-l1"><a class="reference internal" href="Decorator.html">22. 修饰器</a></li>
<li class="toctree-l1"><a class="reference internal" href="Module的语法.html">23. Module 的语法</a></li>
<li class="toctree-l1"><a class="reference internal" href="Module的加载实现.html">24. Module 的加载实现</a></li>
<li class="toctree-l1"><a class="reference internal" href="编程风格.html">25. 编程风格</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">ECMAScript6入门</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>9. 数组的扩展</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>9. 数组的扩展<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<div class="section" id="id2">
<h2>9.1. 扩展运算符<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<div class="section" id="id3">
<h3>9.1.1. 含义<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<p>扩展运算符（ <code class="docutils literal"><span class="pre">spread</span></code> ）是三个点（ <code class="docutils literal"><span class="pre">...</span></code> ）。它好比 <code class="docutils literal"><span class="pre">rest</span></code> 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(...[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="c1">// 1 2 3</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">...[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">5</span><span class="p">)</span>
<span class="c1">// 1 2 3 4 5</span>

<span class="p">[...</span><span class="nb">document</span><span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="s1">&#39;div&#39;</span><span class="p">)]</span>
<span class="c1">// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span>
</pre></div>
</div>
<p>该运算符主要用于函数调用。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">push</span><span class="p">(</span><span class="nx">array</span><span class="p">,</span> <span class="p">...</span><span class="nx">items</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">array</span><span class="p">.</span><span class="nx">push</span><span class="p">(...</span><span class="nx">items</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">add</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">38</span><span class="p">];</span>
<span class="nx">add</span><span class="p">(...</span><span class="nx">numbers</span><span class="p">)</span> <span class="c1">// 42</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">array.push(...items)</span></code> 和 <code class="docutils literal"><span class="pre">add(...numbers)</span></code> 这两行，都是函数的调用，它们的都使用了扩展运算符。该运算符将一个数组，变为参数序列。</p>
<p>扩展运算符与正常的函数参数可以结合使用，非常灵活。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">w</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="kr">const</span> <span class="nx">args</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">];</span>
<span class="nx">f</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">...</span><span class="nx">args</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">...[</span><span class="mi">3</span><span class="p">]);</span>
</pre></div>
</div>
<p>扩展运算符后面还可以放置表达式。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span>
  <span class="p">...(</span><span class="nx">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">:</span> <span class="p">[]),</span>
  <span class="s1">&#39;b&#39;</span><span class="p">,</span>
<span class="p">];</span>
</pre></div>
</div>
<p>如果扩展运算符后面是一个空数组，则不产生任何效果。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="p">[...[],</span> <span class="mi">1</span><span class="p">]</span> <span class="c1">// [1]</span>
</pre></div>
</div>
<p>替代函数的 <code class="docutils literal"><span class="pre">apply</span></code> 方法
由于扩展运算符可以展开数组，所以不再需要 <code class="docutils literal"><span class="pre">apply</span></code> 方法，将数组转为函数的参数了。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// ES5 的写法</span>
<span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">args</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>
<span class="nx">f</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>

<span class="c1">// ES6的写法</span>
<span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">args</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>
<span class="nx">f</span><span class="p">(...</span><span class="nx">args</span><span class="p">);</span>
</pre></div>
</div>
<p>下面是扩展运算符取代 <code class="docutils literal"><span class="pre">apply</span></code> 方法的一个实际的例子，应用 <code class="docutils literal"><span class="pre">Math.max</span></code> 方法，简化求出一个数组最大元素的写法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// ES5 的写法</span>
<span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="p">[</span><span class="mi">14</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">77</span><span class="p">])</span>

<span class="c1">// ES6 的写法</span>
<span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(...[</span><span class="mi">14</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">77</span><span class="p">])</span>

<span class="c1">// 等同于</span>
<span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">77</span><span class="p">);</span>
</pre></div>
</div>
<p>上面代码中，由于 <code class="docutils literal"><span class="pre">JavaScript</span></code> 不提供求数组最大元素的函数，所以只能套用 <code class="docutils literal"><span class="pre">Math.max</span></code> 函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用 <code class="docutils literal"><span class="pre">Math.max</span></code> 了。</p>
<p>另一个例子是通过 <code class="docutils literal"><span class="pre">push</span></code> 函数，将一个数组添加到另一个数组的尾部。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// ES5的 写法</span>
<span class="kd">var</span> <span class="nx">arr1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>
<span class="kd">var</span> <span class="nx">arr2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>
<span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">push</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">arr1</span><span class="p">,</span> <span class="nx">arr2</span><span class="p">);</span>

<span class="c1">// ES6 的写法</span>
<span class="kd">let</span> <span class="nx">arr1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">arr2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>
<span class="nx">arr1</span><span class="p">.</span><span class="nx">push</span><span class="p">(...</span><span class="nx">arr2</span><span class="p">);</span>
</pre></div>
</div>
<p>上面代码的 ES5 写法中， <code class="docutils literal"><span class="pre">push</span></code> 方法的参数不能是数组，所以只好通过 <code class="docutils literal"><span class="pre">apply</span></code> 方法变通使用 <code class="docutils literal"><span class="pre">push</span></code> 方法。有了扩展运算符，就可以直接将数组传入 <code class="docutils literal"><span class="pre">push</span></code> 方法。</p>
<p>下面是另外一个例子。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// ES5</span>
<span class="k">new</span> <span class="p">(</span><span class="nb">Date</span><span class="p">.</span><span class="nx">bind</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nb">Date</span><span class="p">,</span> <span class="p">[</span><span class="kc">null</span><span class="p">,</span> <span class="mi">2015</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
<span class="c1">// ES6</span>
<span class="k">new</span> <span class="nb">Date</span><span class="p">(...[</span><span class="mi">2015</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]);</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h3>9.1.2. 扩展运算符的应用<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<ol class="arabic simple">
<li>复制数组</li>
</ol>
<p>数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">a1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>
<span class="kr">const</span> <span class="nx">a2</span> <span class="o">=</span> <span class="nx">a1</span><span class="p">;</span>

<span class="nx">a2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="nx">a1</span> <span class="c1">// [2, 2]</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">a2</span></code> 并不是 <code class="docutils literal"><span class="pre">a1</span></code> 的克隆，而是指向同一份数据的另一个指针。修改 <code class="docutils literal"><span class="pre">a2</span></code> ，会直接导致 <code class="docutils literal"><span class="pre">a1</span></code> 的变化。</p>
<p>ES5 只能用变通方法来复制数组。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">a1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>
<span class="kr">const</span> <span class="nx">a2</span> <span class="o">=</span> <span class="nx">a1</span><span class="p">.</span><span class="nx">concat</span><span class="p">();</span>

<span class="nx">a2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="nx">a1</span> <span class="c1">// [1, 2]</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">a1</span></code> 会返回原数组的克隆，再修改 <code class="docutils literal"><span class="pre">a2</span></code> 就不会对 <code class="docutils literal"><span class="pre">a1</span></code> 产生影响。</p>
<p>扩展运算符提供了复制数组的简便写法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">a1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>
<span class="c1">// 写法一</span>
<span class="kr">const</span> <span class="nx">a2</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">a1</span><span class="p">];</span>
<span class="c1">// 写法二</span>
<span class="kr">const</span> <span class="p">[...</span><span class="nx">a2</span><span class="p">]</span> <span class="o">=</span> <span class="nx">a1</span><span class="p">;</span>
</pre></div>
</div>
<p>上面的两种写法， <code class="docutils literal"><span class="pre">a2</span></code> 都是 <code class="docutils literal"><span class="pre">a1</span></code> 的克隆。</p>
<ol class="arabic simple" start="2">
<li>合并数组</li>
</ol>
<p>扩展运算符提供了数组合并的新写法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// ES5</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">more</span><span class="p">)</span>
<span class="c1">// ES6</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">...</span><span class="nx">more</span><span class="p">]</span>

<span class="kd">var</span> <span class="nx">arr1</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">];</span>
<span class="kd">var</span> <span class="nx">arr2</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">];</span>
<span class="kd">var</span> <span class="nx">arr3</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">];</span>

<span class="c1">// ES5的合并数组</span>
<span class="nx">arr1</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">arr2</span><span class="p">,</span> <span class="nx">arr3</span><span class="p">);</span>
<span class="c1">// [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]</span>

<span class="c1">// ES6的合并数组</span>
<span class="p">[...</span><span class="nx">arr1</span><span class="p">,</span> <span class="p">...</span><span class="nx">arr2</span><span class="p">,</span> <span class="p">...</span><span class="nx">arr3</span><span class="p">]</span>
<span class="c1">// [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]</span>
</pre></div>
</div>
<ol class="arabic simple" start="3">
<li>与解构赋值结合</li>
</ol>
<p>扩展运算符可以与解构赋值结合起来，用于生成数组。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// ES5</span>
<span class="nx">a</span> <span class="o">=</span> <span class="nx">list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">rest</span> <span class="o">=</span> <span class="nx">list</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// 分割list数组为新的数组</span>
<span class="c1">// ES6</span>
<span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="p">...</span><span class="nx">rest</span><span class="p">]</span> <span class="o">=</span> <span class="nx">list</span>
</pre></div>
</div>
<p>下面是另外一些例子。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="p">[</span><span class="nx">first</span><span class="p">,</span> <span class="p">...</span><span class="nx">rest</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>
<span class="nx">first</span> <span class="c1">// 1</span>
<span class="nx">rest</span>  <span class="c1">// [2, 3, 4, 5]</span>

<span class="kr">const</span> <span class="p">[</span><span class="nx">first</span><span class="p">,</span> <span class="p">...</span><span class="nx">rest</span><span class="p">]</span> <span class="o">=</span> <span class="p">[];</span>
<span class="nx">first</span> <span class="c1">// undefined</span>
<span class="nx">rest</span>  <span class="c1">// []</span>

<span class="kr">const</span> <span class="p">[</span><span class="nx">first</span><span class="p">,</span> <span class="p">...</span><span class="nx">rest</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;foo&quot;</span><span class="p">];</span>
<span class="nx">first</span>  <span class="c1">// &quot;foo&quot;</span>
<span class="nx">rest</span>   <span class="c1">// []</span>
</pre></div>
</div>
<p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="p">[...</span><span class="nx">butLast</span><span class="p">,</span> <span class="nx">last</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>
<span class="c1">// 报错</span>

<span class="kr">const</span> <span class="p">[</span><span class="nx">first</span><span class="p">,</span> <span class="p">...</span><span class="nx">middle</span><span class="p">,</span> <span class="nx">last</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>
<span class="c1">// 报错</span>
</pre></div>
</div>
<ol class="arabic simple" start="4">
<li>字符串</li>
</ol>
<p>扩展运算符还可以将字符串转为真正的数组。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="p">[...</span><span class="s1">&#39;hello&#39;</span><span class="p">]</span> <span class="c1">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span>
</pre></div>
</div>
<p>上面的写法，有一个重要的好处，那就是能够正确识别四个字节的 <code class="docutils literal"><span class="pre">Unicode</span></code> 字符。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="s1">&#39;x\uD83D\uDE80y&#39;</span><span class="p">.</span><span class="nx">length</span> <span class="c1">// 4</span>
<span class="p">[...</span><span class="s1">&#39;x\uD83D\uDE80y&#39;</span><span class="p">].</span><span class="nx">length</span> <span class="c1">// 3</span>
</pre></div>
</div>
<p>上面代码的第一种写法， <code class="docutils literal"><span class="pre">JavaScript</span></code> 会将四个字节的 <code class="docutils literal"><span class="pre">Unicode</span></code> 字符，识别为 2 个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数，可以像下面这样写。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">length</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[...</span><span class="nx">str</span><span class="p">].</span><span class="nx">length</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">length</span><span class="p">(</span><span class="s1">&#39;x\uD83D\uDE80y&#39;</span><span class="p">)</span> <span class="c1">// 3</span>
</pre></div>
</div>
<p>凡是涉及到操作四个字节的 <code class="docutils literal"><span class="pre">Unicode</span></code> 字符的函数，都有这个问题。因此，最好都用扩展运算符改写。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">str</span> <span class="o">=</span> <span class="s1">&#39;x\uD83D\uDE80y&#39;</span><span class="p">;</span>

<span class="nx">str</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">).</span><span class="nx">reverse</span><span class="p">().</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="c1">// &#39;y\uDE80\uD83Dx&#39;</span>

<span class="p">[...</span><span class="nx">str</span><span class="p">].</span><span class="nx">reverse</span><span class="p">().</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="c1">// &#39;y\uD83D\uDE80x&#39;</span>
</pre></div>
</div>
<p>上面代码中，如果不用扩展运算符，字符串的 <code class="docutils literal"><span class="pre">reverse</span></code> 操作就不正确。</p>
<ol class="arabic simple" start="5">
<li>实现了 Iterator 接口的对象</li>
</ol>
<p>任何 <code class="docutils literal"><span class="pre">Iterator</span></code> 接口的对象（参阅 <code class="docutils literal"><span class="pre">Iterator</span></code> 一章），都可以用扩展运算符转为真正的数组。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">nodeList</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="s1">&#39;div&#39;</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">nodeList</span><span class="p">];</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">querySelectorAll</span></code> 方法返回的是一个 <code class="docutils literal"><span class="pre">nodeList</span></code> 对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于 <code class="docutils literal"><span class="pre">NodeList</span></code> 对象实现了 <code class="docutils literal"><span class="pre">Iterator</span></code> 。</p>
<p>对于那些没有部署 <code class="docutils literal"><span class="pre">Iterator</span></code> 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">arrayLike</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s1">&#39;0&#39;</span><span class="o">:</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span>
  <span class="s1">&#39;1&#39;</span><span class="o">:</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span>
  <span class="s1">&#39;2&#39;</span><span class="o">:</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span>
  <span class="nx">length</span><span class="o">:</span> <span class="mi">3</span>
<span class="p">};</span>

<span class="c1">// TypeError: Cannot spread non-iterable object.</span>
<span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">arrayLike</span><span class="p">];</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">arrayLike</span></code> 是一个类似数组的对象，但是没有部署 <code class="docutils literal"><span class="pre">Iterator</span></code> 接口，扩展运算符就会报错。这时，可以改为使用 <code class="docutils literal"><span class="pre">Array.from</span></code> 方法将 <code class="docutils literal"><span class="pre">arrayLike</span></code> 转为真正的数组。</p>
<ol class="arabic simple" start="6">
<li>Map 和 Set 结构，Generator 函数</li>
</ol>
<p>扩展运算符内部调用的是数据结构的 <code class="docutils literal"><span class="pre">Iterator</span></code> 接口，因此只要具有 <code class="docutils literal"><span class="pre">Iterator</span></code> 接口的对象，都可以使用扩展运算符，比如 <code class="docutils literal"><span class="pre">Map</span></code> 结构。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">([</span>
  <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">],</span>
  <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">],</span>
  <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;three&#39;</span><span class="p">],</span>
<span class="p">]);</span>

<span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">map</span><span class="p">.</span><span class="nx">keys</span><span class="p">()];</span> <span class="c1">// [1, 2, 3]</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">Generator</span></code> 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">go</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span><span class="p">(){</span>
  <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">[...</span><span class="nx">go</span><span class="p">()]</span> <span class="c1">// [1, 2, 3]</span>
</pre></div>
</div>
<p>上面代码中，变量 <code class="docutils literal"><span class="pre">go</span></code> 是一个 <code class="docutils literal"><span class="pre">Generator</span></code> 函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。</p>
<p>如果对没有 <code class="docutils literal"><span class="pre">Iterator</span></code> 接口的对象，使用扩展运算符，将会报错。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span><span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span><span class="o">:</span> <span class="mi">2</span><span class="p">};</span>
<span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">obj</span><span class="p">];</span> <span class="c1">// TypeError: Cannot spread non-iterable object</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="array-from">
<h2>9.2. Array.from()<a class="headerlink" href="#array-from" title="永久链接至标题">¶</a></h2>
<p><code class="docutils literal"><span class="pre">Array.from</span></code> 方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（ <code class="docutils literal"><span class="pre">iterable</span></code> ）的对象（包括 ES6 新增的数据结构 <code class="docutils literal"><span class="pre">Set</span></code> 和 <code class="docutils literal"><span class="pre">Map</span></code> ）。</p>
<p>下面是一个类似数组的对象， <code class="docutils literal"><span class="pre">Array.from</span></code> 将它转为真正的数组。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">arrayLike</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;0&#39;</span><span class="o">:</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span>
    <span class="s1">&#39;1&#39;</span><span class="o">:</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span>
    <span class="s1">&#39;2&#39;</span><span class="o">:</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span>
    <span class="nx">length</span><span class="o">:</span> <span class="mi">3</span>
<span class="p">};</span>

<span class="c1">// ES5的写法</span>
<span class="kd">var</span> <span class="nx">arr1</span> <span class="o">=</span> <span class="p">[].</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arrayLike</span><span class="p">);</span> <span class="c1">// [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>

<span class="c1">// ES6的写法</span>
<span class="kd">let</span> <span class="nx">arr2</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">(</span><span class="nx">arrayLike</span><span class="p">);</span> <span class="c1">// [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
</pre></div>
</div>
<p>实际应用中，常见的类似数组的对象是 <code class="docutils literal"><span class="pre">DOM</span></code> 操作返回的 <code class="docutils literal"><span class="pre">NodeList</span></code>  集合，以及函数内部的 <code class="docutils literal"><span class="pre">arguments</span></code> 对象。 <code class="docutils literal"><span class="pre">Array.from</span></code> 都可以将它们转为真正的数组。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// NodeList对象</span>
<span class="kd">let</span> <span class="nx">ps</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">);</span>
<span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">(</span><span class="nx">ps</span><span class="p">).</span><span class="nx">filter</span><span class="p">(</span><span class="nx">p</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">textContent</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">;</span>
<span class="p">});</span>

<span class="c1">// arguments对象</span>
<span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">args</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">querySelectorAll</span></code> 方法返回的是一个类似数组的对象，可以将这个对象转为真正的数组，再使用 <code class="docutils literal"><span class="pre">filter</span></code> 方法。</p>
<p>只要是部署了 <code class="docutils literal"><span class="pre">Iterator</span></code> 接口的数据结构， <code class="docutils literal"><span class="pre">Array.from</span></code> 都能将其转为数组。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>
<span class="c1">// [&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;]</span>

<span class="kd">let</span> <span class="nx">namesSet</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">])</span>
<span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">(</span><span class="nx">namesSet</span><span class="p">)</span> <span class="c1">// [&#39;a&#39;, &#39;b&#39;]</span>
</pre></div>
</div>
<p>上面代码中，字符串和 <code class="docutils literal"><span class="pre">Set</span></code> 结构都具有 <code class="docutils literal"><span class="pre">Iterator</span></code> 接口，因此可以被 <code class="docutils literal"><span class="pre">Array.from</span></code> 转为真正的数组。</p>
<p>如果参数是一个真正的数组， <code class="docutils literal"><span class="pre">Array.from</span></code> 会返回一个一模一样的新数组。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="c1">// [1, 2, 3]</span>
</pre></div>
</div>
<p>值得提醒的是，扩展运算符（ <code class="docutils literal"><span class="pre">...</span></code> ）也可以将某些数据结构转为数组。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// arguments对象</span>
<span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">args</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">arguments</span><span class="p">];</span>
<span class="p">}</span>

<span class="c1">// NodeList对象</span>
<span class="p">[...</span><span class="nb">document</span><span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="s1">&#39;div&#39;</span><span class="p">)]</span>
</pre></div>
</div>
<p>扩展运算符背后调用的是遍历器接口（ <code class="docutils literal"><span class="pre">Symbol.iterator</span></code> ），如果一个对象没有部署这个接口，就无法转换。 <code class="docutils literal"><span class="pre">Array.from</span></code> 方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有 <code class="docutils literal"><span class="pre">length</span></code> 属性。因此，任何有 <code class="docutils literal"><span class="pre">length</span></code> 属性的对象，都可以通过 <code class="docutils literal"><span class="pre">Array.from</span></code> 方法转为数组，而此时扩展运算符就无法转换。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">({</span> <span class="nx">length</span><span class="o">:</span> <span class="mi">3</span> <span class="p">});</span> <span class="c1">// [ undefined, undefined, undefined ]</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">Array.from</span></code> 返回了一个具有三个成员的数组，每个位置的值都是 <code class="docutils literal"><span class="pre">undefined</span></code> 。扩展运算符转换不了这个对象。</p>
<p>对于还没有部署该方法的浏览器，可以用 <code class="docutils literal"><span class="pre">Array.prototype.slice</span></code> 方法替代。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">toArray</span> <span class="o">=</span> <span class="p">(()</span> <span class="p">=&gt;</span>
  <span class="nb">Array</span><span class="p">.</span><span class="nx">from</span> <span class="o">?</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">from</span> <span class="o">:</span> <span class="nx">obj</span> <span class="p">=&gt;</span> <span class="p">[].</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span>
<span class="p">)();</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">Array.from</span></code> 还可以接受第二个参数，作用类似于数组的 <code class="docutils literal"><span class="pre">map</span></code> 方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">(</span><span class="nx">arrayLike</span><span class="p">,</span> <span class="nx">x</span> <span class="p">=&gt;</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span><span class="p">);</span>
<span class="c1">// 等同于</span>
<span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">(</span><span class="nx">arrayLike</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="p">=&gt;</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span><span class="p">);</span>

<span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span><span class="p">)</span>
<span class="c1">// [1, 4, 9]</span>
</pre></div>
</div>
<p>下面的例子是取出一组 <code class="docutils literal"><span class="pre">DOM</span></code> 节点的文本内容。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">spans</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="s1">&#39;span.name&#39;</span><span class="p">);</span>

<span class="c1">// map()</span>
<span class="kd">let</span> <span class="nx">names1</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">map</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">spans</span><span class="p">,</span> <span class="nx">s</span> <span class="p">=&gt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">textContent</span><span class="p">);</span>

<span class="c1">// Array.from()</span>
<span class="kd">let</span> <span class="nx">names2</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">(</span><span class="nx">spans</span><span class="p">,</span> <span class="nx">s</span> <span class="p">=&gt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">textContent</span><span class="p">)</span>
</pre></div>
</div>
<p>下面的例子将数组中布尔值为 <code class="docutils literal"><span class="pre">false</span></code> 的成员转为 0。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">n</span> <span class="o">||</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// [1, 0, 2, 0, 3]</span>
</pre></div>
</div>
<p>另一个例子是返回各种数据的类型。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">typesOf</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">(</span><span class="nx">arguments</span><span class="p">,</span> <span class="nx">value</span> <span class="p">=&gt;</span> <span class="k">typeof</span> <span class="nx">value</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">typesOf</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="p">[],</span> <span class="kc">NaN</span><span class="p">)</span>
<span class="c1">// [&#39;object&#39;, &#39;object&#39;, &#39;number&#39;]</span>
</pre></div>
</div>
<p>如果 <code class="docutils literal"><span class="pre">map</span></code> 函数里面用到了 <code class="docutils literal"><span class="pre">this</span></code> 关键字，还可以传入 <code class="docutils literal"><span class="pre">Array.from</span></code> 的第三个参数，用来绑定 <code class="docutils literal"><span class="pre">this</span></code> 。</p>
<p><code class="docutils literal"><span class="pre">Array.from()</span></code> 可以将各种值转为真正的数组，并且还提供 <code class="docutils literal"><span class="pre">map</span></code> 功能。这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">({</span> <span class="nx">length</span><span class="o">:</span> <span class="mi">2</span> <span class="p">},</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="s1">&#39;jack&#39;</span><span class="p">)</span> <span class="c1">// [&#39;jack&#39;, &#39;jack&#39;]</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">Array.from</span></code> 的第一个参数指定了第二个参数运行的次数。这种特性可以让该方法的用法变得非常灵活。</p>
<p><code class="docutils literal"><span class="pre">Array.from()</span></code> 的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种 <code class="docutils literal"><span class="pre">Unicode</span></code> 字符，可以避免 <code class="docutils literal"><span class="pre">JavaScript</span></code> 将大于 <code class="docutils literal"><span class="pre">\uFFFF</span></code> 的 <code class="docutils literal"><span class="pre">Unicode</span></code> 字符，算作两个字符的 <code class="docutils literal"><span class="pre">bug</span></code> 。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">countSymbols</span><span class="p">(</span><span class="nx">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">(</span><span class="nx">string</span><span class="p">).</span><span class="nx">length</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="array-of">
<h2>9.3. Array.of()<a class="headerlink" href="#array-of" title="永久链接至标题">¶</a></h2>
<p><code class="docutils literal"><span class="pre">Array.of</span></code> 方法用于将一组值，转换为数组。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nb">Array</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="c1">// [3,11,8]</span>
<span class="nb">Array</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1">// [3]</span>
<span class="nb">Array</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="nx">length</span> <span class="c1">// 1</span>
</pre></div>
</div>
<p>这个方法的主要目的，是弥补数组构造函数 <code class="docutils literal"><span class="pre">Array()</span></code> 的不足。因为参数个数的不同，会导致 <code class="docutils literal"><span class="pre">Array()</span></code> 的行为有差异。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nb">Array</span><span class="p">()</span> <span class="c1">// []</span>
<span class="nb">Array</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1">// [, , ,]</span>
<span class="nb">Array</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="c1">// [3, 11, 8]</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">Array</span></code> 方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于 2 个时， <code class="docutils literal"><span class="pre">Array()</span></code> 才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。</p>
<p><code class="docutils literal"><span class="pre">Array.of</span></code> 基本上可以用来替代 <code class="docutils literal"><span class="pre">Array()</span></code> 或 <code class="docutils literal"><span class="pre">new</span> <span class="pre">Array()</span></code> ，并且不存在由于参数不同而导致的重载。它的行为非常统一。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nb">Array</span><span class="p">.</span><span class="k">of</span><span class="p">()</span> <span class="c1">// []</span>
<span class="nb">Array</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="kc">undefined</span><span class="p">)</span> <span class="c1">// [undefined]</span>
<span class="nb">Array</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// [1]</span>
<span class="nb">Array</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">// [1, 2]</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">Array.of</span></code> 总是返回参数值组成的数组。如果没有参数，就返回一个空数组。</p>
<p><code class="docutils literal"><span class="pre">Array.of</span></code> 方法可以用下面的代码模拟实现。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">ArrayOf</span><span class="p">(){</span>
  <span class="k">return</span> <span class="p">[].</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="copywithin">
<h2>9.4. 数组实例的 copyWithin()<a class="headerlink" href="#copywithin" title="永久链接至标题">¶</a></h2>
<p>数组实例的 <code class="docutils literal"><span class="pre">copyWithin</span></code> 方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">copyWithin</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">end</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span>
</pre></div>
</div>
<p>它接受三个参数。</p>
<ul class="simple">
<li>target（必需）：从该位置开始替换数据。如果为负值，表示倒数。</li>
<li>start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。</li>
<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。</li>
</ul>
<p>这三个参数都应该是数值，如果不是，会自动转为数值。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">].</span><span class="nx">copyWithin</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">// [4, 5, 3, 4, 5]</span>
</pre></div>
</div>
<p>上面代码表示将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2。</p>
<p>下面是更多例子。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// 将3号位复制到0号位</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">].</span><span class="nx">copyWithin</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="c1">// [4, 2, 3, 4, 5]</span>

<span class="c1">// -2相当于3号位，-1相当于4号位</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">].</span><span class="nx">copyWithin</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="c1">// [4, 2, 3, 4, 5]</span>

<span class="c1">// 将3号位复制到0号位</span>
<span class="p">[].</span><span class="nx">copyWithin</span><span class="p">.</span><span class="nx">call</span><span class="p">({</span><span class="nx">length</span><span class="o">:</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="o">:</span> <span class="mi">1</span><span class="p">},</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="c1">// {0: 1, 3: 1, length: 5}</span>

<span class="c1">// 将2号位到数组结束，复制到0号位</span>
<span class="kd">let</span> <span class="nx">i32a</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Int32Array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]);</span>
<span class="nx">i32a</span><span class="p">.</span><span class="nx">copyWithin</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="c1">// Int32Array [3, 4, 5, 4, 5]</span>

<span class="c1">// 对于没有部署 TypedArray 的 copyWithin 方法的平台</span>
<span class="c1">// 需要采用下面的写法</span>
<span class="p">[].</span><span class="nx">copyWithin</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">new</span> <span class="nx">Int32Array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
<span class="c1">// Int32Array [4, 2, 3, 4, 5]</span>
</pre></div>
</div>
</div>
<div class="section" id="find-findindex">
<h2>9.5. 数组实例的 find() 和 findIndex()<a class="headerlink" href="#find-findindex" title="永久链接至标题">¶</a></h2>
<p>数组实例的 <code class="docutils literal"><span class="pre">find</span></code> 方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为 <code class="docutils literal"><span class="pre">true</span></code> 的成员，然后返回该成员。如果没有符合条件的成员，则返回 <code class="docutils literal"><span class="pre">undefined</span></code> 。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">].</span><span class="nx">find</span><span class="p">((</span><span class="nx">n</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// -5</span>
</pre></div>
</div>
<p>上面代码找出数组中第一个小于 0 的成员。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">].</span><span class="nx">find</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">value</span> <span class="o">&gt;</span> <span class="mi">9</span><span class="p">;</span>
<span class="p">})</span> <span class="c1">// 10</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">find</span></code> 方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</p>
<p>数组实例的 <code class="docutils literal"><span class="pre">findIndex</span></code> 方法的用法与 <code class="docutils literal"><span class="pre">find</span></code> 方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回 <code class="docutils literal"><span class="pre">-1</span></code> 。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">].</span><span class="nx">findIndex</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">value</span> <span class="o">&gt;</span> <span class="mi">9</span><span class="p">;</span>
<span class="p">})</span> <span class="c1">// 2</span>
</pre></div>
</div>
<p>这两个方法都可以接受第二个参数，用来绑定回调函数的 <code class="docutils literal"><span class="pre">this</span></code> 对象。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">v</span><span class="p">){</span>
  <span class="k">return</span> <span class="nx">v</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">age</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span><span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;John&#39;</span><span class="p">,</span> <span class="nx">age</span><span class="o">:</span> <span class="mi">20</span><span class="p">};</span>
<span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">15</span><span class="p">].</span><span class="nx">find</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">person</span><span class="p">);</span>    <span class="c1">// 26</span>
</pre></div>
</div>
<p>上面的代码中， <code class="docutils literal"><span class="pre">find</span></code> 函数接收了第二个参数 <code class="docutils literal"><span class="pre">person</span></code> 对象，回调函数中的 <code class="docutils literal"><span class="pre">this</span></code> 对象指向 <code class="docutils literal"><span class="pre">person</span></code> 对象。</p>
<p>另外，这两个方法都可以发现 <code class="docutils literal"><span class="pre">NaN</span></code> ，弥补了数组的 <code class="docutils literal"><span class="pre">indexOf</span></code> 方法的不足。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="p">[</span><span class="kc">NaN</span><span class="p">].</span><span class="nx">indexOf</span><span class="p">(</span><span class="kc">NaN</span><span class="p">)</span>
<span class="c1">// -1</span>

<span class="p">[</span><span class="kc">NaN</span><span class="p">].</span><span class="nx">findIndex</span><span class="p">(</span><span class="nx">y</span> <span class="p">=&gt;</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">is</span><span class="p">(</span><span class="kc">NaN</span><span class="p">,</span> <span class="nx">y</span><span class="p">))</span>
<span class="c1">// 0</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">indexOf</span></code> 方法无法识别数组的 <code class="docutils literal"><span class="pre">NaN</span></code> 成员，但是 <code class="docutils literal"><span class="pre">findIndex</span></code> 方法可以借助 <code class="docutils literal"><span class="pre">Object.is</span></code> 方法做到。</p>
</div>
<div class="section" id="fill">
<h2>9.6. 数组实例的 fill()<a class="headerlink" href="#fill" title="永久链接至标题">¶</a></h2>
<p><code class="docutils literal"><span class="pre">fill</span></code> 方法使用给定值，填充一个数组。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">].</span><span class="nx">fill</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="c1">// [7, 7, 7]</span>

<span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="c1">// [7, 7, 7]</span>
</pre></div>
</div>
<p>上面代码表明， <code class="docutils literal"><span class="pre">fill</span></code> 方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。</p>
<p><code class="docutils literal"><span class="pre">fill</span></code> 方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">].</span><span class="nx">fill</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">// [&#39;a&#39;, 7, &#39;c&#39;]</span>
</pre></div>
</div>
<p>上面代码表示， <code class="docutils literal"><span class="pre">fill</span></code> 方法从 1 号位开始，向原数组填充 7，到 2 号位之前结束。</p>
<p>注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="nx">fill</span><span class="p">({</span><span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;Mike&quot;</span><span class="p">});</span>
<span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">name</span> <span class="o">=</span> <span class="s2">&quot;Ben&quot;</span><span class="p">;</span>
<span class="nx">arr</span>
<span class="c1">// [{name: &quot;Ben&quot;}, {name: &quot;Ben&quot;}, {name: &quot;Ben&quot;}]</span>

<span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="nx">fill</span><span class="p">([]);</span>
<span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">push</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="nx">arr</span>
<span class="c1">// [[5], [5], [5]]</span>
</pre></div>
</div>
</div>
<div class="section" id="entries-keys-values">
<h2>9.7. 数组实例的 entries()，keys() 和 values()<a class="headerlink" href="#entries-keys-values" title="永久链接至标题">¶</a></h2>
<p>ES6 提供三个新的方法—— <code class="docutils literal"><span class="pre">entries()</span></code> ， <code class="docutils literal"><span class="pre">keys()</span></code> 和 <code class="docutils literal"><span class="pre">values()</span></code> ——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用 <code class="docutils literal"><span class="pre">for...of</span></code> 循环进行遍历，唯一的区别是 <code class="docutils literal"><span class="pre">keys()</span></code> 是对键名的遍历、 <code class="docutils literal"><span class="pre">values()</span></code> 是对键值的遍历， <code class="docutils literal"><span class="pre">entries()</span></code> 是对键值对的遍历。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">index</span> <span class="k">of</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">].</span><span class="nx">keys</span><span class="p">())</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">index</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 0</span>
<span class="c1">// 1</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">elem</span> <span class="k">of</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">].</span><span class="nx">values</span><span class="p">())</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">elem</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// &#39;a&#39;</span>
<span class="c1">// &#39;b&#39;</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">index</span><span class="p">,</span> <span class="nx">elem</span><span class="p">]</span> <span class="k">of</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">].</span><span class="nx">entries</span><span class="p">())</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="nx">elem</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 0 &quot;a&quot;</span>
<span class="c1">// 1 &quot;b&quot;</span>
</pre></div>
</div>
<p>如果不使用 <code class="docutils literal"><span class="pre">for...of</span></code> 循环，可以手动调用遍历器对象的 <code class="docutils literal"><span class="pre">next</span></code> 方法，进行遍历。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">letter</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">entries</span> <span class="o">=</span> <span class="nx">letter</span><span class="p">.</span><span class="nx">entries</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">entries</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span><span class="p">);</span> <span class="c1">// [0, &#39;a&#39;]</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">entries</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span><span class="p">);</span> <span class="c1">// [1, &#39;b&#39;]</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">entries</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span><span class="p">);</span> <span class="c1">// [2, &#39;c&#39;]</span>
</pre></div>
</div>
</div>
<div class="section" id="includes">
<h2>9.8. 数组实例的 includes()<a class="headerlink" href="#includes" title="永久链接至标题">¶</a></h2>
<p><code class="docutils literal"><span class="pre">Array.prototype.includes</span></code> 方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的 <code class="docutils literal"><span class="pre">includes</span></code> 方法类似。ES2016 引入了该方法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nx">includes</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>     <span class="c1">// true</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nx">includes</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>     <span class="c1">// false</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">NaN</span><span class="p">].</span><span class="nx">includes</span><span class="p">(</span><span class="kc">NaN</span><span class="p">)</span> <span class="c1">// true</span>
</pre></div>
</div>
<p>该方法的第二个参数表示搜索的起始位置，默认为 0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为 -4，但数组长度为 3），则会重置为从 0开始。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nx">includes</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>  <span class="c1">// false</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nx">includes</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// true</span>
</pre></div>
</div>
<p>没有该方法之前，我们通常使用数组的 <code class="docutils literal"><span class="pre">indexOf</span></code> 方法，检查是否包含某个值。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">el</span><span class="p">)</span> <span class="o">!==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">indexOf</span></code> 方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于 -1，表达起来不够直观。二是，它内部使用严格相等运算符（ <code class="docutils literal"><span class="pre">===</span></code> ）进行判断，这会导致对 <code class="docutils literal"><span class="pre">NaN</span></code> 的误判。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="p">[</span><span class="kc">NaN</span><span class="p">].</span><span class="nx">indexOf</span><span class="p">(</span><span class="kc">NaN</span><span class="p">)</span> <span class="c1">// -1</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">includes</span></code> 使用的是不一样的判断算法，就没有这个问题。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="p">[</span><span class="kc">NaN</span><span class="p">].</span><span class="nx">includes</span><span class="p">(</span><span class="kc">NaN</span><span class="p">)</span> <span class="c1">// true</span>
</pre></div>
</div>
<p>下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">contains</span> <span class="o">=</span> <span class="p">(()</span> <span class="p">=&gt;</span>
  <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">includes</span>
    <span class="o">?</span> <span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
    <span class="o">:</span> <span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">some</span><span class="p">(</span><span class="nx">el</span> <span class="p">=&gt;</span> <span class="nx">el</span> <span class="o">===</span> <span class="nx">value</span><span class="p">)</span>
<span class="p">)();</span>
<span class="nx">contains</span><span class="p">([</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">],</span> <span class="s1">&#39;baz&#39;</span><span class="p">);</span> <span class="c1">// =&gt; false</span>
</pre></div>
</div>
<p>另外， <code class="docutils literal"><span class="pre">Map</span></code> 和 <code class="docutils literal"><span class="pre">Set</span></code> 数据结构有一个 <code class="docutils literal"><span class="pre">has</span></code> 方法，需要注意与 <code class="docutils literal"><span class="pre">includes</span></code> 区分。</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">Map</span></code> 结构的 <code class="docutils literal"><span class="pre">has</span></code> 方法，是用来查找键名的，比如 <code class="docutils literal"><span class="pre">Map.prototype.has(key)</span></code> 、 <code class="docutils literal"><span class="pre">WeakMap.prototype.has(key)</span></code> 、 <code class="docutils literal"><span class="pre">Reflect.has(target,</span> <span class="pre">propertyKey)</span></code> 。</li>
<li><code class="docutils literal"><span class="pre">Set</span></code> 结构的 <code class="docutils literal"><span class="pre">has</span></code> 方法，是用来查找值的，比如 <code class="docutils literal"><span class="pre">Set.prototype.has(value)</span></code> 、 <code class="docutils literal"><span class="pre">WeakSet.prototype.has(value)</span></code> 。</li>
</ul>
</div>
<div class="section" id="id5">
<h2>9.9. 数组的空位<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<p>数组的空位指，数组的某一个位置没有任何值。比如， <code class="docutils literal"><span class="pre">Array</span></code> 构造函数返回的数组都是空位。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nb">Array</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1">// [, , ,]</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">Array(3)</span></code> 返回一个具有 3 个空位的数组。</p>
<p>注意，空位不是 <code class="docutils literal"><span class="pre">undefined</span></code> ，一个位置的值等于 <code class="docutils literal"><span class="pre">undefined</span></code> ，依然是有值的。空位是没有任何值， <code class="docutils literal"><span class="pre">in</span></code> 运算符可以说明这一点。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="mi">0</span> <span class="k">in</span> <span class="p">[</span><span class="kc">undefined</span><span class="p">,</span> <span class="kc">undefined</span><span class="p">,</span> <span class="kc">undefined</span><span class="p">]</span> <span class="c1">// true</span>
<span class="mi">0</span> <span class="k">in</span> <span class="p">[,</span> <span class="p">,</span> <span class="p">,]</span> <span class="c1">// false</span>
</pre></div>
</div>
<p>上面代码说明，第一个数组的 0 号位置是有值的，第二个数组的 0 号位置没有值。</p>
<p>ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">forEach()</span></code> , <code class="docutils literal"><span class="pre">filter()</span></code> , <code class="docutils literal"><span class="pre">reduce()</span></code> , <code class="docutils literal"><span class="pre">every()</span></code> 和 <code class="docutils literal"><span class="pre">some()</span></code> 都会跳过空位。</li>
<li><code class="docutils literal"><span class="pre">map()</span></code> 会跳过空位，但会保留这个值</li>
<li><code class="docutils literal"><span class="pre">join()</span></code> <cite>和 ``toString()`</cite> 会将空位视为 <code class="docutils literal"><span class="pre">undefined</span></code> ，而 <code class="docutils literal"><span class="pre">undefined</span></code> 和 <code class="docutils literal"><span class="pre">null</span></code> 会被处理成空字符串。</li>
</ul>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// forEach方法</span>
<span class="p">[,</span><span class="s1">&#39;a&#39;</span><span class="p">].</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">x</span><span class="p">,</span><span class="nx">i</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">));</span> <span class="c1">// 1</span>

<span class="c1">// filter方法</span>
<span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,,</span><span class="s1">&#39;b&#39;</span><span class="p">].</span><span class="nx">filter</span><span class="p">(</span><span class="nx">x</span> <span class="p">=&gt;</span> <span class="kc">true</span><span class="p">)</span> <span class="c1">// [&#39;a&#39;,&#39;b&#39;]</span>

<span class="c1">// every方法</span>
<span class="p">[,</span><span class="s1">&#39;a&#39;</span><span class="p">].</span><span class="nx">every</span><span class="p">(</span><span class="nx">x</span> <span class="p">=&gt;</span> <span class="nx">x</span><span class="o">===</span><span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="c1">// true</span>

<span class="c1">// reduce方法</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,,</span><span class="mi">2</span><span class="p">].</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="k">return</span> <span class="nx">x</span><span class="o">+</span><span class="nx">y</span><span class="p">)</span> <span class="c1">// 3</span>

<span class="c1">// some方法</span>
<span class="p">[,</span><span class="s1">&#39;a&#39;</span><span class="p">].</span><span class="nx">some</span><span class="p">(</span><span class="nx">x</span> <span class="p">=&gt;</span> <span class="nx">x</span> <span class="o">!==</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="c1">// false</span>

<span class="c1">// map方法</span>
<span class="p">[,</span><span class="s1">&#39;a&#39;</span><span class="p">].</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="p">=&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// [,1]</span>

<span class="c1">// join方法</span>
<span class="p">[,</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="kc">undefined</span><span class="p">,</span><span class="kc">null</span><span class="p">].</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;#&#39;</span><span class="p">)</span> <span class="c1">// &quot;#a##&quot;</span>

<span class="c1">// toString方法</span>
<span class="p">[,</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="kc">undefined</span><span class="p">,</span><span class="kc">null</span><span class="p">].</span><span class="nx">toString</span><span class="p">()</span> <span class="c1">// &quot;,a,,&quot;</span>
</pre></div>
</div>
<p>ES6 则是明确将空位转为 <code class="docutils literal"><span class="pre">undefined</span></code> 。</p>
<p><code class="docutils literal"><span class="pre">Array.from</span></code> 方法会将数组的空位，转为 <code class="docutils literal"><span class="pre">undefined</span></code> ，也就是说，这个方法不会忽略空位。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,,</span><span class="s1">&#39;b&#39;</span><span class="p">])</span> <span class="c1">// [ &quot;a&quot;, undefined, &quot;b&quot; ]</span>
</pre></div>
</div>
<p>扩展运算符（ <code class="docutils literal"><span class="pre">...</span></code> ）也会将空位转为 <code class="docutils literal"><span class="pre">undefined</span></code> 。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="p">[...[</span><span class="s1">&#39;a&#39;</span><span class="p">,,</span><span class="s1">&#39;b&#39;</span><span class="p">]]</span> <span class="c1">// [ &quot;a&quot;, undefined, &quot;b&quot; ]</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">copyWithin()</span></code> 会连空位一起拷贝。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="p">[,</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,,].</span><span class="nx">copyWithin</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// [,&quot;a&quot;,,&quot;a&quot;]</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">fill()</span></code> 会将空位视为正常的数组位置。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="c1">// [&quot;a&quot;,&quot;a&quot;,&quot;a&quot;]</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">for...of</span></code> 循环也会遍历空位。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[,</span> <span class="p">,];</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="k">of</span> <span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 1</span>
<span class="c1">// 1</span>
</pre></div>
</div>
<p>上面代码中，数组 <code class="docutils literal"><span class="pre">arr</span></code> 有两个空位， <code class="docutils literal"><span class="pre">for...of</span></code> 并没有忽略它们。如果改成 <code class="docutils literal"><span class="pre">map</span></code> 方法遍历，空位是会跳过的。</p>
<p><code class="docutils literal"><span class="pre">entries()</span></code> 、 <code class="docutils literal"><span class="pre">keys()</span></code> 、 <code class="docutils literal"><span class="pre">values()</span></code> 、 <code class="docutils literal"><span class="pre">find()</span></code> 和 <code class="docutils literal"><span class="pre">findIndex()</span></code> 会将空位处理成 <code class="docutils literal"><span class="pre">undefined</span></code> 。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// entries()</span>
<span class="p">[...[,</span><span class="s1">&#39;a&#39;</span><span class="p">].</span><span class="nx">entries</span><span class="p">()]</span> <span class="c1">// [[0,undefined], [1,&quot;a&quot;]]</span>

<span class="c1">// keys()</span>
<span class="p">[...[,</span><span class="s1">&#39;a&#39;</span><span class="p">].</span><span class="nx">keys</span><span class="p">()]</span> <span class="c1">// [0,1]</span>

<span class="c1">// values()</span>
<span class="p">[...[,</span><span class="s1">&#39;a&#39;</span><span class="p">].</span><span class="nx">values</span><span class="p">()]</span> <span class="c1">// [undefined,&quot;a&quot;]</span>

<span class="c1">// find()</span>
<span class="p">[,</span><span class="s1">&#39;a&#39;</span><span class="p">].</span><span class="nx">find</span><span class="p">(</span><span class="nx">x</span> <span class="p">=&gt;</span> <span class="kc">true</span><span class="p">)</span> <span class="c1">// undefined</span>

<span class="c1">// findIndex()</span>
<span class="p">[,</span><span class="s1">&#39;a&#39;</span><span class="p">].</span><span class="nx">findIndex</span><span class="p">(</span><span class="nx">x</span> <span class="p">=&gt;</span> <span class="kc">true</span><span class="p">)</span> <span class="c1">// 0</span>
</pre></div>
</div>
<p>由于空位的处理规则非常不统一，所以建议避免出现空位。</p>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="对象的扩展.html" class="btn btn-neutral float-right" title="10. 对象的扩展" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="函数的扩展.html" class="btn btn-neutral" title="8. 函数的扩展" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, lzh.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.0',
            LANGUAGE:'zh_CN',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="_static/translations.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();

      });


      $(document).ready(function(){
        var offset = sessionStorage.getItem("offsetTop");
        $('.wy-side-scroll').scrollTop(offset);
        sessionStorage.setItem("offsetTop", 0);


        $('.wy-menu > ul').click(function(){
            sessionStorage.setItem("offsetTop", $('.wy-side-scroll').scrollTop());
        });
      })

  </script>
   

</body>
</html>