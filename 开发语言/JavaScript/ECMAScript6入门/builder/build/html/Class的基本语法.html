

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>20. Class 的基本语法 &mdash; ECMAScript6入门 1.0 文档</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="索引"
              href="genindex.html"/>
        <link rel="search" title="搜索" href="search.html"/>
    <link rel="top" title="ECMAScript6入门 1.0 文档" href="index.html"/>
        <link rel="next" title="21. Class的继承" href="Class的继承.html"/>
        <link rel="prev" title="19. asyn函数" href="async函数.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> ECMAScript6入门
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="前言.html">1. 前言</a></li>
<li class="toctree-l1"><a class="reference internal" href="ECMAScript6简介.html">2. ECMAScript6简介</a></li>
<li class="toctree-l1"><a class="reference internal" href="let和const命令.html">3. let 和 const 命令</a></li>
<li class="toctree-l1"><a class="reference internal" href="变量的解构赋值.html">4. 变量的解构赋值</a></li>
<li class="toctree-l1"><a class="reference internal" href="字符串的扩展.html">5. 字符串的扩展</a></li>
<li class="toctree-l1"><a class="reference internal" href="正则的扩展.html">6. 正则的扩展</a></li>
<li class="toctree-l1"><a class="reference internal" href="数值的扩展.html">7. 数值的扩展</a></li>
<li class="toctree-l1"><a class="reference internal" href="函数的扩展.html">8. 函数的扩展</a></li>
<li class="toctree-l1"><a class="reference internal" href="数组的扩展.html">9. 数组的扩展</a></li>
<li class="toctree-l1"><a class="reference internal" href="对象的扩展.html">10. 对象的扩展</a></li>
<li class="toctree-l1"><a class="reference internal" href="Symbol.html">11. Symbol</a></li>
<li class="toctree-l1"><a class="reference internal" href="Set和Map数据结构.html">12. Set和Map数据结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="Proxy.html">13. Proxy</a></li>
<li class="toctree-l1"><a class="reference internal" href="Reflect.html">14. Reflect</a></li>
<li class="toctree-l1"><a class="reference internal" href="Promise对象.html">15. Promise对象</a></li>
<li class="toctree-l1"><a class="reference internal" href="Iterator和for...of循环.html">16. Iterator 和 for…of 循环</a></li>
<li class="toctree-l1"><a class="reference internal" href="Generator函数的语法.html">17. Generator函数的语法</a></li>
<li class="toctree-l1"><a class="reference internal" href="Generator函数的异步应用.html">18. Generator 函数的异步应用</a></li>
<li class="toctree-l1"><a class="reference internal" href="async函数.html">19. asyn函数</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">20. Class 的基本语法</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1">20.1. 简介</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id2">20.2. 严格模式</a></li>
<li class="toctree-l2"><a class="reference internal" href="#constructor">20.3. constructor 方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">20.4. 类的实例对象</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id4">20.5. Class 表达式</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id5">20.6. 不存在变量提升</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id6">20.7. 私有方法和私有属性</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id7">20.7.1. 私有属性的提案</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#this">20.8. this 的指向</a></li>
<li class="toctree-l2"><a class="reference internal" href="#name">20.9. name 属性</a></li>
<li class="toctree-l2"><a class="reference internal" href="#class-getter-setter">20.10. Class 的取值函数（getter）和存值函数（setter）</a></li>
<li class="toctree-l2"><a class="reference internal" href="#class-generator">20.11. Class 的 Generator 方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id8">20.12. Class 的静态方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id9">20.13. Class 的静态属性和实例属性</a></li>
<li class="toctree-l2"><a class="reference internal" href="#new-target">20.14. new.target 属性</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Class的继承.html">21. Class的继承</a></li>
<li class="toctree-l1"><a class="reference internal" href="Decorator.html">22. 修饰器</a></li>
<li class="toctree-l1"><a class="reference internal" href="Module的语法.html">23. Module 的语法</a></li>
<li class="toctree-l1"><a class="reference internal" href="Module的加载实现.html">24. Module 的加载实现</a></li>
<li class="toctree-l1"><a class="reference internal" href="编程风格.html">25. 编程风格</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">ECMAScript6入门</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>20. Class 的基本语法</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="class">
<h1>20. Class 的基本语法<a class="headerlink" href="#class" title="永久链接至标题">¶</a></h1>
<div class="section" id="id1">
<h2>20.1. 简介<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p><code class="docutils literal"><span class="pre">JavaScript</span></code> 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">Point</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">Point</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">toString</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="s1">&#39;(&#39;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<p>上面这种写法跟传统的面向对象语言（比如 <code class="docutils literal"><span class="pre">C++</span></code> 和 <code class="docutils literal"><span class="pre">Java</span></code> ）差异很大，很容易让新学习这门语言的程序员感到困惑。</p>
<p>ES6 提供了更接近传统语言的写法，引入了 <code class="docutils literal"><span class="pre">Class</span></code> （类）这个概念，作为对象的模板。通过 <code class="docutils literal"><span class="pre">class</span></code> 关键字，可以定义类。</p>
<p>基本上，ES6 的 <code class="docutils literal"><span class="pre">class</span></code> 可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的 <code class="docutils literal"><span class="pre">class</span></code> 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的 <code class="docutils literal"><span class="pre">class</span></code> 改写，就是下面这样。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">//定义类</span>
<span class="kr">class</span> <span class="nx">Point</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">toString</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s1">&#39;(&#39;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码定义了一个“类”，可以看到里面有一个 <code class="docutils literal"><span class="pre">constructor</span></code> 方法，这就是构造方法，而 <code class="docutils literal"><span class="pre">this</span></code> 关键字则代表实例对象。也就是说，ES5 的构造函数 <code class="docutils literal"><span class="pre">Point</span></code> ，对应 ES6 的 <code class="docutils literal"><span class="pre">Point</span></code> 类的构造方法。</p>
<p><code class="docutils literal"><span class="pre">Point</span></code> 类除了构造方法，还定义了一个 <code class="docutils literal"><span class="pre">toString</span></code> 方法。注意，定义“类”的方法的时候，前面不需要加上 <code class="docutils literal"><span class="pre">function</span></code> 这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。</p>
<p>ES6 的类，完全可以看作构造函数的另一种写法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Point</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="k">typeof</span> <span class="nx">Point</span> <span class="c1">// &quot;function&quot;</span>
<span class="nx">Point</span> <span class="o">===</span> <span class="nx">Point</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">constructor</span> <span class="c1">// true</span>
</pre></div>
</div>
<p>上面代码表明，类的数据类型就是函数，类本身就指向构造函数。</p>
<p>使用的时候，也是直接对类使用 <code class="docutils literal"><span class="pre">new</span></code> 命令，跟构造函数的用法完全一致。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Bar</span> <span class="p">{</span>
  <span class="nx">doStuff</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;stuff&#39;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Bar</span><span class="p">();</span>
<span class="nx">b</span><span class="p">.</span><span class="nx">doStuff</span><span class="p">()</span> <span class="c1">// &quot;stuff&quot;</span>
</pre></div>
</div>
<p>构造函数的 <code class="docutils literal"><span class="pre">prototype</span></code> 属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的 <code class="docutils literal"><span class="pre">prototype</span></code> 属性上面。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Point</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>

  <span class="nx">toString</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>

  <span class="nx">toValue</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 等同于</span>

<span class="nx">Point</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">()</span> <span class="p">{},</span>
  <span class="nx">toString</span><span class="p">()</span> <span class="p">{},</span>
  <span class="nx">toValue</span><span class="p">()</span> <span class="p">{},</span>
<span class="p">};</span>
</pre></div>
</div>
<p>在类的实例上面调用方法，其实就是调用原型上的方法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">B</span> <span class="p">{}</span>
<span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">B</span><span class="p">();</span>

<span class="nx">b</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">===</span> <span class="nx">B</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">constructor</span> <span class="c1">// true</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">b</span></code> 是 <code class="docutils literal"><span class="pre">B</span></code> 类的实例，它的 <code class="docutils literal"><span class="pre">constructor</span></code> 方法就是 <code class="docutils literal"><span class="pre">B</span></code> 类原型的 <code class="docutils literal"><span class="pre">constructor</span></code> 方法。</p>
<p>由于类的方法都定义在 <code class="docutils literal"><span class="pre">prototype</span></code> 对象上面，所以类的新方法可以添加在 <code class="docutils literal"><span class="pre">prototype</span></code> 对象上面。 <code class="docutils literal"><span class="pre">Object.assign</span></code> 方法可以很方便地一次向类添加多个方法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Point</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">(){</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">Point</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="p">{</span>
  <span class="nx">toString</span><span class="p">(){},</span>
  <span class="nx">toValue</span><span class="p">(){}</span>
<span class="p">});</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">prototype</span></code> 对象的 <code class="docutils literal"><span class="pre">constructor</span></code> 属性，直接指向“类”的本身，这与 ES5 的行为是一致的。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="nx">Point</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">===</span> <span class="nx">Point</span> <span class="c1">// true</span>
</pre></div>
</div>
<p>另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Point</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>

  <span class="nx">toString</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">Point</span><span class="p">.</span><span class="nx">prototype</span><span class="p">)</span>
<span class="c1">// []</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyNames</span><span class="p">(</span><span class="nx">Point</span><span class="p">.</span><span class="nx">prototype</span><span class="p">)</span>
<span class="c1">// [&quot;constructor&quot;,&quot;toString&quot;]</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">toString</span></code> 方法是 <code class="docutils literal"><span class="pre">Point</span></code> 类内部定义的方法，它是不可枚举的。这一点与 ES5 的行为不一致。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">Point</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">};</span>

<span class="nx">Point</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">toString</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">};</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">Point</span><span class="p">.</span><span class="nx">prototype</span><span class="p">)</span>
<span class="c1">// [&quot;toString&quot;]</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyNames</span><span class="p">(</span><span class="nx">Point</span><span class="p">.</span><span class="nx">prototype</span><span class="p">)</span>
<span class="c1">// [&quot;constructor&quot;,&quot;toString&quot;]</span>
</pre></div>
</div>
<p>上面代码采用 ES5 的写法， <code class="docutils literal"><span class="pre">toString</span></code> 方法就是可枚举的。</p>
<p>类的属性名，可以采用表达式。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">methodName</span> <span class="o">=</span> <span class="s1">&#39;getArea&#39;</span><span class="p">;</span>

<span class="kr">class</span> <span class="nx">Square</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">(</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>

  <span class="p">[</span><span class="nx">methodName</span><span class="p">]()</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">Square</span></code> 类的方法名 <code class="docutils literal"><span class="pre">getArea</span></code> ，是从表达式得到的。</p>
</div>
<div class="section" id="id2">
<h2>20.2. 严格模式<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>类和模块的内部，默认就是严格模式，所以不需要使用 <code class="docutils literal"><span class="pre">use</span> <span class="pre">strict</span></code> 指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。</p>
<p>考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。</p>
</div>
<div class="section" id="constructor">
<h2>20.3. constructor 方法<a class="headerlink" href="#constructor" title="永久链接至标题">¶</a></h2>
<p><code class="docutils literal"><span class="pre">constructor</span></code> 方法是类的默认方法，通过 <code class="docutils literal"><span class="pre">new</span></code> 命令生成对象实例时，自动调用该方法。一个类必须有 <code class="docutils literal"><span class="pre">constructor</span></code> 方法，如果没有显式定义，一个空的 <code class="docutils literal"><span class="pre">constructor</span></code> 方法会被默认添加。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Point</span> <span class="p">{</span>
<span class="p">}</span>

<span class="c1">// 等同于</span>
<span class="kr">class</span> <span class="nx">Point</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码中，定义了一个空的类 <code class="docutils literal"><span class="pre">Point</span></code> ，JavaScript 引擎会自动为它添加一个空的 <code class="docutils literal"><span class="pre">constructor</span></code> 方法。</p>
<p><code class="docutils literal"><span class="pre">constructor</span></code> 方法默认返回实例对象（即 <code class="docutils literal"><span class="pre">this</span></code> ），完全可以指定返回另外一个对象。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Foo</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">new</span> <span class="nx">Foo</span><span class="p">()</span> <span class="k">instanceof</span> <span class="nx">Foo</span>
<span class="c1">// false</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">constructor</span></code> 函数返回一个全新的对象，结果导致实例对象不是 <code class="docutils literal"><span class="pre">Foo</span></code> 类的实例。</p>
<p>类必须使用 <code class="docutils literal"><span class="pre">new</span></code> 调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用 <code class="docutils literal"><span class="pre">new</span></code> 也可以执行。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Foo</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">Foo</span><span class="p">()</span>
<span class="c1">// TypeError: Class constructor Foo cannot be invoked without &#39;new&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h2>20.4. 类的实例对象<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>生成类的实例对象的写法，与 ES5 完全一样，也是使用 <code class="docutils literal"><span class="pre">new</span></code> 命令。前面说过，如果忘记加上 <code class="docutils literal"><span class="pre">new</span></code> ，像函数那样调用 <code class="docutils literal"><span class="pre">Class</span></code> ，将会报错。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Point</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// 报错</span>
<span class="kd">var</span> <span class="nx">point</span> <span class="o">=</span> <span class="nx">Point</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>

<span class="c1">// 正确</span>
<span class="kd">var</span> <span class="nx">point</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</pre></div>
</div>
<p>与 ES5 一样，实例的属性除非显式定义在其本身（即定义在 <code class="docutils literal"><span class="pre">this</span></code> 对象上），否则都是定义在原型上（即定义在 <code class="docutils literal"><span class="pre">class</span></code> 上）。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">//定义类</span>
<span class="kr">class</span> <span class="nx">Point</span> <span class="p">{</span>

  <span class="nx">constructor</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">toString</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s1">&#39;(&#39;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span><span class="p">;</span>
  <span class="p">}</span>

<span class="p">}</span>

<span class="kd">var</span> <span class="nx">point</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>

<span class="nx">point</span><span class="p">.</span><span class="nx">toString</span><span class="p">()</span> <span class="c1">// (2, 3)</span>

<span class="nx">point</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nx">point</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nx">point</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="s1">&#39;toString&#39;</span><span class="p">)</span> <span class="c1">// false</span>
<span class="nx">point</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="s1">&#39;toString&#39;</span><span class="p">)</span> <span class="c1">// true</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">x</span></code> 和 <code class="docutils literal"><span class="pre">y</span></code> 都是实例对象 <code class="docutils literal"><span class="pre">point</span></code> 自身的属性（因为定义在 <code class="docutils literal"><span class="pre">this</span></code> 变量上），所以 <code class="docutils literal"><span class="pre">hasOwnProperty</span></code> 方法返回 <code class="docutils literal"><span class="pre">true</span></code> ，而 <code class="docutils literal"><span class="pre">toString</span></code> 是原型对象的属性（因为定义在 <code class="docutils literal"><span class="pre">Point</span></code> 类上），所以 <code class="docutils literal"><span class="pre">hasOwnProperty</span></code> 方法返回 <code class="docutils literal"><span class="pre">false</span></code> 。这些都与 ES5 的行为保持一致。</p>
<p>与 ES5 一样，类的所有实例共享一个原型对象。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>

<span class="nx">p1</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nx">p2</span><span class="p">.</span><span class="nx">__proto__</span>
<span class="c1">//true</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">p1</span></code> 和 <code class="docutils literal"><span class="pre">p2</span></code> 都是 <code class="docutils literal"><span class="pre">Point</span></code> 的实例，它们的原型都是 <code class="docutils literal"><span class="pre">Point.prototype</span></code> ，所以 <code class="docutils literal"><span class="pre">__proto__</span></code> 属性是相等的。</p>
<p>这也意味着，可以通过实例的 <code class="docutils literal"><span class="pre">__proto__</span></code> 属性为“类”添加方法。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last"><code class="docutils literal"><span class="pre">__proto__</span></code> 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 <code class="docutils literal"><span class="pre">Object.getPrototypeOf</span></code> 方法来获取实例对象的原型，然后再来为原型添加方法/属性。</p>
</div>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>

<span class="nx">p1</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">printName</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="s1">&#39;Oops&#39;</span> <span class="p">};</span>

<span class="nx">p1</span><span class="p">.</span><span class="nx">printName</span><span class="p">()</span> <span class="c1">// &quot;Oops&quot;</span>
<span class="nx">p2</span><span class="p">.</span><span class="nx">printName</span><span class="p">()</span> <span class="c1">// &quot;Oops&quot;</span>

<span class="kd">var</span> <span class="nx">p3</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
<span class="nx">p3</span><span class="p">.</span><span class="nx">printName</span><span class="p">()</span> <span class="c1">// &quot;Oops&quot;</span>
</pre></div>
</div>
<p>上面代码在 <code class="docutils literal"><span class="pre">p1</span></code> 的原型上添加了一个 <code class="docutils literal"><span class="pre">printName</span></code> 方法，由于 <code class="docutils literal"><span class="pre">p1</span></code> 的原型就是 <code class="docutils literal"><span class="pre">p2</span></code> 的原型，因此 <code class="docutils literal"><span class="pre">p2</span></code> 也可以调用这个方法。而且，此后新建的实例 <code class="docutils literal"><span class="pre">p3</span></code> 也可以调用这个方法。这意味着，使用实例的 <code class="docutils literal"><span class="pre">__proto__</span></code> 属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。</p>
</div>
<div class="section" id="id4">
<h2>20.5. Class 表达式<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<p>与函数一样，类也可以使用表达式的形式定义。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">MyClass</span> <span class="o">=</span> <span class="kr">class</span> <span class="nx">Me</span> <span class="p">{</span>
  <span class="nx">getClassName</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">Me</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是 <code class="docutils literal"><span class="pre">MyClass</span></code> 而不是 <code class="docutils literal"><span class="pre">Me</span></code> ， <code class="docutils literal"><span class="pre">Me</span></code> 只在 <code class="docutils literal"><span class="pre">Class</span></code> <strong>的内部代码可用，指代当前类。</strong></p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">inst</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyClass</span><span class="p">();</span>
<span class="nx">inst</span><span class="p">.</span><span class="nx">getClassName</span><span class="p">()</span> <span class="c1">// Me</span>
<span class="nx">Me</span><span class="p">.</span><span class="nx">name</span> <span class="c1">// ReferenceError: Me is not defined</span>
</pre></div>
</div>
<p>上面代码表示， <code class="docutils literal"><span class="pre">Me</span></code> 只在 <code class="docutils literal"><span class="pre">Class</span></code> 内部有定义。</p>
<p>如果类的内部没用到的话，可以省略 <code class="docutils literal"><span class="pre">Me</span></code> ，也就是可以写成下面的形式。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">MyClass</span> <span class="o">=</span> <span class="kr">class</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>
</pre></div>
</div>
<p>采用 <code class="docutils literal"><span class="pre">Class</span></code> 表达式，可以写出立即执行的 <code class="docutils literal"><span class="pre">Class</span></code> 。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">person</span> <span class="o">=</span> <span class="k">new</span> <span class="kr">class</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">sayName</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}(</span><span class="s1">&#39;张三&#39;</span><span class="p">);</span>

<span class="nx">person</span><span class="p">.</span><span class="nx">sayName</span><span class="p">();</span> <span class="c1">// &quot;张三&quot;</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">person</span></code> 是一个立即执行的类的实例。</p>
</div>
<div class="section" id="id5">
<h2>20.6. 不存在变量提升<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<p>类不存在变量提升（hoist），这一点与 ES5 完全不同。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="k">new</span> <span class="nx">Foo</span><span class="p">();</span> <span class="c1">// ReferenceError</span>
<span class="kr">class</span> <span class="nx">Foo</span> <span class="p">{}</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">Foo</span></code> 类使用在前，定义在后，这样会报错，因为 ES6 不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="kd">let</span> <span class="nx">Foo</span> <span class="o">=</span> <span class="kr">class</span> <span class="p">{};</span>
  <span class="kr">class</span> <span class="nx">Bar</span> <span class="kr">extends</span> <span class="nx">Foo</span> <span class="p">{</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码不会报错，因为 <code class="docutils literal"><span class="pre">Bar</span></code> 继承 <code class="docutils literal"><span class="pre">Foo</span></code> 的时候， <code class="docutils literal"><span class="pre">Foo</span></code> 已经有定义了。但是，如果存在 <code class="docutils literal"><span class="pre">class</span></code> 的提升，上面代码就会报错，因为 <code class="docutils literal"><span class="pre">class</span></code> 会被提升到代码头部，而 <code class="docutils literal"><span class="pre">let</span></code> 命令是不提升的，所以导致 <code class="docutils literal"><span class="pre">Bar</span></code> 继承 <code class="docutils literal"><span class="pre">Foo</span></code> 的时候， <code class="docutils literal"><span class="pre">Foo</span></code> 还没有定义。</p>
</div>
<div class="section" id="id6">
<h2>20.7. 私有方法和私有属性<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h2>
<p>私有方法是常见需求，但 ES6 不提供，只能通过变通方法模拟实现。</p>
<p>一种做法是在命名上加以区别。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Widget</span> <span class="p">{</span>

  <span class="c1">// 公有方法</span>
  <span class="nx">foo</span> <span class="p">(</span><span class="nx">baz</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">_bar</span><span class="p">(</span><span class="nx">baz</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// 私有方法</span>
  <span class="nx">_bar</span><span class="p">(</span><span class="nx">baz</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">snaf</span> <span class="o">=</span> <span class="nx">baz</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">_bar</span></code> 方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。</p>
<p>另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Widget</span> <span class="p">{</span>
  <span class="nx">foo</span> <span class="p">(</span><span class="nx">baz</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">bar</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">baz</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">bar</span><span class="p">(</span><span class="nx">baz</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">snaf</span> <span class="o">=</span> <span class="nx">baz</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">foo</span></code> 是公有方法，内部调用了 <code class="docutils literal"><span class="pre">bar.call(this,</span> <span class="pre">baz)</span></code> 。这使得 <code class="docutils literal"><span class="pre">bar</span></code> 实际上成为了当前模块的私有方法。</p>
<p>还有一种方法是利用 <code class="docutils literal"><span class="pre">Symbol</span></code> 值的唯一性，将私有方法的名字命名为一个 <code class="docutils literal"><span class="pre">Symbol</span></code> 值。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">bar</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s1">&#39;bar&#39;</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">snaf</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s1">&#39;snaf&#39;</span><span class="p">);</span>

<span class="kr">export</span> <span class="k">default</span> <span class="kr">class</span> <span class="nx">myClass</span><span class="p">{</span>

  <span class="c1">// 公有方法</span>
  <span class="nx">foo</span><span class="p">(</span><span class="nx">baz</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">[</span><span class="nx">bar</span><span class="p">](</span><span class="nx">baz</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// 私有方法</span>
  <span class="p">[</span><span class="nx">bar</span><span class="p">](</span><span class="nx">baz</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">[</span><span class="nx">snaf</span><span class="p">]</span> <span class="o">=</span> <span class="nx">baz</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// ...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">bar</span></code> 和 <code class="docutils literal"><span class="pre">snaf</span></code> 都是 <code class="docutils literal"><span class="pre">Symbol</span></code> 值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果。</p>
<div class="section" id="id7">
<h3>20.7.1. 私有属性的提案<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h3>
<p>与私有方法一样，ES6 不支持私有属性。目前，有一个提案，为 <code class="docutils literal"><span class="pre">class</span></code> 加了私有属性。方法是在属性名之前，使用 <code class="docutils literal"><span class="pre">#</span></code> 表示。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span>class Point {
  #x;

  constructor(x = 0) {
    #x = +x; // 写成 this.#x 亦可
  }

  get x() { return #x }
  set x(value) { #x = +value }
}
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">#x</span></code> 就是私有属性，在 <code class="docutils literal"><span class="pre">Point</span></code> 类之外是读取不到这个属性的。由于井号 <code class="docutils literal"><span class="pre">#``是属性名的一部分，使用时必须带有</span> <span class="pre">``#</span></code> 一起使用，所以 <code class="docutils literal"><span class="pre">#x</span></code> 和 <code class="docutils literal"><span class="pre">x</span></code> 是两个不同的属性。</p>
<p>私有属性可以指定初始值，在构造函数执行时进行初始化。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span>class Point {
  #x = 0;
  constructor() {
    #x; // 0
  }
}
</pre></div>
</div>
<p>之所以要引入一个新的前缀 <code class="docutils literal"><span class="pre">#</span></code> 表示私有属性，而没有采用 <code class="docutils literal"><span class="pre">private</span></code> 关键字，是因为 <code class="docutils literal"><span class="pre">JavaScript</span></code> 是一门动态语言，使用独立的符号似乎是唯一的可靠方法，能够准确地区分一种属性是否为私有属性。另外， <code class="docutils literal"><span class="pre">Ruby</span></code> 语言使用 <code class="docutils literal"><span class="pre">&#64;</span></code> 表示私有属性，ES6 没有用这个符号而使用 <code class="docutils literal"><span class="pre">#</span></code> ，是因为 <code class="docutils literal"><span class="pre">&#64;</span></code> 已经被留给了  <code class="docutils literal"><span class="pre">Decorator</span></code> 。</p>
<p>这种写法不仅可以写私有属性，还可以用来写私有方法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span>class Foo {
  #a;
  #b;
  #sum() { return #a + #b; }
  printSum() { console.log(#sum()); }
  constructor(a, b) { #a = a; #b = b; }
}
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">#sum()</span></code> 就是一个私有方法。</p>
<p>另外，私有属性也可以设置 <code class="docutils literal"><span class="pre">getter</span></code> 和 <code class="docutils literal"><span class="pre">setter</span></code> 方法。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span>class Counter {
  #xValue = 0;

  get #x() { return #xValue; }
  set #x(value) {
    this.#xValue = value;
  }

  constructor() {
    super();
    // ...
  }
}
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">#x</span></code> 是一个私有属性，它的读写都通过 <code class="docutils literal"><span class="pre">get</span> <span class="pre">#x()</span></code> 和 <code class="docutils literal"><span class="pre">set</span> <span class="pre">#x()</span></code> 来完成。</p>
</div>
</div>
<div class="section" id="this">
<h2>20.8. this 的指向<a class="headerlink" href="#this" title="永久链接至标题">¶</a></h2>
<p>类的方法内部如果含有 <code class="docutils literal"><span class="pre">this</span></code> ，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Logger</span> <span class="p">{</span>
  <span class="nx">printName</span><span class="p">(</span><span class="nx">name</span> <span class="o">=</span> <span class="s1">&#39;there&#39;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">print</span><span class="p">(</span><span class="sb">`Hello </span><span class="si">${</span><span class="nx">name</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="nx">print</span><span class="p">(</span><span class="nx">text</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">text</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">logger</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Logger</span><span class="p">();</span>
<span class="kr">const</span> <span class="p">{</span> <span class="nx">printName</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">logger</span><span class="p">;</span> <span class="c1">// 对象的解构</span>
<span class="nx">printName</span><span class="p">();</span> <span class="c1">// TypeError: Cannot read property &#39;print&#39; of undefined</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">printName</span></code> 方法中的 <code class="docutils literal"><span class="pre">this</span></code> ，默认指向 <code class="docutils literal"><span class="pre">Logger</span></code> 类的实例。但是，如果将这个方法提取出来单独使用， <code class="docutils literal"><span class="pre">this</span></code> 会指向该方法运行时所在的环境，因为找不到 <code class="docutils literal"><span class="pre">print</span></code> 方法而导致报错。</p>
<p>一个比较简单的解决方法是，在构造方法中绑定 <code class="docutils literal"><span class="pre">this</span></code> ，这样就不会找不到 <code class="docutils literal"><span class="pre">print</span></code> 方法了。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Logger</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">printName</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">printName</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>另一种解决方法是使用箭头函数。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Logger</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">printName</span> <span class="o">=</span> <span class="p">(</span><span class="nx">name</span> <span class="o">=</span> <span class="s1">&#39;there&#39;</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">print</span><span class="p">(</span><span class="sb">`Hello </span><span class="si">${</span><span class="nx">name</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
    <span class="p">};</span>
  <span class="p">}</span>

  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>还有一种解决方法是使用 <code class="docutils literal"><span class="pre">Proxy</span></code> ，获取方法的时候，自动绑定 <code class="docutils literal"><span class="pre">this</span></code> 。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">selfish</span> <span class="p">(</span><span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">cache</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WeakMap</span><span class="p">();</span>
  <span class="kr">const</span> <span class="nx">handler</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">get</span> <span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
      <span class="kr">const</span> <span class="nx">value</span> <span class="o">=</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">value</span> <span class="o">!==</span> <span class="s1">&#39;function&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">value</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">cache</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">value</span><span class="p">))</span> <span class="p">{</span>
        <span class="nx">cache</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">value</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">target</span><span class="p">));</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">cache</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">};</span>
  <span class="kr">const</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">handler</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">proxy</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">logger</span> <span class="o">=</span> <span class="nx">selfish</span><span class="p">(</span><span class="k">new</span> <span class="nx">Logger</span><span class="p">());</span>
</pre></div>
</div>
</div>
<div class="section" id="name">
<h2>20.9. name 属性<a class="headerlink" href="#name" title="永久链接至标题">¶</a></h2>
<p>由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被 <code class="docutils literal"><span class="pre">Class</span></code> 继承，包括 <code class="docutils literal"><span class="pre">name</span></code> 属性。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Point</span> <span class="p">{}</span>
<span class="nx">Point</span><span class="p">.</span><span class="nx">name</span> <span class="c1">// &quot;Point&quot;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">name</span></code> 属性总是返回紧跟在 <code class="docutils literal"><span class="pre">class</span></code> 关键字后面的类名。</p>
</div>
<div class="section" id="class-getter-setter">
<h2>20.10. Class 的取值函数（getter）和存值函数（setter）<a class="headerlink" href="#class-getter-setter" title="永久链接至标题">¶</a></h2>
<p>与 ES5 一样，在“类”的内部可以使用 <code class="docutils literal"><span class="pre">get</span></code> 和 <code class="docutils literal"><span class="pre">set</span></code> 关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">MyClass</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
  <span class="nx">get</span> <span class="nx">prop</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s1">&#39;getter&#39;</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nx">set</span> <span class="nx">prop</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;setter: &#39;</span><span class="o">+</span><span class="nx">value</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">inst</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyClass</span><span class="p">();</span>

<span class="nx">inst</span><span class="p">.</span><span class="nx">prop</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
<span class="c1">// setter: 123</span>

<span class="nx">inst</span><span class="p">.</span><span class="nx">prop</span>
<span class="c1">// &#39;getter&#39;</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">prop</span></code> 属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。</p>
<p>存值函数和取值函数是设置在属性的 <code class="docutils literal"><span class="pre">Descriptor</span></code> 对象上的。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">CustomHTMLElement</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">(</span><span class="nx">element</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">element</span> <span class="o">=</span> <span class="nx">element</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">get</span> <span class="nx">html</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">element</span><span class="p">.</span><span class="nx">innerHTML</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">set</span> <span class="nx">html</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">element</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">descriptor</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span>
  <span class="nx">CustomHTMLElement</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="s2">&quot;html&quot;</span>
<span class="p">);</span>

<span class="s2">&quot;get&quot;</span> <span class="k">in</span> <span class="nx">descriptor</span>  <span class="c1">// true</span>
<span class="s2">&quot;set&quot;</span> <span class="k">in</span> <span class="nx">descriptor</span>  <span class="c1">// true</span>
</pre></div>
</div>
<p>上面代码中，存值函数和取值函数是定义在 <code class="docutils literal"><span class="pre">html</span></code> 属性的描述对象上面，这与 ES5 完全一致。</p>
</div>
<div class="section" id="class-generator">
<h2>20.11. Class 的 Generator 方法<a class="headerlink" href="#class-generator" title="永久链接至标题">¶</a></h2>
<p>如果某个方法之前加上星号（ <code class="docutils literal"><span class="pre">*</span></code> ），就表示该方法是一个 <code class="docutils literal"><span class="pre">Generator</span></code> 函数。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Foo</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">(...</span><span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">args</span> <span class="o">=</span> <span class="nx">args</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="o">*</span> <span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">arg</span> <span class="k">of</span> <span class="k">this</span><span class="p">.</span><span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">yield</span> <span class="nx">arg</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="k">of</span> <span class="k">new</span> <span class="nx">Foo</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">,</span> <span class="s1">&#39;world&#39;</span><span class="p">))</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// hello</span>
<span class="c1">// world</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">Foo</span></code> 类的 <code class="docutils literal"><span class="pre">Symbol.iterator</span></code> 方法前有一个星号，表示该方法是一个 <code class="docutils literal"><span class="pre">Generator</span></code> 函数。 <code class="docutils literal"><span class="pre">Symbol.iterator</span></code> 方法返回一个 <code class="docutils literal"><span class="pre">Foo</span></code> 类的默认遍历器， <code class="docutils literal"><span class="pre">for...of</span></code> 循环会自动调用这个遍历器。</p>
</div>
<div class="section" id="id8">
<h2>20.12. Class 的静态方法<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h2>
<p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上 <code class="docutils literal"><span class="pre">static</span></code> 关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Foo</span> <span class="p">{</span>
  <span class="kr">static</span> <span class="nx">classMethod</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s1">&#39;hello&#39;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">Foo</span><span class="p">.</span><span class="nx">classMethod</span><span class="p">()</span> <span class="c1">// &#39;hello&#39;</span>

<span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Foo</span><span class="p">();</span>
<span class="nx">foo</span><span class="p">.</span><span class="nx">classMethod</span><span class="p">()</span>
<span class="c1">// TypeError: foo.classMethod is not a function</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">Foo</span></code> 类的 <code class="docutils literal"><span class="pre">classMethod</span></code> 方法前有 <code class="docutils literal"><span class="pre">static</span></code> 关键字，表明该方法是一个静态方法，可以直接在 <code class="docutils literal"><span class="pre">Foo</span></code> 类上调用( <code class="docutils literal"><span class="pre">Foo.classMethod()</span></code> )，而不是在 <code class="docutils literal"><span class="pre">Foo</span></code> 类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。</p>
<p>注意，如果静态方法包含 <code class="docutils literal"><span class="pre">this</span></code> 关键字，这个 <code class="docutils literal"><span class="pre">this</span></code> 指的是类，而不是实例。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Foo</span> <span class="p">{</span>
  <span class="kr">static</span> <span class="nx">bar</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">baz</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="kr">static</span> <span class="nx">baz</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="nx">baz</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;world&#39;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">Foo</span><span class="p">.</span><span class="nx">bar</span><span class="p">()</span> <span class="c1">// hello</span>
</pre></div>
</div>
<p>上面代码中，静态方法 <code class="docutils literal"><span class="pre">bar</span></code> 调用了 <code class="docutils literal"><span class="pre">this.baz</span></code> ，这里的 <code class="docutils literal"><span class="pre">this</span></code> 指的是 <code class="docutils literal"><span class="pre">Foo</span></code> 类，而不是 <code class="docutils literal"><span class="pre">Foo</span></code> 的实例，等同于调用 <code class="docutils literal"><span class="pre">Foo.baz</span></code> 。另外，从这个例子还可以看出，静态方法可以与非静态方法重名。</p>
<p>父类的静态方法，可以被子类继承。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Foo</span> <span class="p">{</span>
  <span class="kr">static</span> <span class="nx">classMethod</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s1">&#39;hello&#39;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kr">class</span> <span class="nx">Bar</span> <span class="kr">extends</span> <span class="nx">Foo</span> <span class="p">{</span>
<span class="p">}</span>

<span class="nx">Bar</span><span class="p">.</span><span class="nx">classMethod</span><span class="p">()</span> <span class="c1">// &#39;hello&#39;</span>
</pre></div>
</div>
<p>上面代码中，父类 <code class="docutils literal"><span class="pre">Foo</span></code> 有一个静态方法，子类 <code class="docutils literal"><span class="pre">Bar</span></code> 可以调用这个方法。</p>
<p>静态方法也是可以从 <code class="docutils literal"><span class="pre">super</span></code> 对象上调用的。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Foo</span> <span class="p">{</span>
  <span class="kr">static</span> <span class="nx">classMethod</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s1">&#39;hello&#39;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kr">class</span> <span class="nx">Bar</span> <span class="kr">extends</span> <span class="nx">Foo</span> <span class="p">{</span>
  <span class="kr">static</span> <span class="nx">classMethod</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kr">super</span><span class="p">.</span><span class="nx">classMethod</span><span class="p">()</span> <span class="o">+</span> <span class="s1">&#39;, too&#39;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">Bar</span><span class="p">.</span><span class="nx">classMethod</span><span class="p">()</span> <span class="c1">// &quot;hello, too&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h2>20.13. Class 的静态属性和实例属性<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h2>
<p>静态属性指的是 <code class="docutils literal"><span class="pre">Class</span></code> 本身的属性，即 <code class="docutils literal"><span class="pre">Class.propName</span></code> ，而不是定义在实例对象（ <code class="docutils literal"><span class="pre">this</span></code> ）上的属性。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Foo</span> <span class="p">{</span>
<span class="p">}</span>

<span class="nx">Foo</span><span class="p">.</span><span class="nx">prop</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nx">Foo</span><span class="p">.</span><span class="nx">prop</span> <span class="c1">// 1</span>
</pre></div>
</div>
<p>上面的写法为 <code class="docutils literal"><span class="pre">Foo</span></code> 类定义了一个静态属性 <code class="docutils literal"><span class="pre">prop</span></code> 。</p>
<p>目前，只有这种写法可行，因为 ES6 明确规定， <code class="docutils literal"><span class="pre">Class</span></code> 内部只有静态方法，没有静态属性。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// 以下两种写法都无效</span>
<span class="kr">class</span> <span class="nx">Foo</span> <span class="p">{</span>
  <span class="c1">// 写法一</span>
  <span class="nx">prop</span><span class="o">:</span> <span class="mi">2</span>

  <span class="c1">// 写法二</span>
  <span class="kr">static</span> <span class="nx">prop</span><span class="o">:</span> <span class="mi">2</span>
<span class="p">}</span>

<span class="nx">Foo</span><span class="p">.</span><span class="nx">prop</span> <span class="c1">// undefined</span>
</pre></div>
</div>
<p>目前有一个静态属性的提案，对实例属性和静态属性都规定了新的写法。</p>
<ol class="arabic simple">
<li>类的实例属性</li>
</ol>
<p>类的实例属性可以用等式，写入类的定义之中。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">MyClass</span> <span class="p">{</span>
  <span class="nx">myProp</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>

  <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">myProp</span><span class="p">);</span> <span class="c1">// 42</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">myProp</span></code> 就是 <code class="docutils literal"><span class="pre">MyClass</span></code> 的实例属性。在 <code class="docutils literal"><span class="pre">MyClass</span></code> 的实例上，可以读取这个属性。</p>
<p>以前，我们定义实例属性，只能写在类的 <code class="docutils literal"><span class="pre">constructor</span></code> 方法里面。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">ReactCounter</span> <span class="kr">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">super</span><span class="p">(</span><span class="nx">props</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">count</span><span class="o">:</span> <span class="mi">0</span>
    <span class="p">};</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码中，构造方法 <code class="docutils literal"><span class="pre">constructor</span></code> 里面，定义了 <code class="docutils literal"><span class="pre">this.state</span></code> 属性。</p>
<p>有了新的写法以后，可以不在 <code class="docutils literal"><span class="pre">constructor</span></code> 方法里面定义。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">ReactCounter</span> <span class="kr">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
  <span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">count</span><span class="o">:</span> <span class="mi">0</span>
  <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这种写法比以前更清晰。</p>
<p>为了可读性的目的，对于那些在 <code class="docutils literal"><span class="pre">constructor</span></code> 里面已经定义的实例属性，新写法允许直接列出。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">ReactCounter</span> <span class="kr">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
  <span class="nx">state</span><span class="p">;</span>
  <span class="nx">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">super</span><span class="p">(</span><span class="nx">props</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">count</span><span class="o">:</span> <span class="mi">0</span>
    <span class="p">};</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li>类的静态属性</li>
</ol>
<p>类的静态属性只要在上面的实例属性写法前面，加上 <code class="docutils literal"><span class="pre">static</span></code> 关键字就可以了。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">MyClass</span> <span class="p">{</span>
  <span class="kr">static</span> <span class="nx">myStaticProp</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>

  <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">MyClass</span><span class="p">.</span><span class="nx">myStaticProp</span><span class="p">);</span> <span class="c1">// 42</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>同样的，这个新写法大大方便了静态属性的表达。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="c1">// 老写法</span>
<span class="kr">class</span> <span class="nx">Foo</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
<span class="nx">Foo</span><span class="p">.</span><span class="nx">prop</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">// 新写法</span>
<span class="kr">class</span> <span class="nx">Foo</span> <span class="p">{</span>
  <span class="kr">static</span> <span class="nx">prop</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码中，老写法的静态属性定义在类的外部。整个类生成以后，再生成静态属性。这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则。另外，新写法是显式声明（ <code class="docutils literal"><span class="pre">declarative</span></code> ），而不是赋值处理，语义更好。</p>
</div>
<div class="section" id="new-target">
<h2>20.14. new.target 属性<a class="headerlink" href="#new-target" title="永久链接至标题">¶</a></h2>
<p><code class="docutils literal"><span class="pre">new</span></code> 是从构造函数生成实例对象的命令。ES6 为 <code class="docutils literal"><span class="pre">new</span></code> 命令引入了一个 <code class="docutils literal"><span class="pre">new.target</span></code> 属性，该属性一般用在构造函数之中，返回 <code class="docutils literal"><span class="pre">new</span></code> 命令作用于的那个构造函数。如果构造函数不是通过 <code class="docutils literal"><span class="pre">new</span></code> 命令调用的， <code class="docutils literal"><span class="pre">new.target</span></code> 会返回 <code class="docutils literal"><span class="pre">undefined</span></code> ，因此这个属性可以用来确定构造函数是怎么调用的。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">new</span><span class="p">.</span><span class="nx">target</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;必须使用 new 命令生成实例&#39;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 另一种写法</span>
<span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">new</span><span class="p">.</span><span class="nx">target</span> <span class="o">===</span> <span class="nx">Person</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;必须使用 new 命令生成实例&#39;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="s1">&#39;张三&#39;</span><span class="p">);</span> <span class="c1">// 正确</span>
<span class="kd">var</span> <span class="nx">notAPerson</span> <span class="o">=</span> <span class="nx">Person</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">person</span><span class="p">,</span> <span class="s1">&#39;张三&#39;</span><span class="p">);</span>  <span class="c1">// 报错</span>
</pre></div>
</div>
<p>上面代码确保构造函数只能通过 <code class="docutils literal"><span class="pre">new</span></code> 命令调用。</p>
<p><code class="docutils literal"><span class="pre">Class</span></code> 内部调用 <code class="docutils literal"><span class="pre">new.target</span></code> ，返回当前 <code class="docutils literal"><span class="pre">Class</span></code> 。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Rectangle</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">width</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">new</span><span class="p">.</span><span class="nx">target</span> <span class="o">===</span> <span class="nx">Rectangle</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="nx">length</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">width</span> <span class="o">=</span> <span class="nx">width</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Rectangle</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span> <span class="c1">// 输出 true</span>
</pre></div>
</div>
<p>需要注意的是，子类继承父类时， <code class="docutils literal"><span class="pre">new.target</span></code> 会返回子类。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Rectangle</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">width</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">new</span><span class="p">.</span><span class="nx">target</span> <span class="o">===</span> <span class="nx">Rectangle</span><span class="p">);</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kr">class</span> <span class="nx">Square</span> <span class="kr">extends</span> <span class="nx">Rectangle</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">(</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">super</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">length</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Square</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="c1">// 输出 false</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">new.target</span></code> 会返回子类。</p>
<p>利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Shape</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">new</span><span class="p">.</span><span class="nx">target</span> <span class="o">===</span> <span class="nx">Shape</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;本类不能实例化&#39;</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kr">class</span> <span class="nx">Rectangle</span> <span class="kr">extends</span> <span class="nx">Shape</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">width</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">super</span><span class="p">();</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Shape</span><span class="p">();</span>  <span class="c1">// 报错</span>
<span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Rectangle</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>  <span class="c1">// 正确</span>
</pre></div>
</div>
<p>上面代码中， <code class="docutils literal"><span class="pre">Shape</span></code> 类不能被实例化，只能用于继承。</p>
<p>注意，在函数外部，使用 <code class="docutils literal"><span class="pre">new.target</span></code> 会报错。</p>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Class的继承.html" class="btn btn-neutral float-right" title="21. Class的继承" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="async函数.html" class="btn btn-neutral" title="19. asyn函数" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, lzh.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.0',
            LANGUAGE:'zh_CN',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="_static/translations.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();

      });


      $(document).ready(function(){
        var offset = sessionStorage.getItem("offsetTop");
        $('.wy-side-scroll').scrollTop(offset);
        sessionStorage.setItem("offsetTop", 0);


        $('.wy-menu > ul').click(function(){
            sessionStorage.setItem("offsetTop", $('.wy-side-scroll').scrollTop());
        });
      })

  </script>
   

</body>
</html>