****
基本概念
****

变量
====
任何语言都离不开数据类型和变量。虽然 ``JavaScript`` 语言是弱类型语言，但它一样支持变量声明，变量一样存在作用范围，即有局部变量和全局变量之分。下面依次介绍 ``JavaScript`` 中数据类型和变量的基本语法。

变量是程序设计语言里最重要、最基本的概念，与强类型语言不同的是， ``JavaScript`` 是弱类型语言，同一个变量可以一会儿存储数值，一会儿存储字符串。正如前面所讲的，变量声明有两种方式，即显式声明和隐式声明。变量还有个重要的概念：作用范围。

声明变量
--------
``JavaScript`` 是弱类型脚本语言，使用变量之前，可以无须定义，想使用某个变量时直接使用即可。归纳起来， ``JavaScript`` 支持两种方式来引入变量。

- 隐式定义：直接给变量赋值。
- 显式定义：使用 ``var`` 关键字定义变量。

隐式定义的方式简单、快捷，需要使用变量时，直接给变量赋值即可。看下面代码。

.. code-block:: js

	// 隐式定义变量a
    a = "Hello JavaScript";
    // 使用控制台输出a的值
    console.log(a);

显式声明方式是采用 ``var`` 关键字声明变量，声明时变量可以没有初始值，声明的变量数据类型是不确定的。当第一次给变量赋值时，变量的数据类型才确定下来，而且使用过程中变量的数据类型也可随意改变。看下面显式声明变量的示例代码。

.. code-block:: js

	//显式声明变量a
    var a ;
    //给变量a赋值，赋值后a的数据类型为布尔型
    a = true;
    //使用警告对话框输出a的值
    console.log(a);

.. note:: ``JavaScript`` 中的变量是区分大小写的。因此变量 ``abc`` 和 ``Abc`` 是两个不同的变量，读者编程时一定要注意。

与其他编程语言类似的是， ``JavaScript`` 也允许一次定义多个变量，代码如下：

.. code-block:: js

    var a , b , c;//一次定义了a、b、c三个变量

还可以在定义变量时为变量指定初始值，例如如下代码：

.. code-block:: js

    var i, j = 0, k = 0;//定义变量i,j,k，其中j、k指定初始值

作用范围
--------
根据变量定义的范围不同，变量有全局变量和局部变量之分。直接定义的变量是全局变量，全局变量可以被所有的脚本访问；在函数里通过 ``var`` 定义的变量称为局部变量，局部变量只在函数内有效。如果全局变量和局部变量使用相同的变量名，则局部变量将覆盖全局变量。

.. code-block:: js

	// 定义全局变量test
    var test = "全局变量";
    // 定义函数checkScope
    function checkScope()
    {
        // 定义局部变量
        var test = "局部变量";
        // 输出局部变量
        console.log(test);
    }
    checkScope();

代码的执行结果是“局部变量”，代码中定义了名为 ``test`` 的全局变量，但在函数中又定义了名为 ``test`` 的局部变量，函数中的局部变量覆盖了全局变量。与 ``Java`` 、 ``C`` 等语言不同的是， ``JavaScript`` 的变量没有块范围，看如下代码。

.. code-block:: js

	function test(o)
    {
        // 定义变量i，变量i的作用范围是整个函数
        var i = 0;
        if (typeof o == "object")
        {
            // 定义变量j，变量j的作用范围是整个函数内，而不仅仅是在if块内。
            var j = 5;
            for(var k = 0; k < 10; k++)
            {
                // 因为JavaScript没有代码块范围
                // 所以k的作用范围是整个函数内，而不是循环体内
                console.log(k);
            }
        }
        // 即使出了循环体，k的值依然存在
        console.log(k + "\n" + j);
    }
    test(document);

因为 ``JavaScript`` 的变量没有块范围，有时可能出现一些非常奇怪的结果。看如下代码。

.. code-block:: js

	// 定义全局变量
    var scope = "全局变量";
    function test()
    {
        // 因此全局变量被局部变量覆盖
        // 而此时scope局部变量尚未赋值，故此处输出undefined
        console.log(scope + "\n");
        // ①定义scope的局部变量，其作用范围为整个函数内
        var scope = "局部变量"; //1
        // 再次输出scope的值。
        console.log(scope + "\n");
    }
    test();

代码第一次输出的 ``scope`` 值并不是“全局变量”，而是 ``undefined`` 。这是因为全局变量 ``scope`` 在 ``test()`` 函数中已经被覆盖了，局部变量在整个 ``test()`` 函数内都是有效的，但此处 ``scope`` 还没被赋值，故此处输出 ``undefined`` 。

在很多 ``JavaScript`` 编程人员的印象中，定义变量用 ``var`` 和不用 ``var`` 没有区别。但实际上是存在差异的：

- 如果使用 ``var`` 定义变量，那么程序会强制定义一个新变量。
- 如果没有使用 ``var`` 定义变量，系统会优先在当前上下文中搜索是否存在该变量。只有在该变量不存在的前提下，系统才会重新定义一个新变量。

如果把上面①号代码中定义变量的 ``var`` 去掉，那么代码第一次输出的 ``scope`` 值变成了“全局变量”，这是因为在①号代码处不是定义新交量，而是直接为全局变量 ``scope`` 赋值。因此 ``test()`` 函数并没有覆盖全局变量 ``scope`` ，因此程序第一次访问 ``scope`` 时将输出“全局变量”。这就是使用 ``var`` 定义变量和不使用 ``var`` 定义变量的区别。

全局变量的作用范围对于执行 ``HTML`` 事件处理一样有效，看如下代码。

.. code-block:: html

	<html>
	<head>
	    <meta name="author" content="Yeeku.H.Lee(CrazyIt.org)" />
	    <meta http-equiv="Content-Type" content="text/html; charset=GBK" />
	    <title> 事件处理中的局部变量和全局变量 </title>
	    <script type="text/javascript">
	        //定义全局变量
	        var x = "全局变量";
	    </script>
	</head>
	<body>
	<!-- 在onclick事件中重新定义了x局部变量变量 -->
	<input type="button" value="局部变量"
	    onclick="var x = '局部变量'; alert('输出x局部变量的值：' + x);"/>
	<!-- 直接输出全局变量x的值 -->
	<input type="button" value="全局变量 "
	    onclick="alert('输出x全局变量的值： ' + x);" />
	</body>
	</html>

对于第一个按钮的事件处理脚本而言，因为该脚本中重新定义了局部变量 ``x`` ，所以访问 ``x`` 变量将输出该局部变量的值；对于第二个按钮的事件处理脚本而言，由于该脚本中没有定义变量 ``x`` ，所以访问变量 ``x`` 时将输出全局变量的值。单击第一个按钮将弹出局部变量的值，单击第二个按钮将弹出全局变量的值。


类型转换
--------
``JavaScript`` 支持自动类型转换，这种类型转换的功能非常强大，看如下代码。

.. code-block:: js

	var a = "3.145";// 定义字符串变量
    var b = a - 2; // 让字符串变量和数值执行算术运算
    var c = a + 2; // 让字符串变量和数值执行运算，到底是算术运算，还是字符串运算呢？
    alert (b + "\n" + c); // 输出b和c的值

在上面代码中， ``a`` 是值为 ``3.145`` 的字符串，让 ``a`` 和数值执行减法，则自动执行算术运算，并将 ``a`` 的类型转换为数值；让 ``a`` 和数值执行加法，则 ``a`` 的值转换为字符串。这就是自动类型转换，它的转换规律是：

- 对于减号运算符，因为字符串不支持减法运算，所以系统自动将字符串转换成数值。
- 对于加号运算符，因为字符串可用加号作为连接运算符，所以系统自动将数值转换成字符串，并将两个字符串进行连接运算。

各种类型自动类型转换的结果如下表所示。

+-----------+------------------+----------------------------+--------+-------------+
| 值        | 字符串类型       | 数值型                     | 布尔型 | 对象        |
+===========+==================+============================+========+=============+
| undefined | "undefined"      | NaN                        | false  | Error       |
+-----------+------------------+----------------------------+--------+-------------+
| null      | "null"           | 0                          | false  | Error       |
+-----------+------------------+----------------------------+--------+-------------+
| 字符串    | 不变             | 数值或NaN                  | true   | String对象  |
+-----------+------------------+----------------------------+--------+-------------+
| 空字符串  | 不变             | 0                          | false  | String对象  |
+-----------+------------------+----------------------------+--------+-------------+
| 0         | "0"              | 0                          | false  | Number对象  |
+-----------+------------------+----------------------------+--------+-------------+
| NaN       | "NaN"            | NaN                        | false  | Number对象  |
+-----------+------------------+----------------------------+--------+-------------+
| Infinity  | "Infinity"       | Infinity                   | true   | Number对象  |
+-----------+------------------+----------------------------+--------+-------------+
| -Infinity | "-Infinity"      | -Infinity                  | true   | Number对象  |
+-----------+------------------+----------------------------+--------+-------------+
| 数值      | 数值字符串       | 不变                       | true   | Number对象  |
+-----------+------------------+----------------------------+--------+-------------+
| true      | "true"           | 1                          | 不变   | Boolean对象 |
+-----------+------------------+----------------------------+--------+-------------+
| false     | "false"          | 0                          | 不变   | Boolean对象 |
+-----------+------------------+----------------------------+--------+-------------+
| 对象      | toString()返回值 | valueOf()，toString()或NaN | true   | 不变        |
+-----------+------------------+----------------------------+--------+-------------+

这种自动类型转换虽然方便，但程序可读性非常差，而且有时候我们就是希望让字符串和数值执行加法运算，这就需要使用强制类型转换了。 ``JavaScript`` 提供了如下几个函数来执行强制类型转换。

- ``toString()`` ：将布尔值、数值等转换成字符串。
- ``parseInt()`` ：将字符串、布尔值等转换成整数。
- ``parseFloat()`` ：将字符串、布尔值等转换成浮点数。

如果需要让 ``"3.145"+2`` 这种表达式的结果为 ``5.145`` ，可以使用强制类型转换。

.. code-block:: js

	// 定义值为3.145的字符串变量
    var a = "3.145";
    // 直接相加，使用自动类型转换。
    var b = a + 2;
    // 使用强制类型转换
    var c = parseFloat(a) + 2;
    console.log(b + "\n" + c);

对于 ``3.145`` 这种可以正常转换成数值的字符串，可以成功转换为数值；但对于包含其他字符的字符串，将转换成 ``NaN`` 。

当使用 ``parseInt()`` 或 ``parseFloat()`` 将各种类型的变量转换成数值类型时，结果如下。

- 字符串值：如果字符串是一个数值字符串，则可以转换成一个数值，否则将转换成 ``NaN`` 。
-  ``undefined`` 、 ``null`` 、布尔值及其他对象：一律转换成 ``NaN`` 。

当使用 ``toString()`` 函数将各种类型的值向字符串转换时，结果全部是 ``object`` 。



