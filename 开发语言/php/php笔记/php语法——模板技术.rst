模板技术Smarty
=============
如果你正在设计一个交互式的网站，你一定会关注两个主要的问题，就是界面美工和应用程序。在大多数的项目组中，开发一个Web程序都会出现这样的流程：计划文档提交之后，界面设计者（美工）制作了网站的外观模型，然后把它交给后台程序员。程序员使用PHP实现程序逻辑，同时使用外观模型做成基本架构，然后工程被返回到HTML页面设计者继续完善。就这样工程可能在后台程序员和页面设计者之间来来回回好几次。由于后台程序员不喜欢干预任何有关HTML标签，同时也不需要美工们和PHP代码鬼混在一起。美工设计者只需要配置文件，动态区块和其他的界面部分，不必要去接触那些错综复杂的PHP代码。因此，这时候有一个很好的模板支持就显得很重要了。

什么是模板引擎
-------------
PHP是一种HTML内嵌式的在服务器端执行的脚本语言，所以大部分PHP开发出来的Web应用，初始的开发模板就是混合层的数据编程。虽然通过MVC设计模式可以把程序应用逻辑与网页呈现逻辑强制性分离，但也只是将应用程序的输入、处理和输出分开，网页呈现逻辑（视图）还会有HTML代码和PHP程序强耦合在一起。PHP脚本的编写者必须既是网页设计者，又是PHP开发者。但实际情况是，多数Web开发人员要么是精通网页设计，能够设计出漂亮的网页外观，但是编写的PHP代码很糟糕；要么仅熟悉PHP编程，能够写出健壮的PHP代码，
但是设计的网页外观很难看。具备两种才能的开发人员很少见。

现在已经有很多解决方案，可以将网站的页面设计和PHP应用程序几乎完全分离。这些解决方案称为“模板引擎”，它们正在逐步消除由于缺乏层次分离而带来的难题。模板引擎的目的，就是要达到上述提到的逻辑分离的功能。它能让程序开发者专注于资料的控制或是功能的达成；而网页设计师则可专注于网页排版，让网页看起来更具有专业感。因此，模化引擎很适合公司的Web开发团队使用，使每个人都能发挥其专长。

模板引擎技术的核心比较简单。只要将美工页面（不包含任何的PHP代码）指定为模板文件，并将这个模板文件中有活动的内容，如数据库输出、用户交互等部分，定义成使用特殊“定界符”包含的“变量”，然后放在模板文件中相应的位置。当用户浏览时，由PHP脚本程序打开该模板文件，并将模板文件中定义的变量进行替换。这样，模板中的特殊变量被替换为不同的动态内容时，就会输出需要的页面，如图16-1所示。

.. image:: ./_static/images/smarty.jpg

通过图16-1中展示的内容，我们可以打个比方。例如，玩橡皮泥时，用不同的模子按上去，就可以做出需要的形状。如果我们假设PHP中的动态数据就是一块大橡皮泥，模板文件就像是一个模子，玩家就好比是PHP程序，模板引擎比作成使用模子的工具。当玩家创建了一个使用模子的工具，并在工具中将模子安装上，然后用力将橡皮泥按下，这样就做出需要的形状来了。

在Web开发中分离应用程序的业务逻辑和表现逻辑，是我们使用模板引擎的主要目的。这是因为有以下两个重要原因：

- 美工设计人员可以与应用程序开发人员独立工作，因为应用的表现和逻辑并非密不可分地纠缠在一起。此外，因为大多数模板引擎使用的表现逻辑一般比应用程序所使用编程语言的语法更简单，所以，美工设计人员不需要为完成其工作而在程序语言上花费太多精力。
- 可以使用同样的代码基于不同目标生成数据，例如生成打印的数据、生成Web页面或生成电子数据表等。如果不使用模板引擎，则需要针对每种输出目标复制并修改代码，这会带来非常严重的代码冗余，极大地降低了可管理性。

目前，可以在PHP中应用的并且比较成熟的模板有很多，例如Smarty、PHPLIB、IPB等几十种。使用这些通过PHP编写的模板引擎，可以让你的代码脉络更加清晰，结构更加合理化。也可以让网站的维护和更新变得更容易，创造一个更加良好的开发环境，让开发和设计工作更容易结合在一起。但是，对于一个PHP程序员来说，没有哪一个PHP模板对他是最合适、最完美的。因为PHP模板就是大众化的东西，并不是针对某个人开发的。如果能在对模板的特点、应用有清楚的认识基础上，充分认识到模板的优势劣势，就可以知道是否选择使用模板或选择使用哪个模板。

编写自己的模板引擎
-----------------
因为PHP需要继承、创新，做一个自己的PHP模板一步一步地实现，并及时融入最新的思想和理念，尤其对于公司而言尤为实用。最重要的是，属于自己的PHP模板引擎永远不是固定不变的，可以根据项目的需要为其量身定制。

创建自己的模板引擎类
^^^^^^^^^^^^^^^^^^
在下面的示例中，通过前面介绍的模板引擎概念创建了属于自己的一个简单模板引擎，可以用来完成处理模板的基本功能。例如，变量替换、分支结构、数组循环遍历，以及模板之间相互嵌套等。在文件MyTpl.php中自定义的模板MyTpl类代码，如下所示：

.. code-block:: php

    <?php
	/*  类名为MyTpl是自定义的模板引擎，在PHP脚本中创建该类对象 */
	/*  通过该类对象加载模板文件并解析，将解析后的结果输出 */
	class MyTpl
	{
	    /* 该类的构造方法，创建对象时初始化成员属性 */
	    /* 参数template_dir: 指定存放模板文件的位置目录 */
	    /* 参数compile_dir: 指定存放编译后的模板文件位置 */
	    function __construct ($template_dir = './templates/', $compile_dir = './templates_c/')
	    {
	        $this->template_dir = rtrim($template_dir, '/') . '/';   //将./templates/目录作为模板存放目录
	        $this->compile_dir = rtrim($compile_dir, '/') . '/';    //初始化解析后的模板存放目录
	        $this->tpl_vars = array();   //为成员属性tpl_vars赋值为空数组
	    }
	    /* 调用该方法是用来将值分配给模板中对应的变量*/
	    /* 参数tpl_val: 需要一个字符串参数，要和模板中的变量名对应 */
	    /* 参数value: 需要一个标量类型的值，用来分配给模板中变量的值 */
	    function assign ($tpl_var, $value = null)
	    {
	        if ($tpl_var != '')                    //如果第一个参数$tpl_var不是一个空字符串
	            $this->tpl_vars[$tpl_var] = $value; //将第二个参数提供的值添加到数组tpl_var中
	    }
	    /* 加载指定目录下的模板文件，并将解析后的内容存放到另一个指定目录下的文件中 */
	    /* 参数fileName:提供模板文件的文件名  */
	    function display ($fileName)
	    {
	        $tplFile = $this->template_dir . $fileName;      //到指定的目录中寻找模板文件
	        if (!file_exists($tplFile)) {                    //如果需要处理的模板文件不存在
	            return false;                           //结果该函数执行返回FALSE
	        }
	        //获取编译过的模板文件，该文件中的内容都是被替换过的
	        $comFileName = $this->compile_dir . "com_" . basename($tplFile) . '.php';
	        //判断替换后的文件是否存在或是存在但有改动，都需要重新创建
	        if (!file_exists($comFileName) || filemtime($comFileName) < filemtime($tplFile)) {
	            $repContent = $this->tpl_replace(file_get_contents($tplFile));  //调用内部替换模板方法
	            $handle = fopen($comFileName, 'w+');      //打开一个用来保存编译过的文件
	            fwrite($handle, $repContent);           //向文件中写入内容
	            fclose($handle);                        //关闭打开的文件
	        }
	        include($comFileName);                          //包含处理后的模板文件输出给客户端
	    }
	    /*  该方法使用正则表达式将模板文件'<{ }>'中的语句替换为对应的值或PHP代码 */
	    /*  参数content: 提供从模板文件中读入的全部内容字符串 */
	    private function tpl_replace ($content)
	    {
	        $pattern = array(         //匹配模板中各种标识符的正则表达式的模式数组
	            '/<\{\s*\$([a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)\s*\}>/i',    //匹配模板中变量
	            '/<\{\s*if\s*(.+?)\s*\}>(.+?)<\{\s*\/if\s*\}>/ies',             //匹配模板中if标识符
	            '/<\{\s*else\s*if\s*(.+?)\s*\}>/ies',                             //匹配elseif标识符
	            '/<\{\s*else\s*\}>/is',                                   //匹配else标识符
	            '/<\{\s*loop\s+\$(\S+)\s+\$([a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)\s*\}>(.+?)<\{\s*\/loop\s*\}>/is',                //用来匹配模板中的loop标识符，用来遍历数组中的值
	            '/<\{\s*loop\s+\$(\S+)\s+\$([a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)\s*=>\s*\$(\S+)\s*\}>(.+?)<\{\s*\/loop \s*\}>/is',   //用来匹配模板中的loop标识符，用来遍历数组中的键和值
	            '/<\{\s*include\s+[\"\']?(.+?)[\"\']?\s*\}>/ie'                   //匹配include标识符
	        );
	        $replacement = array(   //替换从模板中使用正则表达式匹配到的字符串数组
	            'tpl_vars["${1}"]; ?>',                       //替换模板中的变量
	            '$this->stripvtags(\'\',\'${2}\')', //替换模板中的if字符串
	            '$this->stripvtags(\'\',"")',                  //替换elseif的字符串
	            '',                                               //替换else的字符串
	            'tpl_vars["${1}"] as $this->tpl_vars["${2}"]) { ?>${3}', 'tpl_vars["${1}"] as $this->tpl_vars["${2}"] => $this->tpl_vars["${3}"]) { ?>${4}',    //这两条用来替换模板中的loop标识符为foreach格式
	            'file_get_contents($this->template_dir."${1}")'         //替换include的字符串
	        );
	        $repContent = preg_replace($pattern, $replacement, $content);     //使用正则替换函数处理
	        if (preg_match('/<\{([^(\}>)]{1,})\}>/', $repContent)) {        //如果还有要替换的标识
	            $repContent = $this->tpl_replace($repContent);                 //递归调用自己再次替换
	        }
	        return $repContent;                                             //返回替换后的字符串
	    }
	    /* 该方法用来将条件语句中使用的变量替换为对应的值 */
	    /* 参数expr: 提供模板中条件语句的开始标记   */
	    /* 参数statement: 提供模板中条件语句的结束标记  */
	    private function stripvtags ($expr, $statement = '')
	    {
	        $var_pattern = '/\s*\$([a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)\s*/is';  //匹配变量的正则
	        $expr = preg_replace($var_pattern, '$this->tpl_vars["${1}"]', $expr);        //将变量替换为值
	        $expr = str_replace("\\\"", "\"", $expr);               //将开始标记中的引号转义替换
	        $statement = str_replace("\\\"", "\"", $statement);     //替换语句体和结束标记中的引号
	        return $expr . $statement;   //将处理后的条件语句相连后返回
	    }
	}
    ?>

在MyTpl类中声明的多个方法中，除被封装过的只有两个公有方法assign()和display()在创建对象以后可以被调用。其中assign()方法用来将PHP脚本中的数据分配给模板中对应的变量，display()方法则用来将特定的templates目录下的模板文件加载到PHP脚本中。同时将模板文件中使用“<{”和“}>”标记声明的自定义模板语句，匹配出来并替换成相对应的PHP语法格式，然后将替换后的内容保存在特定的templates_c目录下。在运行时还要编译成一个非模板技术的PHP文件，并将其以模板文件名加上“com_”前缀和“.php”的扩展名形式保存。再通过include()函数将处理后的模板文件包含，并使用PHP解析后发送给客户端。

使用自己的模板引擎
^^^^^^^^^^^^^^^^
使用自己的模板引擎比较容易，都是自己定义的语法格式。但要记住，所有流行的模板引擎解决方案都遵循同样的一组相同的核心实现原则，就是与编程语言一样，学习了一种语言就可以更容易地掌握其他语言。使用模板引擎最主要的原因就是将页面设计者（美工）和PHP程序员的工作分开，所以模板引擎不仅PHP程序员需要使用，页面设计者也需要使用。

PHP程序员对模板引擎的使用
"""""""""""""""""""""""
在PHP脚本中包含模板引擎类所在的文件。如下所示：

``require("MyTpl_class.php"); //包含模板引擎类，相当于模板引擎安装``

创建模板引擎类的对象并对一些成员属性进行初始化赋值。如下所示：

``$tpl=new MyTpl(); //创建模板引擎类的对象，也可以根据参数对成员初始化``

将动态数据（包括标量和数组类型的数据，例如从数据库的表中获得的数据数组）使用模板引擎对象中的assign()方法分配给模板文件，这个方法可以使用多次，将任意多个变量分配给模板。如下所示：

``$tpl->assign("var", "this is a value");  //可以分配标量类型数据，可以使用多次``

``$tpl->assign("arr", array(array(1, 2), array(“a”, “b”)));  //也可以分配数组包括多维数组``

在PHP脚本中通过调用模板对象中的display()方法，并将模板文件名作为参数传入，就会加载指定目录中对应的模板文件到PHP脚本中。再通过模板引擎中的替换方法对模板中自定义的语法进行解析，然后输出处理后的模板。如下所示：

``$tpl->display("test.tpl"); //参数“test.tpl”为特定目录下的模板文件``

页面设计者的使用说明
""""""""""""""""""

- 页面设计者需要将编写的模板文件存放到指定的目录中，这个目录是通过在模板对象中使用$template_dir属性指定的，默认的设置是当前目录下的“templates”目录。另外，模板文件的命名以及后缀名的设置可以随意，例如index.tpl、test.htm等。
- 模板文件是通过使用HTML、CSS以及JavaScript等Web前台语言编写的纯静态页面。但可以在模板文件中使用“<{”和“}>”两个分隔符中间定义一个变量（类似PHP中的变量格式），该变量可以接受并输出由PHP脚本中分配过来的动态数据。在模板中使用的“<{”和“}>”两个分隔符号对，也可以根据个人爱好在模板引擎类中修改。如下所示：

  ``姓名：<{ $name }>, 年龄：<{ $age }>, 性别: <{ $sex }> //模板中使用占位符``

- 如果在PHP脚本中是将数组分配给模板，也可以在模板中进行遍历，还可以通过嵌套的方式遍历多维数组。使用的是在模板引擎中定义的“<{ loop }>”标记对，使用的方式和PHP中foreach结构的语法格式相同。如下所示：

  .. code-block:: html
  
    <{ loop $arr  $value }>             //遍历数组$arr中的元素值
        数组中的元素值<{ $value }>      //每次遍历输出元素中的值
    <{ /loop }>                                 //在模板中遍历数组的结束标记

    <{ loop $arr  $key=>$value }>  //遍历数组$arr中的元素下标和元素值
        数组中元素的键<{ $key }>         //输出每次循环中元素的下标
        数组中元素的值<{ $value }>       //输出每次循环中元素的值
	<{ /loop }>                                  //在模板中遍历数组的结束标记

    <{ loop $arr  $value }>              //在模板中遍历从PHP中分配过来的多维数组
        <{ loop $value $data }>             //使用嵌套标记遍历二维数组
            数组中元素的值<{ $data }>        //循环输出多维数组中的每个元素值
        <{ /loop }>                                  //在模板中遍历数组的内层结束标记
    <{ /loop }>                                  //在模板中遍历数组的外层结束标记

- 模板引擎还可以解析在模板文件中使用特殊标记编写的分支结构，语法风格也是和PHP的分支结构类似。是通过在模板文件中使用“<{ if }>”标记对实现选择结构，也可以实现多路分支和嵌套分支的选择结构。如下所示：

  .. code-block:: html
  
    <{if($var=="red" )}>    //在模板中判断变量$var的值是否为red
        <font color="red">这是“红色”的字 </font> //如果条件成立则输出红色的字
    <{elseif($var=="green") }>  //在模板中判断$var的值是否为green
        <font color="green">这是“绿色”的字</font>   //如果条件成立则输出绿色的字
    <{ else }>  //如果条件都不成立
        <{ if($size==7) }>  //嵌套形式判断变量$size是否等于7
            <font size="7">这是“7号”的字 </font> //如果条件成功则输出7号大小字体
        <{ /if }> //内层嵌套的条件标记结束
    <{/if}>  //外层的条件标记结束

- 在自定义的模板引擎中，也添加了在模板文件中包含其他模板文件的功能。可以使用“<{ include ‘子模板文件名’ }>”标记将子模板包含到当前模板中，还支持在子模板中再次包括另外的子模板。如下所示：

  ``<{ include "other.tpl" }> //在当前的模板文件中包含其他模板文件，也可以使用单引号包含``

自定义模板的使用示例分析
^^^^^^^^^^^^^^^^^^^^^^
这节内容主要是演示自定义模板的使用示例，通过在程序中加载模板引擎可以将PHP与前台HTML等语言的代码设计分开。首先在PHP程序中获取数据库中存储的数据，再通过加载模板引擎将数据分配出去，然后将模板文件再通过模板引擎加载并处理后输出。所以PHP程序只是创建动态数据，加载模板引擎并将动态数据分配给模板，完成了PHP程序的工作。而模板的设计也只需要页面设计人员独立完成，使用HTML、CSS及JavaScript等前台页面设计语言编写。另外，在模板文件中还需要使用模板引擎可以解析的标记，将PHP中分配过来的动态数据在模板中引用。

数据库的设计
"""""""""""
假设数据库服务器在“localhost”主机上，连接的用户名和密码分别为“mysql_user”和“mysql_pwd”，在该服务器上创建一个名为“mydb”的数据库，并在该数据库中创建一个名为“User”的用户表。创建该表的SQL查询语句如下所示：

.. code-block:: sql

	CREATE TABLE User (                                   //创建一名为User的用户表
	id SMALLINT(3) NOT NULL AUTO_INCREMENT,               //User表中自动增加的记录ID
	name VARCHAR(10) NOT NULL DEFAULT '',                 //存储用户名的字段
	sex VARCHAR(4) NOT NULL DEFAULT '',                   //存储用户性别的字段
	age SMALLINT(2) NOT NULL DEFAULT '0',                 //存储用户年龄的字段
	email VARCHAR(20) NOT NULL DEFAULT '',                //存储用户电子邮件的字段
	PRIMARY KEY  (id)                                     //将用户ID设置为主键
	) ;

用户表User创建完成以后，接着可以向该表中插入一些数据作为示例演示使用，SQL查询语句如下所示：

.. code-block:: sql

	INSERT INTO User(name, sex, age, email) VALUES          //向表User中插入4条记录
	("高某某", "男", 27, "gao@lampbrother.net"),            //第一条记录
	("洛某某", "女", 22, "luo@lampbrother.net"),            //第二条记录
	("峰某某", "男", 30, "feng@lampbrother.net"),           //第三条记录
	("书某某", "女", 24, "shu@lampbrother.net");            //第四条记录

模板的设计
"""""""""
模板的设计不要出现任何的PHP代码，可以由纯美工的人员来完成。在自定义的模板引擎中，规定了要到指定的目录中去寻找模板文件，这个特定的目录可以在创建模板引擎对象时指定，也可以使用默认的目录设置，默认可以将模板文件存放在当前目录中的“templates”目录下。本例共需要三个模板文件main.tpl、header.tpl和footer.tpl，都存放在这个默认的目录设置中。这三个模板文件的代码如下所示：

主模板文件main.tpl

.. code-block:: html

	<{ include "header.tpl" }>

	<table border="1" align="center" width="90%" cellpadding="3" cellspacing="0">
	    <caption><h1><{ $tableName }></h1></caption>
	    <tr bgcolor="#cccccc">
	        <th>编号</th><th>姓名</th><th>性别</th><th>年龄</th><th>电子邮件</th>
	    </tr>
	<{ loop $users $user }>
	        <tr>
	    <{ loop $user $colKey => $colValue }>
	        <{ if $colKey == "sex" }>
	            <{ if $colValue=="男" }>
	                    <td bgcolor="red"><{ $colValue }></td>
	            <{ elseif $colValue=="女" }>
	                    <td bgcolor="green"><{ $colValue }></td>
	            <{ else }>
	                    <td bgcolor="blue"> 未知 </td>
	            <{ /if }>
	        <{ else }>
	                    <td><{ $colValue }></td>
	        <{ /if }>
	    <{ /loop }>
	        </tr>
	<{ /loop }>
	</table>
	<center>共查询到<b><{ $rowNum }></b>条记录</center>

	<{ include 'footer.tpl' }>

模板的头部文件header.tpl

.. code-block:: html

	<html>
	    <head>
	        <title><{ $title }></title>
	    </head>
	</html>

模板的尾部文件footer.tpl

.. code-block:: html

	        <hr><center>##########作者：<{ $author }>###########</center>
	    </body>
	</html>

文件main.tpl是主模板文件，在该文件中使用<{ include "header.tpl" }>和<{ include 'footer.tpl' }>两个标记分别在该文件的顶部和底部，将独立的头部和尾部模板文件包含到这个主模板文件中。并在该文件中使用<{ $tableName }>标记获取从PHP中动态分配过来的表名，以及使用双层<{ loop }>标记嵌套，遍历从PHP中动态分配过来的在数据库中获取到的二维数组$Users，还在<{ loop }>标记中使用条件选择标记<{ if }>组合，将数据中性别为“男”的表格背景设置为红色和一些其他判断。又在main.tpl模板文件中，使用<{ $rowNum }>标记输出从PHP程序中动态分配过来的数据记录的个数。被包含进来的头部模板文件header.tpl和尾部模板文件footer.tpl也同样可以获取从PHP中动态分配给模板的数据。

PHP程序设计
""""""""""
通过模板引擎的使用，PHP程序员在编写代码时，只需要PHP一种语言就可以了，不用再去使用HTML、CSS以及JavaScript前页面设计语言完成美工的工作了。下面是一个文件名为index.php的PHP脚本文件，和模板引擎类所在的文件MyTpl_class.php在同一个目录下。代码如下所示：

.. code-block:: php

    <?php
	require "MyTpl_class.php";                             //包含模板引擎类所在文件
	$mysqli=new mysqli("localhost", "mysql_user", "mysql_pwd", "mydb");     //建立mysqli对象
	//执行SQL语句从用户表User中查询所有记录，保存在$User数组中
	if($result=$mysqli->query("SELECT id, name, sex, age, email FROM User")){
	    while($row=$result->fetch_assoc()){       //循环从结果集中遍历每行数据
	        $users[]=$row;                                      //取出所有行都保存在同一个数组中
	    }
	    $rowNum=$result->num_rows;                   //将获取的数据行数保存在变量中
	    $result->close();                                          //关闭结果集
	}
	$mysqli->close();                                              //关闭与数据库的连接
	$tpl=new MyTpl("./templates/", "./templates_c");     //创建模板引擎类对象并对属性初始化
	$tpl->assign("title", "自定义模板引擎示例");    //分配标题变量给头部模板header.tpl
	$tpl->assign("tableName", "用户信息表");        //分配表名变量给主模板
	$tpl->assign("author", "高洛峰");                      //分配作者变量给尾部模板footer.tpl
	$tpl->assign("users", $users);                          //分配存有表User的二维数组给主模板
	$tpl->assign("rowNum", $rowNum);                 //分配所取的数据行数变量给主模板
	$tpl->display("main.tpl");                                  //包括替换模板中的变量输出模板页面
    ?>

在上面的PHP脚本文件中，通过mysqli对象连接MySQL服务器，并获取用户表User中的全部记录，并以PHP的二维数组变量形式保存在变量$users中。接着使用包含进来的当前目录下的“MyTpl_class.php”文件，创建并初始化模板引擎类的对象$tpl。再通过该对象中的assign()方法向模板分配一些数据，然后使用该对象中的display()方法载入模板文件main.tpl。并将模板中标记的特殊变量替换为从PHP中分配的动态数据，处理完毕以后输出模板页面。

限于各种不同的条件限制，比如时间、经验，做一个自己的PHP模板引擎是非常困难的。其实，你需要的并不是重新构造一个PHP模板，而是选择一个最贴近自己的PHP模板加以改造。

选择Smarty模板引擎
-----------------
一般的模板引擎（如PHPLib）都是在建立模板对象时取得要解析的模板，然后把变量套入后，透过parse()这个方法来解析模板，最后再将网页输出。对Smarty的使用者来说，程序里也不需要做任何解析的动作了，这些Smarty自动会帮我们做。而且已经编译过的网页，如果模板没有变动的话，Smarty就自动跳过编译的动作，直接执行编译过的网页，以节省编译的时间。smarty模板引擎运作示意图如16-3所示。

.. image:: ./images/smarty1.jpg

对PHP来说，有很多模板引擎可供选择，但Smarty是一个使用PHP编写出来的，是目前业界最著名、功能最强大的一种PHP模板引擎。Smarty像PHP一样拥有丰富的函数库，从统计字数到自动缩进、文字环绕以及正则表达式都可以直接使用，如果觉得不够，SMARTY还有很强的扩展能力，可以通过插件的形式进行扩充。另外，Smarty也是一种自由软件，用户可以自由使用、修改，以及重新分发该软件。Smarty的优点概括如下。

- 速度：相对于其他的模板引擎技术而言，采用Smarty编写的程序可以获得最大速度的提高。
- 编译型：采用Smarty编写的程序在运行时要编译成一个非模板技术的PHP文件，这个文件采用了PHP与HTML混合的方式，在下一次访问模板时将Web请求直接转换到这个文件中，而不再进行模板重新编译（在源程序没有改动的情况下），使用后续的调用速度更快。
- 缓存技术：Smarty提供了一种可选择使用的缓存技术，它可以将用户最终看到的HTML文件缓存成一个静态的HTML页。当用户开启Smarty缓存时，并在设定的时间内，将用户的Web请求直接转换到这个静态的HTML文件中来，这相当于调用一个静态的HTML文件。
- 插件技术：Smarty模板引擎是采用PHP的面向对象技术实现，不仅可以在原代码中修改，还可以自定义一些功能插件（就是一些按规则自定义的函数）。
- 强大的表现逻辑：在Smarty模板中能够通过条件判断以及迭代地处理数据，它实际上就是一种程序设计语言，但语法简单，设计人员在不需要预备的编程知识前提下就可以很快学会。

当然，也有不适合使用Smarty的地方。例如，需要实时更新的内容，需要经常重新编译模板，所以这类型的程序使用Smarty会使模板处理速度变慢。另外，在小项目中也不适合使用Smarty模板，小项目因为项目简单而美工与程序员兼于一人的项目，使用Smarty会在一定程度上丧失PHP开发迅速的优点。

安装Smarty及初始化配置
---------------------
Smarty的安装比较容易，因为它是采用PHP的面向对象思想编写的软件，只要在我们的PHP脚本中加载Smarty类，并创建一个Smarty对象，就可以使用Smarty模板引擎了。像Smarty这类使用PHP语言编写的软件，并在PHP的项目中应用时，通常都有两种安装方式：

- 依照官方的方式安装，可以只在Web服务器的主机上安装一次，然后提供给该主机下所有设计者开发不同程序时直接引用，而不会重复安装太多的Smarty复本。通常这种安装方法是将Smarty类库放置到Web文档根目录之外的某个目录中，再在PHP的配置文件中将这个位置包含在include_path指令中。但如果某个PHP项目在多个Web服务器之间迁移时，每个Web服务器都必须有同样的Smarty类库配置。
- 使用Smarty和使用其他类库一样，如果在每个PHP项目中都使用独立的Smarty类库，只需要将Smarty软件放置到项目中的某个目录中，再在程序中包含这个目录中的Smarty类文件，就可以使用Smarty模板引擎了。这样，PHP在多个Web服务器之间移植时都会带着Smarty库，就不需要再改变Web服务器的配置了。

安装Smarty
^^^^^^^^^^
通过前面的介绍，选用第二种安装方式比较适合我们，就是在自己的PHP项目中包含Smarty类库。安装步骤如下：

1. 需要到Smarty官方网站http://www.smarty.net/download.php下载最新的稳定版本，所有版本的Smarty类库都可以在Unix和Windows服务器上使用。例如，下载的软件包为Smarty-2.6.18.tar.gz。
2. 然后解压压缩包，解开后会看到很多文件，其中有个名称为libs的文件夹，就是存有Smarty类库的文件夹。安装Smarty只需要这一个文件夹，其他的文件都没有必要使用。
3. 在libs中应该会有三个class.php文件、1个debug.tpl、1个plugin文件夹和1个core文件夹，直接将libs文件夹复制到您的程序主文件夹下。
4. 在执行的PHP脚本中，通过require()语句将libs目录中的Smarty.class.php类文件加载进来，Smarty类库就可以使用了。

上面提供的安装方式适合给程序被带过来移过去的开发者使用，这样就不用再考虑主机有没有安装Smarty了。

初始化Smarty类库的默认设置
^^^^^^^^^^^^^^^^^^^^^^^^
通过前面对Smarty类库安装的介绍，调用require()方法将Smarty.class.php文件包含到执行脚本中，并创建Smarty类的对象就可以使用了。但如果需要改变Smarty类库中一些成员的默认值，不仅可以直接在Smarty源文件中修改，也可以在创建Smarty对象以后重新为Smarty对象设置新值。Smarty类中一些需要注意的成员属性如表16-1所示。

.. image:: ./images/smarty2.png

如果我们不修改Smarty类中的默认行为，也需要创建表16-1中介绍的几个Smarty路径，因为Smarty将会在和php执行脚本相同的目录下寻找这些配置目录。但为了系统安全，通常建议将这些目录放在Web服务器文档根目录之外的位置上，这样就只有通过Smarty引擎使用这些目录中的文件了，而不能再通过Web服务器在远程访问它们。为了避免重复地配置路径，可以在一个文件里配置这些变量，并在每个需要使用Smarty的脚本中包含这个文件即可。将以下这个文件命名为main.inc.php，并放置到主文件夹下，和Smarty类库所在的文件夹libs在同一个目录中。如下所示：

初始化Smarty成员属性的公用文件main.inc.php

.. code-block:: php

    <?php
	include "./libs/Smarty.class.php";         //包含Smarty类库所在的文件
	define('SITE_ROOT', '/usr/demo');  //声明一个常量指定非Web服务器的根目录
	$tpl = new Smarty();           //创建一个Smarty类的对象$tpl
	$tpl->template_dir = SITE_ROOT . "/templates/";      //设置所有模板文件存放的目录
	$tpl->compile_dir = SITE_ROOT . "/templates_c/";     //设置所有编译过的模板文件存放的目录
	$tpl->config_dir = SITE_ROOT . "/configs/";  //设置模板中特殊配置文件存放的目录
	$tpl->cache_dir = SITE_ROOT . "/cache/";  //设置存放Smarty缓存文件的目录
	$tpl->caching=1;                                             //设置开启Smarty缓存模板功能
	$tpl->cache_lifetime=60*60*24;  //设置模板缓存有效时间段的长度为1天
	$tpl->left_delimiter = '<{';  //设置模板语言中的左结束符
	$tpl->right_delimiter = '}>';   //设置模板语言中的右结束符
    ?>

在Smarty类中并没有对成员属性使用private封装，所以创建Smarty类的对象以后就可以直接为成员属性赋值。按照上面文件方式设定的用意在于，程序如果要移植到其他地方，只要改变SITE_ROOT值就可以了。如果以Windows系统上安装Appserv为例，PHP项目的主文件夹是C:\\Appserv\\ww\\project\\，在上面介绍的main.inc.tpl文件中将SITE_ROOT的值也设置为C:\\Appserv\\ww\\project目录。目录结构如图16-4所示。

.. image:: ./images/smarty3.jpg

通过图16-4中提供的一个项目的目录结构，可以清晰地了解在使用模板时各种模块存放的位置。我们一定要按这种规定的目录结构去存放数据，例如所有的模板文件都存放在templates目录中，在需要使用模板文件时，模板引擎会自动到该目录中去寻找对应的模板文件；如果在模板文件中需要加载特殊的配置文件，也会到configs目录中去寻找；如果模板文件有改动或是第一次使用，会通过模板引擎将编译过的模板文件自动写入到templates_c目录中建立的一个文件中；如果在启动缓存的特性情况下，Smarty缓存的所有模板还会被自动存储到cache目录中的一个文件或多个文件中。需要Smarty引擎去主动修改的cache和templates_c两个目录，一定要让PHP脚本的执行用户有写的权限。

第一个Smarty的简单示例
^^^^^^^^^^^^^^^^^^^^^
通过前面的介绍，如果了解了Smarty并学会了安装，就可以通过一个简单的示例测试一下，使用Smarty模板编写的大型项目也会有同样的目录结构。按照上一节的介绍我们需要创建一个项目的主目录Project，并将存放Smarty类库的文件夹libs复制这个目录中，还需要在该目录中分别创建Smarty引擎所需要的各个目录。如果需要修改一些Smarty类中常用成员属性的默认行为，可以在该目录中编写一个类似上一节中介绍的main.inc.php文件。

在这个例子中，唯一的动作就是在PHP程序中替代模板文件中特定的Smarty变量。首先在项目主目录下的templates目录中创建一个模板文件，这个模板文件的扩展名叫什么都无所谓。注意，在模板中声明了$title和$conten两个Smarty变量，都放在大括号“｛｝”中，大括号是Smarty的默认定界符，但为了在模板中嵌入CSS及JavaScript的关系，最好是将它换掉，例如将默认定界符修改为“<{”和“}>”的形式。这些定界符只能在模板文件中使用，并告诉Smarty要对定界符所包围的内容完成某些操作。在templates目录中创建一个名为“test.tpl”的模板文件，代码如下所示：

简单的Smarty设计模板（templates/test.tpl）

.. code-block:: html

	<html>
	    <head>
	        <meta http-equiv="Content-Type" content="text/html;charset=gb2312">
	        <title>{ $title }</title>
	    </head>
	    <body>
	        { $content }
	    </body>
	</html>

还要注意，Smarty这个模板一定要位于templates目录或它的子目录内，除非通过Smarty类中的$template_dir属性修改了模板目录。另外，模板文件只是一个表现层界面，还需要PHP应用程序逻辑，将适当的变量值传入Smarty模板。直接在项目的主目录中创建一个名为index.php的PHP脚本文件，作为templates目录中test.tpl模板的应用程序逻辑。代码如下所示：

在项目的主目录中创建index.php

.. code-block:: php

    <?php
	require("libs/Smarty.class.php");               //第一步：加载 Smarty 模版引擎
	$smarty=new Smarty();                           //第二步：建立 Smarty 对象
	//第三步：设定Smarty的默认属性形为(本例略)
	$smarty->assign("title", "测试用的网页标题");   //第四步：用assign()方法将变量置入模板里
	$smarty->assign("content", "测试用的网页内容"); //也属于第四步，分配其他变量置入模板里
	//在第四步中可以向模板中置入任何类型的变量
	$smarty->display("test.tpl");                   //利用Smarty的display()方法将网页输出
    ?>

这个示例展示了Smarty能够完全分离Web应用程序逻辑层和表现层。用户通过浏览器直接访问项目目录中的index.php文件，就会将模板文件test.tpl中的变量替换后显示出来。

看到输出结果以后，再到项目主目录下的templates_c目录底下，我们会看到一个文件名比较奇怪的文件（例如：%%6D^6D7^6D7C5625%%test.tpl.php）。

这就是Smarty编译过的文件，是在第一次使用模板文件test.tpl时由Smarty引擎自动创建的，它将我们在模板中由特殊定界符声明的变量转换成了PHP的语法来执行。下次再读取同样的内容时，Smarty就会直接抓取这个文件来执行了，直到模板文件test.tpl有改动时，该文件内容才会跟着更新。

Smarty在应用程序逻辑层的使用步骤
------------------------------
Smarty模板引擎的应用和我们前面介绍的自定义模板相似，它需要在PHP的应用程序逻辑和页面模板中配合使用，才能完全分离表现层和逻辑层。在PHP程序中，需要以下五个步骤使用Smarty。

- 第一步：加载Smarty模板引擎，例如：require(“Smarty.class.php”);。
- 第二步：建立Smarty对象，例如：$smarty=new Smarty();。
- 第三步：修改Smarty的默认行为，例如：开启缓存机制、修改模板默认存放目录等。
- 第四步：将程序中动态获取的变量，通过Smarty对象中的assign()方法置入模板里。
- 第五步：利用Smarty对象中的display()方法将模板内容输出。

在这五个步骤中，可以将前三个步骤定义在一个公共文件中，像前面介绍过的用来初始化Smarty对象的文件main.inc.php。因为前三步是Smarty在整个PHP程序中应用的核心，不论是常数定义、外部程序加载、共享变量建立等，都是从这里开始的。所以我们通常都是先将前三个步骤做好放入一个公共文件中，之后每个PHP脚本中只要将这个文件包含进来就可以了，因此在程序流程规划期间，必须好好构思这个公用文件中设置的内容。后面的两个步骤是通过访问Smarty对象中的方法完成的，有必要正式地介绍一下assign()和display()两个方法。

assign()方法
^^^^^^^^^^^^
在PHP脚本中调用该方法可以为Smarty模板文件中的变量赋值。它的使用比较容易，原型如下所示：

``void assign (string varname, mixed var) //Smarty对象中的方法，用来赋值到模板中``

通过调用Smarty对象中的assign()方法，可以将任何PHP所支持的类型数据赋值给模板中的变量，包含数组和对象类型。使用的方式有两种，可以指定一对“名称/数值”或指定包含“名称/数值”的联合数组。如下所示：

.. code-block:: php

    <?php
	//指定一对“名称/数值”的使用方式
	$smarty->assign("name","Fred"); //将字符串"Fred"赋给模板中的变量{$name}
	$smarty->assign("address",$address); //将变量$address的值赋给模板中的变量{$address}
	//指定包含“名称/数值”的联合数组的使用方式
	$smarty->assign(array("city" => "Lincoln","state" => "Nebraska"));  //这种方式很少使用
    ?>

display()方法
^^^^^^^^^^^^^
基于Smarty的脚本中必须用到这个方法，而且在一个脚本中只能使用一次，因为它负责获取和显示由Smarty引擎引用的模板。该方法的原型如下所示：

``Void display (string template [, string cache_id [, string compile_id]]) //用来获取和显示Smarty模板``

第一个参数template是必选的，需要指定一个合法的模板资源的类型和路径。还可以通过第二个可选参数cache_id指定一个缓存标识符的名称，第三个可选参数compile_id在维护一个页面的多个缓存时使用，这两个可选参数将在本章的16.8节中讨论。在下面的示例中使用多种方式指定一个合法的模板资源，如下所示：

.. code-block:: php

    <?php
	//获取和显示由Smarty对象中的$template_dir属性所指定目录下的模板文件index.tpl
	$smarty->display("index.tpl");
	//获取和显示由Smarty对象中的$template_dir变量所指定的目录下子目录admin中的模板文件index.tpl
	$smarty->display("admin/index.tpl");
	//绝对路径,用来使用不在$template_dir模板目录下的文件
	$smarty->display("/usr/local/include/templates/header.tpl");
	//绝对路径的另外一种方式，在WINDOS平台下的绝对路径必须使用“file:”前缀
	$smarty->display("file:C:/www/pub/templates/header.tpl");
    ?>

在使用Smarty的PHP脚本文件中，除了基于Smarty的内容需要上面五个步骤外，程序的其他逻辑没有改变。例如，文件处理、图像处理、数据库连接、MVC的设计模式等，使用形式都没有发生变化。

Smarty模板中的程序逻辑
---------------------
Smarty引擎不仅在PHP程序的逻辑层需要使用，在表现层的模板中也会用到Smarty语法。但并不只是单纯地在一对特殊的定界符中声明一个变量，然后再通过模板引擎在运行时由PHP程序逻辑动态赋值。有时也需要在模板中使用某种迭代，遍历由PHP程序动态分配到模板中的数组，或是通过选择结构过滤数据等程序逻辑。这样就会有一些页面设计者抱怨在表现层中集成了某种程度逻辑，因为使用模板引擎的主旨就是为了完全分离表现层和逻辑层，但要想得到十全十美的解决方案不太可能。因为页面设计人员通常并不是编程人员，所以Smarty的开发者只在引擎中集成了一些简单但非常有效的应用程序逻辑，即使是从没有接触过编程的人员，也可以很快学会。

模板中的注释
^^^^^^^^^^^
每一个Smarty模板文件，都是通过Web前台语言（XHTML、CSS和JavaScript等）结合Smarty引擎的语法共同开发的。除了在模板中多加了一些Smarty语法用来处理程序逻辑以外，用到的其他Web前台开发语言和原来完成一样，注释也没有变化。如果在模板文件中使用HTML或是JavaScript等前台语言的注释，用户可以通过浏览网页源代码的方式查看到这些注释内容。Smarty也在模板中给我们提供了一种注释的语法，包围在定界标记“{*”和“*}”之间的都是注释内容，可以包括一行或多行，并且不会在用户浏览页面源代码时查看到，它只是模板内在的注释。以下是一个合法的Smarty注释：

``{* this is a comment *} //模板注释被*号包围，它不会在模板文件的最后输出中出现``

模板中变量的声明
^^^^^^^^^^^^^^^
在Smarty中，一切以变量为主，所有的呈现逻辑都让模板自行控制。Smarty有几种不同类型的变量，变量的类型取决于它的前缀是什么符号（或者被什么符号包围），Smarty的变量可以直接被输出或者作为函数属性和修饰符的参数，或者用于内部的条件表达式等。以下声明几个可以在Smarty模板中直接输出的变量：

.. code-block:: html

	{$Name}                      {* 常规类型的变量，需要调用模板内的assign函数分配值 *}
	{$Contacts[row].Phone}       {* 数组类型变量，也是调用模板内的assign函数分配值 *}
	<body bgcolor="{#bgcolor#}"> {* 从配置文件中读取变量的值并输出 *}

如果在Smarty模板中输出从PHP中分配的变量，需要在前面加上“$”符号并用定界符将它括起来，命名方式和PHP的变量命名方式是一模一样的。并且定界标示符号又有点像是PHP中的（事实上它们的确会被替换成这个）。

在模板中输出从PHP分配的变量
^^^^^^^^^^^^^^^^^^^^^^^^^
在Smarty模板中经常使用的变量有两种：一种是从PHP中分配的变量；另一种是从配置文件中读取的变量。但使用最多的还是从PHP中分配的变量。但要注意，模板中只能输出从PHP中分配的变量，不能在模板中为这些变量重新赋值。在PHP脚本中分配变量给模板，都是通过调用Smarty引擎中的assign()方法实现的，不仅可以向模板中分配PHP标量类型的变量，而且也可以将PHP中复合类型的数组和对象变量分配给模板。

在前面的示例中已经介绍了，在PHP脚本中调用Smarty模板的assign()方法，向模板中分配字符串类型的变量，这节我们主要在模板中输出从PHP分配的复合类型变量。在PHP的执行脚本中，不管分配什么类型的变量到模板中，都是通过调用Smarty模板的assign()方法完成的，只是在模板中输出的处理方式不同。需要注意的是，在Smarty模板中变量预设是全域的。也就是说你只要分配一次就可以了，如果分配两次以上的话，变量内容会以最后分配的为主。就算我们在主模版中加载了外部的子模版，子模版中同样的变量一样也会被替代，这样我们就不用再针对子模版再做一次解析的动作。

通常，在模板中通过遍历输出数组中的每个元素，可以通过Smarty中提供的foreach或section语句完成，而这节我们主要介绍在模板中单独输出数组中的某个元素。 **索引数组和关联数组在模板中输出方式略有不同，其中索引数组在模板中的访问和在PHP脚本中的引用方式一样，而关联数组中的元素在模板中指定的方式是使用句号“.”访问的。** 在模板中输出数组的示例如下所示：

向模板中分配数组的PHP脚本文件index.php

.. code-block:: php

    <?php
	require "libs/Smarty.class.php";                //包含Smarty类库
	$smarty = new Smarty();                         //创建Smarty类的对象
	$contact=array(                                 //将一个人的联系信息保存在一个关联数组中
	    'fax' => '555-222-9876',
	    'email' => 'gao@lampbrother.net',
	    'phone' => array(
	        'home' => '555-444-3333',
	        'cell' => '555-111-1234'
	    )
	);
	$smarty->assign('contact', $contact);                //将关联数组$contact分配到模板中使用
	$contact2=array(                                //将一个人的联系信息保存在一个索引数组中
	    '555-222-9876',
	    'gao@lampbrother.net',
	    array( '555-444-3333', '555-111-1234')
	);
	$smarty->assign('contact2', $contact2);              //将索引数组$contact2分配到模板中使用
	$contact3=array(                                //使用索引和关联数组保存联系信息
	    'fax' => '555-222-9876',
	    array('first'=>'gao@lampbrother.net','second'=>'feng@lampbrother.net'),
	    'phone' => array('555-444-3333','555-111-1234')
	);
	$smarty->assign('contact3', $contact3);      //将混合数组$contact3分配到模板中使用
	$smarty->display('index.tpl');               //查找模板替换并输出
    ?>

输出从PHP分配的数组的模板文件index.tpl

.. code-block:: html

	访问从PHP中分配的关联数组:
	电子邮件：{$contact.email}  家庭电话：{$contact.phone.home}
	访问从PHP中分配的索引数组:
	电子邮件：{$contact2[1]}  家庭电话：{$contact2[2][0]}
	访问从PHP中分配的索引和关联混合数组：
	第一个电子邮件：{$contact3[0].first}  家庭电话：{$contact3.phone[0]}

在上面的PHP脚本文件index.php中，分别向模板文件index.tpl中分配了三个数组。包含索引数组、关联数组以及两者的混合数组，同时也是混合了一维和二维数的数组。在模板中通过每种数组的不同访问方式，分别输出不同数组中的某个元素，输出结果如下所示：

.. code-block:: text

	访问从PHP中分配的关联数组:
	电子邮件：gao@lampbrother.net 家庭电话：555-444-3333
	访问从PHP中分配的索引数组:
	电子邮件：gao@lampbrother.net 家庭电话：555-444-3333
	访问从PHP中分配的索引和关联混合数组：
	第一个电子邮件：gao@lampbrother.net 家庭电话：555-444-3333

在PHP脚本中创建的对象类型变量也可以分配给模板，并可以在模板中访问对象中的每个成员。 **在模板中访问对象和直接在PHP脚本中访问的方式类似，都是通过“->”运算符完成的。** 在模板文件中输出对象中的成员属性和访问对象中的成员方法，示例如下所示：

.. code-block:: html

	输出从PHP中分配的对象$person中的成员属性：
	姓名: {$person->name}
	电话: {$person->phone}
	访问从PHP中分配的对象$person中的成员属性：
	调用人的工作方法: {$person->work()}
	调用人的学习方法: {$person->study()}

模板中变量的数学计算
^^^^^^^^^^^^^^^^^^
在模板中的变量不能为其重新赋值，但是可以参与数学运算，只要在PHP脚本中可以执行的数学运算都可以直接应用到模板中。使用的示例如下所示：

.. code-block:: html

	{$foo+1}                                        {* 在模板中将PHP中分配的变量加1 *}
	{$foo*$bar}                                     {* 将两个PHP中分配的变量在模板中相乘 *}
	{$foo->bar-$bar[1]*$baz->foo->bar()-3*7}       {* PHP中分配的复合类型变量也可以参与计算 *}
	{if ($foo+$bar.test%$baz*134232+10+$b+10)}      {* 可以将模板中的数学运算在程序逻辑中应用 *}

另外，在Smarty模板中可以识别嵌入在双引号中的变量，只要此变量只包含数字、字母、下画线或中括号[]。对于其他的符号（句号、对象相关的等）此变量必须用两个反引号“`”（此符号和“~”在同一个键上）包住。使用的示例如下所示：

.. code-block:: html

	{func var="test $foo test"}                     {* 在双引号中嵌入标量类型的变量 *}
	{func var="test $foo[0] test"}                  {* 将索引数组嵌入到模板的双引号中 *}
	{func var="test $foo[bar] test"}                {* 也可以将关联数组嵌入到模板的双引号中 *}
	{func var="test `$foo.bar` test"}               {* 嵌入对象中的成员时将变量使用反引号包住*}

在模板中使用{$smarty}保留变量
^^^^^^^^^^^^^^^^^^^^^^^^^^^^
{$smarty}保留变量不需要从PHP脚本中分配，是可以在模板中直接访问的数组类型变量，通常被用于访问一些特殊的模板变量。例如，直接在模板中访问页面请求变量、获取访问模板时的时间邮戳、直接访问PHP中的常量、从配置文件中读取变量等。该保留变量中的部分访问介绍如下。

在模板中访问页面请求变量
""""""""""""""""""""""
我们可以在PHP脚本中，通过超级全局数组$_GET、$_POST、$_REQUEST获取在客户端以不同方法提交给服务器的数据，也可以通过$_COOKIE或$_SESSION在多个脚本之间跟踪变量，或是通过$_ENV和$_SERVER获取系统环境变量。 **如果在模板中需要这些数组，可以调用Smarty对象中的assign()方法分配给模板。但在Smarty模板中，直接就可以通过{$smarty}保留变量访问这些页面请求变量。** 在模板中使用的示例如下所示：

.. code-block:: html

	{$smarty.get.page}                      {* 类似在PHP脚本中访问$_GET["page"] *}
	{$smarty.post.page}                     {* 类似在PHP脚本中访问$_POST["page"] *}
	{$smarty.cookies.username}              {* 类似在PHP脚本中访问$_COOKIE["username"] *}
	{$smarty.session.id}                    {* 类似在PHP脚本中访问$_SESSION["id"] *}
	{$smarty.server.SERVER_NAME}            {* 类似在PHP脚本中访问$_SERVER["SERVER_NAME"] *}
	{$smarty.env.PATH}                      {* 类似在PHP脚本中访问$_ENV["PATH"]*}
	{$smarty.request.username}              {* 类似在PHP脚本中访问$_REQUEST["username"] *}

在模板中访问PHP中的常量
""""""""""""""""""""""
**在PHP脚本中有系统常量和自定义常量两种，同样这两种常量在Smarty模板中也可以被访问，而且不需要从PHP中分配，只要通过{$smarty}保留变量就可以直接输出常量的值。** 在模板中输出常量的示例如下所示：

.. code-block:: html

	{$smarty.const._MY_CONST_VAL}           {* 在模板中输出在PHP脚本中用户自定义的常量 *}
	{$smarty.const.__FILE__}                {* 在模板中通过保留变量数组直接输出系统常量 *}

变量调解器
^^^^^^^^^
在PHP中提供了非常全面的处理文本函数，我们可以通过这些函数将文本修饰后，再调用Smarty对象中的assign()方法分配到模板中输出。而你有可能想在模板中直接对PHP分配的变量进行调解，Smarty开发人员在库中集成了一些这方面的特性，而且允许你对其进行任意扩展。

在Smarty模板中使用变量调解器修饰变量，和在PHP中调用函数处理文本相似，只是Smarty中对变量修饰的语法不同。 **变量在模板中输出以前如果需要调解，可以在该变量后面跟一个竖线“|”，在后面使用调解的命令。而且对于同一个变量，你可以使用多个修改器，它们将从左到右按照设定好的顺序被依次组合使用，使用时必须要用“|”字符作为它们之间的分隔符。** 语法如下所示：

``{变量|函数名:参数1:参数2:参数3...|函数名:参数1:参数2...}      {* 在模板中的变量后面多个调解器组合使用的语法 *}``

另外，　**变量调节器由赋予的参数值决定其行为，参数由冒号“：”分开，有的调解器命令有多个参数。** 使用变量调节器的命令和调用PHP函数有点相似，其实每个调解器命令都对应一个PHP函数。每个函数都自占用一个文件，存放在和Smarty类库同一个目录下的plugins目录中。我们也可以按Smarty规则在该目录中添加自定义函数，对变量调解器的命令进行扩展。也可以按照自己的需求，修改原有的变量调解器命令对应的函数。在下面的示例中使用变量调解器命令truncate，将变量字符串截取为指定数量的字符。如下所示：

``{$topic|truncate:40:"..."}      {* 截取变量值的字符串长度为40，并在结尾使用“…”表示省略 *}``

truncate函数默认截取字符串的长度为80个字符，但可以通过提供的第一个可选参数来改变截取的长度，例如上例中指定截取的长度为40个字符。还可以指定一个字符串作为第二个可选参数的值，追加到截取后的字符串后面，如省略号（…）。此外，还可以通过第三个可选参数指定到达指定的字符数限制后立即截取，或是还需要考虑单词的边界，这个参数默认为FALSE值，则截取到达限制后的单词边界。

truncate函数还有一些不足，开发时只考虑了单字节的字符。因为中文字是双字节的，所以直接使用它截取中英文混合的字符串则会出现乱码。解决的办法就是找到源文件，修改该函数的源代码。源文件存放在Smarty类库的plugins目录中，寻找到声明该函数的文件 ``modifier.truncate.php`` ，修改后的代码如下所示：

.. code-block:: php

    <?php
	/* 函数的定义和原来相同，只是在函数内部功能上做了一些调整，用来截取中文 */
	function smarty_modifier_truncate ($string, $length = 80, $etc = '...', $break_words = false)
	{
	    if ($length == 0)                       //如果指定的截取字符串长度为0
	        return '';                      //直接返回空字符串
	    if (strlen($string) > $length) {             //如果实际字符串的长度大于指定截取的长度
	        $length -= strlen($etc);        //将指定截取的长度减去省略符号字符串的长度
	        if (!$break_words)              //如果需要匹配单词边界做下面的处理
	            $string = preg_replace('/s+?(S+)?$/', '', SubstrGB($string, 0, $length + 1));
	        return SubstrGB($string, 0, $length) . $etc; //返回截取后的字符串
	    } else                                             //如果指定截取的长度小于原字符串的长度
	        return $string;                            //直接返回原字符串
	}

	/* 该函数作为上面函数的子功能，$str字符串,$start开始的位置,$len 截取长度  */
	function SubstrGB ($str, $strart, $len)
	{
	    if (strlen($str) > $len) {                           //如果字符串的长度大于截取长度
	        $strlen = $strart + $len;                           //实际截取的长度是开始的位置加上截取长度
	        for ($i = 0; $i < $strlen; $i++) {                  //遍历在截取长度围内的每个字符
	            if (ord(substr($str, $i, 1)) > 0xa0) {             //如果ASCII的值是从汉字的开始
	                $tmpstr .= substr($str, $i, 2);     //两个字符即一个汉字在一起
	                $i++;                           //需要跳过一次遍历
	            } else {                                //如果ASCII的值是双字节的字
	                $tmpstr .= substr($str, $i, 1);     //次取一个字符的子字符串
	            }
	        }
	        return $tmpstr;                                 //返回处理后的字符串
	    } else {                                                //如果字符串的长度小于截取长度
	        return $str;                                    //不需要处理直接返回
	    }
	}
    ?>

将modifier.truncate.php文件修改后保存，就可以在模板中使用truncate函数截取包含字符串的变量了。使用同样的办法不仅可以修改任何一个自己不满意的调解器函数，还可以在该目录中添加一些自定义的函数，对Smarty的功能进行扩展。但一定要按照Smarty引擎提供的接口规则添加，如果添加成功就可以直接在Smarty模板中使用。还有一些在Smarty中经常用到的变量修饰函数，如表16-2所示。

==================  =====================================================================================================================
成员方法名               描述                                                                                                                   
==================  =====================================================================================================================
capitalize          单词首字母大写，参数值boolean决定带数字的单词是否首字大写，默认不大写。如果单词加数字，例如php100,则这个单词加数字的不大写                                                 
count_characters    计算变量值得字符个数，参数值boolean决定是否计算空格数，默认不计算空格。注：不包括空格和其他特殊字符，UTF-8中一个字母字符占3个长度                                              
cat                 将cat里的参数值连接到给定的变量后面，默认为空                                                                                             
count_paragraphs    计算变量里段落数。注：通过回车或者\\r\\n的换行计算在内，<br>的不计算在内                                                                            
count_sentences     计算变量里句子数量。注：判断字符串有几个"."就为几个句子，"。"不包括在内，且"aa. bb",点号后面要有一个空格才算一个句子                                                    
count_words         计算变量里单词数。注：字母，数字，或字母加数字的组合，在两个空格之间算一个单词                                                                              
date_fomat          日期格式化函数。第一个参数控制日期格式，如果传入date_format的数据是空的，将使用第二个参数作为默认时间                                                             
default             为空变量设置一个默认值，当变量为空或者未分配时，由给定的默认值替代输出                                                                                  
escape              用于html转码、url转码，在没有转码的变量上转换单引号、十六进制转码、十六进制美化，或者javaScript转码，默认是html转码                                                 
indent              在每行缩进字符串，第一个参数指定缩进多少个字符，默认是四个字符；第二个参数，指定缩进用什么字符代替。例如：{$str|indent:4:"&nbsp;"}表示缩进4个字符，字符用空格代替                        
lower               将变量字符串小写                                                                                                             
upper               将变量字符串大写                                                                                                             
nl2br               所有的换行符将被替换成<br/>。功能同PHP中的nl2br()函数一样                                                                                 
regex_replace       寻找和替换正则表达式，必须有两个参数，参数1是替换正则表达式，参数2使用什么文字字串来替换                                                                        
replace             简单的搜索和替换字符串，必须有两个参数，参数1是替换正则表达式，参数2使用什么文本字串来替换。例如:{$str|replace:"需要替换的":"替换的"}                                       
spacify             在字符串的每个字符之间插入空格或者其他的字符(串) 这个函数有一个参数，就是将在两个字符之间插入的字符（串）                                                               
string_format       是一种格式化浮点数的方法，例如十进制数，使用sprintf语法格式化。参数是必须的，规定使用的格式化方式。%d表示显示整数。%.2f表示截取两个浮点数                                          
strip               替换所有重复的空格，换行和tab为单个或者指定的字符串。如果有参数则是指定的字符串                                                                            
strip_tags          去除所有html标签                                                                                                           
truncate            从字符串开始处截取某个长度的字符，默认是80个                                                                                              
wordwrap            可以指定段落的宽度(也就是多少个字符一行，超过这个字符数换行)，默认80。第二个参数可选，可以指定在约束点使用什么字符(默认是换行符\\n)。默认情况下smarty将截取到词尾，如果想精确设定长度饿字符，请将第三个参数设为TRUE  
==================  =====================================================================================================================

表16-2中所提供的变量修饰函数，都比较容易使用。在下面的示例中，多个变量修饰函数组合使用，它们将从左到右按照设定好的顺序，依次对模板中的同一个变量进行调解。首先在index.php的脚本中，向模板中分配一个文章标题变量$articleTitle，该变量由大小写字母混合组成，并且是一个较长的字符串。代码如下所示：

.. code-block:: php

    <?php
	$smarty = new Smarty();
	$smarty->assign('articleTitle', 'Smokers are Productive, but Death Cuts Efficiency.');
	$smarty->display('index.tpl');
    ?>

在下面模板文件index.tpl中，同一个变量将被输出多次，但在每次输出前都通过多个不同修饰函数组合调解过。代码如下所示：

.. code-block:: html

	{$articleTitle}                                         {* 没有被任何修饰函数调用，直接输出变量的值 *}
	{$articleTitle|upper|spacify}                           {* 调节为全部大写并在每个字母之间插入一个空格 *}
	{$articleTitle|lower|spacify|truncate}                  {* 全部小写，字母间插入空格，截取80个字符长度 *}
	{$articleTitle|lower|truncate:30|spacify}               {* 全部小写，截取30个字符，字母间插入空格*}
	{$articleTitle|lower|spacify|truncate:30:". . ."}       {* 改变修饰顺序，从左到右按指的顺序进行调解 *}

模板的控制结构
^^^^^^^^^^^^^
Smarty提供了几种可以控制模板内容输出的结构，包括能够按条件判断决定输出内容的if-elseif-else结构，也有迭代处理传入数据的foreach和section结构。本节将介绍这些在Smarty模板中使用的控制结构。

条件选择结构if-elseif-else
"""""""""""""""""""""""""
Smarty模板中的{if}语句和php中的if语句一样灵活易用，并增加了几个特性以适宜模板引擎。Smarty中{if}必须和{/if}成对出现，当然也可以使用{else}和{elseif}子句。另外，在{if}中可以使用表16-3中给出的全部条件修饰词。

+------------+----------+-------------+--------------+------------+----------+
| 条件修饰符 | 描述     | 条件修饰符  | 描述         | 条件修饰符 | 描述     |
+============+==========+=============+==============+============+==========+
| eq         | 相等     | neq         | 不相等       | mod        | 求模     |
+------------+----------+-------------+--------------+------------+----------+
| gt         | 大于     | is even     | 是否为偶数   | not        | 非       |
+------------+----------+-------------+--------------+------------+----------+
| gte        | 大于等于 | is not even | 是否不为偶数 | ==         | 相等     |
+------------+----------+-------------+--------------+------------+----------+
| ge         | 大于等于 | is odd      | 是否为奇数   | !=         | 不相等   |
+------------+----------+-------------+--------------+------------+----------+
| lt         | 小于     | is not odd  | 是否不为奇数 | >          | 大于     |
+------------+----------+-------------+--------------+------------+----------+
| lte        | 小于等于 | div by      | 是否能被整除 | <          | 小于     |
+------------+----------+-------------+--------------+------------+----------+
| le         | 小于等于 | even by     | 商是否为偶数 | <=         | 小于等于 |
+------------+----------+-------------+--------------+------------+----------+
| ne         | 不相等   | odd by      | 商是否为奇数 | >=         | 大于等于 |
+------------+----------+-------------+--------------+------------+----------+

Smarty模板中在使用这些修饰词时，它们必须和变量或常量用空格隔开。此外，在PHP标准代码中，必须把条件语句包围在小括号中，而在Smarty中小括号的使用则是可选的。一些常见的选择控制结构用法如下所示：

.. code-block:: html

	{if $name eq "Fred"}                            {* 判断变量$name的值是否为Fred *}
	    Welcome Sir.                            {* 如果条件成立则输出这个区块的代码 *}
	{elseif $name eq "Wilma"}                       {* 否则如果变量$name的值是否为Wilma *}
	    Welcome Ma'am.                          {* 如果条件成立则输出这个区块的代码 *}
	{else}                                          {* 否则从句，在其他条件都不成立时执行 *}
	    Welcome, whatever you are.              {* 如果条件成立则输出这个区块的代码 *}
	{/if}                                           {* 是条件控制的关闭标记，if必须成对出现*}
	{if $name eq "Fred" or $name eq "Wilma"}        {* 使用逻辑运算符"or"的一个例子  *}
	    ...                                     {* 如果条件成立则输出这个区块的代码 *}
	{/if}                                           {* 是条件控制的关闭标记，if必须成对出现*}
	{if $name == "Fred" || $name == "Wilma"}        {* 和上面的例子一样，"or"和"||"没有区别 *}
	    ...                                     {* 如果条件成立则输出这个区块的代码 *}
	{/if}                                           {* 是条件控制的关闭标记，if必须成对出现*}
	{if $name=="Fred" || $name=="Wilma"}            {* 错误的语法，条件符号和变量要用空格隔开*}
	    ...                                     {* 如果条件成立则输出这个区块的代码 *}
	{/if}                                           {* 是条件控制的关闭标记，if必须成对出现*}

重复的区块foreach
""""""""""""""""
在Smarty模板中，我们可以使用foreach或section两种方式重复一个区块。而在模板中则需要从PHP中分配过来的一个数组，这个数组也可以是多维数组。foreach标记作用与PHP中的foreach相同，但它们的使用语法大不相同，因为在模板中增加了几个特性以适宜模板引擎。它的语法格式虽然比较简单，但只能用来处理简单数组。在模板中｛foreach｝必须和｛/foreach｝成对使用，它有四个参数，其中form和item两个是必要的。foreach可以使用的全部参数如表16-4所示。

+--------+--------------------------------------------------------+----------+--------+
| 参数名 | 描述                                                   | 类型     | 默认值 |
+========+========================================================+==========+========+
| form   | 待循环数组的名称，该属性决定循环的次数，必要参数       | 数组变量 | 无     |
+--------+--------------------------------------------------------+----------+--------+
| item   | 确定当前元素的变量名称，必要参数                       | 字符串   | 无     |
+--------+--------------------------------------------------------+----------+--------+
| key    | 当前处理元素的键名，可选参数                           | 字符串   | 无     |
+--------+--------------------------------------------------------+----------+--------+
| name   | 该循环的名称，用于访问该循环，这个名是任意的，可选参数 | 字符串   | 无     |
+--------+--------------------------------------------------------+----------+--------+

也可以在模板中嵌套使用foreach遍历二维数组，但必须保证嵌套中的foreach名称唯一。此外，在使用foreach遍历数组时与下标无关，所以在模板中关联数组和索引数组都可以使用foreach遍历。

考虑一个使用foreach遍历数组的示例。假设PHP从数据库中读取了一张表的所有记录，并保存在一个声明好的二维数组中，而且需要将这个数组中的数据在网页中显示。我们可以在脚本文件index.php中，直接声明一个二维数据保存三个人的联系信息，并通过Smarty引擎分配给模板文件。代码如下所示：

.. code-block:: php

    <?php
	require "libs/Smarty.class.php";         //包含Smarty类库
	$smarty = new Smarty();                    //创建Smarty类的对象
	$contact=array(                                 //声明一个保存三个联系人信息的二维数组
	    array('name'=>'高某','fax'=>'1234','email'=>'gao@lampbrother.net','phone'=>'4321'),
	    array('name'=>'洛某','fax'=>'4567','email'=>'luo@lampbrother.net','phone'=>'7654'),
	    array('name'=>'峰某','fax'=>'8910','email'=>'feng@lampbrother.net','phone'=>'0198')
	);
	$smarty->assign('contact', $contact);    //将关联数组$contact分配到模板中使用
	$smarty->display('index.tpl');                  //查找模板替换并输出
    ?>

创建一个模板文件index.tpl，使用双层foreach嵌套遍历从PHP中分配的二维数组，并以表格的形式在网页中输出。代码如下所示：

.. code-block:: html

	<html>
	<head>
	    <title>联系人信息表</title>
	</head>
	<body>
	    <table border="1" width="80%" align="center">
	        <caption><h1>联系人信息</h1></caption>
	        <tr><th>姓名</th><th>传真</th><th>电子邮件</th><th>联系电话</th></tr>
	        {foreach from=$contact item=row}        {* 外层foreach遍历数组$contact *}
	            <tr>                                {* 输出表格的行开始标记 *}
	                {foreach from=$row item=col}    {* 内层foreach遍历数组$row *}
	                    <td>{$col}</td>             {* 以表格形式输出数组中的每个数据 *}
	                {/foreach}                      {* 内层foreach区块结束标记 *}
	            </tr>                               {* 输出表格的行结束标记 *}
	        {/foreach}                              {* 外层foreach区域的结束标记 *}
	    </table>
	</body>
	</html>

在Smarty模板中还为foreach标记提供了一个扩展标记foreachelse，这个语句在from变量没有值的时候被执行，就是在数组为空时foreachelse标记可以生成某个候选结果。在模板中foreachelse标记不能独自使用，一定要与foreach一起使用。而且foreachelse不需要结束标记，它嵌入在foreach中，与elseif嵌入在if语句中很类似。一个使用foreachelse的模板示例如下：

.. code-block:: html

	{foreach key=key item=value from=$array}     {* 使用foreach遍历数组$array中的键和值 *}
	{$key} => {$item}                            {* 在模板中输出数组$array中元素的键和值对 *}
	{foreachelse}                                {* foreachelse在数组$array没有值的时候被执行*}
	<p>数组$array中没有任何值</p>                 {* 如果看到这条语句，说明数组中没有任何数据*}
	{/foreach}                                   {* foreach需要成对出现，是foreach的结束标记 *}

重复的区块section
""""""""""""""""
section是在模板中除foreach以外另一种处理循环的方案，虽然foreach语句已经非常灵活，但你绝对有必要多好费一点时间去学习section函数数的操作。section就像是一个改进的foreach语句，除了有相同的循环特性外，还提供了很多附加选项，可以更多地控制循环的执行。在模板中必须使用成对的section标记遍历数组中的数据，而且必须设置name和loop两个属性。它共有六个可以使用的选项参数，如表16-5所示。

+--------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------+----------+
| 参数名 | 描述                                                                                                                                                                                                 | 类型     | 默认值   |
+========+======================================================================================================================================================================================================+==========+==========+
| name   | 指定该循环的名称，当需要section循环内输出变量时，必须在变量后加上中括号包含着的name变量，为必要参数                                                                                                  | 字符串   | 无       |
+--------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------+----------+
| loop   | 决定循环次数的变量名称，应当设置为与数组变量同名，为必要参数                                                                                                                                         | 数组变量 | 无       |
+--------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------+----------+
| start  | 确定循环开始执行的索引位置，如果该值为负数，开始位置为数组的尾部算起。例如：如果数组中有七个元素，指定start为-2，那么指向当前数组的索引为5。非法值(超过了循环数组的下限)将被自动调整为最接近的合法值 | 整型     | 0        |
+--------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------+----------+
| step   | 该值决定循环的步长。例如指定step=2将只遍历下标为0、2、4等的元素，如果step为负值，那么遍历数组的时候从后向前遍历                                                                                      | 整型     | 1        |
+--------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------+----------+
| max    | 设置循环的最大执行次数                                                                                                                                                                               | 整型     | 数组长度 |
+--------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------+----------+
| show   | 决定是否显示该循环。可以使用这个参数进行程序调试                                                                                                                                                     | 布尔类型 | TRUE     |
+--------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------+----------+

section也可以嵌套遍历多维数组，不过要注意的是，丢给section的数组必须是下标从0开始的顺序索引数组。如果您的数组索引不是从0开始的正整数，可以改用foreach来进行遍历。我们将上例中使用foreach遍历的联系人信息，使用section将其改写，如下所示：

.. code-block:: html

	<table border="1" width="80%" align="center">
	    <caption><h1>联系人信息</h1></caption>
	    <tr><th>姓名</th><th>传真</th><th>电子邮件</th><th>联系电话</th></tr>
	    {section name=line loop=$contact}                       {* 使用section遍历数组$contact *}
	    <tr>{* 输出表格的行开始标记 *}
	    <td>{$contact[line].name}</td>       {* 输出数组第二维中下标为name的元素值 *}
	    <td>{$contact[line].fax}</td>{* 输出数组第二维中下标为fax的元素值*}
	    <td>{$contact[line].email}</td>{* 输出数组第二维中下标为email的元素值*}
	    <td>{$contact[line].phone}</td>{* 输出数组第二维中下标为phone的元素值*}
	    </tr>{* 输出表格的行结束标记 *}
	    {/section}                                              {* section区域的结束标记 *}
	</table>

运行上面程序，输出结果和前面使用foreach的示例相同，而我们只用一层section语句就遍历了二维数组。在本例中，仅使用section标记中两个必须的属性，loop指定了与数组变量同名的一个值，而name则设置了一个任意的字符串。其中使用loop指定的变量名既是循环指示器，也是实际的变量引用。name指定的值可以用来描述本次循环，当在section循环内需要输出数组中的元素时，必须通过数组变量本身及在后面加上中括号，并在中括号中包含着name指定的值。

此外，section标记也可以使用可选的sectionelse子标记。当loop属性指定的数组为空时，则输出sectionelse区域中的内容。sectionelse必须与section一起使用，另外它不能使用结束标记。使用sectionelse的模板示例如下：

.. code-block:: html

	{section name=customer loop=$custid}            {* 使用section迭代处理并输出多个数据数组  *}
	id: {$custid[customer]}<br>  {* 迭代处理数组$custid, 输出所有的客户ID   *}
	name: {$name[customer]}<br>  {* 迭代处理数组$name, 输出所有的客户名字  *}
	address: {$address[customer]}<br>  {* 迭代处理数组$address, 输出所有的客户地址*}
	{sectionelse}                                   {* section在loop指定的数组没有值的时候被执行*}
	<p>数组$custid中没有任何值</p>  {* 如果看到这条语句，说明数组中没有任何数据*}
	{/section}                                      {* section需要成对出现，是section的结束标记 *}

重复区块中可供调用的变量
""""""""""""""""""""""
在section和foreach两个循环中都有可供调用的一些变量名，用来访问该循环中一些特殊的值，而且在循环中都必须通过Smarty保留变量$smarty进行访问。在foreach循环中调用变量的使用方法如下所示：

``{$smarty.foreach.foreachname.varname}           {* 在foreach循环中调用一些特定的变量名语法格式 *}``

其中$smarty.foreach是Smarty的保留变量，只能用在foreach循环中。foreachname即在foreach标记中指定的name属性值，而varname则是在foreach循环中被调用的特定变量名称。可以在foreach循环中调用的变量如表16-6所示。

+-----------+------------------------------------------------------------------------------------------------------------------------------------------------+
| 变量名    | 描述                                                                                                                                           |
+===========+================================================================================================================================================+
| iteration | 用于显示当前循环的执行次数，总是从1开始，每执行一次增加1                                                                                       |
+-----------+------------------------------------------------------------------------------------------------------------------------------------------------+
| first     | 当前foreach循环在第一次执行时该变量的值true                                                                                                    |
+-----------+------------------------------------------------------------------------------------------------------------------------------------------------+
| last      | 当前foreach循环在最后一次执行时该变量的值为true                                                                                                |
+-----------+------------------------------------------------------------------------------------------------------------------------------------------------+
| show      | show是foreach的一个参数，取值为布尔值true或false。如果指定为false该循环不显示，如果循环指定了foreachelse子句，该子句显示与否也取决于show的取值 |
+-----------+------------------------------------------------------------------------------------------------------------------------------------------------+
| total     | total用于显示循环执行的次数，可以在循环中或循环执行后调用                                                                                      |
+-----------+------------------------------------------------------------------------------------------------------------------------------------------------+

我们考虑这样一个示例，使用foreach任意输出一个数组。被输出的数组可能不是按顺序的索引数组，但我们要输出顺序编号。而且循环在第一次执行和最后一次执行时，都要输出一个明显的标记，并统计循环执行的次数。示例代码如下：

.. code-block:: html

	{foreach name=myname item=value  from=$demo}                    {* 使用foreach遍历数组$demo *}
	{if $smarty.foreach.myname.first}                       {* 判断是否是第一次执行循环 *}
	<hr>{* 在第一次循环时输出一条线 *}
	{/if}
	{$smarty.foreach.myname.iteration}. 看一下这是第几行<br>
	{* 显示当前循环的执行次数 *}
	{if $smarty.foreach.myname.last}                        {* 判断是否是第一次执行循环 *}
	<hr>{* 在最后一次循环时输出一条线 *}
	{/if}
	{/foreach}
	共执行了<b>{$smarty.foreach.myname.total}</b>次循环。          {* 在循环外获取循环执行的次数 *}

如果被遍历的数组$demo中有五个元素，输出的结果如下所示：

1. 前面有行号吗？
2. 前面有行号吗？
3. 前面有行号吗？
4. 前面有行号吗？
5. 前面有行号吗？

共执行了五次循环。
在section循环中调用变量的方式和foreach相似，而且可供调用的变量比在foreach中提供得多。在section中通过如下方式调用循环中的变量：

``{$smarty.section.sectionname.varname}        {* 在section循环中调用一些特定的变量名语法格式 *}``

其中$smarty.section是Smarty的保留变量，只能用在section循环中。sectionname即在section标记中指定的name属性值，而varname则是在section循环中被调用的特定变量名称。可以在section循环中调用的变量如表16-7所示。

+------------+-------------------------------------------------------------------------------------------------------------------------------------+
| 变量名     | 描述                                                                                                                                |
+============+=====================================================================================================================================+
| index      | 用于显示当前循环的索引，从0开始(如果指定了start属性，那么由该值开始)，每次加1(如果指定了step属性，那么由该值决定)                   |
+------------+-------------------------------------------------------------------------------------------------------------------------------------+
| index_prev | 用于显示上一个循环索引值。循环开始时，此值为-1                                                                                      |
+------------+-------------------------------------------------------------------------------------------------------------------------------------+
| index_next | 用于显示下一个循环索引值。循环执行到最后一次时，此值仍然比当前索引值大1(如果指定了step,取决于此值)                                  |
+------------+-------------------------------------------------------------------------------------------------------------------------------------+
| iteration  | 用于显示循环的次数                                                                                                                  |
+------------+-------------------------------------------------------------------------------------------------------------------------------------+
| first      | 当前section循环在第一次执行时该变量的值为true                                                                                       |
+------------+-------------------------------------------------------------------------------------------------------------------------------------+
| last       | 当前section循环在最后一次执行时该变量的值为true                                                                                     |
+------------+-------------------------------------------------------------------------------------------------------------------------------------+
| rownum     | 用于显示循环的次数。该属性是iteration的别名，两者等同                                                                               |
+------------+-------------------------------------------------------------------------------------------------------------------------------------+
| loop       | 用于显示该循环上一次循环时的索引值，该值可以用于循环内部或循环结束后                                                                |
+------------+-------------------------------------------------------------------------------------------------------------------------------------+
| show       | 是section的参数。show取值为布尔值true或false。如果设置为false,该循环将不显示，如果指定了sectionelse子句，该子句是否显示也取决于该值 |
+------------+-------------------------------------------------------------------------------------------------------------------------------------+
| total      | 用于显示循环执行总的次数，不仅可以在循环中，也可以在执行结束后调用此属性                                                            |
+------------+-------------------------------------------------------------------------------------------------------------------------------------+

在模板中包含子模板
^^^^^^^^^^^^^^^^
如果在多个模板中有相同的输出内容，可以将这些相同的部分在独立的模板中定义，然后在需要的模板中将其导入。在模板中使用include标记在当前模板中包含其他模板，与PHP脚本中同名的语句作用相同，但必须在include标记中指定file属性指明模板资源的位置。例如，头部文件header.tpl和尾部文件footer.tpl都是独立的模板文件，希望每个模板中都导入这两个文件。假设所有模板文件都在相同的目录下，可以通过下面的代码完成：

.. code-block:: html

	{include file="header.tpl"}     {* 在当前模板中导入头部模板文件 *}
	body of template goes here      {* 在当前模板中的主体内容部分*}
	{include file="footer.tpl"}     {* 在当前模板中尾部头部模板文件 *}

如果从PHP中分配变量到模板中，该变量在被包含的子模板中一样可用。此外，在include标记中还有两个比较实用的特性。

- 第一个特性：可以在include标记中传入可选的assign属性，将导入的子模板内容不在当前模板中输出，而是赋给由assign属性指定的变量。

  例如：

  ``{include file="header.tpl"  assign="header"}     {* 模板header.tpl中的全部内容赋给变量header *}``

  在上面的示例中，并不会在模板中输出子模板header.tpl中的内容，而是将文件header.tpl中的内容以字符串的形式赋给了变量$header，在需要输出的位置再通过{$header}将子模板内容输出。

- 第二个特性：可以在导入子模板的同时向其传递各种属性。以此方式传递给子模板的任何属性，只能在这个被导入的文件中使用，不能用于模板的其他位置。如果传递的属性名在被包含模板中有同名变量，那么该变量被传递的属性替代。带传递参数的include标记演示如下。

  .. code-block:: html
  
      {include file="header.tpl" title="Main Menu" table_bgcolor="#c0c0c0"}
      body of template goes here
      {include file="footer.tpl" logo="http://bbs.lampbrother.net/images/logo.gif"}

  在上面的模板中包含了两个子模板。在包含header.tpl模板时，将title="Main Menu"和table_bgcolor="#c0c0c0"两个属性传递给了它，这两个属性只能在header.tpl模板中使用。同样，在包含footer.tpl模板时，传递了logo=http://bbs.lampbrother.net/images/logo.gif属性，该属性也只能在footer.tpl模板中使用。

为Smarty模板创建配置文件
----------------------
软件在开发完成以后，应用过程中经常需要改变程序的一些执行行为，如果每次都去软件源代码中修改不太现实。所以在程序开发时，都会给用户预留一个配置文件，作为修改程序执行行为的操作接口。例如，Apache服务器的配置文件httpd.conf、MySQL服务器的配置文件my.cnf，以及PHP的配置文件php.ini，都是开发人员留给用户可以修改的文件，这些配置文件负责确定程序的大量行为。

配置文件语法格式
^^^^^^^^^^^^^^^
配置文件在Smarty模板中的应用，有利于设计者管理文件中的模板全局变量。例如，设计人员可以使用配置文件存储页面标题、用户消息，以及有必要集中存储的任何信息。最简单的例子就是模板色彩变量，一般情况下你如果想改变一个程序的外观色彩，你就必须通过更改每一个文件的颜色变量来实现。如果有个配置文件的话，色彩变量就可以保存在一个地方，只要改变这个配置文件就可以实现色彩的更新。以下是一个被命名为foo.conf的配置文件示例：

.. code-block:: text

	# global variables                              #在每行前面使用“#”表示注释，这时标注全局变量
	pageTitle = "Main Menu"                         #在全局声明一个变量pageTitle，值使用双引号括起来
	bodyBgColor = #000000                           #声明一个全局变量bodyBgColor，管理模板背景色
	tableBgColor = #000000                          #全局变量tableBgColor，管理模板中表格的背景色
	rowBgColor = #00ff00                            #全局变量rowBgColor，管理模板中表格的每行背景色
	[Customer]                                      #定义节的名字，以下都是Customer节中的局部变量
	pageTitle = "Customer Info"                     #本节中声明的局部变量，覆盖同名的全局变量
	[Login]                                         #定义另一个节的名字，以下都Login中的局部变量
	pageTitle = "Login"                             #本节中声明的局部变量，定义页面的标题
	focus = "username"                              #本节中声明的局部变量
	Intro = """This is a value that spans more      #使用三个双引号可以将一个字符串声明在多行
	than one line. you must enclose                #声明在三个双引号中的第二行字符串
	it in triple quotes.""" #声明在三个双引号中的最后一行，以三个双引号结束

配置文件的名称可以任意命名，但一定要保存在Smarty引擎可以找到的目录中。配置文件存储的目录是通过Smarty对象的$config_dir属性指定的值，默认的目录是“./configs”，也就是说它将会在和php执行脚本相同的目录下寻找配置目录。建议将该属性指定的目录放在Web服务器文档根之外的位置。

在Smarty的配置文件中，可以在每行前面使用“#”添加一些注释文字。此外，在Smarty配置文件中只能使用配置变量，即“变量名=值”的格式。配置文件变量值能够在引号中使用，但是没有必要。你可以用单引号或者双引号，如果字符串需要声明多行，你可以使用三引号（"""）将它完整地封装起来。

可以在配置文件中声明全局和局部变量两种。如果声明局部变量，可以使用中括号“[]”括起来，中括号包围的项称为“节”。在节中声明的变量都属于局部变量，节之外的项都认为是全局的。使用节的好处不仅是在配置文件中声明变量的模块清晰，而且可以在模板中选择加载某节中的变量。

上面关于配置文件的例子中共有[Customer]和[Login]两个小节，每节的名称都是用一个“[]”给括起来，命名规则就是任意的字符串，只要不再包括有符号“[”或者“]”。例子开头的四个变量都是全局变量，也就是说不仅仅是可以在一个区域内使用，这些变量总是从配置文件中载入。如果某个特定的局部变量已经载入，这样全局变量和局部变量都还可以载入。如果当某个变量名既是全局变量又是局部变量时，局部变量将被优先赋予值来使用。如果在一个局部中两个变量名相同的话，最后一个将被赋值使用。

加载配置文件
^^^^^^^^^^^
在Smarty模板中如果需要使用配置文件中的变量，必须先将配置文件加载到模板中才能访问。加载配置文件可以使用内建函数config_load，并且指定的这个配置文件必须在特定的目录中存在。可以在config_load语句中，通过必选参数file指定被包含的配置文件名称，它还有三个可选参数。config_load函数中可以使用的参数如表16-8所示。

+--------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------+--------+
| 参数名                               | 描述                                                                                                                                                                                               | 类型           | 默认值 |
+======================================+====================================================================================================================================================================================================+================+========+
| file                                 | 待包含的配置文件的名称                                                                                                                                                                             | 字符串         | 无     |
+--------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------+--------+
| section                              | 指定加载配置文件的特定一节，因此，如果只需要用到某个特定节，                                                                                                                                       |                |        |
+--------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------+--------+
| 可以只加载该节中的变量，而非整个文件 | 字符串                                                                                                                                                                                             | 无             |        |
+--------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------+--------+
| scope                                | 加载数据的作用域，取值必须为local、parent或global、local说明该变量的作用域为当前模板。parent说明该变量的作用域为当前模板和当前模板的父模板(调用当前模板的模板)，global说明该变量的作用域为所有模板 | 字符串         | local  |
+--------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------+--------+
| global                               | 说明加载的变量是否全局可见，等同于scope=parent。注意：当指定了scope属性时，可以设置该属性，但模板忽略该属性的值而以scope属性为准                                                                   | 布尔类型 false |        |
+--------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------+--------+

如果配置文件foo.conf在特定目录下存在，通过上面的语句已经加载到了模板中，但只能加载配置文件中的全局变量。如果要加载配置文件中特定的节，则需要使用section属性指定。下面的示例语法，加载配置文件foo.conf中在第一节声明的变量：

``{config_load file="foo.conf" section="Customer"}        {* 加载foo.conf中第一节Customer中的变量 *}``

引用配置文件中的变量
^^^^^^^^^^^^^^^^^^
如果在Smarty模板中成功加载了配置文件，就可以在模板中引用配置文件中声明的变量了。引用的方式与PHP分配给模板的变量有所不同，配置文件中的变量需要通过用两个“#”或者是smarty的保留变量$smarty.config来调用。

考虑这样一个示例，模板页面中的标题、背景色，以及和输出表格有关的一些属性，使用自定义的配置文件进行管理。如果Smarty对象中$config_dir属性指定的值是当前目录下的configs目录，则在configs目录下创建一个名为foo.conf的配置文件，并在该文件中全部声明全局变量。如下所示：

.. code-block:: text

	# global variables                              #在每行前面使用“#”表示注释，这时标注全局变量
	pageTitle = "This is mine"                      #页面的标题
	bodyBgColor = "#eeeeee"                         #页面的背景颜色
	tableBorderSize = "3"                           #输出表格的边框宽度
	tableBgColor = "#bbbbbb"                        #输出表格的背景颜色
	rowBgColor = "#cccccc"                          #输出表格行的背景颜色

如果在模板中使用上面配置文件中声明的变量，当修改文件中的变量值就会改变模板中输出的页面样式。当然，在模板中也可以通过CSS设置样式达到同样的效果。而Smarty的配置文件并不会取代CSS，因为可以在配置文件中设置一些CSS不支持的方面，例如页面标题等。在模板文件中可以使用几种不同的语法引用配置文件中的变量。在下面文件名为index.tpl的模板中，通过在变量前后各加上一个#号来引用配置变量。代码如下所示：

.. code-block:: html

	{config_load file="foo.conf"}                           {* 加载配置文件 *}
	<html>
	<head><title>{#pageTitle#}</title></head>    {* 引用配置文件中声明的标题变量 *}
	<body bgcolor="{#bodyBgColor#}">                {* 引用配置文件中声明的背景颜色变量 *}
	    <table border="{#tableBorderSize#}" bgcolor="{#tableBgColor#}">
	        <tr bgcolor="{#rowBgColor#}">              {* 引用配置文件中行的背景颜色变量 *}
	            <td>First</td>
	            <td>Last</td>
	            <td>Address</td>
	        </tr>
	    </table>
	</body>
	</html>

引用配置变量时，如果喜欢更为正式的语法，可以使用Smarty的$smarty.config保留变量。将上面index.tpl模板代码做如下修改，会得到相同的效果。代码如下所示：

.. code-block:: html

	{config_load file="foo.conf"}                           {* 加载配置文件 *}
	<html>
	<head><title>{$smarty.config.pageTitle}</title></head>    {* 引用配置文件中声明的标题变量 *}
	<body bgcolor="{$smarty.config.bodyBgColor}">                {* 引用配置文件中声明的背景颜色变量 *}
	    <table border="{$smarty.config.tableBorderSize}" bgcolor="{$smarty.config.tableBgColor}">
	        <tr bgcolor="{$smarty.config.rowBgColor}">              {* 引用配置文件中行的背景颜色变量 *}
	            <td>First</td>
	            <td>Last</td>
	            <td>Address</td>
	        </tr>
	    </table>
	</body>
	</html>

无论选择哪一种获取配置参数的语法，都不要忘记首先使用config_load函数加载配置文件。上面两个例子会得到一样的结果。

Smarty处理页面缓存
-----------------
用户在每次访问PHP应用程序时，都会建立新的数据库连接并重新获取一次数据，再经过操作处理形成HTML等代码响应给用户。所以功能越强大的应用程序，执行时的开销就会越大。这是由于HTTP协议的无状态性造成的，对于每次页面的请求，都要重复地执行相同的操作，而不论数据是否被修改。但有些信息比如经常不变的，但是还是能变的信息。如果不想每次都重复执行相同的操作，就可以在第一次访问PHP应用程序时，将动态获取的HTML代码保存为静态页面，形成缓存文件。在以后每次请求该页面时，直接去读取缓存的数据，而不用每次都重复执行获取和处理操作带来的开销。这样，不仅可以加快页面的显示速度，而且我们在保存时通过指定下次更新的时间，也能达到缓存被动态更新的效果。比如需要60分钟更新一次，就可以根据记录的上次更新时间和当前时间比较，如果大于60分钟，重新读取数据库并更新缓存，否则还是直接读取缓存数据。所以，让Web应用程序运行得更高效，缓存技术是一种比较有效的解决方案。

在Smarty中控制缓存
^^^^^^^^^^^^^^^^^
Smarty缓存与前面介绍的Smarty编译是两个完全不同的机制，Smarty的编译功能在默认情况下是启用的，而缓存则必须由开发人员显式开启。编译的过程是将模板转换为PHP脚本，虽然Smarty模板在没被修改过的情况下，不会再重新执行转换过程，直接执行编译过的模板。但这个编译过的模板其实就是一个PHP脚本，只是减少了模板转换的开销，仍需要在逻辑层执行获取数据所需的动作，而这个动作执行开销是最大的。缓存则不仅将模板转换为PHP脚本执行，而且将模板内容转换成为静态页面，所以不仅减少了模板转换的开销，也没有了在逻辑层执行获取数据所需的开销。

建立缓存
"""""""
如果需要使用缓存，首先要做的就是让缓存可用，这就要设置Smarty对象中的缓存属性，如下所示：

.. code-block:: php

	<?php
		require('libs/Smarty.class.php');               //包含Smarty类库
		$smarty = new Smarty;                           //创建Smarty类的对象
		$smarty->caching = true;                     //启用缓存
		$smarty->cache_dir = "./cache/";                     //指定缓存文件保存的目录
		$smarty->display('index.tpl')                        //也会把输出保存
	?>

在上面PHP脚本中，通过设置Smarty对象中的 ``$caching = true（或1）`` 启用缓存。这样，当第一次调用Smarty对象中的 ``display('index.tpl')`` 方法时，不仅会把模板返回原来的状态（没缓存），也会把输出复制到由Smarty对象中的 ``$cache_dir`` 属性指定的目录下，保存为缓存文件。下次调用display('index.tpl')方法时，保存的缓存会被再用来代替原来的模板。在$chche_dir目录里的文件命名跟模板一致，尽管是用.php作为扩展名，但并不会被当做php代码来解析，所以不要去修改它。

处理缓存的生命周期
""""""""""""""""
如果被缓存的页面永远都不更新，就会失去动态数据更新的效果。但对一些经常不变的，但还是需要改变的信息，我们可以通过指定一个更新时间，让缓存的页面在指定的时间内更新一次。缓存页面的更新时间（以秒为单位）是通过Smarty对象中 ``$cache_lifetime`` 属性指定的，默认的缓存时间为3600s。因此，如果希望修改此设置，就可以设置这个属性值。一旦指定的缓存时间失效，则缓存页面将会重新生成。如下所示：

.. code-block:: php

	<?php
		require('libs/Smarty.class.php');               //包含Smarty类库
		$smarty = new Smarty;                           //创建Smarty类的对象
		$smarty->caching = 2;                        //启用缓存，在获取模板之前设置缓存生存时间
		$smarty->cache_dir = "./cache/";                     //指定缓存文件保存的目录
		$smarty->cache_lifetime = 60*60*24*7;        //设置缓存时间为1周
		$smarty->display('index.tpl');                       //也会把输出保存
	?>

如果你想给某些模板设定它们自己的缓存生存时间，你可以在调用display()或fetch()函数之前，通过设置$caching = 2，然后设置$cache_lifetime为一个唯一值来实现。$caching必须因$cache_lifetime需要而设为true，值为值1时将强迫缓存永不过期，0值将导致缓存总是重新生成（仅有利于测试，一个更有效的使缓存无效的方法是设置$caching = false）。

大多数强大的Web应用程序功能都体现在其动态特性上，哪些文件你加了缓存，缓存时间多长都是很重要的。例如，你站点的首页内容不是经常更改，那么对首页缓存一个小时或是更长都可以得到很好效果。相反，几分钟就要更新一下信息的天气地图页面，用缓存就不好了。所以一方面考虑到性能提升，另一方面也要考虑到缓存页面的时间设置是否合理，要在这二者之间进行权衡。

每个页面多个缓存
^^^^^^^^^^^^^^
例如，同一个新闻页面模板，是发布多篇新闻的通用界面。这样，同一个模板在使用时就会生成不同的页面实现。如果开启缓存，则通过同一个模板生成的多个实例都需要被缓存。Smarty实现这个问题比较容易，只要在调用display()方法时，通过在第二个可选参数中提供一个值，这个值是为每一个实例指定的一个唯一标识符，有几个不同的标识符就有几个缓存页面。如下所示：

.. code-block:: php

	<?php
		require('libs/Smarty.class.php');                       //包含Smarty类库
		$smarty = new Smarty;                                   //创建Smarty类的对象
		$smarty->caching = 1;                                //启用缓存
		$smarty->cache_dir = "./cache/";                             //指定缓存文件保存的目录
		$smarty->cache_lifetime = 60*60*24*7;                        //设置缓存时间为1周
		/*
		$news=$db->getNews($_GET["newsid"]);                 //通过表单获取的新闻ID返回新闻对象
		$smarty->assign("newsid", $news->getNewTitle());        //向模板中分配新闻标题
		$smarty->assign("newsdt", $news->getNewDataTime());       //向模板中分配新闻时间
		$smarty->assign("newsContent", $news->getNewContent);     //向模板中分配新闻主体内容
		*/
		$smarty->display('index.tpl', $_GET["newsid"]);         //将新闻ID作为第二个参数提供
	?>

在上例中，假设该脚本通过在GET方法中接收的新闻ID，从数据库中获取一篇新闻，并将新闻的标题、时间、内容通过assign()方法分配给指定的模板。在调用display()方法时，通过在第二个参数中提供的新闻ID，将这篇新闻缓存为单独的实例。采用这种方式，可以轻松地为每一篇新闻都缓存为一个唯一的实例。

为缓存实例消除处理开销
^^^^^^^^^^^^^^^^^^^^
所谓的处理开销，是指在PHP脚本中动态获取数据和处理操作等的开销，如果启用了模板缓存就要消除这些处理开销。因为页面已经被缓存了，直接请求的是缓存文件，不需要再执行动态获取数据和处理操作了。如果禁用缓存，这些处理开销总是会发生的。解决的办法就是通过Smarty对象中的is_cached()方法，判断指定模板的缓存是否存在。使用的方式如下所示：

.. code-block:: php

	<?php
		$smarty->caching = true;                             //开启缓存
		if(!$smarty->is_cached("index.tpl")) {               //判断模板文件imdex.tpl是否已经被缓存了
		// 调用数据库，并对变量进行赋值                  //消除了处理数据库的开销
		}
		$smarty->display("index.tpl");                       //直接寻找缓存的模板输出
	?>

如果同一个模板有多个缓存实例的话，每个实例都要消除访问数据库和操作处理的开销，可以在is_cached()方法中通过第二个可选参数指定缓存号。如下所示：

.. code-block:: php

	<?php
		require('libs/Smarty.class.php');                       //包含Smarty类库
		$smarty = new Smarty;                                   //创建Smarty类的对象
		$smarty->caching = 1;                                //启用缓存，
		$smarty->cache_dir = "./cache/";                        //指定缓存文件保存的目录
		$smarty->cache_lifetime = 60*60*24*7;                        //设置缓存时间为1周
		if(!$smarty->is_cache('news.tpl', $_GET["newsid"])) {   //判断news.tpl的某个实例是否被缓存
		/*
		$news=$db->getNews($_GET["newsid"]);                 //获取的新闻ID返回新闻对象
		$smarty->assign("newsid", $news->getNewTitle());          //向模板中分配新闻标题
		$smarty->assign("newsdt", $news->getNewDataTime());       //向模板中分配新闻时间
		$smarty->assign("newsContent", $news->getNewContent);     //向模板中分配新闻主体内容
		*/
		}
		$smarty->display('news.tpl', $_GET["newsid"]);               //将新闻ID作为第二个参数提供
	?>

在上例中is_cache()和display()两个方法，使用的参数是相同的，都是对同一个模板中的特定实例进行操作。

清除缓存
^^^^^^^
如果开启了模板缓存并指定了缓存时间，则页面在缓存的时间内输出结果不变。所以在程序开发过程中应该关闭缓存，因为程序员需要通过输出结果跟踪程序的运行过程，决定程序的下一步编写或用来调试程序等。但在项目开发结束时，在应用过程中就应当认真地考虑缓存，模板缓存大大提升了应用程序的性能。而用户在应用时，需要对网站内容进行管理，经常需要更新缓存，立即看到网站内容更改后的输出结果。

缓存的更新过程就是先清除缓存，再重新创建一次缓存文件。你可以用 ``clear_all_cache()`` 来清除所有缓存，或用 ``clear_cache()`` 来清除单个缓存文件。使用 ``clear_cache()`` 方法不仅清除指定模板的缓存，如果这个模板有多个缓存，你可以用第二个参数指定要清除缓存的缓存号。清除缓存的示例如下所示：

.. code-block:: php

	<?php
		require('libs/Smarty.class.php');
		$smarty = new Smarty();
		$smarty->caching = true;
		$smarty->clear_all_cache();                  // 清除所有的缓存文件
		$smarty->clear_cache("index.tpl");                   // 清除某一模板的缓存
		$smarty->clear_cache("index.tpl","CACHEID");         // 清除某一模板的多个缓存中指定缓存号的一个
		$smarty->display('index.tpl');
	?>

关闭局部缓存
^^^^^^^^^^^
对模板引擎来说，缓存是必不可少的，而局部缓存的作用也很明显，主要用于同一页中既有需要缓存的内容，又有不适宜缓存内容的情况，有选择的缓存某一部分内容或某一部分内容不被缓存。例如，在页面中如果需要显示用户的登录名称，很明显不能为每个用户都创建一个缓存页面，这就需要将显示用户名地方的缓存关闭，而页面的其他地方缓存。smarty也为我们提供了这种缓存控制能力，有以下三种处理方式。

- 使用{insert}使模板的一部分不被缓存。
- 可以使用$smarty->register_function($params, &$smarty)阻止插件从缓存中输出。
- 使用$smarty->register_block($params, &$smarty)使整篇页面中的某一块不被缓存。

如果使用 ``register_function`` 和 ``register_block`` 则能够方便地控制插件输出的缓冲能力。但一定要通过第三个参数控制是否缓存，默认是缓存的，需要我们显示设置为false。例如， ``$smarty->register _block('name', 'smarty_block_name', false);`` 。而insert函数默认是不缓存的，并且这个属性不能修改。从这个意义上讲insert函数对缓存的控制能力似乎不如 ``register_function`` 和 ``register_block`` 强。虽然这三种方法都可以很容易实现局部关闭缓存，但本节将介绍另一种最常用的方式，就是写成block插件的方式。步骤如下所示。

- 定义一件插件函数在block.cacheless.php文件中，并将其存放在smarty的plugins目录中，编写该文件的内容如下：

  .. code-block:: php
  
      <?php
		function smarty_block_cacheless($param, $content, &$smarty) {
		    return $content;
		}
      ?>

- 编写所用的模板cache.tpl文件：

  .. code-block:: html
  
	已经缓存的:{$smarty.now}
	<br>
	{cacheless}
	没有缓存的:{$smarty.now}
	{/cacheless}

- 编写程序及模板的示例程序testCacheLess.php：

  .. code-block:: php
  
      <?php
		include('Smarty.class.php');
		$tpl = new Smarty;
		$tpl->caching=true;
		$tpl->cache_lifetime = 6;
		$tpl->display('cache.tpl');
      ?>

现在通过浏览器运行一下testCacheLess.php文件，发现是不起作用的，两行时间内容都被缓存了。这是因为block插件默认也是缓存的，所以还需要改写一下Smarty的源代码文件Smarty _Compiler.class.php，在该文件中查找到下面一条语句：

``$this->_plugins['block'][$tag_command] = array($plugin_func, null, null, null, true);``

可以直接将原句的最后一个参数改成false，即关闭默认的缓存。现在清除一下template_c目录里的编译文件，重新再运行testCacheLess.php文件即可。经过我们这几步的定义，以后只需要在模板定义中，不需要缓存的部分，例如，实时比分、广告、时间等，使用 ``{cacheless}`` 和 ``{/cacheless}`` 自定义的Smarty块标记，关闭缓存的内容即可。

应用Smarty实现分页示例
---------------------
本例使用Smarty引擎在模板中实现分页，应用了前几节中介绍的Smarty安装、模板中的程序逻辑处理，以及Smarty对页面缓存的控制等。希望通过本例的学习，读者可以将Smarty各个知识点关联在一起应用，并能够充分的理解和掌握Smarty在项目中应用的价值。

准备工作
^^^^^^^
在编写分页代码之前，需要准备两方面内容：一是Smarty类库及所需的各级子目录；二是创建数据库表及插入分页所需要的多条记录。

- 假设程序的主目录为page，将Smarty类库所在的文件夹libs复制到这个目录中，并在page目录下创建templates目录，用来存放该程序所应用的所有模板文件。再在该目录下创建templates_c和cache两个目录，分别用于存放编译过的模板文件和被缓存的页面文件，并设置在服务器中PHP脚本的执行用户对这两个目录具有写的权限。
- 本例主要以实现分页为主，任何一张数据表都可以应用，可以根据需要定义自己的详细数据表。假设连接的是localhost主机的MySQL数据库，用户名和密码分别是“mysql_user”和“mysql_pwd”。并在数据库“Products”中，通过下面的SQL命令创建一个product商品表，然后向该表中随意插入多条商品记录，以供分页程序使用。如下所示：

  .. code-block:: sql
  
	CREATE TABLE product (                          //创建一个保存商品信息的数据表
	productID INT NOT NULL AUTO_INCREMENT,          //商品ID字段，自动增长
	name VARCHAR(50) NOT NULL,                      //商品名称字段，指定非空
	price DECIMAL(8,2) NOT NULL DEFAULT 0.00,       //商品价格字段
	description MEDIUMTEXT NOT NULL,                //商品描述字段
	PRIMARY KEY(productID)                          //商品ID为主键
	);

在本例中只需要编写四个文件，三个PHP脚本和一个模板文件。每个文件的作用及所存放的目录如表16-9所示。

+----------------+----------------------------------------------------------------------------------------------------------------------------------------------------------+
| 文件名         | 描述                                                                                                                                                     |
+================+==========================================================================================================================================================+
| MyDB_class.php | 声明数据库操作类所在的文件，通过该类对象获取数据表中记录总数和指定的一段数据记录。该文件存放在程序主目录page下                                           |
+----------------+----------------------------------------------------------------------------------------------------------------------------------------------------------+
| page_class.php | 声明分页操作类所在的文件，通过该类对象可以获取和当前页有关的所有信息。该文件存放在程序主目录page下                                                       |
+----------------+----------------------------------------------------------------------------------------------------------------------------------------------------------+
| index.php      | 主索引文件，加载Smarty类并初始化Smarty对象。获取指定页面所需要的数据记录。并发送到模板中，以及在该文件中建立模板缓存。该文件存放在程序主目录page下       |
+----------------+----------------------------------------------------------------------------------------------------------------------------------------------------------+
| index.tpl      | 模板文件，以HTML表格形式输出指定页面的记录，并提供用户可以操作的一些分页链接，单击链接就可以访问其他页面数据，该文件存放在主目录page下的子目录template中 |
+----------------+----------------------------------------------------------------------------------------------------------------------------------------------------------+

设计数据库操作类
^^^^^^^^^^^^^^^
分页示例只需要在数据库中执行SELECT操作，所以数据库操作类的设计也比较容易。创建一个MyDB_class.php文件，用来存放自定义的数据库操作类MyDB。在实例化该类的对象时，自动调用构造方法连接MySQL数据库。并在对象消失前自动调用析构方法，断开与数据库的连接释放资源。此外，在本例中只需要两个对外可以调用的方法：一个在调用时返回数据表中记录的总数；另一个在调用时则获取数据表中指定的一段数据记录，即在分页系统中的某一页记录。代码如下所示：

文件MyDB_class.php包含数据库处理类

.. code-block:: php

	<?php
	class MyDB
	{
	    private $mysqli;                                //保存mysqli扩展中的mysqli对象

	    /* 本类的构造方法，用来创建mysqli对象并连接到数据库，和初始化一些成员属性 */
	    public function __construct () {
	        $this->mysqli = new mysqli("localhost", "mysql_user", "mysql_pwd", "products");
	        if (mysqli_connect_errno()) {            //如果连接失败打印错误信息并退出程序
	            echo "连接失败，原因为：" . mysqli_connect_error();
	            $this->mysqli = FALSE;         //将mysqli对象赋上false值
	            exit();                         //退出程序
	        }
	        $this->showError = "";         //为成员属性showError赋初值
	    }

	    public function __destruct () {                  //该类的析构方法
	        $this->close();                      //当对象不可用时自动调用本类中的close()方法
	    }

	    public function close () {                       //调用该方法关闭与数据库的连接并释放资源
	        if ($this->mysqli)                            //如果mysqli对象存在条件成功
	            $this->mysqli->close();           //调用mysqli对象中的class()方法关闭数据库
	        $this->mysqli = FALSE;                         //将成员属性mysqli赋上FALSE值
	    }

	    public function getRowTotal () {                  //调用该方法返回商品表product中记录总数
	        $result = $this->mysqli->query("select * from Product");    //执行Select语句
	        return $result->num_rows;                            //返回结果集中的记录总数
	    }

	    public function getPageRows ($offset, $num) {                     //获取指定一段的记录
	        $query = "SELECT productID,name,price,description FROM product ";
	        $query .= "ORDER BY productID LIMIT $offset, $num";
	        if ($result = $this->mysqli->query($query)) {                 //执行Select语句获取指定一段记录
	            while ($row = $result->fetch_assoc())           //从结果集中遍历出每一行记录
	                $allProduct[] = $row;                     //将每行记录都添加到$allProduct数组中
	            $result->close();                            //关闭结果集
	            return $allProduct;                             //返回指定一页的所有行记录
	        } else {                                                  //如果查询不成功
	            return FALSE;                                   //返回FALSE值
	        }
	    }
	}
	?>

在创建MyDB类的对象后，就可以通过调用该对象中的getRowTotal()方法，获取product表中所存商品记录的总数。还可以在调用getPageRows()方法时提供两个数参数，从商品表product中指定位置处获取特定个数的记录。

设计分页操作类
^^^^^^^^^^^^^
如果数据量比较大，都会将数据表分成多页，再通过用户的操作，获取指定一页的数据输出。在程序主目录page下，新建一个文件Page_class.php，并在该文件中声明一个分页类Page。当创建该类对象时，需要在构造方法中提供记录总数、每页显示记录的个数以及当前页数索引三个参数。该类对象如果创建成功，就可以调用该对象中的getPageInfo()方法，获取和索引页有关的所有分页信息。代码如下所示：

文件Page_class.php包含分页处理类

.. code-block:: php

	<?php
	class Page {                    //分页类
	    private $total;         //保存所有的数据表记录的总条数
	    private $page;          //保存当前第几页
	    private $num;           //设置每页显示记录的条数
	    private $pageNum;       //保存一共被分为多少页的数字
	    private $offset;        //保存从数据库中取记录的开始偏移数

	    /* 该类的构造方法，创建对象时用来初始化成员属性        */
	    /* 参数total：需要提供一个数据表的记录总数         */
	    /* 参数page：需要提供一个当前页面数                    */
	    /* 参数num：需要提供每页显示记录的条数           */
	    function __construct($total, $page=1, $num=5) {
	        $this->total=$total;                         //为成员属性$total通过提供的参数初始化
	        $this->page=$page;                           //为成员属性$page通过提供的参数初始化
	        $this->num=$num;                     //为成员属性$num通过提供的参数初始化
	        $this->pageNum=$this->getPageNum();       //为属性$pageNum通过调用内部方法初始化
	        $this->offset=$this->getOffset(); //为属性$offset通过调用内部方法初始化
	    }
	    private function getPageNum(){                  //调用该方法返回计算后的页面总数
	        return ceil($this->total/$this->num);   //根据记录总数和每页显示记录的个数计算
	    }
	    private function getNextPage() {                //调用该方法返回下一页的页面索引
	        if($this->page==$this->pageNum)           //判断是否是最后一页
	            return false;                   //如果是最后一页，则没有下一页，返回FALSE
	        else                                    //如果有下一页
	            return $this->page+1;           //返回下一页的索引页面数字
	    }
	    private function getPrevPage() {                //调用该方法返回上一页的页面索引数字
	        if($this->page==1)                           //如果现在是第一页
	            return false;                   //没有上一页，则返回FALSE
	        else                                    //如果不是第一页，还存在上一页
	            return $this->page-1;           //返回上一页的页面索引数字
	    }
	    private function getOffset() {                  //调用该方法返回数据库查询所需要的偏移量
	        return ($this->page-1)*$this->num;        //返回在数据表中开始查询的位置
	    }
	    private function getStartNum() {                //调用该方法返回当前页开始的记录偏移数
	        if($this->total==0)                          //如果数据表中没有记录
	            return 0;                       //返回0
	        else                                    //如果数据表中有记录
	            return $this->offset+1;         //返回当前页开始的记录偏移数
	    }
	    private function getEndNum() {                  //调用时返回当前页结束的记录偏移数
	        return min($this->offset+$this->num,$this->total); //计算并返回结束的位置
	    }
	    /* 该方法是唯一可以在对象外部调用的公有方法                         */
	    /* 该方法会将所有和当前页面有关系的值放入一个数组一起返回          */
	    public function getPageInfo(){
	        $pageInfo=array(                                        //声明一个数组存放以下信息
	            "row_total" => $this->total,              //存放数据表中记录的总行数
	            "row_num" => $this->num,                  //存放每页显示的行数
	            "page_num" => $this->getPageNum(),        //被分为的总页数信息
	            "current_page"  => $this->page,           //当前页面索引
	            "row_offset" => $this->getOffset(),       //当前页开始的偏移位置
	            "next_page" => $this->getNextPage(),      //下一页面的索引页面索引数字
	            "prev_page" => $this->getPrevPage(),      //上一页面的索引页面索引数字
	            "page_start" => $this->getStartNum(),     //当前页面开始的记录位置
	            "page_end" => $this->getEndNum()          //当前页面结束的记录位置
	        );
	        return $pageInfo;                                       //将存放和当前页有关的所有信息数组返回
	    }
	}
	?>

创建Page类的对象以后，只提供一个可以调用的方法getPageInfo()。当调用该方法时返回一个数组，这个数组中保存和索引页面有关的所有信息。

PHP的程序逻辑层
^^^^^^^^^^^^^^
在编写分页程序时，需要在PHP脚本中处理的程序逻辑比较多，但我们已经将绝大部分功能交给了MyDB和Page两个类实现。所以在下面的脚本中，除了包含Smarty类库、创建及初始化Smarty模板引擎和开启模板页面的缓存功能外，还需要通过MyDB和Page两个类的对象访问，获取索引页面的数据和分页信息，并都以数组的形式通过Smarty引擎分配给模板。文件index.php是分页示例中的主程序文件，存放在主目录page下。代码如下所示：

程序的主索引文件index.php

.. code-block:: php

	<?php
	include "./libs/Smarty.class.php";              //包含Smarty类库所在的文件
	require("Page_class.php");                      //包含分页类Page所在的文件
	require("MyDB_class.php");                      //包含数据库读取类所在的文件
	$tpl = new Smarty();                            //创建一个Smarty类的对象$tpl
	$tpl->template_dir = "./templates/";                 //设置所有模板文件存放的目录
	$tpl->compile_dir = "./templates_c/";                //设置所有编译过的模板文件存放的目录
	$tpl->cache_dir = "./cache/";                        //设置存放Smarty缓存文件的目录
	$tpl->caching=1;                             //设置开关Smarty缓存模板功能属性，这里为开启
	$tpl->cache_lifetime=60*60;                  //设置模板缓存有效时间段的长度，这里为1小时
	$tpl->left_delimiter = '<{';                      //设置模板语言中的左结束符
	$tpl->right_delimiter = '}>';                     //设置模板语言中的右结束符

	/*在GET方法中获取用户提交的页面索引数字。默认第一页，页面索引$current_page值为1*/
	$current_page=isset($_GET['page'])?intval($_GET['page']):1;
	/* 通过is_cached()方法判断指定的页面是否已经被缓存，如果是则不再执行数据库操作 */
	if(!$tpl->is_cached("index.tpl", $current_page)) {
	    $mydb=new MyDB();                               //创建数据库操作类MyDB的对象
	    $total=$mydb->getRowTotal();                 //调用MyDB类的方法返回数据表记录总数
	    $fpage=new Page($total,$current_page, 5);       //通过获取的值创建分页类Page的对象
	    $pageInfo=$fpage->getPageInfo();             //获取和当前页面有关的所有信息数组
	    /* 通过调用MyDB中的方法，获取当前页面所需要的所有记录的数据数组 */
	    $products=$mydb->getPageRows($pageInfo["row_offset"], $pageInfo["row_num"]);
	    if($products) {                                 //如果从数据库中获取到商品记录
	        $tpl->assign("tableName", "商品列表");  //分配页面显示的表面到模板中
	        $tpl->assign("url", "index.php");       //分配分页处理文件的URL到模板中
	        $tpl->assign("products", $products);    //将在本页显示的所有数据数组分配给模板
	        $tpl->assign("pageInfo", $pageInfo);    //将和当前页有关的所有信息数组分配给模板
	    }else {                                         //如果没有获取到任何商品记录
	        echo "数据读取失败!";                 //输出一行提示信息
	        exit;                                   //并退出程序
	    }
	}
	$tpl->display("index.tpl", $current_page);           //加载输出模板index.tpl，并指定页面缓存标号
	?>

在上面的脚本中，通过在get方法中获取用户请求的页面索引，处理用户所请求的页面数据。并通过该索引为访问过的每个页面单独创建一个缓存文件，而且使用模板引擎中的is_cached()方法进行判断，消除了访问缓存页面时的处理开销。

Smarty模板的表现层
^^^^^^^^^^^^^^^^^
在程序主目录Page下的子目录templates中，创建一个模板文件index.tpl，分页中的每个页面实例都是通过这一模板输出的。在该模板中，主要输出两方面内容：一是遍历索引页面的数组并以HTML表格形式输出；二是输出用户可以操作的分页链接及其他和分页有关的信息。代码如下所示：

目录templates下面的主模板文件index.tpl

.. code-block:: html

	<html>
	    <head><title>Smarty实现商品列表</title></head>
	    <body>
	        <{* 以表格的形式显式当前页的特定个数数据 *}>
	        <table align="center" border="1" width="90%">
	            <caption><h1><{ $tableName }></h1></caption>
	            <tr>
	                <th>编号</th><th>商品名称</th><th>价格</th><th>商品介绍</th>
	            </tr>
	            <{* 使用section语句遍历从PHP中分配过来的商品数组$products *}>
	            <{ section name=record loop=$products }>
	                <tr>
	                    <td><{ $products[record].productID} ></td>
	                    <td><{ $products[record].name} ></td>
	                    <td><{ $products[record].price} ></td>
	                    <td><{ $products[record].description} ></td>
	                </tr>
	            <{ sectionelse }>
	                <tr><td colspan="4">没有任何商品存储</td></tr>
	            <{ /section }>
	        </table>
	        <{* 在下面段落中输出和分页有关的信息，并输出用户可以页面切换操作的链接 *}>
	        <p align="center">
	        共<b> <{ $pageInfo.row_total }> </b> 条记录，
	        显示第 <b> <{ $pageInfo.page_start }> </b>-<b> <{ $pageInfo.page_end }> </b>条记录
	            <a href="<{ $url }>?page=1">|&lt;</a>
	        <{ if $pageInfo.prev_page }>
	            <a href="<{ $url }>?page=<{ $pageInfo.prev_page }>">&lt;&lt;</a>
	        <{ else }>
	           &lt;&lt;
	        <{ /if }>
	        <{ if $pageInfo.next_page }>
	            <a href="<{ $url }>?page=<{ $pageInfo.next_page }>">>></a>
	        <{ else }>
	        >>
	        <{ /if }>
	            <a href="<{ $url }>?page=<{ $pageInfo.page_num }>"> >|</a>
	            当前 <b><{ $pageInfo.current_page }>/<{ $pageInfo.page_num }></b> 页
	        </p>
	    </body>
	</html>


因为我们开启了页面缓存的功能，所以通过该模板输出的每个实例都会被缓存，存放在程序主目录下的子目录cache中。在缓存的时间内，如果操作该模板中的每个分页，都会直接访问和该页面索引对应的缓存文件。

https://kuaizhui.baidu.com/view/b025391fbb4cf7ec4afed0f7?cn=20-1,20-3
