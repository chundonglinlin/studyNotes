正则表达式
=====

什么是正则表达式
--------
正则表达式是一种描述字符串结构的语法规则，是一个特定的格式化模块，可以匹配、替换、截取匹配的字符串。先弄清楚几个术语：

- grep:最初是ED编辑器的一条命令，用来显示文件中特定的内容，后来成为一个独立的工具grep。
- egrep: grep虽然不断地更新升级，但仍然无法跟上技术的脚步。为此，贝尔实验室推出了egrep,意为“扩展的grep”，这大大增强了正则表达式的能力。
- POSIX (Portable Operating System Interface of Vnix ):可移植操作系统接口。在grep发展的同时，其他一些开发人员也按照自己的喜好开发出了具有独特风格的版本。但问题也随之而来，有的程序支持某个元字符，而有的程序则不支持。因此就有了POSIX, POSIX是一系列标准，确保了操作系统之间的可移植性。但POSIX和SQL一样，没有成为最终的标准而只能作为一个参考。
- Perl (Practical Extraction and Reporting Language):实际抽取与汇报语言。1987年，Larry Wall发布了Pert。在随后的7年时间里，Perl经历了从Perl I到现在的Perl5的发展，最终Perl成为了POSIX之后的另一个标准。
- PCRE:Perl的成功，让其他的开发人员在某种程度上要兼容Perl，包括。C++, Java。Python等都有自己的正则表达式。1997年，Philip Hazel开发了PCRE库，这是兼容Per!正则表达式的一套正则引擎，其他开发人员可以将PCRE整合到自己的语言中，为用户提供丰富的正则功能。许多软件都使用PCRE, PHP正是其中之一。

正则表达式语法规则
---------
一个完整的正则表达式由两部分构成，元字符和文本字符。元字符就是具有特殊含义的字符。文本字符就是普通的文本。PCRE风格的正则表达式一般放置在定界符“/”中间。

行定位符(^和$)
^^^^
行定位符就是用来描述字串的边界：

- “^”表示行的开始;
- “$”表示行的结尾;

``^tm``

该表达式表示要匹配字串tm的开始位置是行头，如 ``tm equal Tomorrow Moon`` 就可以匹配，而 ``Tomorrow
Moon equal tm`` 则不匹配。但如果使用

``tm$``

则后者可以匹配而前者不能匹配。如果要匹配的字串可以出现在字符串的任意部分，那么可以直接写成 ``tm`` 这样两个字符申就都可以匹配了。

单词定界符(\\b、\\B)
^^^^^
使用tm可以匹配在字符串中出现的任何位置。那么类似html, utmost中的tm也会被查找出来。但现在需要匹配的是单词
tm，而不是单词的一部分。这时可以使用单词分界符 ``\b``,表示要查找的字符串为一个完整的单词。

如： ``\btm\b``

还有一个大写的 ``\B``，意思和 ``\b`` 相反。它匹配的字串不能是一个完整的单词，而是其他单词或字串的一部分。如:  ``\Btm\B``

字符类([])
^^^^^^^^^^
正则表达式是区分大小写的，如果要忽略大小写可使用方括号表达式“[]”。只要匹配的宇符出现在方括号内，即可表示匹配成功。但要注意:一个方括号只能匹配一个字符。匹配不区分大小写的字母 ： 如 ： ``[Tt][Mm]``

这样，即可匹配字符串tm的所有写法。POSIX和PCRE都使用了一些预定义字符类。但表示方法略有不同。POSIX风格的预定义字符类如下表：

+------------+--------------------------------------------------+------------------------------------------+
| 类         | 描述                                             | 扩展                                     |
+============+==================================================+==========================================+
| [:alnum:]  | 字母和数字字符集合                               | [0-9a-zA-Z]                              |
+------------+--------------------------------------------------+------------------------------------------+
| [:alpha:]  | 字母字符集合                                     | [a-zA-Z]                                 |
+------------+--------------------------------------------------+------------------------------------------+
| [:ascii:]  | 7位ASCII                                         | [\\x01-\\x7F]                            |
+------------+--------------------------------------------------+------------------------------------------+
| [:blank:]  | 水平空白符(空格、制表符)                         | [ \\t]                                   |
+------------+--------------------------------------------------+------------------------------------------+
| [:cntrl:]  | 控制字符                                         | [\\x01-\\x1F]                            |
+------------+--------------------------------------------------+------------------------------------------+
| [:digit:]  | 数字                                             | [0-9]                                    |
+------------+--------------------------------------------------+------------------------------------------+
| [:space:]  | 空白字符（换行、回车、制表符、空格、垂直制表符） | [\\n\\r\\t \\x0B]                        |
+------------+--------------------------------------------------+------------------------------------------+
| [:graph:]  | 所有可打印的字符(不包括空白字符)                 | [^\\x01-\\x20]                           |
+------------+--------------------------------------------------+------------------------------------------+
| [:print:]  | 可所有打印字符(包括空白字符)                     | [\\t\\x20-\\xFF]                         |
+------------+--------------------------------------------------+------------------------------------------+
| [:punct:]  | 任意标点符号，如句点(.)和分号(;)                 | [-!"#$%&'( )\*+,./:;<=>?@[\\\\]^_'{\|}~] |
+------------+--------------------------------------------------+------------------------------------------+
| [:lower:]  | 小写字母                                         | [a-z]                                    |
+------------+--------------------------------------------------+------------------------------------------+
| [:upper:]  | 大写字母                                         | [A-Z]                                    |
+------------+--------------------------------------------------+------------------------------------------+
| [:xdigit:] | 十六进制数字                                     | [0-9a-fA-F]                              |
+------------+--------------------------------------------------+------------------------------------------+
而PCRE的预定义字符类则使用反斜线来表示，反斜线的用法请参考下面小节。

选择字符(|)
^^^^
这个可以实现上面字符类的匹配模式，可以理解为“或”。如： ``T|tM|m`` 表示字母T或tM或m。

 使用"[]"和"|"的区别在于"[]"只能匹配单个字符，而"|"可以匹配任意长度的字串，上例可以写为: ``TM|tm|Tm|tM``

 模式“LAMP|J2EE”表示可以匹配“LAMP”也可以匹配“J2EE”，因为元字符竖线“|”的优先级是最低的，所以并不是表示匹配“LAMP2EE”或“LAMJ2EE”。

连字符(-)
^^^^^^^^
如果用正则表达式来匹配变量的第一个字母，要写为:[a,b,c,d...A,B,C,D...] 这无疑是非常麻烦的，正则表达式提供了连字符来解决这个问题。上述可以写成 ``[a-zA-Z]``

排除字符([^])
^^^^
匹配不符合命名规则的变量，正则表达式提供了"^"字符。如：

``[^a-zA-Z]`` 该表达式匹配的就是不包含字母的字符串。

限定符(?\*+{n,m})
^^^^^^^^^^^^^^^^
对于重复出现字母或字符串，可以使用限定符来实现匹配。限定符主要有6种：

+--------+--------------------------------+--------------------------------------------------------------+
| 限定符 | 说明                           | 举例                                                         |
+========+================================+==============================================================+
| ?      | 匹配前面的字符零次或一次       | 如:colou?r,该表达式可以匹配colour和color                     |
+--------+--------------------------------+--------------------------------------------------------------+
| \+     | 匹配前面的字符一次或多次       | 如:go\+gle,该表达式可以匹配的范围从gogle到goo..gle           |
+--------+--------------------------------+--------------------------------------------------------------+
| \*     | 匹配前面的字符零次或多次       | 如:go\*gle,该表达式可以匹配的范围从ggle到goo...gle           |
+--------+--------------------------------+--------------------------------------------------------------+
| {n}    | 匹配前面的字符n次              | 如go{2}gle,该表达式只匹配google                              |
+--------+--------------------------------+--------------------------------------------------------------+
| {n,}   | 匹配前面的字符最少n次          | 如go{2,}gle，该表达式可以匹配从google到goo...gle             |
+--------+--------------------------------+--------------------------------------------------------------+
| {n,m}  | 匹配前面的字符最少n次，最多m次 | 如employe{0,2},该表达式额可以匹配employm、employe和employee. |
+--------+--------------------------------+--------------------------------------------------------------+

点号字符(.)
^^^^
如遇到这样的试题：写出5~10个以s开头，t结尾的单词，这是由很大难度的。在正则表达式中可以通过点字符(.)来实现这样的匹配。**点字符(.)可以匹配出换行符外的任意一个字符。** 如匹配以s开头，t结尾，中间包含一个字母的单词的格式为： ``^s.t$`` 匹配的单词包括：sat,set,sit等。

再一个举实例，匹配一个单词，它的第一个字母为r,第3个字母为s，最后一个字母为t。能匹配该单词的正则表达式为： ``^r.s.*t$``

转义字符(\\)
^^^^
转义字符就是将特殊字符（如".","?","\\"）变为普通的字符。举一个IP地址的实例

127.0.0.1 格式为： ``[0-9]{1,3}(\.[0-9]{1,3}){3}``

在这里介绍下 括号字符（()） 这个表达式的作用是分组，也就是 ``(\.[0-9]{1,3})`` 这个是一组，而且要出现三次（因为后面的{3}）

 小括号在正则表达式中也算是一个元字符。

反斜线(\\)
^^^^^^^^^
除了可以做转义字符外，反斜线还有其他一些功能。

- 将一些不可打印的字符显示出来，如下表：

  +-------+--------------------------------------------------------------------------+
  | 字符  | 说明                                                                     |
  +=======+==========================================================================+
  | \\a   | 警报，即ASCII中的<BEL>字符(0x07)                                         |
  +-------+--------------------------------------------------------------------------+
  | \\b   | 退格，即ASCII中的<BS>字符(0x08)，在PHP中只有在中括号([])里使用才表示退格 |
  +-------+--------------------------------------------------------------------------+
  | \\e   | Escape，即ASCII中的<ESC>字符(0x1B)                                       |
  +-------+--------------------------------------------------------------------------+
  | \\f   | 换页符，即ASCII中的<FF>字符(0x0C)                                        |
  +-------+--------------------------------------------------------------------------+
  | \\n   | 换行符，即ASCII中的<LF>字符(0x0A)                                        |
  +-------+--------------------------------------------------------------------------+
  | \\r   | 回车符，即ASCII中的<CR>字符(0x0D)                                        |
  +-------+--------------------------------------------------------------------------+
  | \\t   | 水平制表符，即ASCII中的<HT>字符(0x09)                                    |
  +-------+--------------------------------------------------------------------------+
  | \\xhh | 十六进制代码                                                             |
  +-------+--------------------------------------------------------------------------+
  | \\ddd | 八进制代码                                                               |
  +-------+--------------------------------------------------------------------------+
  | \\cx  | 即control-x的缩写，匹配有x指明的控制字符，其中x是任意字符                |
  +-------+--------------------------------------------------------------------------+

- 指定预定义字符集，如下表：

  +--------------+----------------------------------------------------------------------------------+
  | 预定义字符集 | 说明                                                                             |
  +==============+==================================================================================+
  | \\d          | 任意一个十进制数字，相当于[0-9]                                                  |
  +--------------+----------------------------------------------------------------------------------+
  | \\D          | 任意一个非十进制数字                                                             |
  +--------------+----------------------------------------------------------------------------------+
  | \\s          | 任意一个空白字符(空格、换行符、换页符、回车符、水平制表符)，相当于[\\f\\n\\r\\t] |
  +--------------+----------------------------------------------------------------------------------+
  | \\S          | 任意一个非空白字符                                                               |
  +--------------+----------------------------------------------------------------------------------+
  | \\w          | 任意一个单词字符，相当于[a-zA-Z0-9]                                              |
  +--------------+----------------------------------------------------------------------------------+
  | \\W          | 任意一个非单词字符                                                               |
  +--------------+----------------------------------------------------------------------------------+

- 定义断言，如下表：

  +--------+----------------------------------------+
  | 限定符 | 说明                                   |
  +========+========================================+
  | \\b    | 单词定界符，用来匹配字符串中的某些位置 |
  +--------+----------------------------------------+
  | \\B    | 非单词定界符序列                       |
  +--------+----------------------------------------+
  | \\A    | 匹配搜索文本的起始位置                 |
  +--------+----------------------------------------+
  | \\Z    | 匹配搜索文本的末尾位置                 |
  +--------+----------------------------------------+
  | \\z    | 只匹配字符串的末尾，而不考虑任何换行符 |
  +--------+----------------------------------------+
  | \\G    | 当前匹配的其实位置                     |
  +--------+----------------------------------------+

括号字符(())
^^^^
- 小括号字符的第一个作用就是可以改变限定符的作用范围，如“|”、“\*”、“^”等，例如 ``(thir|four)th``  这个表达式的意思是匹配单词thirth或fourth，如果不使用小括号，那么就变成了匹配单词thir和fourth了。
- 小括号的第二个作用是分组，也就是子表达式。如 ``(\.[0-9]{1,3}){3}`` ，就是对分组 ``(\.[0-9]{1,3})`` 进行重复操作。

反向引用
^^^^
依靠子表达式的“记忆”功能来匹配连续出现的字串或字母。如匹配连续两个it,格式为 ``(it)\1``

如果使用了多个分组，那么可以用"\\1","\\2"来表示每个分组（顺序是从左到右）如： ``([a-z])([A-Z])\1\2``

除了可以使用数字来表示分组外，还可以自己来指定分组名称。语法格式如下：

``(?P<subname>...)``

如果想要反向引用该分组，使用如下语法：

``(?P=subname)``

下面来重写一下表达式 ``([a-z])([A-Z])\1\2`` 为这两个分组分别命名，并反向引用它们。正则表达式如下：

``(?P<fir>[a-z])(?P<sec>[A-Z])(?P=fir)(?P=sec)``

模式修饰符
^^^^^
模式修饰符的作用是设定模式。也就是规定正则表达式应该如何解释和应用。不同的语言都有自己的模式设置，PHP中的主要模式修饰符如下表：

+--------+------------------------+----------------------------------------------------------+
| 修饰符 | 表达式写法             | 说明                                                     |
+========+========================+==========================================================+
| i      | (?i)···(?-i)、(?i:···) | 忽略大小写模式                                           |
+--------+------------------------+----------------------------------------------------------+
| m      | (?m)···(?-m)、(?m:···) | 多文本模式，字符串内部有多个换行符时，影响"^"和"$"的匹配 |
+--------+------------------------+----------------------------------------------------------+
| s      | (?s)···(?-s)、(?s:···) | 单文本模式                                               |
+--------+------------------------+----------------------------------------------------------+
| x      | (?x)···(?-x)、(?x:···) | 忽略空白字符                                             |
+--------+------------------------+----------------------------------------------------------+

  模式修饰符既可以写在正则表达式的外面，也可以写在表达式内。如忽略大小写模式，可以写为/tm/i、(?!)tm(?-i)和(?i:tm)3种格式。

POSIX扩展正则表达式函数
--------------

ereg()函数和eregi()函数
^^^^^^^^^^^^^^^^^^^^^^
函数语法：

``bool ereg/eregi ( string pattern, string string [, array regs] )``

函数功能：

在字符串string中匹配表达式pattern，如果匹配成功返回true，否则返回false。如果有第3个参数regs，则将成功匹配的字串按子串（子表达式）划分，并存储到regs数组中。ereg区分大小写，而eregi不区分大小写。

.. code-block:: php

    <?php
	$ereg='^[$][[:alpha:]_][[:alnum:]]*';   //要匹配的字串表达式
	ereg($ereg,'$_name',$register);   //使用ereg()函数匹配
	var_dump($register);   //显示匹配后的数组结构
    ?>

ereg_replace()函数和eregi_replace()函数
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
函数语法：

``string ereg_replace/eregi_replace ( string pattern, string replacement, string string )``

函数功能：

在字符串string中匹配表达式pattern。如果匹配成功，则使用replacement来替换匹配字串，并返回替换后的string。eregi_replace()不区分大小写。

.. code-block:: php

    <?php
	$ereg = 'tm';   //要匹配的字串表达式
	$str = 'hello,tm,Tm,tM';   //要查找的文本
	$rep_str=eregi_replace($ereg,'TM',$str);    //替换查找的文本
	echo $rep_str;   //输出替换后的文本
	// 运行结果为：hello,TM,TM,TM
    ?>

split()函数和spliti()函数
^^^^^^^^^^^^^^^^^^^^^^^^
函数语法：

``array split/spliti ( string pattern, string string [, int limit] )``

函数功能：

使用表达式pattern来分割字符串string。如果有参数limit，那么数组最多有limit个元素，剩余部分都写到最后一个数组元素中。如果函数错误，则返回false。split()函数区分大小写，spliti()函数不区分大小写。

.. code-block:: php

    <?php
	$ereg = 'is';    //分割字符串的表达式
	$str = 'This is a register book';   //要被分割的字符串
	$arr_str = spliti($ereg,$str);  //使用spliti()函数分割
	var_dump($arr_str);   //显示分割后的数组结构
	/* 运行结果：
	array (size=4)
	  0 => string 'Th' (length=2)
	  1 => string ' ' (length=1)
	  2 => string ' a reg' (length=6)
	  3 => string 'ter book' (length=8)
	 */
    ?>

PCRE兼容正则表达式函数
-------------
实现PCRE风格的正则表达式的函数也有7个；但是执行效率和语法支持上PCRE都略优于POSIX函数；

preg_grep()函数
^^^^^^^^^
函数语法：

``array preg_grep (string pattern, array input)``

函数功能：

使用数组input中的元素一一匹配表达式pattern，最后返回由所有相匹配的元素所组成的数组。对于输入数组input中的每个元素，只进行一次匹配。

.. code-block:: php

    <?php
	$preg='/\d{3,4}-?\d{7,8}/';   //国内电话格式表达式
	$arr = array('043212345678','0431-7654321','12345678');    //数组
	$preg_arr = preg_grep($preg,$arr);  //使用函数匹配
	var_dump($preg_arr);   //返回匹配的数组
	/* 运行结果
	array (size=2)
	  0 => string '043212345678' (length=12)
	  1 => string '0431-7654321' (length=12)
 	*/
    ?>

preg_match()函数
^^^^^^^^^^^^^^^
函数语法：

``int preg_match/preg_match_all ( string $pattern , string $subject [, array &$matches [, int $flags = 0 [, int $offset = 0 ]]] )``

函数功能：

在字符串subject中匹配表达式pattern。函数返回匹配的次数。如果有数组matches，那么每次匹配的结果都将被存储到数组matches中。

参数：

- pattern：要搜索的模式，字符串类型。
- subject：输入字符串。
- matches：如果提供了参数matches，则可以用于保存与第一个参数中的子模式的各个部分的匹配结果。正则表达式中的子模式是使用括号括起来的模式单元。其中$matches[0]将包含与正则表达式pattern完整模式匹配到的文本，$matches[1]将包含第一个捕获子组匹配到的文本，以此类推。
- flags：flags可以被设置为以下标记值：
    + PREG_OFFSET_CAPTURE
	如果传递了这个标记，对于每一个出现的匹配返回时会附加字符串偏移量(相对于目标字符串的)。 注意：这会改变填充到matches参数的数组，使其每个元素成为一个由 第0个元素是匹配到的字符串，第1个元素是该匹配字符串 在目标字符串subject中的偏移量。

	.. code-block:: php
	  
	      <?php
			preg_match('/(foo)(bar)(baz)/', 'foobarbaz', $matches, PREG_OFFSET_CAPTURE);
			print_r($matches);
			/* 运行结果
			Array
			(
			    [0] => Array
			        (
			            [0] => foobarbaz
			            [1] => 0
			        )

			    [1] => Array
			        (
			            [0] => foo
			            [1] => 0
			        )

			    [2] => Array
			        (
			            [0] => bar
			            [1] => 3
			        )

			    [3] => Array
			        (
			            [0] => baz
			            [1] => 6
			        )
			)
			 */
	      ?>

- offset
      通常，搜索从目标字符串的哪个位置开始。可选参数 offset 用于指定从目标字符串的某个位置开始搜索(单位是字节)。

返回值：

- preg_match()返回 pattern 的匹配次数。 它的值将是0次（不匹配）或1次，因为preg_match()在第一次匹配后 将会停止搜索。preg_match_all()不同于此，它会一直搜索subject 直到到达结尾。 如果发生错误preg_match()返回 FALSE。

.. code-block:: php

    <?php
	$str = 'This is an example!';
	$preg = '/\b\w{2}\b/';
	$num1 = preg_match($preg,$str,$str1);
	echo $num1."<br>";
	var_dump($str1);
	$num2 = preg_match_all($preg,$str,$str2);
	echo '<p>'.$num2.'<br>';
	var_dump($str2);
	/*运行结果为：
	1
	array (size=1)
	  0 => string 'is' (length=2)
	2
	array (size=1)
	  0 => 
	    array (size=2)
	      0 => string 'is' (length=2)
	      1 => string 'an' (length=2)
	 */
    ?>

preg_match_all()函数
^^^^^^^^^^^^^^^^^^^^
函数语法：

``int preg_match_all ( string $pattern , string $subject [, array &$matches [, int $flags = PREG_PATTERN_ORDER [, int $offset = 0 ]]] )``

函数功能：

搜索subject中所有匹配pattern给定正则表达式 的匹配结果并且将它们以flag指定顺序输出到matches中。

在第一个匹配找到后, 子序列继续从最后一次匹配位置搜索。

参数：

- pattern：要搜索的模式，字符串形式。
- subject：输入字符串。
- matches：多维数组，作为输出参数输出所有匹配结果, 数组排序通过flags指定。
- flags：可以结合下面标记使用(注意不能同时使用 **PREG_PATTERN_ORDER** 和 **PREG_SET_ORDER** )：
    + PREG_PATTERN_ORDER：
      结果排序为$matches[0]保存完整模式的所有匹配, $matches[1] 保存第一个子组所匹配的字符串组成的数组，以此类推。

      .. code-block:: php
      
          <?php
		preg_match_all("|<[^>]+>(.*)</[^>]+>|U",
		    "<b>example: </b><div align=left>this is a test</div>",
		    $out, PREG_PATTERN_ORDER);
		echo $out[0][0] . ", " . $out[0][1] . "\n";
		echo $out[1][0] . ", " . $out[1][1] . "\n";
		/*
		<b>example: </b>, <div align=left>this is a test</div>
		example: , this is a test
		 */
          ?>

      如果正则表达式包含了带名称的子组，$matches 额外包含了带名称子组的键。

    + PREG_SET_ORDER：

      .. code-block:: php
      
          <?php
		preg_match_all("|<[^>]+>(.*)</[^>]+>|U",
		    "<b>example: </b><div align=\"left\">this is a test</div>",
		    $out, PREG_SET_ORDER);
		echo $out[0][0] . ", " . $out[0][1] . "\n";
		echo $out[1][0] . ", " . $out[1][1] . "\n";
		/* 运行结果
		<b>example: </b>, example:
		<div align="left">this is a test</div>, this is a test
		 */
	  ?>

      结果排序为$matches[0]包含第一次匹配得到的所有匹配(包含子组)， $matches[1]是包含第二次匹配到的所有匹配(包含子组)的数组，以此类推。
    + PREG_OFFSET_CAPTURE：
      如果这个标记被传递，每个发现的匹配返回时会增加它相对目标字符串的偏移量。 注意这会改变matches中的每一个匹配结果字符串元素，使其 成为一个第0个元素为匹配结果字符串，第1个元素为 匹配结果字符串在subject中的偏移量。

      .. code-block:: php
      
		<?php
			preg_match_all('/(foo)(bar)(baz)/', 'foobarbaz', $matches, PREG_OFFSET_CAPTURE);
			print_r($matches);
			/* 运算结果
			Array
			(
			    [0] => Array
			        (
			            [0] => Array
			                (
			                    [0] => foobarbaz
			                    [1] => 0
			                )
			        )

			    [1] => Array
			        (
			            [0] => Array
			                (
			                    [0] => foo
			                    [1] => 0
			                )
			        )

			    [2] => Array
			        (
			            [0] => Array
			                (
			                    [0] => bar
			                    [1] => 3
			                )
			        )

			    [3] => Array
			        (
			            [0] => Array
			                (
			                    [0] => baz
			                    [1] => 6
			                )
			        )
			)
			 */
		?>

    如果没有给定排序标记，假定设置为PREG_PATTERN_ORDER。
    
    + offset：
      通常， 查找时从目标字符串的开始位置开始。可选参数offset用于 从目标字符串中指定位置开始搜索(单位是字节)。

preg_quote()函数
^^^^^^^^^^^^^^^^
函数语法：

``string preg_quote (string str [, string delimiter])``

函数功能：

该函数将字符串str中的所有特殊字符进行自动转义。如果指定了可选参数 delimiter，它也会被转义。函数返回转义后的字串。 这通常用于你有一些运行时字符串需要作为正则表达式进行匹配的时候。

正则表达式特殊字符有： ``. \ + * ? [ ^ ] $ ( ) { } = ! < > | : -``

例如：输出常用的特殊字符，并且将字母b也当做特殊字符输出：

.. code-block:: php

    <?php
	$str ='!、$、^、*、+、.、[、]、\\、/、b、<、>';
	$str2= 'b';
	$match_one = preg_quote($str,$str2);  //将$str和$str2字符进行转义
	echo $match_one;   //输出转义后的字符
	/*运行结果
	\!、\$、\^、\*、\+、\.、\[、\]、\\、/、\b、\<、\>
	*/
    ?>

这里的特殊字符是指正则表达式中具有一定意义的元字符。其它如"@"、"#"等则不会被当作特殊字符处理。

preg_replace()函数
^^^^^^^^^^^^^^^^^^
函数语法：

``mixed preg_replace (mixed pattern, mixed replacement, mixed subject [, int limit])``

函数功能：

该函数在字符串subject中匹配表达式pattern，并将匹配项替换成字串replacement。如果有参数limit，则仅替换limit次。如果省略limit或者其值为-1，则所有的匹配项都会被替换。

参数：

- pattern：要搜索的模式。可以使一个字符串或字符串数组。 **可以使用一些PCRE修饰符。**
- replacement：用于替换的字符串或字符串数组。如果这个参数是一个字符串，并且pattern 是一个数组，那么所有的模式都使用这个字符串进行替换。如果pattern和replacement 都是数组，每个pattern使用replacement中对应的 元素进行替换。如果replacement中的元素比pattern中的少， 多出来的pattern使用空字符串进行替换。

  replacement中可以包含后向引用\\n 或$n，语法上首选后者(如\\11 函数搞不清楚是想要一个\\1的逆向引用后面跟着一个数字1，还是一个\\11的逆向引用，建议使用\${1}1)。 每个 这样的引用将被匹配到的第n个捕获子组捕获到的文本替换。 n 可以是0-99，\\0和$0代表完整的模式匹配文本。 捕获子组的序号计数方式为：代表捕获子组的左括号从左到右， 从1开始数。如果要在replacement 中使用反斜线，必须使用4个("\\\\"，译注：因为这首先是php的字符串，经过转义后，是两个，再经过 正则表达式引擎后才被认为是一个原文反斜线)。

  当在替换模式下工作并且后向引用后面紧跟着需要是另外一个数字(比如：在一个匹配模式后紧接着增加一个原文数字)， 不能使用\\1这样的语法来描述后向引用。比如， \\11将会使preg_replace() 不能理解你希望的是一个\\1后向引用紧跟一个文本1，还是一个\\11后向引用后面不跟任何东西。 这种情况下解决方案是使用${1}1。 这创建了一个独立的$1后向引用, 一个独立的文本1。

  当使用被弃用的 e 修饰符时, 这个函数会转义一些字符(即：'、"、 \\ 和 NULL)然后进行后向引用替换。当这些完成后请确保后向引用解析完后没有单引号或双引号引起的语法错误(比如： ``'strlen(\'$1\')+strlen("$2")'`` )。确保符合PHP的 字符串语法，并且符合eval语法。 **因为在完成替换后，引擎会将结果字符串作为php代码使用eval方式进行评估并将返回值作为最终参与替换的字符串。**

- subject：要进行搜索和替换的字符串或字符串数组。
  如果subject是一个数组，搜索和替换回在subject 的每一个元素上进行, 并且返回值也会是一个数组。
- limit：每个模式在每个subject上进行替换的最大次数。默认是 -1(无限)。
- count：如果指定，将会被填充为完成的替换次数。

返回值：

- 如果subject是一个数组， preg_replace()返回一个数组， 其他情况下返回一个字符串。
- 如果匹配被查找到，替换后的subject被返回，其他情况下 返回没有改变的 subject。如果发生错误，返回 NULL 。

preg_replace_callback()函数
^^^^^^^^^^^^^^^^^^^^^^^^^^^
函数语法：

``mixed preg_replace_callback ( mixed $pattern , callable $callback , mixed $subject [, int $limit = -1 [, int &$count ]] )``

函数功能：

preg_replace_callback()函数与preg_replace()函数的功能相同，都用于查找和替换字串。不同的是preg_replace_callback()函数使用一个回调函数（callback）来代替replacement参数。

 在preg_replace_callback()函数的回调函数中，字符串使用''，这样可以保证字符串中的特殊符号不被转义。

函数参数：

- pattern：要搜索的模式，可以使字符串或一个字符串数组。
- callback：一个回调函数，在每次需要替换时调用，调用时函数得到的参数是从subject 中匹配到的结果。回调函数返回真正参与替换的字符串。这是该回调函数的签名： ``string handler ( array $matches )`` 
- subject：要搜索替换的目标字符串或字符串数组。
- limit：对于每个模式用于每个 subject 字符串的最大可替换次数。 默认是-1（无限制）。
- count：如果指定，这个变量将被填充为替换执行的次数。

返回值：

- 如果subject是一个数组， preg_replace_callback()返回一个数组，其他情况返回字符串。 错误发生时返回 NULL。

- 如果查找到了匹配，返回替换后的目标字符串（或字符串数组）， 其他情况subject 将会无变化返回。

preg_split()函数
^^^^^^^^^^^^^^^^
函数语法：

``array preg_split ( string $pattern , string $subject [, int $limit = -1 [, int $flags = 0 ]] )``

函数功能：

使用表达式pattern来分割字符串subject。如果有参数limit，那么数组最多有limit个元素。该函数与ereg_split()函数的使用方法相同。简单的字符串分割处理，可使用字符串处理函数explode()进行分割。

参数：

- pattern：用于搜索的模式，字符串形式。
- subject：输入字符串
- limit：如果指定，将限制分隔得到的子串最多只有limit个，返回的最后一个 子串将包含所有剩余部分。limit值为-1， 0或null时都代表"不限制"， 作为php的标准，你可以使用null跳过对flags的设置。
- flags：可以是任何下面标记的组合(以位或运算 | 组合)：
	+ PREG_SPLIT_NO_EMPTY：如果这个标记被设置， preg_split() 将返回分隔后的非空部分。
	+ PREG_SPLIT_DELIM_CAPTURE：如果这个标记设置了，用于分隔的模式中的括号表达式将被捕获并返回。
	+ PREG_SPLIT_OFFSET_CAPTURE：如果这个标记被设置, 对于每一个出现的匹配返回时将会附加字符串偏移量。 **注意：这将会改变返回数组中的每一个元素, 使其每个元素成为一个由第0 个元素为分隔后的子串，第1个元素为该子串在subject 中的偏移量组成的数组。**

返回值：

返回一个使用 pattern 边界分隔 subject 后得到 的子串组成的数组， 或者在失败时返回 FALSE。

.. code-block:: php

    <?php
	// 按任意数量的空格和逗号分隔字符串，其中包括" ",\r,\t,\n 和\f
	$keywords = preg_split("/[\s.]+/","hypertext language,programming");
	print_r($keywords);

	//将字符串分割成字符
	$chars = preg_split('//',"lamp",-1, PREG_SPLIT_NO_EMPTY);
	print_r($chars);

	// 将字符串分割为匹配项及其偏移量
	$chars = preg_split('/[\s.]+/','hypertext language programming',-1,PREG_SPLIT_OFFSET_CAPTURE);
	print_r($chars);
	/* 运行结果
	Array
	(
	    [0] => hypertext
	    [1] => language,programming
	)
	Array
	(
	    [0] => l
	    [1] => a
	    [2] => m
	    [3] => p
	)
	Array
	(
	    [0] => Array
	        (
	            [0] => hypertext
	            [1] => 0
	        )

	    [1] => Array
	        (
	            [0] => language
	            [1] => 10
	        )

	    [2] => Array
	        (
	            [0] => programming
	            [1] => 19
	        )

	)
	*/
    ?>