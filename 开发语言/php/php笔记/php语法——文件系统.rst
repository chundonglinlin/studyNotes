文件系统处理
===========

文件系统概述
-----------
通过PHP中内置的文件处理函数可以完成服务器端文件系统的操作，但PHP对文件系统的操作时基于UNIX系统模型的。因此其中的很多函数类似于UNIX Shell命令的，在Windows中并没有提供UNIX的文件系统特性。所以有一些PHP文件处理函数不能在Windows服务器中使用，但绝大多数函数的功能是兼容的。另外在PHP中，对文件读写等操作与C语言中的文件读写操作是相同的，如果读者曾经编写过C语言或者是UNIX Shell脚本程序，就会非常熟悉这些操作。

文件的类型
^^^^^^^^^
PHP是以UNIX的文件系统为模型的，因此在Windows系统中我们只能获得“file”、“dir”或者“unknown”三种文件类型。而在UNIX系统中，我们可以获得“block”、“char”、“dir”、“fifo”、“file”、“link”和“unknown”七种类型的详细说明如下表：


=========  =============================================
文件类型       描述
=========  =============================================
block      块设备文件，如某个磁盘分区，软驱，光驱 ``CD-ROM`` 等
char       字符设备是指在 ``I/O`` 传输过程中以字符为单位进行传输的设备，如键盘、打印机等
dir        目录类型，目录也是文件的一种
fifo       命名管道，常用于将信息从一个进程传递到另一个进程
file       普通文件类型，如文本文件或可执行文件等
link       符号链接，是指文件指针的指针，类似于Windows中的快捷方式
unknown    未知类型​
=========  =============================================


在PHP中可以使用filetype()函数获取文件的上述类型，该函数接受一个文件名作为参数，如果文件不存在将返回FALSE。下面的程序是判断文件类型的示例，代码如下所示：

.. code-block:: php

    <?php
	//获取Linux系统下的文件类型
	echo filetype('/etc/passwd');     //输出file,/etc/passwd为普通文件
	echo filetype('/etc/grub.conf');     //输出lilnk，/etc/grub.conf为连接文件-->/boot/grub/grub.conf
	echo filetype('/etc/');     //输出dir，/etc/为一个目录，即文件夹
	echo filetype('/dev/sda1');    //输出block,/dev/sda1为块设备，它是一个分区
	echo filetype('/dev/tty01');    //输出char,为字符设备，它是一个字符终端

	//获取windows系统下文件类型
	echo filetype("C:\\WINDOWS\\php.ini");  //输出file，C:\\WINDOWS\\php.ini为一个普通文件
	echo filetype("C:\\WINDOWS");   //输出dir,C:\\WINDOWS为一个文件夹（目录）
    ?>

对于一个已知的文件，还可以：

- 使用is_file()函数判断给定的文件名是否为一个正常的文件；
- 使用is_dir()函数判断给定的文件名是否是同一个目录；
- 使用is_link()函数判断给定的文件名是否为一个符号连接；

文件的属性
^^^^^^^^^
在进行编程时，需要使用到文件的一些常见属性，如文件的大小、文件的类型、文件的修改时间、文件的访问时间和文件的权限等。PHP中提供了非常全面的用来获取这些属性的内置函数，如下表所示：

+-----------------+--------------------------+--------+-------------------------------------+
| 函数名          | 作用                     | 参数   | 返回值                              |
+=================+==========================+========+=====================================+
| file_exists()   | 检查文件或目录是否存在   | 文件名 | 文件存在返回TRUE，不存在则返回FALSE |
+-----------------+--------------------------+--------+-------------------------------------+
| filesize()      | 取得文件大小             | 文件名 | 返回文件大小的字节数，出错返回FALSE |
+-----------------+--------------------------+--------+-------------------------------------+
| is_readable()   | 判断给定文件名是否可读   | 文件名 | 如果文件存在且可读则返回TRUE        |
+-----------------+--------------------------+--------+-------------------------------------+
| is_writable()   | 判断给定文件名是否可写   | 文件名 | 如果文件存在且可写则返回TRUE        |
+-----------------+--------------------------+--------+-------------------------------------+
| is_executable() | 判断给定文件名是否可执行 | 文件名 | 如果文件存在且可执行则返回TRUE      |
+-----------------+--------------------------+--------+-------------------------------------+
| filectime()     | 获取文件的创建时间       | 文件名 | 返回UNIX时间戳格式                  |
+-----------------+--------------------------+--------+-------------------------------------+
| filemtime()     | 获取文件的最后修改时间   | 文件名 | 返回UNIX时间戳格式                  |
+-----------------+--------------------------+--------+-------------------------------------+
| fileatime()     | 获取文件的最后访问时间   | 文件名 | 返回UNIX时间戳格式                  |
+-----------------+--------------------------+--------+-------------------------------------+
| stat()          | 获取文件大部分属性值     | 文件名 | 返回关于给定文件有用信息的数组      |
+-----------------+--------------------------+--------+-------------------------------------+
| filegroup()     | 取得文件组               | 文件名 | 返回整数                            |
+-----------------+--------------------------+--------+-------------------------------------+
| fileinode()     | 取得文件的信息节点数     | 文件名 | 返回整数                            |
+-----------------+--------------------------+--------+-------------------------------------+
| fileowner()     | 取得文件的所有者         | 文件名 | 返回用户ID                          |
+-----------------+--------------------------+--------+-------------------------------------+
| fileperms()     | 取得文件的权限           | 文件名 | 返回权限                            |
+-----------------+--------------------------+--------+-------------------------------------+

　　在表中的函数都需要提供同样的字符串参数，即一个指向文件或目录的字符串变量。PHP将缓存这些函数的返回信息以提供更快的性能。然而在某些情况下，你可能想清楚被缓存的信息。例如，如果在一个脚本中多次检查同一个文件，而该文件在此脚本执行期间有被删除或修改的危险时，你需要清除文件状态缓存。在这种情况下，可以用clearstatcache()函数来清除被PHP缓存的该文件信息。clearstatcache()函数缓存特定文件名的信息，因此只在对同一个文件名进行多次操作，并且需要该文件信息不被缓存时才需要调用它。下面的程序中通过调用这些函数获取文件大部分属性。代码如下所示：

.. code-block:: php

    <?php
	//声明一个函数，通过传入一个文件名称获取文件大部分属性
	function getFilePro($fileName){
	    //如果提供的文件或目录不存在，则直接退出函数
	    if(!file_exists($fileName)){
	        echo "目标不存在！！<br>";
	        return;
	    }

	    //判断是否是一个普通文件，如果是则条件成立
	    if(is_file($fileName))
	        echo $fileName."是一个文件<br>";

	    //判断是否是一个目录
	    if(is_dir($fileName))
	        echo $fileName."是一个目录<br>";

	    //用定义的函数输出文件形态
	    echo "文件形态：".getFileType($fileName)."<br>";
	    //获取文件大小，并自定义转换单位
	    echo "文件大小：".getFileSize(filesize($fileName))."<br>";

	    if(is_readable($fileName))      //判断提供的文件是否可以读取内容
	        echo "文件可读<br>";
	    if(is_writable($fileName))      //判断提供的文件是否可以改写
	        echo "文件可写<br>";
	    if(is_executable($fileName))      //判断提供的文件是否有执行的权限
	        echo "文件可执行<br>";

	    echo "文件建立时间：".date("Y年m月j日",filectime($fileName))."<br>";
	    echo "文件最后更新的时间：".date("Y年m月j日",filemtime($fileName))."<br>";
	    echo "文件最后打开时间：".date("Y年m月j日",fileatime($fileName))."<br>";
	}

	//声明一个函数用来返回文件的类型
	function getFileType($fileName){
	    //通过filetype()函数返回的文件类型作为选择条件
	    switch(filetype($fileName)){
	        case 'file': $type .= "普通文件";   break;
	        case 'dir': $type .= "目录文件";   break;
	        case 'block': $type .= "块设备文件";   break;
	        case 'char': $type .= "字符设备文件";   break;
	        case 'fifo': $type .= "命名管道文件";   break;
	        case 'link': $type .= "符号连接";   break;
	        case 'unknown': $type .= "未知类型";   break;
	        default:     $type .="没有检测到类型";
	    }
	    return $type;       //返回转换后的类型
	}

	//自定义一个文件大小单位转换函数
	function getFileSize($bytes){
	    if($bytes >= pow(2,40)){    //如果提供的字符数大于等于2的40次方
	        $return = round($bytes/pow(1024,4),2);        //将字节大小转换为同等的T大小
	        $suffix = "TB";    //单位为TB
	    }elseif($bytes >= pow(2,30)){    //如果提供的字符数大于等于2的30次方
	        $return = round($bytes/pow(1024,3),2);        //将字节大小转换为同等的G大小
	        $suffix = "GB";      //单位为GB
	    }elseif($bytes >= pow(2,20)){    //如果提供的字符数大于等于2的20次方
	        $return = round($bytes/pow(1024,2),2);        //将字节大小转换为同等的M大小
	        $suffix = "MB";     //单位为MB
	    }elseif($bytes >= pow(2,10)){    //如果提供的字符数大于等于2的10次方
	        $return = round($bytes/pow(1024,1),2);        //将字节大小转换为同等的K大小
	        $suffix = "KB";       //单位为KB
	    }else{
	        $return = $bytes;    //字节大小单位不变
	        $suffix = "Byte";
	    }
	    return $return." ".$suffix;    //返回合适的文件大小和单位
	}

	//调用自定义函数，将当前目录下的file.php文件传入，获取属性
	getFilePro("file.php");
    ?>

除了可以使用这些独立的函数分别获取文件的属性外，还可以使用一个stat()函数获取文件的大部分属性值。该函数将返回一个数组，数组中的每个元素对应文件的一种属性值。该函数的使用如下代码所示：

.. code-block:: php

    <?php
	//返回关于文件的信息数组，是关联和索引混合的数组
	$filePro = stat("demo.php");
	//只打印其中的关联数组，第13个元素之后为关联数组
	print_r(array_slice($filePro,13));
	/* 输出结果：
	Array
	(
	    [dev] => 3 // 文件所在的设备好
	    [ino] => 0 // 文件的inode号，是与每个文件名关联的唯一数值标识符
	    [mode] => 33206 // 文件的inode保护模式，这个值确定指派给文件的访问和修改权限
	    [nlink] => 1 //与该文件关联的硬链接的数组
	    [uid] => 0 // 文件所有者的用户ID
	    [gid] => 0 // 文件所属组的ID
	    [rdev] => 3 // 设备类型(如果inode设备可用的话)
	    [size] => 303 // 文件大小以字节为单位
	    [atime] => 1510665206 // 文件的最后访问时间，UNIX时间戳格式
	    [mtime] => 1510665206 // 文件的最后修改时间，UNIX时间戳格式
	    [ctime] => 1510055911 //文件的最后改变时间，UNIX时间戳格式
	    [blksize] => -1 // 文件的块大小。注意，此元素在Windows平台上不可用
	    [blocks] => -1 // 分配此文件的块数。注意，此元素在Windows平台上不可用
	)
	*/
    ?>

除了使用stat()函数获取文件的大部分属性值之外，也可以使用对应的函数lstat和fstat()函数取得。和stat()函数略有不同，stat()函数作用于一个普通的文件，lstat()只能作用于一个符号连接，而fstat()函数需要一个资源句柄。

文件时间戳解惑

- touch()：函数修改文件的更新时间
- fileatime()：函数返回文件因为读或写被打开的最后时间
- filemtime()：函数返回文件内容被修改的最后时间
- filectime()：函数返回文件内容或元数据被修改的最后时间

修改文件权限
^^^^^^^^^^^

- chmod()：函数修改文件的权限
- chown()：函数修改文件的所有者
- chgrp()：函数修改文件所属组

**注意：上述3个函数在Windows系统中无效。**

目录的基本操作
-------------
使用PHP脚本可以方便地对目录进行操作，包括创建目录、遍历目录、复制目录、删除目录等操作。可以借助PHP的系统函数完成一部分，但还有一些功能需要自定一个函数操作。

目录相关函数

+----------+----------------------------------------------+
| 函数名   | 函数提供什么文件信息？                       |
+==========+==============================================+
| mkdir()  | 创建一个新目录，第二个参数可用来设置访问权限 |
+----------+----------------------------------------------+
| rmdir()  | 删除目录                                     |
+----------+----------------------------------------------+
| rename() | 重命名一个文件或目录                         |
+----------+----------------------------------------------+

解析目录路径
^^^^^^^^^^^
要描述一个文件的位置，可以使用绝对路径和相对路径。绝对路径是从根开始一级一级地进入各个子目录，最后指定该文件名或目录名。而相对路径是从当前目录进入某目录，最后指定该文件名或目录名。在系统的每个目录下都有两个特殊的目录“.”和“..”，分别指示当前目录和当前目录的父目录。例如：

.. code-block:: php

    <?php
	$unixPath = "/var/www/html/index.php"; //在UNIX系统中绝对路径，必须使用“/”作为路径分隔符
	$winPath = "C:\\Appserv\\www\\index.php"; //Windows系统的绝对路径，默认使用“\”作为路径分隔符
	$winPath = "C:/Appserv/www/index.php"; //在Windows系统中也接受“/”作为路径分隔符，推荐使用
	$fileName1= "file.txt";  //相对路径，当前目录下的file.txt文件
	$fileName2= "Javascript/common.js"; // 相对路径，当前目录中javascript子目录下的common.js文件
	$fileName3="../images/logo.gif";  //相对路径，上一级目录中images子目录下的logo.gif文件
    ?>

在上例中，分别列出了UNIX和Windows系统中绝对路径和相对路径的格式。其中在UNIX系统中必须使用正斜线“/”作为路径分隔符，而在Windows系统中默认使用反斜线“\\”作为路径分隔符，在程序中表示还要将“\\”转义，但也接受正斜线“/”作为分隔符的写法。为了程序可以有很好的移植性，建议都使用“/”作为文件的路径分隔符。另外，也可以使用PHP的内置常量DIRECTORY_SEPARATOR，其值为当前操作系统的默认文件路径分隔符。例如：

``$fileName2 = "javascript".DIRECTORY_SEPARATOR."common.js"; //Unix为"/"，Windows为"\"``

将目录路径中各个属性分离开通常很有用，如末尾的扩展名、目录部分和基本名。可以通过PHP的系统函数 ``basename()`` 、 ``dirname()`` 和 ``pathinfo()`` 函数完成这些任务。

函数basename()
""""""""""
函数 ``basename()`` 返回路径中的文件名部分。该函数的原型如下所示：

``string basename(string path[,string suffix]) //返回路径中的文件名部分``

该函数给出一个包含其指向一个文件的全路径的字符串，本函数返回基本的文件名。第二个参数可选参数，规定文件的扩展名。如果提供了则不会输出这个扩展名。该函数的使用如下面的代码所示：

.. code-block:: php

    <?php
	//包含有指向一个文件的全部路径的字符串
	$path = "/var/www/html/page.php";
	//显示带有文件扩展名的文件名，输出page.php
	echo basename($path);
	//显示不带有文件扩展名的文件名，输出page
	echo basename($path,".php");
    ?>

函数dirname()
"""""""""
该函数恰好与 ``basename()`` 相反，只需要一个参数，给出一个包含有指向一个文件的全部路径的字符串，本函数返回去掉文件名后的目录名。该函数的使用如以下代码所示：

.. code-block:: php

    <?php
	$path = "/var/www/html/page.php"; //包含有指向一个文件的全路径的字符串
	echo dirname($path); //返回目录名/var/www/html
	echo dirname('c:/'); //返回目录名c:/
    ?>

函数pathinfo()
""""""""""
函数pathinfo()返回一个关联数组，其中包括指定路径中的目录名、基本名和扩展名三个部分。分别通过数组键 ``dirname、basename`` 和 ``extension`` 来引用。该函数的使用如下代码所示。

.. code-block:: php

    <?php
	$path = "/var/www/html/page.php";
	$path_parts = pathinfo($path); //返回包括指定路径中的目录名、基本名和扩展名关联数组
	echo $path_parts["dirname"]; //输出目录名/var/www/html
	echo $path_parts["basename"]; //输出基本名page.php
	echo $path_parts["extension"]; //输出扩展名.php
    ?>

遍历目录
^^^^^^^
在进行PHP编程的时候，需要对服务器某个目录下面的文件进行浏览，通常称为遍历目录。取得一个目录下的文件和子目录，就需要用到 ``opendir()`` 函数、 ``readdir()`` 函数、 ``closedir()``函数和 ``rewinddir()`` 函数。

- 函数opendir()用于打开指定目录，接受一个目录的路径及目录名作为参数，函数返回值为可供其他目录函数使用的目录句柄（资源类型）。如果该目录不存在或者没有访问权限，则返回FALSE。
- 函数readdir()用于读取指定目录，接受已经用opendir()函数打开的可操作目录句柄作为参数，函数返回当前目录指针位置的一个文件名，并将目录指针向后移动一位。当指针位于目录的结尾时，因为没有文件存在则返回FALSE。
- 函数closedir()关闭指定目录，接受已经用opendir()函数打开的可操作目录句柄作为参数。函数无返回值，运行后关闭打开的目录。
- 函数rewinddir()倒回目录句柄，接受已经用opendir()函数打开的可操作目录句柄作为参数。将目录指针重置目录到开始处，即倒回目录的开头。

下面用一个实例来说明以上几个函数的使用方法。注意，在使用该例子前请确保同一目录下有phpMyAdmin文件夹。代码如下所示：

.. code-block:: php

    <?php
	$num = 0; //用来统计子目录和文件的个数
	$dirname = 'phpMyAdmin'; //保存当前目录下用来便利的一个目录名
	$dir_handle = opendir($dirname); //用opendir打开目录

	//将遍历的目录和文件名使用表格格式输出
	echo '<table border="0" align="center" width="600" cellspacing="0" cellpadding="0">';
	echo '<caption><h2>目录'.$dirname.'下面的内容</h2></caption>';
	echo '<tr align="left" bgcolor="#cccccc">';
	echo '<th>文件名</th><th>文件大小</th><th>文件类型</th><th>修改时间</th>';

	//使用readdir循环读取目录里的内容
	while($file = readdir($dir_handle)){
	//将将目录下的文件和当前目录连接起来，才能在程序中使用
	$dirFile = $dirname."/".$file;

	$bgcolor = $num+%2==0 ? '#FFFFFF' : '#CCCCCC'; //各行一种颜色
	echo '<tr bgcolor='.$bgcolor.'>';
	echo '<td>'.filesize($dirFile).'</td>'; //显示文件名
	echo '<td>'.filetype($dirFile).'</td>'; //显示文件大小
	echo '<td>'.date("Y/n/t",filemtime($dirFile)).'</td>'; //格式化显示文件修改时间
	echo '</tr>';
	}

	echo '</table>';
	closedir($dir_handle); //关闭文件操作句柄
	echo '在<b>'.$dirname.'</b>目录下的子目录和文件共有<b>'.$num.'</b>个';
    ?>

上述程序首先打开一个目录指针，并对其进行遍历。遍历目录时，会包括“.”和“..”两个特殊的目录，如果不需要这俩个目录，可以将其屏蔽。当然显示细节会因为文件夹中内容的不同而有所不同。通过上例可见，在PHP中浏览文件夹中的内容也并不是一件多么复杂的事情。而且PHP还提供了一种面向对象的方式用于目录的遍历，通过使用“dir”类完成。不仅如此，PHP也可以按用户的要求检索目录下指定的内容，提供了glob()函数检索指定的目录。该函数最终返回一个包含检索结果的数组。

统计目录大小
^^^^^^^^^^^
计算文件、磁盘分区和目录的大小在各种应用程序中都是常见的任务。计算文件的大小可以通过我们前面介绍过的filesize()函数完成，统计磁盘大小也可以使用disk_free_space()和disk_total_space()两个函数实现。

.. code-block:: php

    <?php
	//自定义一个函数dirSize()，统计传入参数的目录大小
	function dirSize($directory){
	    $dir_size = 0; //用来累加各个文件大小

	    if($dir_handle = @opendir($directory)){      //打开目录，并判断是否能成功打开
	        while($filename = readdir($dir_handle)){     //循环遍历目录下的所有文件
	            if($filename != "."&& $filename != ".."){     //一定要排除两个特殊的目录
	                $subFile = $directory."/".$filename;     //将目录下的子文件和当前目录相连
	                if(is_dir($subFile))     //如果为目录
	                    $dir_size += dirSize($subFile);     //递归地调用自身函数，求子目录的大小
	                if(is_file($subFile))     //如果是文件
	                    $dir_size += filesize($subFile);     //求出文件的大小并累加
	            }
	        }
	        closedir($dir_handle);      //关闭文件资源
	        return $dir_size;     //返回计算后的目录大小
	    }
	}

	$dir_size = dirSize("phpMyAdmin");    //调用该函数计算目录大小
	echo round($dir_size/pow(1024,1),2)."KB";    //字节数转换为“KB”单位并输出
    ?>

也可以使用exec()或system()函数调用操作系统命令“du”来返回目录的大小。但出于安全原因，这些函数通常是禁用的，而且不利于跨平台操作。

建立和删除目录
^^^^^^^^^^^^^
在PHP中，使用 ``mkdir()`` 函数只需要传入一个目录名即可很容易地建立一个新目录。但删除目录所使用的函数 ``rmdir()`` ,只能删除一个空目录并且目录必须存在。如果是非空的目录就需要先进入到目录中，使用 ``unlink()`` 函数将目录中的每个文件都删除掉，再回来将这个空目录删除。如果目录中还存在目录，而且子目录也非空，就要使用递归的方法了。自定义递归函数删除目录的程序代码如下所示：

.. code-block:: php

    <?php
	//自定义函数递归的删除整个目录
	function delDir($directory){
	    if(file_exists($directory)){      //如果不存在rmdir()函数会出错
	        if($dir_handle = @opendir($directory)){       //打开目录，并判断是否能成功打开
	            while($filename = readdir($dir_handle)){       //循环遍历目录下的所有文件
	                if($filename != "."&& $filename != ".."){       //一定要排除两个特殊的目录
	                    $subFile = $directory."/".$filename;       //将目录下的子文件和当前目录相连
	                    if(is_dir($subFile))        //如果为目录则条件成立
	                        delDir($subFile);       //递归地调用自身函数，删除子目录
	                    if(is_file($subFile))      //如果是文件则条件成立
	                        unlink($subFile);           //直接删除这个文件
	                }
	            }
	            closedir($dir_handle); //关闭文件资源
	            rmdir($directory); //删除空目录
	        }
	    }
	}

	dirDir("phpMyAdmin"); //调用delDir()函数，将程序所在目录中的“phpMyAdmin”文件删除
    ?>

复制或移动目录
^^^^^^^^^^^^^
虽然复制一个目录是文件操作的基本功能。但PHP中也没有给出特定的函数，同样需要自定义一个递归函数实现。要复制一个包含多个子目录的目录，将涉及文件的复制、目录创建等操作。复制一个文件可以通过PHP提供的copy()函数完成，创建目录可以使用mkdir()函数。定义函数时，首先对源目录进行遍历，如果遇到的是普通文件，直接使用copy()函数进行复制。如果遍历时遇到一个目录，则必须建立该目录，然后再对该目录下的文件进行复制操作，如果还有子目录，则使用递归重复操作，最终将整个目录复制完成。自定义的递归函数复制目录的程序代码如下所示：

.. code-block:: php

    <?php
	//自定义函数递归的复制带有多级子目录的目录
	function copyDir($dirSrc,$dirTo){
	    if(is_file($dirTo)){      //如果目标不是一个目录则退出
	        echo "目标不是目录不能创建！！";
	        return; //退出函数
	    }
	    if(!file_exists($dirTo)){       //如果目标不是一个目录则退出
	        mkdir($dirTo);              //创建目录
	    }

	    if($dir_handle = @opendir($dirSrc)){   //打开目录，并判断是否能成功打开
	        while($filename = readdir($dir_handle)){   //循环遍历目录下的所有文件
	            if($filename != "."&& $filename != ".."){    //一定要排除两个特殊的目录
	                $subSrcFile = $dirSrc."/".$filename;  //将目录下的子文件和当前目录相连
	                $subToFile = $dirTo."/".$filename;      //将目标目录的多级子目录相连

	                if(is_dir($subSrcFile))    //如果为目录则条件成立
	                    copyDir($subSrcFile,$subToFile);    //递归调用自己复制子目录
	                if(is_file($subSrcFile))   //如果是文件则条件成立
	                    copy($subSrcFile,$subToFile);  //直接复制到目标位置
	            }
	        }
	        losedir($dir_handle);   //关闭文件资源
	    }
	}

	//测试函数，将目录“phpMyAdmin”复制到“D:/admin”
	copyDir("phpMyAdmin","D:/admin");
    ?>

从安全和跨平台等方面考虑，尽量不要去调用操作系统的SHELL命令“cp -a”或者“mv”完成目录的复制。

文件的基本操作
-------------
虽然PHP与外部资源接触最多的是数据库，但也有很多情况会应用到普通文件或是XML文件等。例如文件系统、网页静态化和在没有数据库的环境中持久存储数据等。对文件的操作最常见的就是读和写，以及一些其他的相关处理，这些操作都可以通过PHP提供的众多与文件有关的标准函数完成。

文件的打开与关闭
^^^^^^^^
在处理文件内容之前，通常需要建立与文件资源的连接，即打开文件。同样，结束该资源的操作后，应当关闭连接资源。所谓打开文件，实际是建立文件的各种有关信息，并使文件指针指向该文件，就可以发起输入或输出的实体联系在一起，也就禁止再对该文件进行操作。在PHP中可以通过标准函数fopen()建立与文件资源的连接，使用fclose()函数关闭通过fopen()函数打开的文件资源。

函数fopen()
"""""""""""
该函数用来打开一个文件，并在打开一个文件时，还需要指定如果使用它。也就是以哪种文件模式打开文件资源。服务器上的操作系统文件必须知道要对打开的文件进行什么操作。操作系统需要了解在打开这个文件之后，这个文件是否还允许其他的程序脚本再打开，还需要了解脚本的属主用户是否具有在这种方式下使用该文件的权限。该函数的原型如下所示：

``resource fopen(string filename,string mode[,bool use_include_path[,resource zcontext]) //打开文件``

- 第一个参数需要提供要被打开文件的URL。这个URL可以是脚本所在的服务器中的绝对路径，也可以是相对路径，还可以是网络资源中的文件。
- 第二个参数需要提供文件模式，文件模式可以告诉操作系统如何处理来自其他人或脚本的访问请求，以及一种用来检查你是否有权访问这个特定文件的写法。当在打开文件时有三种选择：

  + 打开一个文件为了只读、只写或者是读和写。
  + 如果要写一个文件，可以覆盖所有已有的文件内容，或者需要将新数据追加到文件末尾。
  + 如果在一个区分二进制文件和纯文本文件的系统上写一个文件，还必须指定采用的方式。

    函数fopen()也支持以上三种方式的组合，只需要在第二个参数中提供一个字符串，指定将对文件进行的操作即可。在下表中列出了可以使用的文件模式及其意义。

    表格没有，需要后面补充。。。。

- 第三个参数是可选的，如果资源位于本地文件系统，PHP则认为可以使用本地路径或是相对路径来访问此资源。如果将这个参数设置为1，这样就会使PHP考虑配置指令include_path中指定的路径（在PHP的配置文件中设置）。
- 第四个参数也是可选的，fopen()函数允许文件名称以协议名称开始，例如“http://”，并且在一个远程位置打开该文件。通过设置这个参数，还可以支持一些其他的协议。

如果fopen()函数成功地打开一个文件，该函数将返回一个指向这个文件的文件指针。对该文件进行操作所使用的读、写以及其他的文件操作函数，都要使用这个资源来访问该文件。如果打开文件失败，则返回FALSE。函数fopen()的使用示例如下：

.. code-block:: php

    <?php
	//使用绝对路径打开file.txt文件，选择只读模式，并返回资源$handle
	$handle = fopen("/home/rasmus/file.txt", "r");
	//访问文档根目录下的文件，也以只读模式打开
	$handle = fopen("$_SERVER[‘DOCUMENT_ROOT’]/data/info.txt","r");
	//在Windows平台上，转义文件路径的每个反斜线，或者用斜线，以二进制和只写模式组合
	$handle = fopen("C:\\data\\file.gif", "wb");
	//使用相对路径打开file.txt文件，选择只读模式，并返回资源$handle
	$handle = fopen("../data/info.txt", "r");
	//打开远程文件，使用HTTP协议只能以只读的模式打开
	$handle = fopen("http://www.example.com", "r");
	//使用FTP协议打开远程文件，如果FTP服务器可写，则可以以写的模式打开
	$handle = fopen("ftp://user:password@example.com", "w");
    ?>

函数fclose()
""""""""""""
资源类型属于PHP的基本类型之一，一旦完成资源的处理，一定要将其关闭，否则可能会出现一些预料不到的错误。函数fclose()就会撤销fopen()打开的资源类型，成功时返回 ``TRUE`` ，否则返回 ``FALSE`` 。参数必须是使用 ``fopen()`` 或 ``fsockopen()`` 函数打开的已存的文件指针。在目录操作中 ``opendir()`` 函数也是开启一个资源，使用 ``closedir()`` 将其关闭。

写入文件
^^^^^^^
将程序中的数据保存到文件中比较容易，使用 ``fwrite()`` 函数就可以将字符串内容写入文件中。在文件中通过字符序列 ``\n`` 表示换行符，表示文件中一行的末尾。当需要一次输入或输出一行信息时，请记住这一点。不同的操作系统具有不同的结束符号，基于UNIX的系统使用 ``\n`` 作为行结束字符，基于Windows系统使用 ``\r\n`` 作为行结束字符，基于Macintosh的系统使用 ``\r`` 作为行结束字符。当要写入一个文本文件并想插入一个新行时，需要使用相应操作系统的行结束符号。函数fwrite()的原型如下所示：

``int fwrite(resource handle,string string[,int length]) //写入文件``

第一个参数需要提供fopen()函数打开的文件资源，该函数将第二个参数提供的字符串内容输出到由第一个参数指定的资源中。如果给出了第三个可选参数length，fwrite()将在写入了length个字符时会停止。否则将一直写入，直到到达内容结尾时才停止。如果写入的内容少于length个字节，该函数也会在写完全部内容后停止。函数fwrite()执行完成以后会返回写入的字符数，出现错误时则返回 ``FALSE`` 。下面的代码是写入文件的一个示例。

.. code-block:: php

    <?php
	//声明一个变量用来保存文件名
	$fileName = "data.txt";
	//使用fopen()函数以只写的模式打开文件，如果不存在则创建它，打开失败则通过程序
	$handle = fopen($fileName,'w') or die('打开<b>'.$fileName.'</br>文件失败！！');
	//循环10次写入10行数据到文件中
	for($row=0;$row<10;$row++){
	    fwrite($handle, $row.":www.lampbrother.net\n"); // 写入文件
	}
	fclose($handle); // 关闭由fopen()打开的文件指针资源
    ?>

该程序执行后，如果当前目录下存在data.txt文件，则清空该文件并写入10行数据。如果不存在data.txt文件，则会创建该文件并将10行数据写入。

另外，写入文件还可以使用 ``fputs()`` 函数，该函数是 ``fwrite()`` 函数的别名函数如果需要快速写入文件，可以使用 ``file_put_contents()`` 函数，和依次调用 ``fopen()，fwrite()`` 以及 ``fclose()`` 函数的功能一样。该函数的使用代码如下所示：

.. code-block:: php

    <?php
	//声明一个变量用来保存文件名
	$fileName = “data.txt”;
	//声明一个变量用来保存被写入文件中的数据
	$data = "共10行数据\n";
	for($row=0;$row<10;$row++){
	//将10数据都存放到一个字符串变量中
	    $data .= $row.":www.lampbrother.net\n";
	}
	//一次将所有数据写入到指定的文件中
	file_put_contents($fileName, $data);
    ?>

该函数可以将数据直接写入到指定的文件中。如果同时调用多次时，并向同一个文件中写入数据，则文件中只保存了最后一次调用该函数写入的数据。因为在每次调用时都会重新打开文件并将文件中原有的数据清空，所以不能像第一个程序那样连续写入多行数据。

读取文件内容
^^^^^^^^^^^
在PHP中提供了多个从文件中读取内容的标准函数，可以根据它们的功能特性在程序中选择哪个函数使用。这些函数功能及其描述如下表所示。

+---------------------+--------------------------------+
| 函数                | 描述                           |
+=====================+================================+
| fread()             | 读取打开的文件                 |
+---------------------+--------------------------------+
| file_get_contents() | 将文件读入字符串               |
+---------------------+--------------------------------+
| fgets()             | 从打开的文件中返回一行         |
+---------------------+--------------------------------+
| file()              | 把文件读入一个数组中           |
+---------------------+--------------------------------+
| readfile()          | 读取一个文件，并输出到输出缓冲 |
+---------------------+--------------------------------+

在读取文件时，不仅要注意行结束符号 ``\n`` ，程序也需要一种标准的方式来识别何时到达文件的末尾，这个标准通常成为EOF（End Of File）字符。EOF是非常重要的概念，几乎每种主流的编程语言中都提供了相应的内置函数，来分析是否到达了文件EOF。在PHP中，使用feof()函数。该函数接受一个打开的文件资源，判断一个文件指针是否位于文件的结束处，如果在文件末尾处，则返回TRUE。

函数fread()
"""""""""""
该函数用来在打开的文件中读取指定长度的字符串。也可以安全用于二进制文件，在区分二进制文件和文本文件的系统上（如Windows）打开文件时，fopen()函数的mode参数要加上'b'。函数fread()的原型如下所示：

``string fread(int handle,int length) //读取打开的文件``

该函数从文件指针资源handle中读取最多length个字节。在读取完length个字节数，或到达EOF时，或（对于网络流）当一个包可用时都会停止读取文件，就看先碰到哪种情况了。该函数返回读取的内容字符串，如果失败则返回 ``FALSE`` 。函数的使用代码如下所示：

.. code-block:: php

    <?php
	//从文件中读取指定字节数的内容存入到一个变量中
	$filename = "data.txt";
	$handle = fopen($filename, 'r') or die("文件打开失败 ");
	$contents = fread($handle, 100);   //从文件中读取100个字节
	fclose($handle);    //关闭文件资源
	echo $contents;    //将从文件中读取的内容输出

	//从文件中读取全部内容到一个变量中，每次读取一部分，循环读取
	$filename = "c:\\files\\somepic.gif";
	$handle = fopen($filename, 'rb') or die("文件打开失败");     //以只读的方式，模式加了‘b’
	$contents = "";
	while(!feof($handle)){   //使用feof()判断文件结尾
	    $contents .=fread($handle, 1024);   //每次读取1024个字节
	}
	fclose($handle);   //关闭文件资源
	echo $contents;   //将从文件中读取的全部内容输出

	//另一种从文件中读取全部内容的方法
	$filename = "data.txt";
	$handle = fopen($filename, "r")or die("文件打开失败");
	$contents = fread($handle, filesize($filename));   //使用fielsize()函数一起读出
	fclose($handle);
	echo $contents;
    ?>

如果你只是想将一个文件的内容读入到一个字符串中，可以用 ``file_get_contents()`` 函数，它的性能比上面的代码好得多。 ``file_get_contents()`` 函数是用来将文件的内容读入到一个字符串中的首选方法，如果操作系统支持，还会使用内存映射技术来增强性能。该函数的使用代码如下所示：

.. code-block:: php

    <?php
	echo file_get_contents("data.txt"); //读取文本文件中的内容并输出
	echo file_get_contents("c:\\files\\somepic.gif"); //读取二进制文件中的内容并输出
    ?>

函数fgets()、fgetc()
""""""""""""""""""""
fgets()该函数一次至多从打开的文件资源中读取一行内容。函数fgets()的原型如下所示：

``string fgets(int handle[,int length]) //从打开的文件中返回一行``

第一个参数提供使用fopen()函数打开的资源。如果提供了第二个可选参数length，该函数返回length-1个字节。或者返回遇到换行或EOF之前读取的所有内容。如果忽略可选的length参数，默认为1024个字符。在大多数情况下，这意味着fgets()函数将读取到1024个字符前遇到换行符号，因此每次成功调用都会返回下一行。如果读取失败则返回FALSE。该函数的使用代码如下所示：

.. code-block:: php

    <?php
	$handle = fopen("data.txt", "r") or die("文件打开失败 "); //以只读模式打开文件
	while(!feof($handle)){
	    $buffer = fgets($handle,4096); //一次读取一行内容
	    echo $buffer."<br>"; //输出每一个航
	}
	fclose($handle);
    ?>

函数 ``fgetc()`` 在打开的文件资源中只读取当前指针位置处的一个字符。如果遇到文件结束标志 ``EOF`` ，则返回 ``FALSE`` 值。该函数的使用代码如下所示：

.. code-block:: php

    <?php
	$fp = fopen('data.txt','r') or die("文件打开失败");
	while(false !==($char = fgetc($fp))){
	    echo $char."<br>";
	}
    ?>

函数file()
""""""""""
该函数非常有用，与file_get_contents()类似，不需要使用fopen()函数打开文件，不同的是file()函数可以把整个文件读入到一个数组中。数组中的每个元素对应文件中相应的行，各元素由换行符分割，同时换行符仍附加在每个元素的末尾。这样，就可以使用数组的相关函数对文件内容进行处理。该函数的使用代码如下所示：

.. code-block:: php

    <?php
	//将文件test.txt中的内容读入到一个数组中，并输出
	print_r(file(test.txt));
    ?>

函数readfile()
""""""""""""""
该函数可以读取指定的整个文件，立即输出到输出缓冲区，并返回读取的字节数。该函数也不需要使用fopen()函数打开文件。在下面的示例中，轻松地将文件内容输出到浏览器。代码如下所示：

.. code-block:: php

    <?php
	//直接将文件data.txt中的数据读出并输出到浏览器
	readfile("data.txt");
    ?>

访问远程文件
^^^^^^^^^^^
使用PHP不仅可以让用户通过浏览器访问服务器端的文件，还可以通过HTTP或FTP等协议访问其它服务器中的文件，可以在大多数需要用文件名作为参数的函数中使用HTTP和FTP URL来代替文件名。使用fopen()函数将指定的文件名与资源绑定到一个流上，如果文件名是“scheme://...”的格式，则被当成一个URL，PHP将搜索协议处理器来处理此模式。

如果需要远程访问文件，必须在PHP的配置文件中激活“allow_url_fopen”选项，才能使用fopen()函数打开远程文件。而且还要确定其他服务器中的文件是否有访问权限，如果使用HTTP协议对远程文件进行连接，只能以“只读”模式打开。如果需要访问的远程FTP服务器中，对所提供的用户开启了“可写权限，则使用FTP协议连接远程文件时，就可以使用“只写”或“只读”模式打开文件。但不可以使用“可读可写”模式。

使用PHP访问远程文件就像访问本地文件一样，都是使用相同的读写函数处理。例如，可以用以下范例来打开远程Web服务器上的文件，解析我们需要的输出数据，然后就将这些数据用在数据库的检索中，或者简单地将其输出到网站剩下内容的样式匹配中。代码如下所示：

.. code-block:: php

    <?php
	//通过http打开远程文件
	$file = fopen("http://www.jb51.net", "r") or die("打开远程文件失败！！");
	while (!feof($file)){
	    $line = fgets($file,1024);     //每读取一行
	//如果找到远程文件中的标题标记则取出标题，并退出循环，不在读取文件
	    if (preg_match("/<titile>(.*/)<\/title>",$line,$out)){     //使用正则匹配标题标记
	        $title = $out[1];     //将标题标记中的标题字符取出
	        break;     //退出循环，结束远程文件读取
	    }
	}

	fclose($file);
	echo $title;
    ?>

如果有合法的访问权限，可以以一个用户的身份和某FTP服务器建立连接，这样就可以向该FTP服务器端的文件进行写操作了。可以用该技术来存储远程日志文件等操作，但仅能用该方法来创建新的文件，如果尝试覆盖已经存在的文件，fopen()函数的调用将会失败。而且要以匿名(anonymous)以外的用户名连接服务器，并需要指明用户名（甚至密码），例如“ftp://user:password@ftp.lampbrother.net/path/to/file”。代码如下所示：

.. code-block:: php

    <?php
	//在ftp.lampbrother.net的远程服务器上创建文件，以写的模式打开
	$file = fopen("ftp://user:password@ftp.lapbrother.net/path/to/file", "w");
	//将一个字符串写入到远程文件中去
	fwrite($file, "Linux+Apache+MySQL+PHP");

	fclose($file);
    ?>

为了避免由于访问远程主机时发生的超时错误，可以使用 ``set_time_limit()`` 函数对程序的运行时间加以限制。

移动文件指针
^^^^^^^^^^^
在对文件进行读写过程中，有时需要在文件中跳转、同不同位置读取，以及将数据写入到不同的位置。例如，使用文件模拟数据库保存数据，就需要移动文件指针。指针的位置是以从文件头开始的字节数度量的，默认以不同模式打开文件时，文件指针通常在文件的开头或是结尾处，可以通过ftell()、fseek()和rewind()三个函数对文件指针进行操作，它们的原型如下所示：

.. code-block:: php

    <?php
	int ftell(resource handle) //返回文件指针的当前位置
	int fseek(resource hanlde,int offset[,int whence]) //移动文件指针到指定位置
	bool rewind(resource handle) //移动文件指针到文件的开头
    ?>

使用这些函数时，必须提供一个用 ``fopen()`` 函数打开的、合法的文件指针。函数 ``ftell()`` 获取由指定的资源中的文件指针当前位置的偏移量；函数 ``rewind()`` 将文件指针移回到指定资源的开头；而函数 ``fseek()`` 函数则将指针移动到第二个参数 ``offset`` 指定的位置，如果没有提供第三个可选参数 ``whence`` ，则位置将设置为从文件开头的 ``offset`` 字节处。否则，第三个参数 ``whence`` 可以设置为三个可能的值，它将影响指针的位置。

- SEEK_CUR:设置指针位置为当前位置加上第二个参数所提供的offset字节。
- SEEK_END:设置指针位置为EOF加上offset字节。在这里，offset必须设置为负值。
- SEEK_SET:设置指针位置为offset字节处。这与忽略第三个参数whence效果相同。

如果fseek()函数执行成功，将返回0，失败则返回-1。如果将文件以追加模式“a”或“a+”打开，写入文件的任何数据是会被附加在后面，不会管文件指针的位置。代码如下所示：

.. code-block:: php

    <?php
	$fp = fopen('data.txt' ,'r')or die("文件打开失败");

	echo ftell($fp)."<br>";    //输出刚打开文件的指针默认位置，指针在文件的开头位置为0
	echo fread($fp, 10)."<br>";   //读取文件中的前10个字符输出，指针位置发生了变化
	echo ftell($fp)."<br>";    //读取文件的前10个字符之后，指针移动的位置在第10个字节处

	fseek($fp, 100,SEEK_CUR);    //又将指针移动到倒数10个字节位置处
	echo ftell($fp); //文件的位置在110个字节处
	echo fread($fp,10)."<br>";   //读取110到120字节数位置的字符串，读取后指针的位置为120

	fseek($fp,-10,SEEK_END);   //又将指针移动到倒数10个字节位置处
	echo fread($fp, 10)."<br>";   //输出文件中最后10个字符

	rewind($fp);    //又移动文件指针到文件的开头
	echo ftell($fp);     //指针在文件的开头位置，输出0

	fclose($fp);
    ?>

文件的锁定机制
^^^^^^^^^^^^^
文件系统操作是在网络环境下完成的，可能有多个客户端用户在同一个时刻对服务器上的同一个文件访问。当这种并发访问发生时，很可能会破坏文件中的数据。例如，一个用户正向文件中写入数据，当还没写完，其他用户在这一时刻也向这个文件中写入数据，就会造成数据写入混乱，还有，当用户没有将数据写完时，其他用户就去获取这个文件中的内容，也会得到残缺的数据。

在PHP中提供了flock()函数，可以对文件使用锁定机制，当一个进程在访问文件时加上锁，其他进程要想对文件进行访问，则必须等到锁定被释放以后，这样就可以避免在并发访问同一个文件时破坏数据。该函数的原型如下：

``bool flock(resource $handle , int $operation [, int &$wouldblock ])``

该函数第一个参数handle必须是一个已经打开的文件资源，第二个参数operation也是必需的，规定使用哪种锁定类型，operation可以是以下值：

- LOCK_SH取得共享锁定（从文件中读取数据时使用）
- LOCK_EX取得独占锁定（向文件中写入数据时使用）
- LOCK_UN释放锁定(无论共享或独占，都用它释放)
- LOCK_NB附加锁定(如果不希望flock()锁定时阻塞，则应在上述锁定后加上该锁)

如果锁定会阻塞的话，已经被锁定的文件，再次加锁，flock()函数会被挂起，这时称为堵塞，也可以将可选的第三个参数设置为1，则当进行锁定时会阻挡其他进程，锁定操作也可以被fclose()函数释放，为了让flock()函数发挥作用，在所有访问文件的程序中都必须使用相同的方式锁定文件。该函数如果成功则返回 ``TRUE`` ,失败返回 ``FALSE`` 。

在下面的示例中，通过编写一个网络留言板的模型，应用一下flock()函数，首先创建一个包含表单内容的脚本，在表单中允许输入用户名，标题以及留言内容三部分，并在脚本中接受表单提交的内容，存储到文本文件text_data.txt中，文件以追加方式打开。文本文件存储规则为每次提交存储一行。例如"王小二||我要吃饭||哪里有饭店<|>"，每部分之间使用两个竖线分隔，每行以<|>结束，并将读取存储的文本文件text_data.txt中的数据，以html方式输出。代码如下：

.. code-block:: php

	<html>
	<head>
	    <title>file文件留言板</title>
	</head>
	<body>
	<?php
	$filename = "text_data.txt";
	if(isset($_POST['sub'])){
	    $message = $_POST['username'].'||'.$_POST['title'].'||'.$_POST['mess'].'<|>';
	    writeMessage($filename,$message);
	}

	if(file_exists($filename)){
	    readMessage($filename);
	}

	function writeMessage($filename,$message){
	    $fp = fopen($filename,'a');
	    if(flock($fp,LOCK_EX)){
	        fwrite($fp,$message);
	        flock($fp,LOCK_UN);
	    }else{
	        echo"不能锁定文件";
	    }
	    fclose($fp);
	}

	function readMessage($filename){
	    $fp = fopen($filename,'r');
	    flock($fp,LOCK_SH);
	    $buffer = '';
	    while(!feof($fp)){
	        $buffer.=fread($fp,1024);
	    }
	    $data=explode('<|>',$buffer);
	    foreach($data as $line){
	        @list($username,$title,$message)=explode("||",$line);
	        if($username!=''&&$title!=''&& $message!=''){
	            echo $username.'说：';
	            echo $title;
	            echo $message.'<hr>';
	        }
	    }
	    flock($fp,LOCK_UN);
	    fclose($fp);
	}

	?>
	<form action='' method="post">

	    用户名:<input type="text" size=10 name="username"><br>
	    标  题:<input type="text" size=30 name="title"><br>
	    <textarea name="mess" rows=4 cols=38>请在这里输入留言信息!</textarea>
	    <input type="submit" name="sub" value="留言">

	</form>
	</body>
	</html>

上面留言板程序中，在对文件的读取和写入时，都是使用flock()函数对文件加锁和释放锁，一个文件可以同时存在很多个共享锁定LOCK_SH,这意味着多个用户可以在同一时刻拥有对该文件的读取访问权限。而一个独占锁定LOCK_EX中允许一个用户拥有一次，通常被用于文件的写入操作。如果不希望出现锁定堵塞发生，可以附加LOCK_NB。代码如下所示：

.. code-block:: php

    <?php
	$file = fopen("test.txt","w+");
	flock($file,LOCK_EX + LOCK_NB);
	fwrite($file,"www.txxwl.com");
	flock($file,LOCK_UN + LOCK_NB);
	fclose($file);
    ?>

文件的一些基本操作函数
^^^^^^^^^^^^^^^^^^^^
在对文件操作时，不仅可以对文件中的数据进行操作，还可以对文件本身进行操作。例如复制文件、删除文件、截取文件以及为文件重命名等操作。在PHP中已经提供了这些文件处理方式的标准函数，使用也非常容易，如下表所示：

+-------------+-----------------------------------+------------------------+
| 函数        | 语法结构                          | 描述                   |
+=============+===================================+========================+
| copy()      | copy(来源文件,目的文件)           | 复制文件               |
+-------------+-----------------------------------+------------------------+
| unlink()    | unlink(目标文件)                  | 删除文件               |
+-------------+-----------------------------------+------------------------+
| ftruncate() | ftruncate(目标文件资源，截取长度) | 将文件截断到指定的长度 |
+-------------+-----------------------------------+------------------------+
| rename()    | rename(旧文件名，新文件名)        | 重命名文件或目录       |
+-------------+-----------------------------------+------------------------+

上表中四个函数如果执行成功则都会返回TRUE，失败则返回FALSE。代码如下：

.. code-block:: php

    <?php
	// 复制文件示例
	if(copy('./file1.txt','../data/file2.txt')){
	    echo '文件复制成功';
	}else {
	    echo '文件复制失败';
	}

	// 删除文件示例
	$filename='file1.txt';
	if(file_exists($filename)){
	    if(unlink($filename)){
	        echo '文件删除成功';
	    }else {
	        echo '文件删除失败';
	    }
	}

	// 重命名文件示例
	if(rename('./demo.php','./demo.html')){
	    echo "文件改名成功";
	}else {
	    echo '文件重命名失败';
	}

	// 截取文件示例
	$fp = fopen('./data.txt','r+') or die('文件打开失败');
	if(ftruncate($fp,1024)){
	    echo '文件截取成功';
	}else {
	    echo '文件截取失败';
	}
    ?>

文件的上传和下载
---------------
在web开发中，经常需要将本地文件上传到Web服务器上，可以从Web服务器上下载一些文件到本地磁盘。文件的上传和下载应用十分广泛，在PHP中可以接受来自几乎所有类型浏览器上传的文件，PHP还允许对服务器的下载进行控制。

文件上传
^^^^^^^
为了满足传递文件信息的需要，HTTP协议实现了文件上传机制，从而可以将客户端的文件通过自己的浏览器上传到服务器上指定目录存放。上传文件时，需要在客户端选择本地磁盘文件，而在服务器端需要接收并处理来自客户端上传的文件，所以客户端和Web服务器都需要设置。

客户端上传设置
"""""""""""""
文件上传的最基本方法，是使用HTML表单选择本地文件进行提交，在form表单中可以通过<input type="file">标记选择本地文件。如果支持文件上传操作，必须在<form>标签中将enctype和method两个属性指明相应的值，如下所示：

- enctype="multipart/form-data"用来指定表单编码数据方式，让服务器知道，我们要传递一个文件，并带有常规的表单信息。
- method="POST"用来指明发送数据的方法。

另外，还需要在form表单中设置一个hidden类型的input框。其中name的值为MAX_FILE_SIZE的隐藏值域，并通过设置其VALUE的值限制上传文件的大小(单位字节),但这个值不能超过PHP的配置文件中upload_max_filesize值设置的大小。文件上传表单的示例代码如下所示：

.. code-block:: php

    <!DOCTYPE html>
	<html lang="en">
	<head>
	    <meta charset="UTF-8">
	    <title>文件上传</title>
	</head>
	<body>
	        <form action="upload.php" method="post" enctype="multipart/form-data">
	            <input type="hidden" name="MAX_FILE_SIZE" value="1000000">
	            选择文件：<input type="file" name="myfile">
	            <input type="submit" value="上传文件">
	        </form>
	</body>
	</html>

在服务器端通过PHP处理上传
"""""""""""""""""""""""
客户端的上传表单只能提供本地文件选择，以及提供将文件发送给服务器的标准化方式，但并没有提供相关功能来确定文件到达目的地之后发生了什么。所以上传文件的接收和后续处理就要通过PHP脚本来处理。要想通过PHP成功地管理文件上传，需要通过以下三方面信息。如下所示：

- 设置PHP配置文件的指令，用于精细的调节PHP的文件上传功能；
- $_FILE多维数组：用于存储各种与上传文件有关的信息；
- PHP的文件上传处理函数：用于上传文件的后续处理；

文件上传与PHP配置文件的设置有关，首先，应该设置php.ini文件中的一些指令，精细调节PHP的文件上传功能。选项如下：

+---------------------+--------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| 指令名              | 默认值 | 功能描述                                                                                                                                                                                                                                                                           |
+=====================+========+====================================================================================================================================================================================================================================================================================+
| file_uploads        | ON     | 确定服务器上的PHP脚本是否可以接受HTTP文件上传                                                                                                                                                                                                                                      |
+---------------------+--------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| memory_limit        | 8M     | 设置脚本可以分配的最大内存量，防止失控的脚本独占服务器内存                                                                                                                                                                                                                         |
+---------------------+--------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| upload_max_filesize | 2M     | 限制PHP处理上传文件大小的最大值，此值必须小于post_max_size                                                                                                                                                                                                                         |
+---------------------+--------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| post_max_size       | 8M     | 限制通过post方法可以接受信息的最大值，此值应当大于配置指令upload_max_filesize的值，因为除了上传的文件之外，还可能传递其他的表单域。                                                                                                                                                |
+---------------------+--------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| upload_tmp_dir      | NULL   | 上传文件存放的临时路径，可以是一个绝对路径，这个目录对于拥有此服务进程用户必须是可写的。上传的文件在处理之前必须成功传输到服务器，所以必须指定一个位置，可以临时放置这些文件，直到文件移到最终目的地为止。例如：upload_tmp_dir=/tmp/uploads/。默认值为NULL则为操作系统的临时文件夹 |
+---------------------+--------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| max_execution_time  | 30     | 默认为30s，可以修改为0，表示不限制执行时间                                                                                                                                                                                                                                         |
+---------------------+--------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+


通过POST方法上传的文件有关信息都被存储在多维数组$_FILES中，这些信息对于通过PHP脚本上传到服务器的文件至关重要，因为文件上传后，首先存储于服务器的临时目录中，同时在PHP脚本中就会获取一个$_FILES全局数组。$_FILES数组的第二维中共有五项，如表所示：

+-------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| 数值                          | 描述                                                                                                                                                                                           |
+===============================+================================================================================================================================================================================================+
| $_FILES['myfile']['name']     | 客户端机器文件的原名称，包含扩展名                                                                                                                                                             |
+-------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| $_FILES['myfile']['size']     | 已上传文件大小，单位为字节                                                                                                                                                                     |
+-------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| $_FILES['myfile']['tmp_name'] | 文件上传后，在服务器端的临时文件名。这是存储在临时目录中时所指定的文件名                                                                                                                       |
+-------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| $_FILES['myfile']['error']    | 文件上传产生的错误信息                                                                                                                                                                         |
+-------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| $_FILES['myfile']['type']     | 获取从客户端上传文件的MIME类型。每种MIME类型都是由“/”分隔的主类型和子类型组成，如“image/gif”，主类型为“图像”，子类型为GIF格式的文件，“text/html”代表文本的HTML文件，还有很多其它不同类型的文件 |
+-------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

伴随文件上传时产生的错误信息，有五个可能的值。如下所示：

- 0：表示没有发生任何错误，文件上传成功；
- 1：表示上传文件的大小超出了在PHP配置文件中指令upload_max_filesize选项限制的值；
- 2：表示上传文件大小超出了HTML表单中MAX_FILE_SIZE选项所指定的值；
- 3：表示文件只被部分上传；
- 4：表示没有上传任何文件；

在上表中，$_FILES数组的第一维所使用的“myfile”是一个占位符，代表赋给文件上传表单元素 ``<input type="file" name="myfile">`` 中name属性的值。因此，这个值将根据你所选择的名字有所不同。

上传文件时，除了可以应用PHP中所提供的文件系统函数外，PHP还提供了专门用于文件上传所使用 ``is_uploaded_file()`` 和 ``move_uploaded_file()`` 两个函数。

函数is_uploaded_file()
++++++++++++++++++
该函数判断指定的文件是否通过HTTP POST上传的，如果是则返回true，用于防止潜在的攻击者对原本不能通过脚本交互的文件进行非法管理，这可以用来确保恶意的用户无法欺骗脚本去访问本不能访问的文件，例如/etc/passwd。此函数的原型如下所示：

``bool is_uploaded_file(string $filename) ///判断指定的文件是否是通过HTTP POST上传的``

为了能使此函数正常工作，唯一的参数必须指定类似于 ``$_FILES['myfile']['tmp_name']`` 的变量，才能判断指定的文件确实是上传文件。如果使用从客户端上传的文件名$_FILES['userfile']['name']则不能正常运作。

函数move_uploaded_file()
++++++++++++++++++++
文件上传后，首先会存储在服务器的临时目录中，可以使用该函数将上传的文件移动到新位置。此函数的原型如下所示：

``bool move_uploaded_file(string $filename , string $destination) //将上传的文件移动到新位置``

虽然函数copy()和函数move()也同样好用，但函数move_uploaded_file()还提供了一种额外的功能，检测并确保由第一个参数指定的文件，是否是合法的上传文件，如果合法，将其移动为由第二个参数指定的文件，如果不是合法的上传文件，不会出现任何操作，将返回false,成功返回true。

既然对上传文件有了基本的概念，就可以实现文件上传了，下面示例中，限制用户不能上传“文件类型”的文件，并将用户上传的文件从临时目录移动到当前的uploads目录下面，并将上传文件的原始文件名改变一下。脚本upload.php文件如下所示：

.. code-block:: php

    <?php
	if($_FILES['myfile']['error'] > 0){ // 判断文件是否成功上传到服务器，0表示上传成功
	    switch($_FILES['myfile']['error']){
	        case 1:
	            echo "上传文件大小超过PHP配置文件中的约定值:upload_max_filesize";
	            break;
	        case 2:
	            echo "上传文件大小超过表单中的约定值:MAX_FILE_SIZE";
	            break;
	        case 3:
	            echo "文件只有部分上传";
	            break;
	        case 4:
	            echo "没有上传任何文件";
	            break;
	    }
	    exit;
	}
	// 获取上传文件的MIME类型中的主类型和子类型
	list($maintype,$subtype) = explode('/',$_FILES['myfile']['type']);
	if($maintype == 'text') { // 通过主类型限制不能上传文本文件，例如.txt .html .php等文件
	    echo '问题：不能上传文本文件。';
	    exit; // 如果用户上传文本文件则退出程序
	}

	$upfile = __DIR__.'/uploads/'.time().$_FILES['myfile']['name']; // 定义上传后的位置和新文件名
	if(is_uploaded_file($_FILES['myfile']['tmp_name'])) { // 判断是否是上传文件
	    if (move_uploaded_file($_FILES['myfile']['tmp_name'], $upfile)) { // 移动文件
	    	// window文件名称为gbk编码，这里把utf-8编码转换为window平台的gbk编码
        	rename($upfile, iconv("utf-8","gbk",$upfile));
	        echo '文件' . $upfile . '上传成功，大小为' . $_FILES['myfile']['size'] . '!<br>'; // 如果文件上传成功则输出
	    } else {
	        echo "上传文件失败";
	        echo $_FILES['myfile']['name'];
	    }
	}
    ?>

执行上例时，需要在当前目录创建一个 ``uploads`` 目录，并且该目录必须具有web服务器进程用户可写的权限，还可以通过设置PHP配置文件中的指令调整上传文件的大小限制，以及通过上传文件的 ``MIME`` 类型或文件扩展名，控制上传文件的类型等。

处理多个文件上传
^^^^^^^^^^^^^^
多个文件上传和单独文件上传的处理方式是一样的，只需要在客户端多提供几个类型为“file”的输入表单，并指定不同的“name”属性值。例如，在下面的代码中，可以让用户同时选择三个本地文件一起上传给服务器，客户端的表单如下所示：

.. code-block:: html

    <html>
	<head><title>多个文件上传表单</title></head>
	<body>
		<form action="mul_upload.php" method="post" enctype="multipart/form-data">
		    <input type="hidden" name="MAX_FILE_SIZE" value="1000000">
		    选择文件1：<input type="file" name='myfile[]'><br>
		    选择文件2：<input type="file" name='myfile[]'><br>
		    选择文件3：<input type="file" name='myfile[]'><br>
		    <input type="submit" value="上传文件">
		</form>
	</body>
	</html>

在上面的代码中，将三个文件类型的表单以数组的形式组织在一起。当上面的表单教给PHP的脚本文件mul_upload.php时，在服务器端同样使用全局数组 ``$_FILES`` 存储所有上述文件的信息，但 ``$_FILES`` 由二维数组已经转变为三维数组，这样就可以存储多个上传文件的信息。在脚本文件mul_upload.php中，使用 ``print_r()`` 函数将 ``$_FILES`` 数组中的内容输出，代码如下所示：

.. code-block:: php

    <?php
	//打印三维数组$_FILES中的内容，查看一下存储上传文件的结构
	print_r($_FILES);
    ?>

当选择三个本地文件提交后，输出结果如下所示:

.. code-block:: text

    Array(
	    [myfile]=>Array( //$_FILES["myfile"]数组中的内容如下
	        [name]=>Array(            //$_FILES["myfile"]["name"]存储所有上传文件的内容
	            [0]=>Rav.ini         //$_FILES["myfile"]["name"][0]第一个上传文件的名称
	            [1]=>msgsocm.log     //$_FILES["myfile"]["name"][1]第二个上传文件的名称
	            [2]=>NOTEPAD.EXE)        //$_FILES["myfile"]["name"][2]第三个上传文件的名称
	        [type]=>Array(               //$_FILES["myfile"]["type"]存储所有上传文件的类型
	            [0]=>application/octet-stream          //$_FILES["myfile"]["type"][0]第一个上传文件的类型
	            [1]=>application/octet-stream          //$_FILES["myfile"]["type"][1]第二个上传文件的类型
	            [2]=>application/octet-stream)         //$_FILES["myfile"]["type"][2]第三个上传文件的类型
	        [tmp_name]=>Array(
	            [0]=>C:/WINDOWS/Temp/phpAF.tmp
	            [1]=>C:/WINDOWS/Temp/phpB0.tmp
	            [2]=>C:/WINDOWS/Temp/phpB1.tmp)
	        [error]=>Array(
	            [0]=>0
	            [1]=>0
	            [2]=>0)
	        [size]=>Array(
	            [0]=>64
	            [1]=>1350
	            [2]=>66560))
	)

通过输出$_FILES数组的值可以看到，处理多个文件的上传和单个文件上传时的情况一样的，只是$_FILES数组的结构形式略有不同。通过这种方式可以支持更多数量的文件上传。

文件下载
^^^^^^^
简单的文件下载只需要使用HTML的链接标记<a>,并将属性href的URL值指定下载的文件即可。代码如下所示：

``<a href=”http://www.lampbrother.net/download/book.rar”>下载文件</a>``

如果通过上面的代码实现文件下载，只能处理一些浏览器不能默认识别的MIME类型文件，例如当访问book.rar文件时，浏览器并没有直接打开，而是弹出一个下载提示框，提示用户“下载”还是“打开”等处理方式。但如果需要下载后缀名为.html的网页文件、图片文件以及PHP脚本文件等，使用这种链接方式，则会将文件内容直接输出到浏览器中，并不会提示用户下载。

为了提高文件的安全性，不希望在<a>标签中给出文件的链接，则必须向浏览器发送必要的头信息，以通知浏览器将要进行下载文件的处理。PHP使用header()函数发送网页的头部信息给浏览器，该函数接收一个头信息的字符串作为参数。文件下载需要发送的头信息包括以下三部分，通过调用三次header()函数完成。以下载图片test.gif为例，需要发送的头信息的代码如下所示：

.. code-block:: php

    <?php
	//发送指定文件MIME类型的头部信息，如果不指定，系统优先自动识别文件类型
	Header('Content-Type:image/gif');
	//发送描述文件的头信息，附件和文件名
	Header('Content-Disposition:attachment;filename="test.gif"');
	//发送指定文件大小的信息，单位字节，系统优先自动识别
	Header('Content-Length:3390');
    ?>

如果使用header()函数向浏览器发送了这三行头信息，图片test.gif就不会直接在浏览器中显示，而是让浏览器将改文件形成下载的形式。在函数header()中，“Content-Type”指定了文件的MIME类型，“Content-Disposition”用于文件的描述，值“attachment;filename=’test.gif’”说明这是一个附件，并且指定了下载后的文件名，“Content-Length”则给出了被下载文件的大小。

基于Web程序开发中，服务器将数据响应给浏览器时，必须严格按照固定的顺序。首先是协议状态和描述代码，如“HTTP/1.1 200 OK”等，第二个则是要发送的头部信息，最后响应给浏览器的才是网页的主体内容。所以在调用header()函数发送头信息时，一定要在发送网页内容之前，在发送头信息前不能有任何字符的输出，包括空格或空行也不行。
设置头部信息以后，需要将文件的内容输出到浏览器，以便进行下载。可以使用PHP中的文件系统函数将文件内容读取出来后，直接输入给浏览器。最方便的是使用 ``readfile()`` 函数，将文件内容读取出来并直接输出。下载文件test.gif的代码如下所示：

.. code-block:: php

    <?php
	$filename="test.gif";  //指定文件名
	header('Content-Type:image/gif');  //指定下载文件类型
	header('Content-Disposition:attachment;filename="$filename"'); //指定下载文件的描述
	header('Content-Length:'.filesize($filename));  //指定下载文件的大小
	readfile($filename);  //将文件内容读取出来并直接输出，以便下载
    ?>


文件处理提高
============
SplFileInfo
-----------
SplFileInfo类为单个文件的信息提供高级面向对象的接口。

类定义如下：

.. code-block:: php

    <?php
	SplFileInfo {
	    /* 方法 */
	    public __construct ( string $file_name )
	    // 获取当前Iterator item最后访问时间
	    public int getATime ( void )
	    // 获取当前文件名称以及后缀
	    public string getBasename ([ string $suffix ] )
	    // 获取文件 inode 修改时间
	    public int getCTime ( void )
	    // 获取当前Iterator item后缀
	    public string getExtension ( void )
	    // 似乎用指定继承类来获取该文件的SplFileInfo对象
	    public SplFileInfo getFileInfo ([ string $class_name ] )
	    // 获取当前Iterator item文件名（带扩展名）
	    public string getFilename ( void )
	    // 获取当前Iterator item组ID
	    public int getGroup ( void )
	    // 获取当前Iterator item的inode节点号
	    public int getInode ( void )
	    // 如果是链接，则获取链接的文件
	    public string getLinkTarget ( void )
	    // 获取当前Iterator item文件数据块最后被写入的时间
	    public int getMTime ( void )
	    // 获取当前Iterator item拥有者ID
	    public int getOwner ( void )
	    // 获取当前Iterator item路径名和文件名
	    public string getPath ( void )
	    // 使用指定的继承类获取当前Iterator item上一级的SplFileInfo对象
	    public SplFileInfo getPathInfo ([ string $class_name ] )
	    // 获取当前Iterator item路径名
	    public string getPathname ( void )
	    // 获取当前Iterator item权限
	    public int getPerms ( void )
	    // 获取文件或目录绝对路径
	    public string getRealPath ( void )
	    // 获取当前Iterator item文件大小
	    public int getSize ( void )
	    // 获取当前Iterator item类型，可能是file,link or dir
	    public string getType ( void )
	    // 判断给定的DirectoryIterator item对象是否是一个目录
	    public bool isDir ( void )
	    // 判断当前的DirectoryIterator item对象是否可执行
	    public bool isExecutable ( void )
	    // 判断当前的DirectoryIterator item对象是否是一个有效的文件
	    public bool isFile ( void )
	    // 判断当前的DirectoryIterator item对象是否是一个连接
	    public bool isLink ( void )
	    // 判断当前的DirectoryIterator item对象是否可读
	    public bool isReadable ( void )
	    // 判断当前的DirectoryIterator item对象是否可写
	    public bool isWritable ( void )
	    // 获取该文件的SplFileObject对象
	    public SplFileObject openFile ([ string $open_mode = "r" [, bool $use_include_path = false [, resource $context = NULL ]]] )
	    /*
	    使用此方法设置将在SplFileInfo :: getFileInfo（）和SplFileInfo :: getPathInfo（）被调用时使用的自定义类。
	    传递给此方法的类名称必须是SplFileInfo或派生自SplFileInfo的类。
	    */
	    public void setFileClass ([ string $class_name = "SplFileObject" ] )
	    public void setInfoClass ([ string $class_name = "SplFileInfo" ] )
	    // 以字符串形式返回文件的路径
	    public void __toString ( void )
	}
    ?>

SplFileObject类
---------------
这个类用来对文本文件进行遍历。

类定义如下：

.. code-block:: php

    <?php
	SplFileObject {
	    /* 常量 */
	    const integer DROP_NEW_LINE = 1 ;
	    const integer READ_AHEAD = 2 ;
	    const integer SKIP_EMPTY = 4 ;
	    const integer READ_CSV = 8 ;
	    /* 方法 */
	    public string|array current ( void )     //返回文件当前行内容
	    public bool eof ( void )  //检测文件是否到末尾，如果到末尾返回true，否则返回false
	    public bool fflush ( void )   //将缓冲内容输出到文件,成功时返回 TRUE， 或者在失败时返回 FALSE。
	    public string fgetc ( void )   //按字符读取文件
	    public array fgetcsv ([ string $delimiter = "," [, string $enclosure = "\"" [, string $escape = "\\" ]]] )   //读取csv文件
	    public string fgets ( void )   //按行读取文件
	    public string fgetss ([ string $allowable_tags ] )  //按行读取文件，并去掉html标记
	    public bool flock ( int $operation [, int &$wouldblock ] )   //文件锁定或解锁，返回true或false
	    /*参数：
	    LOCK_SH 共享锁 (读).
	    LOCK_EX 独占锁 (写).
	    LOCK_UN 释放锁 (共享或独占).
	    LOCK_NB (附加锁定) 如果不希望flock()在锁定时堵塞，则应在上述锁定后加上改锁（windows上不支持）
	    flock(LOCK_EX+LOCK_NB);   // 独占锁定加上附加锁定
	    flock(LOCK_UN+LOCK_NB); */
	    public int fpassthru ( void )   //输出文件指针之后的所有数据和字符数
	    public int fputcsv (array $fields)  //将一维数组作为一行输入csv文件中，返回写入的字符串长度或false
	    public string fread ( int $length )  //从文件中读取指定的字节数，返回读取的字符串或false
	    public mixed fscanf ( string $format [, mixed &$... ] )  //从文件中读取一行并按照指定模式解析
	    /*例：
	    $file = new SplFileObject("misc.txt");
	    while ($userinfo = $file->fscanf("%s %s %s")) {
	        list ($name, $profession, $countrycode) = $userinfo;
	        // Do something with $name $profession $countrycode
	    }*/
	    public int fseek ( int $offset [, int $whence = SEEK_SET ] ) //按字节移动文件指针位置，
	    /*SEEK_SET 设置文件指针到指定字节位置（默认为该模式）.
	    SEEK_CUR 设置文件指针到当前位置加上指定字节位置.
	    SEEK_END 设置文件指针到文件末尾加上指定字节位置（此时字节经常为负值）.
	    public array fstat ( void )  //获取文件信息，以数组形式返回*/
	    /*
	    数字下标    关联键名（自 PHP 4.0.6）   说明
	    0           dev device number - 设备名
	    1           ino inode number - inode 号码
	    2           mode    inode protection mode - inode 保护模式
	    3           nlink   number of links - 被连接数目
	    4           uid userid of owner - 所有者的用户 id
	    5           gid groupid of owner- 所有者的组 id
	    6           rdev    device type, if inode device * - 设备类型，如果是 inode 设备的话
	    7           size    size in bytes - 文件大小的字节数
	    8           atime   time of last access (unix timestamp) - 上次访问时间（Unix 时间戳）
	    9           mtime   time of last modification (unix timestamp) - 上次修改时间（Unix 时间戳）
	    10          ctime   time of last change (unix timestamp) - 上次改变时间（Unix 时间戳）
	    11          blksize blocksize of filesystem IO * - 文件系统 IO 的块大小
	    12          blocks  number of blocks allocated - 所占据块的数目* Windows 下总是 0。
	    * - 仅在支持 st_blksize 类型的系统下有效。其它系统（如 Windows）返回 -1。 */


	    public int ftell ( void )  //返回当前文件位置，文件指针位置
	    public bool ftruncate ( int $size )   //将文件截断到指定的长度，若长度大于文件长度用空补齐（文件打开方法对其有影响）
	    public int fwrite ( string $str [, int $length ] )  //将$str字符串写入文件，只写$length长度。放回写入字节数或null
	    public array getCsvControl ( void )  //Gets the delimiter and enclosure character used for parsing CSV fields.
	    public int getFlags ( void )  //Gets the flags set for an instance of SplFileObject as an integer.
	    public int getMaxLineLen ( void )  //返回一行读取的最大字节数（在已设置的前提下），若未设置，默认为0
	    public int key ( void )  //获取当前行号。
	    public void next ( void )  //移动到下一行
	    public void rewind ( void ) //返回到第一行
	    public void seek ( int $line_pos )  //定位到文件指定行
	    public void setCsvControl ([ string $delimiter = "," [, string $enclosure = "\"" [, string $escape = "\\" ]]] )
	    public void setFlags ( int $flags )
	    public void setMaxLineLen ( int $max_len )  //设置文件读取一行的最大字节数，若文件每行有10个字符，但设置最大读取为
	    public bool valid ( void )  //检查是否到达文件底部，未到达底部返回 TRUE ，抵达返回false.

	    /*省略继承的方法*/
	}
    ?>

例子：

.. code-block:: php

    <?php
	try {
	    $file = new SplFileObject('Book.xml');
	    $file->setFlags(SplFileObject::READ_AHEAD | SplFileObject::SKIP_EMPTY | SplFileObject::DROP_NEW_LINE);

	    // 返回文本文件的第三行
	    $file->seek(3);
	    echo $file->current();

	    foreach ( $file as $line)
	        echo $line . PHP_EOL;
	} catch (Exception $e) {
	    echo $e->getMessage();
	}
    ?>

另一种写法：

.. code-block:: php

    <?php
	$file = new SplFileObject("Book.xml", 'r+');
	while (!$file->eof()) {
	    echo $file->current();
	    $file->next();
	}
	//关闭文件对象，SplFileObject持有该文件的一个指针，所以不能通过unlink来删除文件
	//只有在释放掉对象后，才可以通过unlink来删除文件
	$file = null;
    ?>

常用文件处理方法：

.. code-block:: php

    <?php
	/**
	 * 获取文件指定行数范围数据
	 * @param unknown $filename  文件名称
	 * @param number $startLine  开始行
	 * @param number $endLine    结束行
	 * @param string $method
	 * @return multitype:
	 */
	function getFileLines($filename, $startLine = 1, $endLine = 20, $method = 'rb'){
	    $content = array();
	    $count = $endLine - $startLine;
	    $fp = new SplFileObject($filename, $method);
	    $fp->seek($startLine - 1); // 转到第N行, seek方法参数从0开始计数
	    for ($i = 0; $i <= $count; ++$i) {
	        $content[] = $fp->current(); // current()获取当前行内容
	        $fp->next(); // 下一行
	        if($fp->eof()) {
	            array_pop($content);
	            break;
	        }
	    }
	    return array_filter($content); // array_filter过滤：false,null,''
	}

	/**
	 * 获取文章最后一行内容
	 * @param string $res 文件路径/名
	 */
	function get_last_line($res) {
	    $fp = fopen($res, 'r');
	    if (false == $fp) {
	        return 'error';
	    }
	    fseek($fp,-1,SEEK_END);
	    $s = '';
	    while(($c = fgetc($fp)) !== false)
	    {
	        if($c == "\n" && $s) break;
	        $s = $c . $s;
	        fseek($fp, -2, SEEK_CUR);
	    }
	    fclose($fp);
	    return $s;
	}
    ?>

SplTempFileObject
-----------------
SplTempFileObject类为临时文件提供面向对象的接口。

有时你需要一些临时存储空间，你需要判断是否将所有内容都保存在内存中（当脚本超过了PHP的memory_limit设置时，可能会导致脚本死掉）或磁盘上（速度慢，通常是不必要的）。 PHP有一个名为 ``php://temp`` 的内置流和一个名为 ``SPLTempFileObject`` 的类，它们在内存中的存储量最高（默认为2MB），然后透明地切换到磁盘存储。对于像cURL中检索文件，或者使用 ``SPLFileObject的fputcsv()`` 方法准备CSV输出，它们非常方便：

类定义如下：

.. code-block:: php

    <?php
	// Fake dataset - imagine this was bigger
	$data = [
	    ['id','Name',   'Type'],
	    ['1', 'Orange', 'Fruit'],
	    ['2', 'Cheese', 'Dairy comestible'],
	];
	// Build CSV
	$file = new SPLTempFileObject();
	foreach ($data as $row) {
	    $file->fputcsv($row);
	}

	// 直接输出
	$file->rewind();
	foreach ($file as $line) {
	    echo $line;
	}

	// 写入输出缓冲区
	header('Content-type: text/csv; charset=utf-8');
	$file->rewind();
	$file->fpassthru();
    ?>

文件搜索
--------
glob函数
^^^^^^^^
glob — 寻找与模式匹配的文件路径。

``array glob ( string $pattern [, int $flags = 0 ] )``

glob() 函数依照 libc glob() 函数使用的规则寻找所有与 pattern 匹配的文件路径，类似于一般 shells 所用的规则一样。不进行缩写扩展或参数替代。

glob使用两个特殊的元字符\*和?

- ?：匹配除了/之外的任何一个字符；
- \*：匹配除了/之外的多个字符；

glob还支持字符类，大小写敏感

- []：表示匹配任意一个位于中括号中的字符；
- [^]：表示匹配任意一个不位于中括号中的字符；

参数：

- pattern：不进行缩写扩展或参数替代。
- flags：它的有效标记有

  + GLOB_MARK - 在每个返回的项目中加一个斜线
  + GLOB_NOSORT - 按照文件在目录中出现的原始顺序返回（不排序）
  + GLOB_NOCHECK - 如果没有文件匹配则返回用于搜索的模式
  + GLOB_NOESCAPE - 反斜线不转义元字符
  + GLOB_BRACE - 扩充 {a,b,c} 来匹配 'a'，'b' 或 'c'
  + GLOB_ONLYDIR - 仅返回与模式匹配的目录项
  + GLOB_ERR - 停止并读取错误信息（比如说不可读的目录），默认的情况下忽略所有错误

返回值：

- 返回一个包含有匹配文件／目录的数组。如果出错返回 FALSE。

.. code-block:: php

    <?php
	// 搜索当前目录所有文件
	$array = glob('*.*');

	// 搜索以.php结果的php文件
	$array = glob('*.php');

	// 搜索包括有php,aspx 文件
	$files = glob('*.{php,aspx}', GLOB_BRACE);

	// 在指定目录搜索以1开头的php文件
	$files = glob('../05-15/1*.php');

	// 返回隐藏文件
	$files = glob('{,.}*', GLOB_BRACE);
    ?>

DirectoryIterator (extends SplFileInfo)
---------------------------------------
这个类用来查看一个目录中的所有文件和目录(不自动进入子目录)：

类定义如下：

.. code-block:: php

    <?php
	DirectoryIterator extends SplFileInfo implements SeekableIterator {

	    public __construct ( string $path )
	    public DirectoryIterator current ( void )
	    // 获取当前Iterator item最后访问时间
	    public int getATime ( void )
	    // 获取当前文件名称以及后缀
	    public string getBasename ([ string $suffix ] )
	    // 获取当前Iterator item最后修改时间
	    public int getCTime ( void )
	    // 获取当前Iterator item后缀
	    public string getExtension ( void )
	    // 获取当前Iterator item文件名（带扩展名）
	    public string getFilename ( void )
	    // 获取当前Iterator item组ID
	    public int getGroup ( void )
	    // 获取当前Iterator item的inode节点号
	    public int getInode ( void )
	    // 获取当前Iterator item文件数据块最后被写入的时间
	    public int getMTime ( void )
	    // 获取当前Iterator item拥有者ID
	    public int getOwner ( void )
	    // 获取当前Iterator item路径名和文件名
	    public string getPath ( void )
	    // 获取当前Iterator item路径名
	    public string getPathname ( void )
	    // 获取当前Iterator item权限
	    public int getPerms ( void )
	    // 获取当前Iterator item文件大小
	    public int getSize ( void )
	    // 获取当前Iterator item类型，可能是file,link or dir
	    public string getType ( void )
	    // 判断给定的DirectoryIterator item对象是否是一个目录
	    public bool isDir ( void )
	    // 判断当前的DirectoryIterator item对象是否是‘.’或‘..’
	    public bool isDot ( void )
	    // 判断当前的DirectoryIterator item对象是否可执行
	    public bool isExecutable ( void )
	    // 判断当前的DirectoryIterator item对象是否是一个有效的文件
	    public bool isFile ( void )
	    // 判断当前的DirectoryIterator item对象是否是一个连接
	    public bool isLink ( void )
	    // 判断当前的DirectoryIterator item对象是否可读
	    public bool isReadable ( void )
	    // 判断当前的DirectoryIterator item对象是否可写
	    public bool isWritable ( void )
	    public string key ( void )
	    public void next ( void )
	    public void rewind ( void )
	    public void seek ( int $position )
	    public string __toString ( void )
	    public bool valid ( void )
	}
    ?>

.. code-block:: php

    <?php
	try {
	    /*** class create new DirectoryIterator Object ***/
	    foreach (new DirectoryIterator('./') as $Item) {
	        echo iconv('GB2312','UTF-8', $Item).PHP_EOL;
	    }
	} /*** if an exception is thrown, catch it here ***/ catch (Exception $e) {
	    echo 'No files Found!<br />';
	}
    ?>

在\*nix环境中isDot()方法对于./..目录不能识别，总是作为普通目录。而FilesystemIterator修复了该问题。

FilesystemIterator
^^^^^^^^^^^^^^^^^^^
FilesystemIterator遍历文件系统(不自动进入子目录)。

当您使用DirectoryIterator迭代时，每个返回的“值”都是相同的DirectoryIterator对象。内部状态被改变，所以当你调用isDir（），getPathname（）时，返回对应文件或目录的信息。如果你在迭代时要求一个键，你会得到一个整数索引值。

FilesystemIterator（和RecursiveDirectoryIterator）另一方面为每个迭代步骤返回一个新的、不同的SplFileInfo对象。key是文件的完整路径名。这是默认的。您可以使用“flags”参数更改构造函数返回的键或值的内容。

.. code-block:: php

    <?php
	date_default_timezone_set('PRC');//设置时区，中华人民共和国
	$it = new FileSystemIterator('.');//实例化

	foreach ($it as $finfo) {
	    printf("%s\t%s\t%8s\t%s",
	        date("Y-m-d H:i:s",$finfo->getMTime()),//文件创建时间
	        $finfo -> isDir()?"<DIR>":"",
	        number_format($finfo -> getSize()),//文件大小
	        iconv("gb2312","utf-8",$finfo->getFileName())//文件名称
	    ); // window是用的GB2312的编码，你的php文件应该用的是UTF-8
	    echo PHP_EOL;
	}
    ?>


GlobIterator
""""""""""""
遍历一个文件系统行为类似于 glob()。该类是对glob封装，提供对文件或目录的过滤。

.. code-block:: php

    <?php
	$iterator = new GlobIterator('*.xml');

	printf("Matched %d item(s)\r\n", $iterator->count());
    ?>

RecursiveDirectoryIterator
"""""""""""""""""""""""""""
RecursiveDirectoryIterator提供了一个通过文件系统目录递归迭代的接口。

.. code-block:: php

    <?php
	RecursiveDirectoryIterator extends FilesystemIterator implements SeekableIterator , RecursiveIterator {

	    // 构造一个RecursiveDirectoryIterator对象
	    public __construct ( string $path [, int $flags = FilesystemIterator::KEY_AS_PATHNAME | FilesystemIterator::CURRENT_AS_FILEINFO ] )
	    // 如果它是一个目录，则返回当前目录的迭代器
	    public mixed getChildren ( void )
	    // 获取子路径
	    public string getSubPath ( void )
	    // 获取子路径和名称
	    public string getSubPathname ( void )
	    // 返回当前条目是否是一个目录，而不是'.'和 '..'
	    public bool hasChildren ([ bool $allow_links = false ] )
	    // 返回当前目录实体的路径和文件名
	    public string key ( void )
	    // 移到下一个实体
	    public void next ( void )
	    // 重置指针
	    public void rewind ( void )

	    /*省略继承方法*/
	}
    ?>

current 默认是SplFileInfo对象。

.. code-block:: php

    <?php
	$directory = new \RecursiveDirectoryIterator('.');
	$iterator = new \RecursiveIteratorIterator($directory);
	foreach ($iterator as $key => $info) {
	    /* @var $info SplFileInfo */
	   echo $key .":::::::". $info->getFilename().PHP_EOL;
	}
    ?>

还可以通过 ``RecursiveFilterIterator`` 和 ``RecursiveCallbackFilterIterator`` 迭代器来过滤。参考 http://php.net/manual/zh/class.recursivedirectoryiterator.php

综合例子：

filter-dots.php:

.. code-block:: php

    <?php
	/**
	 * Directory iterator class - filters out the . and .. directories
	 *
	 */
	class DirectoryFilterDots extends RecursiveFilterIterator
	{
	    /**
	     * Init with a recursive directory iterator.
	     *
	     * @access  public
	     * @param   RecursiveDirectoryIterator  $path   The directory to iterate
	     */
	    public function __construct($path)
	    {
	        parent::__construct(new RecursiveDirectoryIterator($path));
	    }
	    /**
	     * Filter out both kinds of dots in a directory structure.
	     *
	     * @access  public
	     * @return  bool    Whether the current entry is neither '.' nor '..'
	     */
	    public function accept()
	    {
	        return !$this->getInnerIterator()->isDot();
	    }
	    /**
	     * Override the key method to return the path name.
	     *
	     * @access  public
	     * @return  string  The current entries path name
	     */
	    public function key()
	    {
	        return $this->getInnerIterator()->getPathname();
	    }
	}
    ?>

filter-extension.php

.. code-block:: php

    <?php
	/**
	 * Filters out files with specified extensions.
	 */
	class ExtensionFilter extends FilterIterator {
	    private $_ext;
	    private $_it;
	    private $_whitelisted;
	    /**
	     * Takes both a directory iterator and a file extension and only returns
	     * results matching the particular extension.
	     *
	     * @access  public
	     */
	    public function __construct(DirectoryIterator $it, $ext, $whitelisted = false)
	    {
	        parent::__construct($it);
	        $this->_it = $it;
	        $this->_ext = $ext;
	        $this->_whitelisted = $whitelisted;
	    }
	    /**
	     * Given the current iterator position, check the filename against
	     * the extension and filter accordingly.
	     *
	     * @access  public
	     * @return  bool
	     */
	    public function accept()
	    {
	        $return = true;
	        // skip dots
	        if ($this->_it->isDot()) return false;
	        // pop off the extension for non-directories and try to match
	        if (!$this->_it->isDir()) {
	            $ext = $this->_it->getExtension();
	            if ($this->_whitelisted) {
	                if (is_array($this->_ext)) {
	                    $return = in_array($ext, $this->_ext);
	                } else {
	                    $return = $ext === $this->_ext;
	                }
	            } else {
	                if (is_array($this->_ext)) {
	                    $return = !in_array($ext, $this->_ext);
	                } else {
	                    $return = $ext !== $this->_ext;
	                }
	            }
	        }
	        return $return;
	    }
	}
    ?>

filter-key.php

.. code-block:: php

    <?php
	/**
	 * Filter an array of string results based on a given regular expression.
	 */
	class KeyFilter extends FilterIterator
	{
	    private $_regex;
	    /**
	     * The key filter takes in an iterator and a regular expression pattern
	     * to filter the iterator keys against.
	     *
	     * @access  public
	     * @return  void
	     */
	    public function __construct(Iterator $it, $regex)
	    {
	        parent::__construct($it);
	        $this->_regex = $regex;
	    }
	    /**
	     * Provide the required accept() method for filtering keys by
	     * a regular expression.
	     *
	     * @access  public
	     * @return  int|bool
	     */
	    public function accept()
	    {
	        return preg_match($this->_regex, $this->getInnerIterator()->key());
	    }
	    /**
	     * Override the cloning method.
	     *
	     * @access  protected
	     * @return  bool
	     */
	    protected function __clone() {
	        return false;
	    }
	}
    ?>

directory-match.php

.. code-block:: php

    <?php
	/**
	 * Handle matching and filtering directories by a regular expression.
	 */
	class DirectoryMatch extends KeyFilter {
	    public function __construct ($path, $regex) {
	        parent::__construct(new DirTreeIterator($path), $regex);
	    }

	    /**
	     * Override the current element to simply return the key.
	     *
	     * @access  public
	     * @return  string
	     */
	    public function current () {
	        return parent::key();
	    }

	    /**
	     * Override the key element to simply return the key.
	     *
	     * @access  public
	     * @return  string
	     */
	    public function key () {
	        return parent::key();
	    }
	}
    ?>

directory-tree.php

.. code-block:: php

    <?php
	class DirectoryTreeIterator extends RecursiveIteratorIterator {
	    /**
	     * Construct from a path.
	     * @param $path directory to iterate
	     */
	    public function __construct ($path) {
	        try {
	            parent::__construct(new RecursiveCachingIterator(new RecursiveDirectoryIterator($path, RecursiveDirectoryIterator::KEY_AS_FILENAME
	            ), CachingIterator::CALL_TOSTRING | CachingIterator::CATCH_GET_CHILD
	            ), parent::SELF_FIRST
	            );
	        } catch (Exception $e) {
	            die($e->getMessage());
	        }
	    }

	    /**
	     * Skip over elements with children, returning keys.
	     *
	     * @access  public
	     * @return  string
	     */
	    public function current () {
	        if ($this->hasChildren()) {
	            $this->next();
	        }
	        return $this->getInnerIterator()->current()->getPath() . DIRECTORY_SEPARATOR . $this->key();
	    }

	    /**
	     * An aggregate of the inner iterator.
	     *
	     * @access  public
	     * @param   string $func
	     * @param   mixed $params
	     */
	    public function __call ($func, $params) {
	        return call_user_func_array(array($this->getSubIterator(), $func), $params);
	    }
	}
    ?>

.. code-block:: php

    <?php
	require_once(__DIR__ . DIRECTORY_SEPARATOR . 'directory-iterator' . DIRECTORY_SEPARATOR . 'filter-dots.php');
	require_once(__DIR__ . DIRECTORY_SEPARATOR . 'directory-iterator' . DIRECTORY_SEPARATOR . 'filter-extension.php');
	require_once(__DIR__ . DIRECTORY_SEPARATOR . 'directory-iterator' . DIRECTORY_SEPARATOR . 'filter-key.php');
	require_once(__DIR__ . DIRECTORY_SEPARATOR . 'directory-iterator' . DIRECTORY_SEPARATOR . 'directory-tree.php');
	require_once(__DIR__ . DIRECTORY_SEPARATOR . 'directory-iterator' . DIRECTORY_SEPARATOR . 'directory-graph.php');
	require_once(__DIR__ . DIRECTORY_SEPARATOR . 'directory-iterator' . DIRECTORY_SEPARATOR . 'directory-match.php');

	/**
	 * 该类包含迭代文件目录的使用例子
	 */
	class DirectoryUsage
	{
	    /**
	     * 递归列出所有文件或目录。第二个参数允许你指定是列出文件，还是目录。
	     *
	     * @param   string  $dir
	     * @param   string  $type ['file'|'dir']
	     * @return  array
	     */
	    public function dirListByType($dir, $type = 'file')
	    {
	        $output = array();

	        $it = new RecursiveDirectoryIterator($dir);
	        $it = new RecursiveIteratorIterator($it, RecursiveIteratorIterator::CHILD_FIRST);
	        foreach ($it as $file) {
	            if ($file->getType() == $type) {
	                $output[] = $file->getPathname();
	            }
	        }

	        return $output;
	    }
	    /**
	     * 删除指定目录的指定文件
	     *
	     * @access  public
	     * @param   string  $directory
	     * @param   array   $filter
	     */
	    public function cleanDir($directory, $filter = array('_vti_cnf', '_vti_private', '_vti_txt', '_private', '_themes', 'msupdate', 'vti_pvt', 'vti_script', '_vti_log', '_template','Thumbs.db'))
	    {
	        $it = new RecursiveDirectoryIterator($directory);
	        $it = new RecursiveIteratorIterator($it, RecursiveIteratorIterator::CHILD_FIRST);
	        foreach ($it as $file) {

	            // remove empty dirs
	            if (sizeof($file->getSize()) == 0) {
	                unlink($file->getPath());
	            }

	            // remove instances of Thumbs.db
	            if ($file->getFileName() == 'Thumbs.db') {
	                unlink($file->getPath() . DIRECTORY_SEPARATOR . $file->getFilename());
	            }

	            // if paths match filter, delete directory recursively
	            $parts = explode(DIRECTORY_SEPARATOR, $file->getPath());
	            if(in_array(end($parts), $filter)) {
	                $this->deleteDir($file->getPath());
	            }

	        }
	    }
	    /**
	     * 递归获取指定目录的所有文件信息
	     *
	     * @param   string  $directory
	     * @param   array   $filter
	     * @return  array
	     */
	    public function fileInfo($directory, $filter = array('php', 'xsl', 'xml', 'htm', 'html','css'))
	    {
	        $count_directories = 0;
	        $count_files = 0;
	        $count_lines = 0;
	        $count_bytes = 0;
	        $iterator = new RecursiveDirectoryIterator($directory);
	        $it = new RecursiveIteratorIterator($iterator, RecursiveIteratorIterator::CHILD_FIRST);
	        foreach ($it as $file) {
	            if (false === $file->isDir()) {
	                // get the file extension
	                $ext = $file->getExtension();
	                if (in_array($ext, $filter)) {
	                    $count_files++;
	                    $count_bytes += $file->getSize();
	                    $count_lines += sizeof(explode("n", file_get_contents($file->getPathName())));
	                }
	            } else if(false === strpos($file->getPathname(), 'CVS') && $file->isDir()) {
	                $count_directories++;
	            }
	        }
	        return array(
	            'bytes'       => $count_bytes,
	            'files'       => $count_files,
	            'lines'       => $count_lines,
	            'directories' => $count_directories
	        );
	    }
	    /**
	     * 递归删除一个目录和所有子目录
	     *
	     * @access  public
	     * @param   string  $dir
	     * @return  void
	     */
	    public function deleteDir($dir)
	    {
	        $iterator = new RecursiveDirectoryIterator($dir);
	        $it = new RecursiveIteratorIterator($iterator, RecursiveIteratorIterator::CHILD_FIRST);
	        foreach ($it as $file) {
	            if ($file->isDir()) {
	                rmdir($file->getPathname());
	            } else {
	                unlink($file->getPathname());
	                @rmdir($dir);
	            }
	        }
	        @rmdir($dir);
	    }
	    /**
	     * 在给定的目录中通过正则表达式查找一个文件
	     *
	     * @param string $path
	     * @param string $regex
	     * @return array
	     */
	    public function fileFinder($path, $regex)
	    {
	        $matches = array();

	        $fileList = new DirMatch($path, $regex);
	        foreach ($fileList as $file) {
	            $matches[] = $file;
	        }

	        return $matches;
	    }

	    /**
	     * 列出给定目录的所有文件，不递归
	     *
	     * @param string $dir
	     * @return array
	     */
	    public function fileLister($dir)
	    {
	        $files = array();

	        $filtered = new DirectoryFilterDots($dir);
	        foreach ($filtered as $file) {
	            if ($file->isDir()) {
	                continue;
	            }
	            $files[] = $file->getFilename();
	        }

	        return $files;
	    }

	}
	// generate the directory path to the example dir
	$dir = __DIR__ . DIRECTORY_SEPARATOR . 'directory-iterator-example';
	// load up the class
	$DirectoryUsage = new DirectoryUsage();
	echo '==================================' . PHP_EOL;
	echo 'Recursively show all files in a directory.' . PHP_EOL;
	echo '==================================' . PHP_EOL;
	$files = $DirectoryUsage->dirListByType($dir, 'file');
	foreach ($files as $f) {
	    echo $f . PHP_EOL;
	}
	echo '==================================' . PHP_EOL;
	echo 'Recursively show all directories in a directory.' . PHP_EOL;
	echo '==================================' . PHP_EOL;
	$dirs = $DirectoryUsage->dirListByType($dir, 'dir');
	foreach ($dirs as $d) {
	    echo $d . PHP_EOL;
	}
	echo '==================================' . PHP_EOL;
	echo 'Recursively iterate over all files in a directory.' . PHP_EOL;
	echo '==================================' . PHP_EOL;
	// recursively generate a tree representation
	$files = new DirectoryTreeIterator($dir);
	foreach ($files as $f) {
	    echo $f . PHP_EOL;
	}
	echo '==================================' . PHP_EOL;
	echo 'Iterate over a all files in a directory, filtering out dots.' . PHP_EOL;
	echo '==================================' . PHP_EOL;
	// recursively generate a tree representation
	$files = new DirectoryFilterDots($dir);
	foreach ($files as $f) {
	    echo $f . PHP_EOL;
	}
	echo '==================================' . PHP_EOL;
	echo 'Find all files with a PHP extension.' . PHP_EOL;
	echo '==================================' . PHP_EOL;
	// filter by PHP file extension
	$phpFiles = new ExtensionFilter(new DirectoryIterator($dir), 'php', $whitelist=true);
	foreach ($phpFiles as $f) {
	    echo $f->getPathName() . PHP_EOL;
	}
	echo '==================================' . PHP_EOL;
	echo 'Find all files without a PHP extension.' . PHP_EOL;
	echo '==================================' . PHP_EOL;
	// filter by PHP file extension
	$phpFiles = new ExtensionFilter(new DirectoryIterator($dir), 'php', $whitelist=false);
	foreach ($phpFiles as $f) {
	    echo $f->getPathName() . PHP_EOL;
	}
    ?>