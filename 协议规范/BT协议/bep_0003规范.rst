**********
bep_0003规范
**********

``BT`` 协议是一个协议簇。

有点像 ``tcp/ip`` 协议一样， ``bt`` 协议不是一个简单的协议，而是一系列相关的协议组成的，而且这个协议簇一直在进化。

既然这篇文章的主题是“基础篇”，所以它的内容主要来自 ``bep_0003`` ,也就是 ``bittorrent`` 协议规范，因为其它的协议都是以这个协议为基础的，可见这个的重要性。

bittorrent协议规范（中文版）
==========================
``bittorrent`` 是一个文件分发协议，它使用 ``url`` 来定位文件而且跟 ``web`` 服务无缝集成。当有多个人同时下载同一个文件时，下载者之间可以互相上传自己已有的那部分文件，让一个文件支持很多人同时下载却只增加小量的带宽负担变成可能，这就是 ``bt`` 协议相比 ``http`` 协议的优势。

``bt`` 文件分享由下列内容组成：
-----------------------------

- 传统的文件服务器(Web服务器)；
- 种子文件(.torrent文件)；
- 一个tracker服务器；
- 一个原始文件分享者；
- 一个网络浏览器；
- 一个或多个下载者；

``Web`` 服务器上保存着种子文件，下载者使用网络浏览器（如IE浏览器）从 ``Web`` 服务器上下载种子文件。种子文件，又称为元原文件或 ``metafile`` ，它保存了共享文件的一些信息，如共享文件的文件名、文件大小、 ``Tracker`` 服务器的地址。种子文件通常很小，一般大小为 ``1GB`` 的共享文件，其种子文件不足 ``100KB`` ，种子文件以 ``.torrent`` 为后缀。 ``Tracker`` 服务器保存着当前下载某共享文件的所有下载者的 ``IP`` 和端口。原始文件提供者提供完整的共享文件供其他下载者下载，它也被称为种子，种子文件就是提供者使用 ``BT`` 客户端生成的。每个下载者通过运行 ``BT`` 客户端软件下载共享文件。我们把某个下载者本身称为客户端，把其他下载者称为 ``peer`` 。

``BT`` 客户端下载一个共享文件的过程是：客户端首先解析种子文件，获取待下载的共享文件的一些信息，其中包括 ``Tracker`` 服务器的地址。然后客户端连接 ``Tracker`` 获取当前下载该文件的所有下载者的 ``IP`` 和端口。之后客户端根据 ``IP`` 和端口连接其他下载者，从它们那里下载文件，同时把自己已下载的部分提供给其他下载者下载。

共享文件在逻辑上被划分为大小相同的块，称为 ``piece`` ，每个 ``piece`` 的大小通常为 ``256KB`` 。对于共享文件，文件的第 1 字节到第 256K （即262144）字节为第一个 piece ，第 256K＋1 字节到第 512K 字节为第二个 piece ，依此类推。种子文件中包含有每个 piece 的 hash 值。 BT 协议规定使用 Sha1 算法对每个 piece 生成 20 字节的 hash 值，作为每个 piece 的指纹。每当客户端下载完一个 piece 时，即对该 peice 使用 Sha1 算法计算其 hash 值，并与种子文件中保存的该 peice 的 hash 值进行比较，如果一致即表明下载了一个完整而正确的 piece 。一旦某个 piece 被下载，该 piece 即提供给其他 peer 下载。在实际上传和下载中，每个 piece 又被划分为大小相同的 slice ，每个 slice 的大小固定为 16KB （16384字节）。 peer 之间每次传输以 slice 为单位。

从以上描述可以得知，待开发的 BT 软件（即BT客户端）主要包含以下几个功能：解析种子文件获取待下载的文件的一些信息，连接 Tracker 获取 peer 的 IP 和端口，连接 peer 进行数据上传和下载、对要发布的提供共享文件制作和生成种子文件。种子文件和 Tracker 的返回信息都以一种简单而高效的编码方式进行编码，称为 B 编码。客户端与 Tracker 交换信息基于 HTTP 协议， Tracker 本身作为一个 Web 服务器存在。客户端与其他 peer 采用面向连接的可靠传输协议 TCP 进行通信。下面将进一步作详细的介绍。

一个服务器按照下面的步骤开始文件分享过程：
--------------------------------------

1. 启动一个 ``bt tracker`` 服务器；
2. 启动一个普通的 ``web`` 服务器，如 ``apache`` ；
3. 在 ``web`` 服务器上配置多媒体类型 ``application/x-bittorrent`` 关联到 ``.torrent`` 文件；
4. 生成一个 ``.torrent`` 文件，在文件中添加 ``bt tracker`` 服务器的地址；
5. 上传 ``torrent`` 文件到 ``web`` 服务器；
6. 发布 ``torrent`` 文件下载页面；
7. 等待用户下载

一个用户按照下面的步骤开始文件下载：

1. 安装 ``bt`` 客户端；
2. 浏览 ``web`` 页面；
3. 下载 ``torrent`` 文件；
4. 保存 ``torrent`` 文件到本地；
5. 使用 ``bt`` 客户端打开 ``torrent`` 文件，开始下载；
6. 等待文件下载完成；

bencoding编码
-------------

- ``strings`` (字符串)编码为： ``<字符串长度>:<字符串>`` 例如： 4:test 表示为字符串"test"， 4: 例子 表示为字符串“例子”，字符串长度单位为字节，没开始或结束标记；
- ``integers`` (整数)编码为： ``i<整数>e`` ，开始标记 i ，结束标记为 e ，例如： i1234e 表示为整数 1234 ， i-1234e 表示为整数 -1234 ，整数没有大小限制， i0e 表示为整数 0 ， i-0e 为非法，以 0 开头的为非法如： i01234e 为非法；
- ``lists`` (列表)编码为： ``le`` ，开始标记为 l ，结束标记为 e ，列表里可以包含任何 bencoding 编码类型，包括整数，字符串，列表，字典。例如： l4:test5:abcdee 表示为二个字符串["test","abcde"]
- ``dictionaries`` (字典)编码为 ``de`` ，开始标记为 d ，结束标记为 e ，关键字必须为 bencoding 字符串，值可以为任何 bencoding 编码类型，例如： d3:agei20ee 表示为{"age"=20}， d4:path3:C:\8:filename8:test.txte 表示为 {"path"="C:","filename"="test.txt"}。键必须是字符串并按排序顺序出现（按原始字符串排序，而不是字母数字）。

元信息文件
---------

``Metainfo files`` (俗称 ``torrent`` 文件)使用 ``bencoding`` 进行编码的一个 ``dictionaries`` 数据类型，有两个 ``key`` ：

- ``announce`` : ``bt tracker`` 服务器地址；
- ``info`` : ``info`` 又是一个 ``dictionaries`` （ bencoding 支持数据类型的嵌套）， ``info`` 里面的字符串都是使用 ``UTF-8`` 编码；

info dictionary: info字典
^^^^^^^^^^^^^^^^^^^^^^^^^^

- ``name`` (文件名) ： 通常用作 ``torrent`` 文件的文件名。
- ``piece length`` （文件块长度）： 每一个 ``peace`` （文件块）的字节长度。为了传输的方便， ``bt`` 协议把文件分成等大的文件块，除了最后一块。每一个文件块的长度通常是 2 的指数（ ``bittorrent 3.2`` 默认文件块大小是 1M ）。
- ``pieces`` ： ``pieces`` 是一个字符串，它的长度是 20 的倍数，每一段 20 个字符表示对应文件块的 ``sha1 hash`` 索引值。
- ``length`` 和 ``files`` 两个中有且只有一个会出现。当存在 ``length key`` 时，表示 ``torrent`` 种子文件只包含一个单一的文件， ``length`` 表示这个文件的字节数，俗称文件长度。当 ``torrent`` 种子文件包含多个文件时， ``files`` 表示一组目录结构的文件。

``files`` 也是一个 ``dictionaries`` 数据类型，它有两个 ``key`` ：

- ``length`` ： 文件长度，总字节数；
- ``path`` ： 一个 ``UTF-8`` 编码的字符串数组，最后一个字符串保存真实的文件名，前面的字符串保存文件路径。长度为 ``0`` 表示 ``path`` 字段不合法；

在单个文件的情况下， ``name key`` 是文件的名称，在多文件的情况下，它是目录的名称。

trackers
---------
``tracker`` 服务器接收 ``get`` 请求，一个 ``get`` 请求由下列字段组成：

info_hash
^^^^^^^^^^

``20`` 字节的 ``sha1`` 哈希值，是 ``bencoding`` 编码之后的 ``torrent`` 文件内容的 ``hash`` 。

请注意，这是元信息文件的子字符串。 info-hash 必须是 .torrent 文件中找到的编码格式的散列，这与对元信息文件进行 bdecoding 相同，提取信息字典并对其进行编码，当且仅当 bdecoder 完全验证了输入时（例如密钥排序），没有前导零）。相反，这意味着客户端必须拒绝无效的元信息文件或直接提取子字符串。它们不得对无效数据执行解码编码往返。

peer_id
^^^^^^^^

长度为 ``20`` 的字符串，代表下载者的 ``id`` ，每一个下载者开始下载之前会随机生成自己的 ``id`` 。

ip
^^^

可选参数，表示文件下载者的ip

port
^^^^^

文件下载者监听的端口，默认从 ``6881`` 开始，如果被占用，则是 ``6882`` ，最大的 ``6889`` 。

uploaded
^^^^^^^^^
十进制表示的上传字节总数

downloaded
^^^^^^^^^^^
十进制表示的下载字节总数

left
^^^^^
十进制表示的剩余还需要下载的字节总数，注意这个值不能通过 ``downloaded`` 和 ``length`` 进行算数计算得到，因为当一些下载文件块的数据的完整性校验失败的，这些文件块必须被重新下载。

event
^^^^^
可选参数，有四个可能的值 ``started`` ， ``completed`` ， ``stopped`` ， ``empty`` (相当于不存在) 。如果不存在，这是定期发布的公告之一。 ``started`` 的事件在下载首次启动时发送， ``completed`` 的事件将在下载完成时发送。如果启动时文件已经完成则不会发送 ``completed`` 事件。当停止下载时下载器发送一个使用 ``stopped`` 的事件。

``tracker`` 返回的内容是一个 ``bencoded dictionaries`` 数据类型，如果返回的内容包含 ``failure reason`` 字段，表示请求失败，``failure reason`` 包含失败的理由。如果没有 ``failure reason`` 字段，则返回内容必须包含 ``interval`` 和 ``peers`` 字段。 ``interval`` 代表客户端发起下一次请求的间隔， ``peers`` 包含一个 ``peer`` 列表。一个 ``peer`` 由 ``peer id`` 、 ``ip`` 、 ``port`` 组成。请注意，如果事件发生或需要更多 ``peers`` ，下载程序可能会在非计划时间重新请求。

更常见的是 ``trackers`` 返回对等列表的紧凑表示，参见 `BEP 23 <http://www.bittorrent.org/beps/bep_0023.html>`_ 。

如果您想对元信息文件或 ``tracker`` 查询进行任何扩展，请与 ``Bram Cohen`` 协调以确保所有扩展都兼容完成。

通常也会通过 `UDP tracker协议 <http://www.bittorrent.org/beps/bep_0015.html>`_ 进行通告。

Peer 协议
---------
``BitTorrent`` 的 ``Peer`` 协议操作基于 ``TCP`` 或 `uTP <http://www.bittorrent.org/beps/bep_0029.html>`_ 。

``Peer`` 连接是对称的。消息在两个方向上的发送看起来是一样的，数据可在任一方向上流动。

``Peer`` 协议通过 ``metainfo`` 文件中所描述的索引引用文件的片段，索引从零开始。当 ``Peer`` 完成一个片的下载，并检查了哈希值的匹配性，它将向它所有的 ``Peers`` 通告它具有该片。

连接在任一端包含两个状态位：阻塞或不阻塞，以及是否感兴趣。（注：即与对端的数据通道是否畅通，以及对端是否具有自己需要的数据。）阻塞是一种通知，在阻塞解除之前将不会发送任何数据。阻塞背后的原因和常见技术将在本文后面解释。

数据传输发生在一端需要数据而另一端没有阻塞的时候。感兴趣状态必须随时保持更新 - 当下载者无需在对端处于非阻塞状态的话，就向对端请求数据的时候，它们必须表达缺乏兴趣，尽管正在被阻塞。正确实现这一点很棘手，但是下载者可以知道哪些 ``Peers`` 会在解除阻塞时立即开始下载。

连接开始时处于阻塞且不感兴趣状态。

当传输数据时，下载者应该一次在队列中保持多个片的请求以获得较好的 ``TCP`` 性能（这被称为 ``pipelining`` ）。另一方面，无法立即写入 ``TCP`` 缓冲区的请求应该放进内存队列中，而不是应用级的网络缓冲区中，以使它们在阻塞发生时可以被扔掉。（注：内存缓冲区和应用级缓冲区到底分别指什么？）

``Peer`` 协议由握手消息及其后永不停止的长度前缀消息流组成。握手消息由字符 ``19`` （十进制）及其后面的字符串 ``BitTorrent protocol`` 构成。前导字符是长度前缀，希望其他新协议可以做同样的事情，因此可以在很小的程度上相互区分。

协议中后续发送的整数都以四字节大端编码。

固定头部之后是 ``8`` 个保留字节，在当前所有的实现中它们都是 ``0`` 。如果你想使用这些字节扩展协议，请与 Bram Cohen 合作，以确保所有扩展可以兼容地完成。

接下来是 ``metainfo`` 文件中 ``info`` 值的 ``B`` 编码形式的 ``20`` 字节 ``SHA1`` 哈希。（这个值与向 ``Tracker`` 服务器公告的 ``info_hash`` 相同，只是在这里它是原始的而不是在这里引用的）。如果两端没有发送相同的值，则切断连接。一个可能的例外是，如果下载者想要通过单个端口执行多个下载，则他们可能会等待传入连接首先提供下载哈希，并且如果它在列表中的话则以相同的哈希响应。

下载哈希后面的是 ``20`` 字节的 ``Peer ID`` ，该 ``Peer ID`` 由 ``Tracker`` 请求报告，并包含在 ``Tracker`` 响应的 ``Peer`` 列表中。如果接收端的 ``Peer ID`` 与发起端的期待不匹配，则它切断连接。

这就是握手消息，接下来是长度前缀和消息的交替流。长度为 ``0`` 的消息是 ``keepalives`` ，它们会被忽略。 ``Keepalives`` 通常每 ``2`` 分钟发送一次，但是注意，在预期数据时可以更快地完成超时。

Peer 消息
---------
所有的非 ``keepalive`` 消息以一个标识消息类型的字节开始。

可能的值为：

- 0 - choke
- 1 - unchoke
- 2 - interested
- 3 - not interested
- 4 - have
- 5 - bitfield
- 6 - request
- 7 - piece
- 8 - cancel

``choke`` ， ``unchoke`` ， ``interested`` 和 ``not interested`` 没有载荷。

``bitfield`` 只作为第一条消息发送。它的载荷是一个位域，其中下载器已经发送的每个索引设置为 ``1`` ，其它设置为 ``0`` 。没有任何东西的下载器可以跳过 ``bitfield`` 消息。位域的第一个字节从高位到低位分别对应于索引 ``0 - 7`` 。接下来的一个是 ``8 - 15`` ，等等。最后一个字节中多余的位设置为 ``0`` 。

``have`` 消息的载荷是一个数字，是下载器刚刚完成并检查了哈希值的索引。

request 消息包含索引，起始位置，和长度。后两个是字节偏移量。长度通常是 2 的幂，除非它被文件尾截断。所有当前的实现使用 2^14 (16 kiB)，当请求比这个值更大数量的数据时，连接关闭。

cancel 消息具有与 request 消息相同的载荷。它们通常仅在下载结束时发送，称为“结束游戏模式”。当下载快结束时，最后一些数据片倾向于从单个调制解调器线上下载，这需要很长时间。为了确保最后的数据片快速地到达，一旦特定下载器还没有下载到的所有数据片的请求都处于挂起状态，则它向当前正从其下载的每个 Peer 请求所有的数据。为了防止这种情况变得特别低效，每次数据片到达时它都向其它 Peer 发送 cancel。

piece 消息包含索引，起始位置，和数据片。注意，它们隐式地与请求消息相关联。如果 choke 和 unchoke 消息快速连续地发送和/或传输速度非常慢的话，可能会有未预期的数据片到达。

下载器通常以随机顺序下载数据片，这样可以很好地防止它们拥有任何 Peers 的片的严格子集或超集。

Choking 有几个原因。当一次性通过多个连接发送时，TCP 拥塞控制的表现很差。而且，choking 让每个 Peer 使用 tit-for-tat-ish 算法以确保它们获得一致的下载速率。

下面描述的 choking 算法正是当前部署的。所有新算法在完全由他们自己组成的网络中，以及在主要由这个算法组成的网络中，都能很好地工作是非常重要的。

一个好的 choking 算法应该满足一些标准。它应该限制并发上传的数量以获得良好的 TCP 性能。它应该避免快速地 choking 和 unchoking，这被称为 抖动。它应该回应让它下载的 Peer。最后，它应该偶尔尝试使用未使用的连接，以确定它们是否可能比当前使用的更好，这称为乐观的 unchoking。

当前部署的 choking 算法通过仅改变每隔 10 秒钟 choked 一次的 Peer 避免了抖动。它通过解除对其具有最佳下载速率并且感兴趣的四个 peers 来实现往复和上传数量的限制。拥有更高上传率但不感兴趣的 peer 会被 unchoked，如果它们变得被感兴趣则最糟糕的上传者被 choked。如果下载者拥有一个完整的文件，它使用它的上传速率而不是它的下载速率来决定谁 unchoke。

对于乐观的 unchoking，在任何时间都有一个单独的 peer，它处于 unchoked 状态而无论它的上传速率是多少（如果感兴趣，它被作为四个允许的下载者中的一个）。哪个 peer 是乐观的 unchoked 每隔 30 秒轮转一次。为了给他们一个很好的机会获得一个完整的片段上传，新的连接的开始时间是当前乐观的unchoke的三倍，与旋转中的其他任何地方一样。


参考：

- http://www.bittorrent.org/beps/bep_0003.html
- https://zh.wikibooks.org/zh-hans/BitTorrent%E5%8D%8F%E8%AE%AE%E8%A7%84%E8%8C%83
















